var B = /* @__PURE__ */ ((i) => (i.Application = "application", i.WebGLPipes = "webgl-pipes", i.WebGLPipesAdaptor = "webgl-pipes-adaptor", i.WebGLSystem = "webgl-system", i.WebGPUPipes = "webgpu-pipes", i.WebGPUPipesAdaptor = "webgpu-pipes-adaptor", i.WebGPUSystem = "webgpu-system", i.CanvasSystem = "canvas-system", i.CanvasPipesAdaptor = "canvas-pipes-adaptor", i.CanvasPipes = "canvas-pipes", i.Asset = "asset", i.LoadParser = "load-parser", i.ResolveParser = "resolve-parser", i.CacheParser = "cache-parser", i.DetectionParser = "detection-parser", i.MaskEffect = "mask-effect", i.BlendMode = "blend-mode", i.TextureSource = "texture-source", i.Environment = "environment", i.ShapeBuilder = "shape-builder", i.Batcher = "batcher", i))(B || {});
const eg = (i) => {
  if (typeof i == "function" || typeof i == "object" && i.extension) {
    if (!i.extension)
      throw new Error("Extension class must have an extension object");
    i = { ...typeof i.extension != "object" ? { type: i.extension } : i.extension, ref: i };
  }
  if (typeof i == "object")
    i = { ...i };
  else
    throw new Error("Invalid extension type");
  return typeof i.type == "string" && (i.type = [i.type]), i;
}, $u = (i, t) => eg(i).priority ?? t, Ee = {
  /** @ignore */
  _addHandlers: {},
  /** @ignore */
  _removeHandlers: {},
  /** @ignore */
  _queue: {},
  /**
   * Remove extensions from PixiJS.
   * @param extensions - Extensions to be removed.
   * @returns {extensions} For chaining.
   */
  remove(...i) {
    return i.map(eg).forEach((t) => {
      t.type.forEach((e) => {
        var s, r;
        return (r = (s = this._removeHandlers)[e]) == null ? void 0 : r.call(s, t);
      });
    }), this;
  },
  /**
   * Register new extensions with PixiJS.
   * @param extensions - The spread of extensions to add to PixiJS.
   * @returns {extensions} For chaining.
   */
  add(...i) {
    return i.map(eg).forEach((t) => {
      t.type.forEach((e) => {
        var n, a;
        const s = this._addHandlers, r = this._queue;
        s[e] ? (a = s[e]) == null || a.call(s, t) : (r[e] = r[e] || [], (n = r[e]) == null || n.push(t));
      });
    }), this;
  },
  /**
   * Internal method to handle extensions by name.
   * @param type - The extension type.
   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.
   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.
   * @returns {extensions} For chaining.
   */
  handle(i, t, e) {
    var a;
    const s = this._addHandlers, r = this._removeHandlers;
    if (s[i] || r[i])
      throw new Error(`Extension type ${i} already has a handler`);
    s[i] = t, r[i] = e;
    const n = this._queue;
    return n[i] && ((a = n[i]) == null || a.forEach((o) => t(o)), delete n[i]), this;
  },
  /**
   * Handle a type, but using a map by `name` property.
   * @param type - Type of extension to handle.
   * @param map - The object map of named extensions.
   * @returns {extensions} For chaining.
   */
  handleByMap(i, t) {
    return this.handle(
      i,
      (e) => {
        e.name && (t[e.name] = e.ref);
      },
      (e) => {
        e.name && delete t[e.name];
      }
    );
  },
  /**
   * Handle a type, but using a list of extensions with a `name` property.
   * @param type - Type of extension to handle.
   * @param map - The array of named extensions.
   * @param defaultPriority - Fallback priority if none is defined.
   * @returns {extensions} For chaining.
   */
  handleByNamedList(i, t, e = -1) {
    return this.handle(
      i,
      (s) => {
        t.findIndex((n) => n.name === s.name) >= 0 || (t.push({ name: s.name, value: s.ref }), t.sort((n, a) => $u(a.value, e) - $u(n.value, e)));
      },
      (s) => {
        const r = t.findIndex((n) => n.name === s.name);
        r !== -1 && t.splice(r, 1);
      }
    );
  },
  /**
   * Handle a type, but using a list of extensions.
   * @param type - Type of extension to handle.
   * @param list - The list of extensions.
   * @param defaultPriority - The default priority to use if none is specified.
   * @returns {extensions} For chaining.
   */
  handleByList(i, t, e = -1) {
    return this.handle(
      i,
      (s) => {
        t.includes(s.ref) || (t.push(s.ref), t.sort((r, n) => $u(n, e) - $u(r, e)));
      },
      (s) => {
        const r = t.indexOf(s.ref);
        r !== -1 && t.splice(r, 1);
      }
    );
  }
}, qM = {
  extension: {
    type: B.Environment,
    name: "browser",
    priority: -1
  },
  test: () => !0,
  load: async () => {
    await import("./browserAll-DE8X1jJq.js");
  }
}, $M = {
  extension: {
    type: B.Environment,
    name: "webworker",
    priority: 0
  },
  test: () => typeof self < "u" && self.WorkerGlobalScope !== void 0,
  load: async () => {
    await import("./webworkerAll-DDfEw7Nf.js");
  }
};
class Me {
  /**
   * Creates a new `ObservablePoint`
   * @param observer - Observer to pass to listen for change events.
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(t, e, s) {
    this._x = e || 0, this._y = s || 0, this._observer = t;
  }
  /**
   * Creates a clone of this point.
   * @param observer - Optional observer to pass to the new observable point.
   * @returns a copy of this observable point
   */
  clone(t) {
    return new Me(t ?? this._observer, this._x, this._y);
  }
  /**
   * Sets the point to a new `x` and `y` position.
   * If `y` is omitted, both `x` and `y` will be set to `x`.
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=x] - position of the point on the y axis
   * @returns The observable point instance itself
   */
  set(t = 0, e = t) {
    return (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this._observer._onUpdate(this)), this;
  }
  /**
   * Copies x and y from the given point (`p`)
   * @param p - The point to copy from. Can be any of type that is or extends `PointData`
   * @returns The observable point instance itself
   */
  copyFrom(t) {
    return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this._observer._onUpdate(this)), this;
  }
  /**
   * Copies this point's x and y into that of the given point (`p`)
   * @param p - The point to copy to. Can be any of type that is or extends `PointData`
   * @returns The point (`p`) with values updated
   */
  copyTo(t) {
    return t.set(this._x, this._y), t;
  }
  /**
   * Accepts another point (`p`) and returns `true` if the given point is equal to this point
   * @param p - The point to check
   * @returns Returns `true` if both `x` and `y` are equal
   */
  equals(t) {
    return t.x === this._x && t.y === this._y;
  }
  toString() {
    return `[pixi.js/math:ObservablePoint x=0 y=0 scope=${this._observer}]`;
  }
  /** Position of the observable point on the x axis. */
  get x() {
    return this._x;
  }
  set x(t) {
    this._x !== t && (this._x = t, this._observer._onUpdate(this));
  }
  /** Position of the observable point on the y axis. */
  get y() {
    return this._y;
  }
  set y(t) {
    this._y !== t && (this._y = t, this._observer._onUpdate(this));
  }
}
var rh = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function _T(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var bR = { exports: {} };
(function(i) {
  var t = Object.prototype.hasOwnProperty, e = "~";
  function s() {
  }
  Object.create && (s.prototype = /* @__PURE__ */ Object.create(null), new s().__proto__ || (e = !1));
  function r(h, u, c) {
    this.fn = h, this.context = u, this.once = c || !1;
  }
  function n(h, u, c, l, _) {
    if (typeof c != "function")
      throw new TypeError("The listener must be a function");
    var d = new r(c, l || h, _), f = e ? e + u : u;
    return h._events[f] ? h._events[f].fn ? h._events[f] = [h._events[f], d] : h._events[f].push(d) : (h._events[f] = d, h._eventsCount++), h;
  }
  function a(h, u) {
    --h._eventsCount === 0 ? h._events = new s() : delete h._events[u];
  }
  function o() {
    this._events = new s(), this._eventsCount = 0;
  }
  o.prototype.eventNames = function() {
    var u = [], c, l;
    if (this._eventsCount === 0) return u;
    for (l in c = this._events)
      t.call(c, l) && u.push(e ? l.slice(1) : l);
    return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(c)) : u;
  }, o.prototype.listeners = function(u) {
    var c = e ? e + u : u, l = this._events[c];
    if (!l) return [];
    if (l.fn) return [l.fn];
    for (var _ = 0, d = l.length, f = new Array(d); _ < d; _++)
      f[_] = l[_].fn;
    return f;
  }, o.prototype.listenerCount = function(u) {
    var c = e ? e + u : u, l = this._events[c];
    return l ? l.fn ? 1 : l.length : 0;
  }, o.prototype.emit = function(u, c, l, _, d, f) {
    var p = e ? e + u : u;
    if (!this._events[p]) return !1;
    var g = this._events[p], m = arguments.length, O, y;
    if (g.fn) {
      switch (g.once && this.removeListener(u, g.fn, void 0, !0), m) {
        case 1:
          return g.fn.call(g.context), !0;
        case 2:
          return g.fn.call(g.context, c), !0;
        case 3:
          return g.fn.call(g.context, c, l), !0;
        case 4:
          return g.fn.call(g.context, c, l, _), !0;
        case 5:
          return g.fn.call(g.context, c, l, _, d), !0;
        case 6:
          return g.fn.call(g.context, c, l, _, d, f), !0;
      }
      for (y = 1, O = new Array(m - 1); y < m; y++)
        O[y - 1] = arguments[y];
      g.fn.apply(g.context, O);
    } else {
      var C = g.length, b;
      for (y = 0; y < C; y++)
        switch (g[y].once && this.removeListener(u, g[y].fn, void 0, !0), m) {
          case 1:
            g[y].fn.call(g[y].context);
            break;
          case 2:
            g[y].fn.call(g[y].context, c);
            break;
          case 3:
            g[y].fn.call(g[y].context, c, l);
            break;
          case 4:
            g[y].fn.call(g[y].context, c, l, _);
            break;
          default:
            if (!O) for (b = 1, O = new Array(m - 1); b < m; b++)
              O[b - 1] = arguments[b];
            g[y].fn.apply(g[y].context, O);
        }
    }
    return !0;
  }, o.prototype.on = function(u, c, l) {
    return n(this, u, c, l, !1);
  }, o.prototype.once = function(u, c, l) {
    return n(this, u, c, l, !0);
  }, o.prototype.removeListener = function(u, c, l, _) {
    var d = e ? e + u : u;
    if (!this._events[d]) return this;
    if (!c)
      return a(this, d), this;
    var f = this._events[d];
    if (f.fn)
      f.fn === c && (!_ || f.once) && (!l || f.context === l) && a(this, d);
    else {
      for (var p = 0, g = [], m = f.length; p < m; p++)
        (f[p].fn !== c || _ && !f[p].once || l && f[p].context !== l) && g.push(f[p]);
      g.length ? this._events[d] = g.length === 1 ? g[0] : g : a(this, d);
    }
    return this;
  }, o.prototype.removeAllListeners = function(u) {
    var c;
    return u ? (c = e ? e + u : u, this._events[c] && a(this, c)) : (this._events = new s(), this._eventsCount = 0), this;
  }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = e, o.EventEmitter = o, i.exports = o;
})(bR);
var ZM = bR.exports;
const Js = /* @__PURE__ */ _T(ZM), QM = Math.PI * 2, JM = 180 / Math.PI, Po = Math.PI / 180;
class st {
  /**
   * Creates a new `Point`
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(t = 0, e = 0) {
    this.x = 0, this.y = 0, this.x = t, this.y = e;
  }
  /**
   * Creates a clone of this point
   * @returns A clone of this point
   */
  clone() {
    return new st(this.x, this.y);
  }
  /**
   * Copies `x` and `y` from the given point into this point
   * @param p - The point to copy from
   * @returns The point instance itself
   */
  copyFrom(t) {
    return this.set(t.x, t.y), this;
  }
  /**
   * Copies this point's x and y into the given point (`p`).
   * @param p - The point to copy to. Can be any of type that is or extends `PointData`
   * @returns The point (`p`) with values updated
   */
  copyTo(t) {
    return t.set(this.x, this.y), t;
  }
  /**
   * Accepts another point (`p`) and returns `true` if the given point is equal to this point
   * @param p - The point to check
   * @returns Returns `true` if both `x` and `y` are equal
   */
  equals(t) {
    return t.x === this.x && t.y === this.y;
  }
  /**
   * Sets the point to a new `x` and `y` position.
   * If `y` is omitted, both `x` and `y` will be set to `x`.
   * @param {number} [x=0] - position of the point on the `x` axis
   * @param {number} [y=x] - position of the point on the `y` axis
   * @returns The point instance itself
   */
  set(t = 0, e = t) {
    return this.x = t, this.y = e, this;
  }
  toString() {
    return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
  }
  /**
   * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.
   * @readonly
   */
  static get shared() {
    return Qd.x = 0, Qd.y = 0, Qd;
  }
}
const Qd = new st();
class ot {
  /**
   * @param a - x scale
   * @param b - y skew
   * @param c - x skew
   * @param d - y scale
   * @param tx - x translation
   * @param ty - y translation
   */
  constructor(t = 1, e = 0, s = 0, r = 1, n = 0, a = 0) {
    this.array = null, this.a = t, this.b = e, this.c = s, this.d = r, this.tx = n, this.ty = a;
  }
  /**
   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
   *
   * a = array[0]
   * b = array[1]
   * c = array[3]
   * d = array[4]
   * tx = array[2]
   * ty = array[5]
   * @param array - The array that the matrix will be populated from.
   */
  fromArray(t) {
    this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5];
  }
  /**
   * Sets the matrix properties.
   * @param a - Matrix component
   * @param b - Matrix component
   * @param c - Matrix component
   * @param d - Matrix component
   * @param tx - Matrix component
   * @param ty - Matrix component
   * @returns This matrix. Good for chaining method calls.
   */
  set(t, e, s, r, n, a) {
    return this.a = t, this.b = e, this.c = s, this.d = r, this.tx = n, this.ty = a, this;
  }
  /**
   * Creates an array from the current Matrix object.
   * @param transpose - Whether we need to transpose the matrix or not
   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out
   * @returns The newly created array which contains the matrix
   */
  toArray(t, e) {
    this.array || (this.array = new Float32Array(9));
    const s = e || this.array;
    return t ? (s[0] = this.a, s[1] = this.b, s[2] = 0, s[3] = this.c, s[4] = this.d, s[5] = 0, s[6] = this.tx, s[7] = this.ty, s[8] = 1) : (s[0] = this.a, s[1] = this.c, s[2] = this.tx, s[3] = this.b, s[4] = this.d, s[5] = this.ty, s[6] = 0, s[7] = 0, s[8] = 1), s;
  }
  /**
   * Get a new position with the current transformation applied.
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   * @param pos - The origin
   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {Point} The new point, transformed through this matrix
   */
  apply(t, e) {
    e = e || new st();
    const s = t.x, r = t.y;
    return e.x = this.a * s + this.c * r + this.tx, e.y = this.b * s + this.d * r + this.ty, e;
  }
  /**
   * Get a new position with the inverse of the current transformation applied.
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   * @param pos - The origin
   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {Point} The new point, inverse-transformed through this matrix
   */
  applyInverse(t, e) {
    e = e || new st();
    const s = this.a, r = this.b, n = this.c, a = this.d, o = this.tx, h = this.ty, u = 1 / (s * a + n * -r), c = t.x, l = t.y;
    return e.x = a * u * c + -n * u * l + (h * n - o * a) * u, e.y = s * u * l + -r * u * c + (-h * s + o * r) * u, e;
  }
  /**
   * Translates the matrix on the x and y.
   * @param x - How much to translate x by
   * @param y - How much to translate y by
   * @returns This matrix. Good for chaining method calls.
   */
  translate(t, e) {
    return this.tx += t, this.ty += e, this;
  }
  /**
   * Applies a scale transformation to the matrix.
   * @param x - The amount to scale horizontally
   * @param y - The amount to scale vertically
   * @returns This matrix. Good for chaining method calls.
   */
  scale(t, e) {
    return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this;
  }
  /**
   * Applies a rotation transformation to the matrix.
   * @param angle - The angle in radians.
   * @returns This matrix. Good for chaining method calls.
   */
  rotate(t) {
    const e = Math.cos(t), s = Math.sin(t), r = this.a, n = this.c, a = this.tx;
    return this.a = r * e - this.b * s, this.b = r * s + this.b * e, this.c = n * e - this.d * s, this.d = n * s + this.d * e, this.tx = a * e - this.ty * s, this.ty = a * s + this.ty * e, this;
  }
  /**
   * Appends the given Matrix to this Matrix.
   * @param matrix - The matrix to append.
   * @returns This matrix. Good for chaining method calls.
   */
  append(t) {
    const e = this.a, s = this.b, r = this.c, n = this.d;
    return this.a = t.a * e + t.b * r, this.b = t.a * s + t.b * n, this.c = t.c * e + t.d * r, this.d = t.c * s + t.d * n, this.tx = t.tx * e + t.ty * r + this.tx, this.ty = t.tx * s + t.ty * n + this.ty, this;
  }
  /**
   * Appends two matrix's and sets the result to this matrix. AB = A * B
   * @param a - The matrix to append.
   * @param b - The matrix to append.
   * @returns This matrix. Good for chaining method calls.
   */
  appendFrom(t, e) {
    const s = t.a, r = t.b, n = t.c, a = t.d, o = t.tx, h = t.ty, u = e.a, c = e.b, l = e.c, _ = e.d;
    return this.a = s * u + r * l, this.b = s * c + r * _, this.c = n * u + a * l, this.d = n * c + a * _, this.tx = o * u + h * l + e.tx, this.ty = o * c + h * _ + e.ty, this;
  }
  /**
   * Sets the matrix based on all the available properties
   * @param x - Position on the x axis
   * @param y - Position on the y axis
   * @param pivotX - Pivot on the x axis
   * @param pivotY - Pivot on the y axis
   * @param scaleX - Scale on the x axis
   * @param scaleY - Scale on the y axis
   * @param rotation - Rotation in radians
   * @param skewX - Skew on the x axis
   * @param skewY - Skew on the y axis
   * @returns This matrix. Good for chaining method calls.
   */
  setTransform(t, e, s, r, n, a, o, h, u) {
    return this.a = Math.cos(o + u) * n, this.b = Math.sin(o + u) * n, this.c = -Math.sin(o - h) * a, this.d = Math.cos(o - h) * a, this.tx = t - (s * this.a + r * this.c), this.ty = e - (s * this.b + r * this.d), this;
  }
  /**
   * Prepends the given Matrix to this Matrix.
   * @param matrix - The matrix to prepend
   * @returns This matrix. Good for chaining method calls.
   */
  prepend(t) {
    const e = this.tx;
    if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
      const s = this.a, r = this.c;
      this.a = s * t.a + this.b * t.c, this.b = s * t.b + this.b * t.d, this.c = r * t.a + this.d * t.c, this.d = r * t.b + this.d * t.d;
    }
    return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this;
  }
  /**
   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
   * @param transform - The transform to apply the properties to.
   * @returns The transform with the newly applied properties
   */
  decompose(t) {
    const e = this.a, s = this.b, r = this.c, n = this.d, a = t.pivot, o = -Math.atan2(-r, n), h = Math.atan2(s, e), u = Math.abs(o + h);
    return u < 1e-5 || Math.abs(QM - u) < 1e-5 ? (t.rotation = h, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = o, t.skew.y = h), t.scale.x = Math.sqrt(e * e + s * s), t.scale.y = Math.sqrt(r * r + n * n), t.position.x = this.tx + (a.x * e + a.y * r), t.position.y = this.ty + (a.x * s + a.y * n), t;
  }
  /**
   * Inverts this matrix
   * @returns This matrix. Good for chaining method calls.
   */
  invert() {
    const t = this.a, e = this.b, s = this.c, r = this.d, n = this.tx, a = t * r - e * s;
    return this.a = r / a, this.b = -e / a, this.c = -s / a, this.d = t / a, this.tx = (s * this.ty - r * n) / a, this.ty = -(t * this.ty - e * n) / a, this;
  }
  /** Checks if this matrix is an identity matrix */
  isIdentity() {
    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
  }
  /**
   * Resets this Matrix to an identity (default) matrix.
   * @returns This matrix. Good for chaining method calls.
   */
  identity() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   * @returns A copy of this matrix. Good for chaining method calls.
   */
  clone() {
    const t = new ot();
    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
  }
  /**
   * Changes the values of the given matrix to be the same as the ones in this matrix
   * @param matrix - The matrix to copy to.
   * @returns The matrix given in parameter with its values updated.
   */
  copyTo(t) {
    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
  }
  /**
   * Changes the values of the matrix to be the same as the ones in given matrix
   * @param matrix - The matrix to copy from.
   * @returns this
   */
  copyFrom(t) {
    return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;
  }
  /**
   * check to see if two matrices are the same
   * @param matrix - The matrix to compare to.
   */
  equals(t) {
    return t.a === this.a && t.b === this.b && t.c === this.c && t.d === this.d && t.tx === this.tx && t.ty === this.ty;
  }
  toString() {
    return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
  }
  /**
   * A default (identity) matrix.
   *
   * This is a shared object, if you want to modify it consider creating a new `Matrix`
   * @readonly
   */
  static get IDENTITY() {
    return eb.identity();
  }
  /**
   * A static Matrix that can be used to avoid creating new objects.
   * Will always ensure the matrix is reset to identity when requested.
   * Use this object for fast but temporary calculations, as it may be mutated later on.
   * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.
   * @readonly
   */
  static get shared() {
    return tb.identity();
  }
}
const tb = new ot(), eb = new ot(), vn = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], Cn = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], xn = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], Mn = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], sg = [], PR = [], Zu = Math.sign;
function sb() {
  for (let i = 0; i < 16; i++) {
    const t = [];
    sg.push(t);
    for (let e = 0; e < 16; e++) {
      const s = Zu(vn[i] * vn[e] + xn[i] * Cn[e]), r = Zu(Cn[i] * vn[e] + Mn[i] * Cn[e]), n = Zu(vn[i] * xn[e] + xn[i] * Mn[e]), a = Zu(Cn[i] * xn[e] + Mn[i] * Mn[e]);
      for (let o = 0; o < 16; o++)
        if (vn[o] === s && Cn[o] === r && xn[o] === n && Mn[o] === a) {
          t.push(o);
          break;
        }
    }
  }
  for (let i = 0; i < 16; i++) {
    const t = new ot();
    t.set(vn[i], Cn[i], xn[i], Mn[i], 0, 0), PR.push(t);
  }
}
sb();
const fe = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0°       | East      |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45°↻     | Southeast |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90°↻     | South     |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135°↻    | Southwest |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180°     | West      |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135°/225°↻ | Northwest    |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90°/270°↻  | North        |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45°/315°↻  | Northeast    |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: (i) => vn[i],
  /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: (i) => Cn[i],
  /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: (i) => xn[i],
  /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: (i) => Mn[i],
  /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: (i) => i & 8 ? i & 15 : -i & 7,
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @memberof maths.groupD8
   * @param {GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {GD8Symmetry} Composed operation
   */
  add: (i, t) => sg[i][t],
  /**
   * Reverse of `add`.
   * @memberof maths.groupD8
   * @param {GD8Symmetry} rotationSecond - Second operation
   * @param {GD8Symmetry} rotationFirst - First operation
   * @returns {GD8Symmetry} Result
   */
  sub: (i, t) => sg[i][fe.inv(t)],
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @memberof maths.groupD8
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: (i) => i ^ 4,
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @memberof maths.groupD8
   * @param {GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: (i) => (i & 3) === 2,
  // rotation % 4 === 2
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @memberof maths.groupD8
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: (i, t) => Math.abs(i) * 2 <= Math.abs(t) ? t >= 0 ? fe.S : fe.N : Math.abs(t) * 2 <= Math.abs(i) ? i > 0 ? fe.E : fe.W : t > 0 ? i > 0 ? fe.SE : fe.SW : i > 0 ? fe.NE : fe.NW,
  /**
   * Helps sprite to compensate texture packer rotation.
   * @memberof maths.groupD8
   * @param {Matrix} matrix - sprite world matrix
   * @param {GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: (i, t, e = 0, s = 0) => {
    const r = PR[fe.inv(t)];
    r.tx = e, r.ty = s, i.append(r);
  }
}, Qu = [new st(), new st(), new st(), new st()];
class Kt {
  /**
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   */
  constructor(t = 0, e = 0, s = 0, r = 0) {
    this.type = "rectangle", this.x = Number(t), this.y = Number(e), this.width = Number(s), this.height = Number(r);
  }
  /** Returns the left edge of the rectangle. */
  get left() {
    return this.x;
  }
  /** Returns the right edge of the rectangle. */
  get right() {
    return this.x + this.width;
  }
  /** Returns the top edge of the rectangle. */
  get top() {
    return this.y;
  }
  /** Returns the bottom edge of the rectangle. */
  get bottom() {
    return this.y + this.height;
  }
  /** Determines whether the Rectangle is empty. */
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
  /** A constant empty rectangle. This is a new object every time the property is accessed */
  static get EMPTY() {
    return new Kt(0, 0, 0, 0);
  }
  /**
   * Creates a clone of this Rectangle
   * @returns a copy of the rectangle
   */
  clone() {
    return new Kt(this.x, this.y, this.width, this.height);
  }
  /**
   * Converts a Bounds object to a Rectangle object.
   * @param bounds - The bounds to copy and convert to a rectangle.
   * @returns Returns itself.
   */
  copyFromBounds(t) {
    return this.x = t.minX, this.y = t.minY, this.width = t.maxX - t.minX, this.height = t.maxY - t.minY, this;
  }
  /**
   * Copies another rectangle to this one.
   * @param rectangle - The rectangle to copy from.
   * @returns Returns itself.
   */
  copyFrom(t) {
    return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
  }
  /**
   * Copies this rectangle to another one.
   * @param rectangle - The rectangle to copy to.
   * @returns Returns given parameter.
   */
  copyTo(t) {
    return t.copyFrom(this), t;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rectangle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rectangle
   */
  contains(t, e) {
    return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @returns Whether the x/y coordinates are within this rectangle
   */
  strokeContains(t, e, s) {
    const { width: r, height: n } = this;
    if (r <= 0 || n <= 0)
      return !1;
    const a = this.x, o = this.y, h = a - s / 2, u = a + r + s / 2, c = o - s / 2, l = o + n + s / 2, _ = a + s / 2, d = a + r - s / 2, f = o + s / 2, p = o + n - s / 2;
    return t >= h && t <= u && e >= c && e <= l && !(t > _ && t < d && e > f && e < p);
  }
  /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   * Returns true only if the area of the intersection is >0, this means that Rectangles
   * sharing a side are not overlapping. Another side effect is that an arealess rectangle
   * (width or height equal to zero) can't intersect any other rectangle.
   * @param {Rectangle} other - The Rectangle to intersect with `this`.
   * @param {Matrix} transform - The transformation matrix of `other`.
   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
   */
  intersects(t, e) {
    if (!e) {
      const F = this.x < t.x ? t.x : this.x;
      if ((this.right > t.right ? t.right : this.right) <= F)
        return !1;
      const U = this.y < t.y ? t.y : this.y;
      return (this.bottom > t.bottom ? t.bottom : this.bottom) > U;
    }
    const s = this.left, r = this.right, n = this.top, a = this.bottom;
    if (r <= s || a <= n)
      return !1;
    const o = Qu[0].set(t.left, t.top), h = Qu[1].set(t.left, t.bottom), u = Qu[2].set(t.right, t.top), c = Qu[3].set(t.right, t.bottom);
    if (u.x <= o.x || h.y <= o.y)
      return !1;
    const l = Math.sign(e.a * e.d - e.b * e.c);
    if (l === 0 || (e.apply(o, o), e.apply(h, h), e.apply(u, u), e.apply(c, c), Math.max(o.x, h.x, u.x, c.x) <= s || Math.min(o.x, h.x, u.x, c.x) >= r || Math.max(o.y, h.y, u.y, c.y) <= n || Math.min(o.y, h.y, u.y, c.y) >= a))
      return !1;
    const _ = l * (h.y - o.y), d = l * (o.x - h.x), f = _ * s + d * n, p = _ * r + d * n, g = _ * s + d * a, m = _ * r + d * a;
    if (Math.max(f, p, g, m) <= _ * o.x + d * o.y || Math.min(f, p, g, m) >= _ * c.x + d * c.y)
      return !1;
    const O = l * (o.y - u.y), y = l * (u.x - o.x), C = O * s + y * n, b = O * r + y * n, D = O * s + y * a, P = O * r + y * a;
    return !(Math.max(C, b, D, P) <= O * o.x + y * o.y || Math.min(C, b, D, P) >= O * c.x + y * c.y);
  }
  /**
   * Pads the rectangle making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @param paddingX - The horizontal padding amount.
   * @param paddingY - The vertical padding amount.
   * @returns Returns itself.
   */
  pad(t = 0, e = t) {
    return this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this;
  }
  /**
   * Fits this rectangle around the passed one.
   * @param rectangle - The rectangle to fit.
   * @returns Returns itself.
   */
  fit(t) {
    const e = Math.max(this.x, t.x), s = Math.min(this.x + this.width, t.x + t.width), r = Math.max(this.y, t.y), n = Math.min(this.y + this.height, t.y + t.height);
    return this.x = e, this.width = Math.max(s - e, 0), this.y = r, this.height = Math.max(n - r, 0), this;
  }
  /**
   * Enlarges rectangle that way its corners lie on grid
   * @param resolution - resolution
   * @param eps - precision
   * @returns Returns itself.
   */
  ceil(t = 1, e = 1e-3) {
    const s = Math.ceil((this.x + this.width - e) * t) / t, r = Math.ceil((this.y + this.height - e) * t) / t;
    return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = s - this.x, this.height = r - this.y, this;
  }
  /**
   * Enlarges this rectangle to include the passed rectangle.
   * @param rectangle - The rectangle to include.
   * @returns Returns itself.
   */
  enlarge(t) {
    const e = Math.min(this.x, t.x), s = Math.max(this.x + this.width, t.x + t.width), r = Math.min(this.y, t.y), n = Math.max(this.y + this.height, t.y + t.height);
    return this.x = e, this.width = s - e, this.y = r, this.height = n - r, this;
  }
  /**
   * Returns the framing rectangle of the rectangle as a Rectangle object
   * @param out - optional rectangle to store the result
   * @returns The framing rectangle
   */
  getBounds(t) {
    return t = t || new Kt(), t.copyFrom(this), t;
  }
  toString() {
    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}
const Jd = {
  default: -1
};
function me(i = "default") {
  return Jd[i] === void 0 && (Jd[i] = -1), ++Jd[i];
}
const JI = {}, Se = "8.0.0", ib = "8.3.4";
function dt(i, t, e = 3) {
  if (JI[t])
    return;
  let s = new Error().stack;
  typeof s > "u" ? console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${i}`) : (s = s.split(`
`).splice(e).join(`
`), console.groupCollapsed ? (console.groupCollapsed(
    "%cPixiJS Deprecation Warning: %c%s",
    "color:#614108;background:#fffbe6",
    "font-weight:normal;color:#614108;background:#fffbe6",
    `${t}
Deprecated since v${i}`
  ), console.warn(s), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${i}`), console.warn(s))), JI[t] = !0;
}
const NR = () => {
};
function Ll(i) {
  return i += i === 0 ? 1 : 0, --i, i |= i >>> 1, i |= i >>> 2, i |= i >>> 4, i |= i >>> 8, i |= i >>> 16, i + 1;
}
function tS(i) {
  return !(i & i - 1) && !!i;
}
function rb(i) {
  const t = {};
  for (const e in i)
    i[e] !== void 0 && (t[e] = i[e]);
  return t;
}
const eS = /* @__PURE__ */ Object.create(null);
function nb(i) {
  const t = eS[i];
  return t === void 0 && (eS[i] = me("resource")), t;
}
const UR = class DR extends Js {
  /**
   * @param options - options for the style
   */
  constructor(t = {}) {
    super(), this._resourceType = "textureSampler", this._touched = 0, this._maxAnisotropy = 1, this.destroyed = !1, t = { ...DR.defaultOptions, ...t }, this.addressMode = t.addressMode, this.addressModeU = t.addressModeU ?? this.addressModeU, this.addressModeV = t.addressModeV ?? this.addressModeV, this.addressModeW = t.addressModeW ?? this.addressModeW, this.scaleMode = t.scaleMode, this.magFilter = t.magFilter ?? this.magFilter, this.minFilter = t.minFilter ?? this.minFilter, this.mipmapFilter = t.mipmapFilter ?? this.mipmapFilter, this.lodMinClamp = t.lodMinClamp, this.lodMaxClamp = t.lodMaxClamp, this.compare = t.compare, this.maxAnisotropy = t.maxAnisotropy ?? 1;
  }
  set addressMode(t) {
    this.addressModeU = t, this.addressModeV = t, this.addressModeW = t;
  }
  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
  get addressMode() {
    return this.addressModeU;
  }
  set wrapMode(t) {
    dt(Se, "TextureStyle.wrapMode is now TextureStyle.addressMode"), this.addressMode = t;
  }
  get wrapMode() {
    return this.addressMode;
  }
  set scaleMode(t) {
    this.magFilter = t, this.minFilter = t, this.mipmapFilter = t;
  }
  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
  get scaleMode() {
    return this.magFilter;
  }
  /** Specifies the maximum anisotropy value clamp used by the sampler. */
  set maxAnisotropy(t) {
    this._maxAnisotropy = Math.min(t, 16), this._maxAnisotropy > 1 && (this.scaleMode = "linear");
  }
  get maxAnisotropy() {
    return this._maxAnisotropy;
  }
  // TODO - move this to WebGL?
  get _resourceId() {
    return this._sharedResourceId || this._generateResourceId();
  }
  update() {
    this.emit("change", this), this._sharedResourceId = null;
  }
  _generateResourceId() {
    const t = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
    return this._sharedResourceId = nb(t), this._resourceId;
  }
  /** Destroys the style */
  destroy() {
    this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this.removeAllListeners();
  }
};
UR.defaultOptions = {
  addressMode: "clamp-to-edge",
  scaleMode: "linear"
};
let ab = UR;
const LR = class FR extends Js {
  /**
   * @param options - options for creating a new TextureSource
   */
  constructor(t = {}) {
    super(), this.options = t, this.uid = me("textureSource"), this._resourceType = "textureSource", this._resourceId = me("resource"), this.uploadMethodId = "unknown", this._resolution = 1, this.pixelWidth = 1, this.pixelHeight = 1, this.width = 1, this.height = 1, this.sampleCount = 1, this.mipLevelCount = 1, this.autoGenerateMipmaps = !1, this.format = "rgba8unorm", this.dimension = "2d", this.antialias = !1, this._touched = 0, this._batchTick = -1, this._textureBindLocation = -1, t = { ...FR.defaultOptions, ...t }, this.label = t.label ?? "", this.resource = t.resource, this.autoGarbageCollect = t.autoGarbageCollect, this._resolution = t.resolution, t.width ? this.pixelWidth = t.width * this._resolution : this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1, t.height ? this.pixelHeight = t.height * this._resolution : this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1, this.width = this.pixelWidth / this._resolution, this.height = this.pixelHeight / this._resolution, this.format = t.format, this.dimension = t.dimensions, this.mipLevelCount = t.mipLevelCount, this.autoGenerateMipmaps = t.autoGenerateMipmaps, this.sampleCount = t.sampleCount, this.antialias = t.antialias, this.alphaMode = t.alphaMode, this.style = new ab(rb(t)), this.destroyed = !1, this._refreshPOT();
  }
  /** returns itself */
  get source() {
    return this;
  }
  /** the style of the texture */
  get style() {
    return this._style;
  }
  set style(t) {
    var e, s;
    this.style !== t && ((e = this._style) == null || e.off("change", this._onStyleChange, this), this._style = t, (s = this._style) == null || s.on("change", this._onStyleChange, this), this._onStyleChange());
  }
  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
  get addressMode() {
    return this._style.addressMode;
  }
  set addressMode(t) {
    this._style.addressMode = t;
  }
  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
  get repeatMode() {
    return this._style.addressMode;
  }
  set repeatMode(t) {
    this._style.addressMode = t;
  }
  /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */
  get magFilter() {
    return this._style.magFilter;
  }
  set magFilter(t) {
    this._style.magFilter = t;
  }
  /** Specifies the sampling behavior when the sample footprint is larger than one texel. */
  get minFilter() {
    return this._style.minFilter;
  }
  set minFilter(t) {
    this._style.minFilter = t;
  }
  /** Specifies behavior for sampling between mipmap levels. */
  get mipmapFilter() {
    return this._style.mipmapFilter;
  }
  set mipmapFilter(t) {
    this._style.mipmapFilter = t;
  }
  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
  get lodMinClamp() {
    return this._style.lodMinClamp;
  }
  set lodMinClamp(t) {
    this._style.lodMinClamp = t;
  }
  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
  get lodMaxClamp() {
    return this._style.lodMaxClamp;
  }
  set lodMaxClamp(t) {
    this._style.lodMaxClamp = t;
  }
  _onStyleChange() {
    this.emit("styleChange", this);
  }
  /** call this if you have modified the texture outside of the constructor */
  update() {
    if (this.resource) {
      const t = this._resolution;
      if (this.resize(this.resourceWidth / t, this.resourceHeight / t))
        return;
    }
    this.emit("update", this);
  }
  /** Destroys this texture source */
  destroy() {
    this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._style && (this._style.destroy(), this._style = null), this.uploadMethodId = null, this.resource = null, this.removeAllListeners();
  }
  /**
   * This will unload the Texture source from the GPU. This will free up the GPU memory
   * As soon as it is required fore rendering, it will be re-uploaded.
   */
  unload() {
    this._resourceId = me("resource"), this.emit("change", this), this.emit("unload", this);
  }
  /** the width of the resource. This is the REAL pure number, not accounting resolution   */
  get resourceWidth() {
    const { resource: t } = this;
    return t.naturalWidth || t.videoWidth || t.displayWidth || t.width;
  }
  /** the height of the resource. This is the REAL pure number, not accounting resolution */
  get resourceHeight() {
    const { resource: t } = this;
    return t.naturalHeight || t.videoHeight || t.displayHeight || t.height;
  }
  /**
   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture
   * but will the size of the texture when rendered.
   *
   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel
   * density will have increased)
   */
  get resolution() {
    return this._resolution;
  }
  set resolution(t) {
    this._resolution !== t && (this._resolution = t, this.width = this.pixelWidth / t, this.height = this.pixelHeight / t);
  }
  /**
   * Resize the texture, this is handy if you want to use the texture as a render texture
   * @param width - the new width of the texture
   * @param height - the new height of the texture
   * @param resolution - the new resolution of the texture
   * @returns - if the texture was resized
   */
  resize(t, e, s) {
    s = s || this._resolution, t = t || this.width, e = e || this.height;
    const r = Math.round(t * s), n = Math.round(e * s);
    return this.width = r / s, this.height = n / s, this._resolution = s, this.pixelWidth === r && this.pixelHeight === n ? !1 : (this._refreshPOT(), this.pixelWidth = r, this.pixelHeight = n, this.emit("resize", this), this._resourceId = me("resource"), this.emit("change", this), !0);
  }
  /**
   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.
   * This is only important for RenderTexture instances, as standard Texture instances will have their
   * mipmaps generated on upload. You should call this method after you make any change to the texture
   *
   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,
   * We want you, the developer to specify when this action should happen.
   *
   * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,
   */
  updateMipmaps() {
    this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this);
  }
  set wrapMode(t) {
    this._style.wrapMode = t;
  }
  get wrapMode() {
    return this._style.wrapMode;
  }
  set scaleMode(t) {
    this._style.scaleMode = t;
  }
  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
  get scaleMode() {
    return this._style.scaleMode;
  }
  /**
   * Refresh check for isPowerOfTwo texture based on size
   * @private
   */
  _refreshPOT() {
    this.isPowerOfTwo = tS(this.pixelWidth) && tS(this.pixelHeight);
  }
  static test(t) {
    throw new Error("Unimplemented");
  }
};
LR.defaultOptions = {
  resolution: 1,
  format: "bgra8unorm",
  alphaMode: "premultiply-alpha-on-upload",
  dimensions: "2d",
  mipLevelCount: 1,
  autoGenerateMipmaps: !1,
  sampleCount: 1,
  antialias: !1,
  autoGarbageCollect: !1
};
let ke = LR;
class Md extends ke {
  constructor(t) {
    const e = t.resource || new Float32Array(t.width * t.height * 4);
    let s = t.format;
    s || (e instanceof Float32Array ? s = "rgba32float" : e instanceof Int32Array || e instanceof Uint32Array ? s = "rgba32uint" : e instanceof Int16Array || e instanceof Uint16Array ? s = "rgba16uint" : (e instanceof Int8Array, s = "bgra8unorm")), super({
      ...t,
      resource: e,
      format: s
    }), this.uploadMethodId = "buffer";
  }
  static test(t) {
    return t instanceof Int8Array || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array;
  }
}
Md.extension = B.TextureSource;
const sS = new ot();
class wR {
  /**
   * @param texture - observed texture
   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
   */
  constructor(t, e) {
    this.mapCoord = new ot(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, typeof e > "u" ? this.clampMargin = t.width < 10 ? 0 : 0.5 : this.clampMargin = e, this.isSimple = !1, this.texture = t;
  }
  /** Texture property. */
  get texture() {
    return this._texture;
  }
  set texture(t) {
    var e;
    this.texture !== t && ((e = this._texture) == null || e.removeListener("update", this.update, this), this._texture = t, this._texture.addListener("update", this.update, this), this.update());
  }
  /**
   * Multiplies uvs array to transform
   * @param uvs - mesh uvs
   * @param [out=uvs] - output
   * @returns - output
   */
  multiplyUvs(t, e) {
    e === void 0 && (e = t);
    const s = this.mapCoord;
    for (let r = 0; r < t.length; r += 2) {
      const n = t[r], a = t[r + 1];
      e[r] = n * s.a + a * s.c + s.tx, e[r + 1] = n * s.b + a * s.d + s.ty;
    }
    return e;
  }
  /**
   * Updates matrices if texture was changed
   * @returns - whether or not it was updated
   */
  update() {
    const t = this._texture;
    this._updateID++;
    const e = t.uvs;
    this.mapCoord.set(e.x1 - e.x0, e.y1 - e.y0, e.x3 - e.x0, e.y3 - e.y0, e.x0, e.y0);
    const s = t.orig, r = t.trim;
    r && (sS.set(
      s.width / r.width,
      0,
      0,
      s.height / r.height,
      -r.x / r.width,
      -r.y / r.height
    ), this.mapCoord.append(sS));
    const n = t.source, a = this.uClampFrame, o = this.clampMargin / n._resolution, h = this.clampOffset / n._resolution;
    return a[0] = (t.frame.x + o + h) / n.width, a[1] = (t.frame.y + o + h) / n.height, a[2] = (t.frame.x + t.frame.width - o + h) / n.width, a[3] = (t.frame.y + t.frame.height - o + h) / n.height, this.uClampOffset[0] = this.clampOffset / n.pixelWidth, this.uClampOffset[1] = this.clampOffset / n.pixelHeight, this.isSimple = t.frame.width === n.width && t.frame.height === n.height && t.rotate === 0, !0;
  }
}
class W extends Js {
  /**
   * @param {rendering.TextureOptions} options - Options for the texture
   */
  constructor({
    source: t,
    label: e,
    frame: s,
    orig: r,
    trim: n,
    defaultAnchor: a,
    defaultBorders: o,
    rotate: h,
    dynamic: u
  } = {}) {
    if (super(), this.uid = me("texture"), this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }, this.frame = new Kt(), this.noFrame = !1, this.dynamic = !1, this.isTexture = !0, this.label = e, this.source = (t == null ? void 0 : t.source) ?? new ke(), this.noFrame = !s, s)
      this.frame.copyFrom(s);
    else {
      const { width: c, height: l } = this._source;
      this.frame.width = c, this.frame.height = l;
    }
    this.orig = r || this.frame, this.trim = n, this.rotate = h ?? 0, this.defaultAnchor = a, this.defaultBorders = o, this.destroyed = !1, this.dynamic = u || !1, this.updateUvs();
  }
  set source(t) {
    this._source && this._source.off("resize", this.update, this), this._source = t, t.on("resize", this.update, this), this.emit("update", this);
  }
  /** the underlying source of the texture (equivalent of baseTexture in v7) */
  get source() {
    return this._source;
  }
  /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */
  get textureMatrix() {
    return this._textureMatrix || (this._textureMatrix = new wR(this)), this._textureMatrix;
  }
  /** The width of the Texture in pixels. */
  get width() {
    return this.orig.width;
  }
  /** The height of the Texture in pixels. */
  get height() {
    return this.orig.height;
  }
  /** Call this function when you have modified the frame of this texture. */
  updateUvs() {
    const { uvs: t, frame: e } = this, { width: s, height: r } = this._source, n = e.x / s, a = e.y / r, o = e.width / s, h = e.height / r;
    let u = this.rotate;
    if (u) {
      const c = o / 2, l = h / 2, _ = n + c, d = a + l;
      u = fe.add(u, fe.NW), t.x0 = _ + c * fe.uX(u), t.y0 = d + l * fe.uY(u), u = fe.add(u, 2), t.x1 = _ + c * fe.uX(u), t.y1 = d + l * fe.uY(u), u = fe.add(u, 2), t.x2 = _ + c * fe.uX(u), t.y2 = d + l * fe.uY(u), u = fe.add(u, 2), t.x3 = _ + c * fe.uX(u), t.y3 = d + l * fe.uY(u);
    } else
      t.x0 = n, t.y0 = a, t.x1 = n + o, t.y1 = a, t.x2 = n + o, t.y2 = a + h, t.x3 = n, t.y3 = a + h;
  }
  /**
   * Destroys this texture
   * @param destroySource - Destroy the source when the texture is destroyed.
   */
  destroy(t = !1) {
    this._source && t && (this._source.destroy(), this._source = null), this._textureMatrix = null, this.destroyed = !0, this.emit("destroy", this), this.removeAllListeners();
  }
  /**
   * Call this if you have modified the `texture outside` of the constructor.
   *
   * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.
   */
  update() {
    this.noFrame && (this.frame.width = this._source.width, this.frame.height = this._source.height), this.updateUvs(), this.emit("update", this);
  }
  /** @deprecated since 8.0.0 */
  get baseTexture() {
    return dt(Se, "Texture.baseTexture is now Texture.source"), this._source;
  }
}
W.EMPTY = new W({
  label: "EMPTY",
  source: new ke({
    label: "EMPTY"
  })
});
W.EMPTY.destroy = NR;
W.WHITE = new W({
  source: new Md({
    resource: new Uint8Array([255, 255, 255, 255]),
    width: 1,
    height: 1,
    alphaMode: "premultiply-alpha-on-upload",
    label: "WHITE"
  }),
  label: "WHITE"
});
W.WHITE.destroy = NR;
function ob(i, t, e, s) {
  const { width: r, height: n } = e.orig, a = e.trim;
  if (a) {
    const o = a.width, h = a.height;
    i.minX = a.x - t._x * r - s, i.maxX = i.minX + o, i.minY = a.y - t._y * n - s, i.maxY = i.minY + h;
  } else
    i.minX = -t._x * r - s, i.maxX = i.minX + r, i.minY = -t._y * n - s, i.maxY = i.minY + n;
}
const iS = new ot();
class Zs {
  constructor(t = 1 / 0, e = 1 / 0, s = -1 / 0, r = -1 / 0) {
    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = iS, this.minX = t, this.minY = e, this.maxX = s, this.maxY = r;
  }
  /**
   * Checks if bounds are empty.
   * @returns - True if empty.
   */
  isEmpty() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }
  /** The bounding rectangle of the bounds. */
  get rectangle() {
    this._rectangle || (this._rectangle = new Kt());
    const t = this._rectangle;
    return this.minX > this.maxX || this.minY > this.maxY ? (t.x = 0, t.y = 0, t.width = 0, t.height = 0) : t.copyFromBounds(this), t;
  }
  /** Clears the bounds and resets. */
  clear() {
    return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = iS, this;
  }
  /**
   * Sets the bounds.
   * @param x0 - left X of frame
   * @param y0 - top Y of frame
   * @param x1 - right X of frame
   * @param y1 - bottom Y of frame
   */
  set(t, e, s, r) {
    this.minX = t, this.minY = e, this.maxX = s, this.maxY = r;
  }
  /**
   * Adds sprite frame
   * @param x0 - left X of frame
   * @param y0 - top Y of frame
   * @param x1 - right X of frame
   * @param y1 - bottom Y of frame
   * @param matrix
   */
  addFrame(t, e, s, r, n) {
    n || (n = this.matrix);
    const a = n.a, o = n.b, h = n.c, u = n.d, c = n.tx, l = n.ty;
    let _ = this.minX, d = this.minY, f = this.maxX, p = this.maxY, g = a * t + h * e + c, m = o * t + u * e + l;
    g < _ && (_ = g), m < d && (d = m), g > f && (f = g), m > p && (p = m), g = a * s + h * e + c, m = o * s + u * e + l, g < _ && (_ = g), m < d && (d = m), g > f && (f = g), m > p && (p = m), g = a * t + h * r + c, m = o * t + u * r + l, g < _ && (_ = g), m < d && (d = m), g > f && (f = g), m > p && (p = m), g = a * s + h * r + c, m = o * s + u * r + l, g < _ && (_ = g), m < d && (d = m), g > f && (f = g), m > p && (p = m), this.minX = _, this.minY = d, this.maxX = f, this.maxY = p;
  }
  /**
   * Adds a rectangle to the bounds.
   * @param rect - The rectangle to be added.
   * @param matrix - The matrix to apply to the bounds.
   */
  addRect(t, e) {
    this.addFrame(t.x, t.y, t.x + t.width, t.y + t.height, e);
  }
  /**
   * Adds other {@link Bounds}.
   * @param bounds - The Bounds to be added
   * @param matrix
   */
  addBounds(t, e) {
    this.addFrame(t.minX, t.minY, t.maxX, t.maxY, e);
  }
  /**
   * Adds other Bounds, masked with Bounds.
   * @param mask - The Bounds to be added.
   */
  addBoundsMask(t) {
    this.minX = this.minX > t.minX ? this.minX : t.minX, this.minY = this.minY > t.minY ? this.minY : t.minY, this.maxX = this.maxX < t.maxX ? this.maxX : t.maxX, this.maxY = this.maxY < t.maxY ? this.maxY : t.maxY;
  }
  /**
   * Adds other Bounds, multiplied with matrix.
   * @param matrix - The matrix to apply to the bounds.
   */
  applyMatrix(t) {
    const e = this.minX, s = this.minY, r = this.maxX, n = this.maxY, { a, b: o, c: h, d: u, tx: c, ty: l } = t;
    let _ = a * e + h * s + c, d = o * e + u * s + l;
    this.minX = _, this.minY = d, this.maxX = _, this.maxY = d, _ = a * r + h * s + c, d = o * r + u * s + l, this.minX = _ < this.minX ? _ : this.minX, this.minY = d < this.minY ? d : this.minY, this.maxX = _ > this.maxX ? _ : this.maxX, this.maxY = d > this.maxY ? d : this.maxY, _ = a * e + h * n + c, d = o * e + u * n + l, this.minX = _ < this.minX ? _ : this.minX, this.minY = d < this.minY ? d : this.minY, this.maxX = _ > this.maxX ? _ : this.maxX, this.maxY = d > this.maxY ? d : this.maxY, _ = a * r + h * n + c, d = o * r + u * n + l, this.minX = _ < this.minX ? _ : this.minX, this.minY = d < this.minY ? d : this.minY, this.maxX = _ > this.maxX ? _ : this.maxX, this.maxY = d > this.maxY ? d : this.maxY;
  }
  /**
   * Resizes the bounds object to include the given rectangle.
   * @param rect - The rectangle to be included.
   */
  fit(t) {
    return this.minX < t.left && (this.minX = t.left), this.maxX > t.right && (this.maxX = t.right), this.minY < t.top && (this.minY = t.top), this.maxY > t.bottom && (this.maxY = t.bottom), this;
  }
  /**
   * Resizes the bounds object to include the given bounds.
   * @param left - The left value of the bounds.
   * @param right - The right value of the bounds.
   * @param top - The top value of the bounds.
   * @param bottom - The bottom value of the bounds.
   */
  fitBounds(t, e, s, r) {
    return this.minX < t && (this.minX = t), this.maxX > e && (this.maxX = e), this.minY < s && (this.minY = s), this.maxY > r && (this.maxY = r), this;
  }
  /**
   * Pads bounds object, making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @param paddingX - The horizontal padding amount.
   * @param paddingY - The vertical padding amount.
   */
  pad(t, e = t) {
    return this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e, this;
  }
  /** Ceils the bounds. */
  ceil() {
    return this.minX = Math.floor(this.minX), this.minY = Math.floor(this.minY), this.maxX = Math.ceil(this.maxX), this.maxY = Math.ceil(this.maxY), this;
  }
  /** Clones the bounds. */
  clone() {
    return new Zs(this.minX, this.minY, this.maxX, this.maxY);
  }
  /**
   * Scales the bounds by the given values
   * @param x - The X value to scale by.
   * @param y - The Y value to scale by.
   */
  scale(t, e = t) {
    return this.minX *= t, this.minY *= e, this.maxX *= t, this.maxY *= e, this;
  }
  /** the x value of the bounds. */
  get x() {
    return this.minX;
  }
  set x(t) {
    const e = this.maxX - this.minX;
    this.minX = t, this.maxX = t + e;
  }
  /** the y value of the bounds. */
  get y() {
    return this.minY;
  }
  set y(t) {
    const e = this.maxY - this.minY;
    this.minY = t, this.maxY = t + e;
  }
  /** the width value of the bounds. */
  get width() {
    return this.maxX - this.minX;
  }
  set width(t) {
    this.maxX = this.minX + t;
  }
  /** the height value of the bounds. */
  get height() {
    return this.maxY - this.minY;
  }
  set height(t) {
    this.maxY = this.minY + t;
  }
  /** the left value of the bounds. */
  get left() {
    return this.minX;
  }
  /** the right value of the bounds. */
  get right() {
    return this.maxX;
  }
  /** the top value of the bounds. */
  get top() {
    return this.minY;
  }
  /** the bottom value of the bounds. */
  get bottom() {
    return this.maxY;
  }
  /** Is the bounds positive. */
  get isPositive() {
    return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
  }
  get isValid() {
    return this.minX + this.minY !== 1 / 0;
  }
  /**
   * Adds screen vertices from array
   * @param vertexData - calculated vertices
   * @param beginOffset - begin offset
   * @param endOffset - end offset, excluded
   * @param matrix
   */
  addVertexData(t, e, s, r) {
    let n = this.minX, a = this.minY, o = this.maxX, h = this.maxY;
    r || (r = this.matrix);
    const u = r.a, c = r.b, l = r.c, _ = r.d, d = r.tx, f = r.ty;
    for (let p = e; p < s; p += 2) {
      const g = t[p], m = t[p + 1], O = u * g + l * m + d, y = c * g + _ * m + f;
      n = O < n ? O : n, a = y < a ? y : a, o = O > o ? O : o, h = y > h ? y : h;
    }
    this.minX = n, this.minY = a, this.maxX = o, this.maxY = h;
  }
  /**
   * Checks if the point is contained within the bounds.
   * @param x - x coordinate
   * @param y - y coordinate
   */
  containsPoint(t, e) {
    return this.minX <= t && this.minY <= e && this.maxX >= t && this.maxY >= e;
  }
  toString() {
    return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
  }
}
var hb = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, $i = function(i) {
  return typeof i == "string" ? i.length > 0 : typeof i == "number";
}, Be = function(i, t, e) {
  return t === void 0 && (t = 0), e === void 0 && (e = Math.pow(10, t)), Math.round(e * i) / e + 0;
}, Ks = function(i, t, e) {
  return t === void 0 && (t = 0), e === void 0 && (e = 1), i > e ? e : i > t ? i : t;
}, GR = function(i) {
  return (i = isFinite(i) ? i % 360 : 0) > 0 ? i : i + 360;
}, rS = function(i) {
  return { r: Ks(i.r, 0, 255), g: Ks(i.g, 0, 255), b: Ks(i.b, 0, 255), a: Ks(i.a) };
}, tf = function(i) {
  return { r: Be(i.r), g: Be(i.g), b: Be(i.b), a: Be(i.a, 3) };
}, ub = /^#([0-9a-f]{3,8})$/i, Ju = function(i) {
  var t = i.toString(16);
  return t.length < 2 ? "0" + t : t;
}, BR = function(i) {
  var t = i.r, e = i.g, s = i.b, r = i.a, n = Math.max(t, e, s), a = n - Math.min(t, e, s), o = a ? n === t ? (e - s) / a : n === e ? 2 + (s - t) / a : 4 + (t - e) / a : 0;
  return { h: 60 * (o < 0 ? o + 6 : o), s: n ? a / n * 100 : 0, v: n / 255 * 100, a: r };
}, kR = function(i) {
  var t = i.h, e = i.s, s = i.v, r = i.a;
  t = t / 360 * 6, e /= 100, s /= 100;
  var n = Math.floor(t), a = s * (1 - e), o = s * (1 - (t - n) * e), h = s * (1 - (1 - t + n) * e), u = n % 6;
  return { r: 255 * [s, o, a, a, h, s][u], g: 255 * [h, s, s, o, a, a][u], b: 255 * [a, a, h, s, s, o][u], a: r };
}, nS = function(i) {
  return { h: GR(i.h), s: Ks(i.s, 0, 100), l: Ks(i.l, 0, 100), a: Ks(i.a) };
}, aS = function(i) {
  return { h: Be(i.h), s: Be(i.s), l: Be(i.l), a: Be(i.a, 3) };
}, oS = function(i) {
  return kR((e = (t = i).s, { h: t.h, s: (e *= ((s = t.l) < 50 ? s : 100 - s) / 100) > 0 ? 2 * e / (s + e) * 100 : 0, v: s + e, a: t.a }));
  var t, e, s;
}, mh = function(i) {
  return { h: (t = BR(i)).h, s: (r = (200 - (e = t.s)) * (s = t.v) / 100) > 0 && r < 200 ? e * s / 100 / (r <= 100 ? r : 200 - r) * 100 : 0, l: r / 2, a: t.a };
  var t, e, s, r;
}, lb = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, cb = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, _b = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, db = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, ig = { string: [[function(i) {
  var t = ub.exec(i);
  return t ? (i = t[1]).length <= 4 ? { r: parseInt(i[0] + i[0], 16), g: parseInt(i[1] + i[1], 16), b: parseInt(i[2] + i[2], 16), a: i.length === 4 ? Be(parseInt(i[3] + i[3], 16) / 255, 2) : 1 } : i.length === 6 || i.length === 8 ? { r: parseInt(i.substr(0, 2), 16), g: parseInt(i.substr(2, 2), 16), b: parseInt(i.substr(4, 2), 16), a: i.length === 8 ? Be(parseInt(i.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(i) {
  var t = _b.exec(i) || db.exec(i);
  return t ? t[2] !== t[4] || t[4] !== t[6] ? null : rS({ r: Number(t[1]) / (t[2] ? 100 / 255 : 1), g: Number(t[3]) / (t[4] ? 100 / 255 : 1), b: Number(t[5]) / (t[6] ? 100 / 255 : 1), a: t[7] === void 0 ? 1 : Number(t[7]) / (t[8] ? 100 : 1) }) : null;
}, "rgb"], [function(i) {
  var t = lb.exec(i) || cb.exec(i);
  if (!t) return null;
  var e, s, r = nS({ h: (e = t[1], s = t[2], s === void 0 && (s = "deg"), Number(e) * (hb[s] || 1)), s: Number(t[3]), l: Number(t[4]), a: t[5] === void 0 ? 1 : Number(t[5]) / (t[6] ? 100 : 1) });
  return oS(r);
}, "hsl"]], object: [[function(i) {
  var t = i.r, e = i.g, s = i.b, r = i.a, n = r === void 0 ? 1 : r;
  return $i(t) && $i(e) && $i(s) ? rS({ r: Number(t), g: Number(e), b: Number(s), a: Number(n) }) : null;
}, "rgb"], [function(i) {
  var t = i.h, e = i.s, s = i.l, r = i.a, n = r === void 0 ? 1 : r;
  if (!$i(t) || !$i(e) || !$i(s)) return null;
  var a = nS({ h: Number(t), s: Number(e), l: Number(s), a: Number(n) });
  return oS(a);
}, "hsl"], [function(i) {
  var t = i.h, e = i.s, s = i.v, r = i.a, n = r === void 0 ? 1 : r;
  if (!$i(t) || !$i(e) || !$i(s)) return null;
  var a = function(o) {
    return { h: GR(o.h), s: Ks(o.s, 0, 100), v: Ks(o.v, 0, 100), a: Ks(o.a) };
  }({ h: Number(t), s: Number(e), v: Number(s), a: Number(n) });
  return kR(a);
}, "hsv"]] }, hS = function(i, t) {
  for (var e = 0; e < t.length; e++) {
    var s = t[e][0](i);
    if (s) return [s, t[e][1]];
  }
  return [null, void 0];
}, fb = function(i) {
  return typeof i == "string" ? hS(i.trim(), ig.string) : typeof i == "object" && i !== null ? hS(i, ig.object) : [null, void 0];
}, ef = function(i, t) {
  var e = mh(i);
  return { h: e.h, s: Ks(e.s + 100 * t, 0, 100), l: e.l, a: e.a };
}, sf = function(i) {
  return (299 * i.r + 587 * i.g + 114 * i.b) / 1e3 / 255;
}, uS = function(i, t) {
  var e = mh(i);
  return { h: e.h, s: e.s, l: Ks(e.l + 100 * t, 0, 100), a: e.a };
}, rg = function() {
  function i(t) {
    this.parsed = fb(t)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return i.prototype.isValid = function() {
    return this.parsed !== null;
  }, i.prototype.brightness = function() {
    return Be(sf(this.rgba), 2);
  }, i.prototype.isDark = function() {
    return sf(this.rgba) < 0.5;
  }, i.prototype.isLight = function() {
    return sf(this.rgba) >= 0.5;
  }, i.prototype.toHex = function() {
    return t = tf(this.rgba), e = t.r, s = t.g, r = t.b, a = (n = t.a) < 1 ? Ju(Be(255 * n)) : "", "#" + Ju(e) + Ju(s) + Ju(r) + a;
    var t, e, s, r, n, a;
  }, i.prototype.toRgb = function() {
    return tf(this.rgba);
  }, i.prototype.toRgbString = function() {
    return t = tf(this.rgba), e = t.r, s = t.g, r = t.b, (n = t.a) < 1 ? "rgba(" + e + ", " + s + ", " + r + ", " + n + ")" : "rgb(" + e + ", " + s + ", " + r + ")";
    var t, e, s, r, n;
  }, i.prototype.toHsl = function() {
    return aS(mh(this.rgba));
  }, i.prototype.toHslString = function() {
    return t = aS(mh(this.rgba)), e = t.h, s = t.s, r = t.l, (n = t.a) < 1 ? "hsla(" + e + ", " + s + "%, " + r + "%, " + n + ")" : "hsl(" + e + ", " + s + "%, " + r + "%)";
    var t, e, s, r, n;
  }, i.prototype.toHsv = function() {
    return t = BR(this.rgba), { h: Be(t.h), s: Be(t.s), v: Be(t.v), a: Be(t.a, 3) };
    var t;
  }, i.prototype.invert = function() {
    return Ei({ r: 255 - (t = this.rgba).r, g: 255 - t.g, b: 255 - t.b, a: t.a });
    var t;
  }, i.prototype.saturate = function(t) {
    return t === void 0 && (t = 0.1), Ei(ef(this.rgba, t));
  }, i.prototype.desaturate = function(t) {
    return t === void 0 && (t = 0.1), Ei(ef(this.rgba, -t));
  }, i.prototype.grayscale = function() {
    return Ei(ef(this.rgba, -1));
  }, i.prototype.lighten = function(t) {
    return t === void 0 && (t = 0.1), Ei(uS(this.rgba, t));
  }, i.prototype.darken = function(t) {
    return t === void 0 && (t = 0.1), Ei(uS(this.rgba, -t));
  }, i.prototype.rotate = function(t) {
    return t === void 0 && (t = 15), this.hue(this.hue() + t);
  }, i.prototype.alpha = function(t) {
    return typeof t == "number" ? Ei({ r: (e = this.rgba).r, g: e.g, b: e.b, a: t }) : Be(this.rgba.a, 3);
    var e;
  }, i.prototype.hue = function(t) {
    var e = mh(this.rgba);
    return typeof t == "number" ? Ei({ h: t, s: e.s, l: e.l, a: e.a }) : Be(e.h);
  }, i.prototype.isEqual = function(t) {
    return this.toHex() === Ei(t).toHex();
  }, i;
}(), Ei = function(i) {
  return i instanceof rg ? i : new rg(i);
}, lS = [], gb = function(i) {
  i.forEach(function(t) {
    lS.indexOf(t) < 0 && (t(rg, ig), lS.push(t));
  });
};
function pb(i, t) {
  var e = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, s = {};
  for (var r in e) s[e[r]] = r;
  var n = {};
  i.prototype.toName = function(a) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
    var o, h, u = s[this.toHex()];
    if (u) return u;
    if (a != null && a.closest) {
      var c = this.toRgb(), l = 1 / 0, _ = "black";
      if (!n.length) for (var d in e) n[d] = new i(e[d]).toRgb();
      for (var f in e) {
        var p = (o = c, h = n[f], Math.pow(o.r - h.r, 2) + Math.pow(o.g - h.g, 2) + Math.pow(o.b - h.b, 2));
        p < l && (l = p, _ = f);
      }
      return _;
    }
  }, t.string.push([function(a) {
    var o = a.toLowerCase(), h = o === "transparent" ? "#0000" : e[o];
    return h ? new i(h).toRgb() : null;
  }, "name"]);
}
gb([pb]);
const No = class ch {
  /**
   * @param {ColorSource} value - Optional value to use, if not provided, white is used.
   */
  constructor(t = 16777215) {
    this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = t;
  }
  /** Get red component (0 - 1) */
  get red() {
    return this._components[0];
  }
  /** Get green component (0 - 1) */
  get green() {
    return this._components[1];
  }
  /** Get blue component (0 - 1) */
  get blue() {
    return this._components[2];
  }
  /** Get alpha component (0 - 1) */
  get alpha() {
    return this._components[3];
  }
  /**
   * Set the value, suitable for chaining
   * @param value
   * @see Color.value
   */
  setValue(t) {
    return this.value = t, this;
  }
  /**
   * The current color source.
   *
   * When setting:
   * - Setting to an instance of `Color` will copy its color source and components.
   * - Otherwise, `Color` will try to normalize the color source and set the components.
   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.
   *
   * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter
   * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.
   *
   * When getting:
   * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},
   *   {@link Color.premultiply premultiply} or {@link Color.round round}).
   * - Otherwise, the color source used when setting is returned.
   */
  set value(t) {
    if (t instanceof ch)
      this._value = this._cloneSource(t._value), this._int = t._int, this._components.set(t._components);
    else {
      if (t === null)
        throw new Error("Cannot set Color#value to null");
      (this._value === null || !this._isSourceEqual(this._value, t)) && (this._value = this._cloneSource(t), this._normalize(this._value));
    }
  }
  get value() {
    return this._value;
  }
  /**
   * Copy a color source internally.
   * @param value - Color source
   */
  _cloneSource(t) {
    return typeof t == "string" || typeof t == "number" || t instanceof Number || t === null ? t : Array.isArray(t) || ArrayBuffer.isView(t) ? t.slice(0) : typeof t == "object" && t !== null ? { ...t } : t;
  }
  /**
   * Equality check for color sources.
   * @param value1 - First color source
   * @param value2 - Second color source
   * @returns `true` if the color sources are equal, `false` otherwise.
   */
  _isSourceEqual(t, e) {
    const s = typeof t;
    if (s !== typeof e)
      return !1;
    if (s === "number" || s === "string" || t instanceof Number)
      return t === e;
    if (Array.isArray(t) && Array.isArray(e) || ArrayBuffer.isView(t) && ArrayBuffer.isView(e))
      return t.length !== e.length ? !1 : t.every((n, a) => n === e[a]);
    if (t !== null && e !== null) {
      const n = Object.keys(t), a = Object.keys(e);
      return n.length !== a.length ? !1 : n.every((o) => t[o] === e[o]);
    }
    return t === e;
  }
  /**
   * Convert to a RGBA color object.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }
   */
  toRgba() {
    const [t, e, s, r] = this._components;
    return { r: t, g: e, b: s, a: r };
  }
  /**
   * Convert to a RGB color object.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }
   */
  toRgb() {
    const [t, e, s] = this._components;
    return { r: t, g: e, b: s };
  }
  /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */
  toRgbaString() {
    const [t, e, s] = this.toUint8RgbArray();
    return `rgba(${t},${e},${s},${this.alpha})`;
  }
  toUint8RgbArray(t) {
    const [e, s, r] = this._components;
    return this._arrayRgb || (this._arrayRgb = []), t = t || this._arrayRgb, t[0] = Math.round(e * 255), t[1] = Math.round(s * 255), t[2] = Math.round(r * 255), t;
  }
  toArray(t) {
    this._arrayRgba || (this._arrayRgba = []), t = t || this._arrayRgba;
    const [e, s, r, n] = this._components;
    return t[0] = e, t[1] = s, t[2] = r, t[3] = n, t;
  }
  toRgbArray(t) {
    this._arrayRgb || (this._arrayRgb = []), t = t || this._arrayRgb;
    const [e, s, r] = this._components;
    return t[0] = e, t[1] = s, t[2] = r, t;
  }
  /**
   * Convert to a hexadecimal number.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toNumber(); // returns 16777215
   */
  toNumber() {
    return this._int;
  }
  /**
   * Convert to a BGR number
   * @example
   * import { Color } from 'pixi.js';
   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff
   */
  toBgrNumber() {
    const [t, e, s] = this.toUint8RgbArray();
    return (s << 16) + (e << 8) + t;
  }
  /**
   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
   * @example
   * import { Color } from 'pixi.js';
   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
   * @returns {number} - The color as a number in little endian format.
   */
  toLittleEndianNumber() {
    const t = this._int;
    return (t >> 16) + (t & 65280) + ((t & 255) << 16);
  }
  /**
   * Multiply with another color. This action is destructive, and will
   * override the previous `value` property to be `null`.
   * @param {ColorSource} value - The color to multiply by.
   */
  multiply(t) {
    const [e, s, r, n] = ch._temp.setValue(t)._components;
    return this._components[0] *= e, this._components[1] *= s, this._components[2] *= r, this._components[3] *= n, this._refreshInt(), this._value = null, this;
  }
  /**
   * Converts color to a premultiplied alpha format. This action is destructive, and will
   * override the previous `value` property to be `null`.
   * @param alpha - The alpha to multiply by.
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
   * @returns {Color} - Itself.
   */
  premultiply(t, e = !0) {
    return e && (this._components[0] *= t, this._components[1] *= t, this._components[2] *= t), this._components[3] = t, this._refreshInt(), this._value = null, this;
  }
  /**
   * Premultiplies alpha with current color.
   * @param {number} alpha - The alpha to multiply by.
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
   * @returns {number} tint multiplied by alpha
   */
  toPremultiplied(t, e = !0) {
    if (t === 1)
      return (255 << 24) + this._int;
    if (t === 0)
      return e ? 0 : this._int;
    let s = this._int >> 16 & 255, r = this._int >> 8 & 255, n = this._int & 255;
    return e && (s = s * t + 0.5 | 0, r = r * t + 0.5 | 0, n = n * t + 0.5 | 0), (t * 255 << 24) + (s << 16) + (r << 8) + n;
  }
  /**
   * Convert to a hexadecimal string.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toHex(); // returns "#ffffff"
   */
  toHex() {
    const t = this._int.toString(16);
    return `#${"000000".substring(0, 6 - t.length) + t}`;
  }
  /**
   * Convert to a hexadecimal string with alpha.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toHexa(); // returns "#ffffffff"
   */
  toHexa() {
    const e = Math.round(this._components[3] * 255).toString(16);
    return this.toHex() + "00".substring(0, 2 - e.length) + e;
  }
  /**
   * Set alpha, suitable for chaining.
   * @param alpha
   */
  setAlpha(t) {
    return this._components[3] = this._clamp(t), this;
  }
  /**
   * Normalize the input value into rgba
   * @param value - Input value
   */
  _normalize(t) {
    let e, s, r, n;
    if ((typeof t == "number" || t instanceof Number) && t >= 0 && t <= 16777215) {
      const a = t;
      e = (a >> 16 & 255) / 255, s = (a >> 8 & 255) / 255, r = (a & 255) / 255, n = 1;
    } else if ((Array.isArray(t) || t instanceof Float32Array) && t.length >= 3 && t.length <= 4)
      t = this._clamp(t), [e, s, r, n = 1] = t;
    else if ((t instanceof Uint8Array || t instanceof Uint8ClampedArray) && t.length >= 3 && t.length <= 4)
      t = this._clamp(t, 0, 255), [e, s, r, n = 255] = t, e /= 255, s /= 255, r /= 255, n /= 255;
    else if (typeof t == "string" || typeof t == "object") {
      if (typeof t == "string") {
        const o = ch.HEX_PATTERN.exec(t);
        o && (t = `#${o[2]}`);
      }
      const a = Ei(t);
      a.isValid() && ({ r: e, g: s, b: r, a: n } = a.rgba, e /= 255, s /= 255, r /= 255);
    }
    if (e !== void 0)
      this._components[0] = e, this._components[1] = s, this._components[2] = r, this._components[3] = n, this._refreshInt();
    else
      throw new Error(`Unable to convert color ${t}`);
  }
  /** Refresh the internal color rgb number */
  _refreshInt() {
    this._clamp(this._components);
    const [t, e, s] = this._components;
    this._int = (t * 255 << 16) + (e * 255 << 8) + (s * 255 | 0);
  }
  /**
   * Clamps values to a range. Will override original values
   * @param value - Value(s) to clamp
   * @param min - Minimum value
   * @param max - Maximum value
   */
  _clamp(t, e = 0, s = 1) {
    return typeof t == "number" ? Math.min(Math.max(t, e), s) : (t.forEach((r, n) => {
      t[n] = Math.min(Math.max(r, e), s);
    }), t);
  }
  /**
   * Check if the value is a color-like object
   * @param value - Value to check
   * @returns True if the value is a color-like object
   * @static
   * @example
   * import { Color } from 'pixi.js';
   * Color.isColorLike('white'); // returns true
   * Color.isColorLike(0xffffff); // returns true
   * Color.isColorLike([1, 1, 1]); // returns true
   */
  static isColorLike(t) {
    return typeof t == "number" || typeof t == "string" || t instanceof Number || t instanceof ch || Array.isArray(t) || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Float32Array || t.r !== void 0 && t.g !== void 0 && t.b !== void 0 || t.r !== void 0 && t.g !== void 0 && t.b !== void 0 && t.a !== void 0 || t.h !== void 0 && t.s !== void 0 && t.l !== void 0 || t.h !== void 0 && t.s !== void 0 && t.l !== void 0 && t.a !== void 0 || t.h !== void 0 && t.s !== void 0 && t.v !== void 0 || t.h !== void 0 && t.s !== void 0 && t.v !== void 0 && t.a !== void 0;
  }
};
No.shared = new No();
No._temp = new No();
No.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
let Pt = No;
const mb = {
  cullArea: null,
  cullable: !1,
  cullableChildren: !0
};
class dT {
  /**
   * Constructs a new Pool.
   * @param ClassType - The constructor of the items in the pool.
   * @param {number} [initialSize] - The initial size of the pool.
   */
  constructor(t, e) {
    this._pool = [], this._count = 0, this._index = 0, this._classType = t, e && this.prepopulate(e);
  }
  /**
   * Prepopulates the pool with a given number of items.
   * @param total - The number of items to add to the pool.
   */
  prepopulate(t) {
    for (let e = 0; e < t; e++)
      this._pool[this._index++] = new this._classType();
    this._count += t;
  }
  /**
   * Gets an item from the pool. Calls the item's `init` method if it exists.
   * If there are no items left in the pool, a new one will be created.
   * @param {unknown} [data] - Optional data to pass to the item's constructor.
   * @returns {T} The item from the pool.
   */
  get(t) {
    var s;
    let e;
    return this._index > 0 ? e = this._pool[--this._index] : e = new this._classType(), (s = e.init) == null || s.call(e, t), e;
  }
  /**
   * Returns an item to the pool. Calls the item's `reset` method if it exists.
   * @param {T} item - The item to return to the pool.
   */
  return(t) {
    var e;
    (e = t.reset) == null || e.call(t), this._pool[this._index++] = t;
  }
  /**
   * Gets the number of items in the pool.
   * @readonly
   * @member {number}
   */
  get totalSize() {
    return this._count;
  }
  /**
   * Gets the number of items in the pool that are free to use without needing to create more.
   * @readonly
   * @member {number}
   */
  get totalFree() {
    return this._index;
  }
  /**
   * Gets the number of items in the pool that are currently in use.
   * @readonly
   * @member {number}
   */
  get totalUsed() {
    return this._count - this._index;
  }
  /** clears the pool - mainly used for debugging! */
  clear() {
    this._pool.length = 0, this._index = 0;
  }
}
class Eb {
  constructor() {
    this._poolsByClass = /* @__PURE__ */ new Map();
  }
  /**
   * Prepopulates a specific pool with a given number of items.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
   * @param {number} total - The number of items to add to the pool.
   */
  prepopulate(t, e) {
    this.getPool(t).prepopulate(e);
  }
  /**
   * Gets an item from a specific pool.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
   * @param {unknown} [data] - Optional data to pass to the item's constructor.
   * @returns {T} The item from the pool.
   */
  get(t, e) {
    return this.getPool(t).get(e);
  }
  /**
   * Returns an item to its respective pool.
   * @param {PoolItem} item - The item to return to the pool.
   */
  return(t) {
    this.getPool(t.constructor).return(t);
  }
  /**
   * Gets a specific pool based on the class type.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.
   * @returns {Pool<T>} The pool of the given class type.
   */
  getPool(t) {
    return this._poolsByClass.has(t) || this._poolsByClass.set(t, new dT(t)), this._poolsByClass.get(t);
  }
  /** gets the usage stats of each pool in the system */
  stats() {
    const t = {};
    return this._poolsByClass.forEach((e) => {
      const s = t[e._classType.name] ? e._classType.name + e._classType.ID : e._classType.name;
      t[s] = {
        free: e.totalFree,
        used: e.totalUsed,
        size: e.totalSize
      };
    }), t;
  }
}
const Es = new Eb();
function Tb(i, t, e) {
  const s = i.length;
  let r;
  if (t >= s || e === 0)
    return;
  e = t + e > s ? s - t : e;
  const n = s - e;
  for (r = t; r < n; ++r)
    i[r] = i[r + e];
  i.length = n;
}
const Ib = {
  allowChildren: !0,
  /**
   * Removes all children from this container that are within the begin and end indexes.
   * @param beginIndex - The beginning position.
   * @param endIndex - The ending position. Default value is size of the container.
   * @returns - List of removed children
   * @memberof scene.Container#
   */
  removeChildren(i = 0, t) {
    const e = t ?? this.children.length, s = e - i, r = [];
    if (s > 0 && s <= e) {
      for (let a = e - 1; a >= i; a--) {
        const o = this.children[a];
        o && (r.push(o), o.parent = null);
      }
      Tb(this.children, i, e);
      const n = this.renderGroup || this.parentRenderGroup;
      n && n.removeChildren(r);
      for (let a = 0; a < r.length; ++a)
        this.emit("childRemoved", r[a], this, a), r[a].emit("removed", this);
      return r;
    } else if (s === 0 && this.children.length === 0)
      return r;
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  },
  /**
   * Removes a child from the specified index position.
   * @param index - The index to get the child from
   * @returns The child that was removed.
   * @memberof scene.Container#
   */
  removeChildAt(i) {
    const t = this.getChildAt(i);
    return this.removeChild(t);
  },
  /**
   * Returns the child at the specified index
   * @param index - The index to get the child at
   * @returns - The child at the given index, if any.
   * @memberof scene.Container#
   */
  getChildAt(i) {
    if (i < 0 || i >= this.children.length)
      throw new Error(`getChildAt: Index (${i}) does not exist.`);
    return this.children[i];
  },
  /**
   * Changes the position of an existing child in the container container
   * @param child - The child Container instance for which you want to change the index number
   * @param index - The resulting index number for the child container
   * @memberof scene.Container#
   */
  setChildIndex(i, t) {
    if (t < 0 || t >= this.children.length)
      throw new Error(`The index ${t} supplied is out of bounds ${this.children.length}`);
    this.getChildIndex(i), this.addChildAt(i, t);
  },
  /**
   * Returns the index position of a child Container instance
   * @param child - The Container instance to identify
   * @returns - The index position of the child container to identify
   * @memberof scene.Container#
   */
  getChildIndex(i) {
    const t = this.children.indexOf(i);
    if (t === -1)
      throw new Error("The supplied Container must be a child of the caller");
    return t;
  },
  /**
   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.
   * If the child is already in this container, it will be moved to the specified index.
   * @param {Container} child - The child to add.
   * @param {number} index - The absolute index where the child will be positioned at the end of the operation.
   * @returns {Container} The child that was added.
   * @memberof scene.Container#
   */
  addChildAt(i, t) {
    this.allowChildren || dt(Se, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
    const { children: e } = this;
    if (t < 0 || t > e.length)
      throw new Error(`${i}addChildAt: The index ${t} supplied is out of bounds ${e.length}`);
    if (i.parent) {
      const r = i.parent.children.indexOf(i);
      if (i.parent === this && r === t)
        return i;
      r !== -1 && i.parent.children.splice(r, 1);
    }
    t === e.length ? e.push(i) : e.splice(t, 0, i), i.parent = this, i.didChange = !0, i._updateFlags = 15;
    const s = this.renderGroup || this.parentRenderGroup;
    return s && s.addChild(i), this.sortableChildren && (this.sortDirty = !0), this.emit("childAdded", i, this, t), i.emit("added", this), i;
  },
  /**
   * Swaps the position of 2 Containers within this container.
   * @param child - First container to swap
   * @param child2 - Second container to swap
   * @memberof scene.Container#
   */
  swapChildren(i, t) {
    if (i === t)
      return;
    const e = this.getChildIndex(i), s = this.getChildIndex(t);
    this.children[e] = t, this.children[s] = i;
    const r = this.renderGroup || this.parentRenderGroup;
    r && (r.structureDidChange = !0), this._didContainerChangeTick++;
  },
  /**
   * Remove the Container from its parent Container. If the Container has no parent, do nothing.
   * @memberof scene.Container#
   */
  removeFromParent() {
    var i;
    (i = this.parent) == null || i.removeChild(this);
  },
  /**
   * Reparent the child to this container, keeping the same worldTransform.
   * @param child - The child to reparent
   * @returns The first child that was reparented.
   * @memberof scene.Container#
   */
  reparentChild(...i) {
    return i.length === 1 ? this.reparentChildAt(i[0], this.children.length) : (i.forEach((t) => this.reparentChildAt(t, this.children.length)), i[0]);
  },
  /**
   * Reparent the child to this container at the specified index, keeping the same worldTransform.
   * @param child - The child to reparent
   * @param index - The index to reparent the child to
   * @memberof scene.Container#
   */
  reparentChildAt(i, t) {
    if (i.parent === this)
      return this.setChildIndex(i, t), i;
    const e = i.worldTransform.clone();
    i.removeFromParent(), this.addChildAt(i, t);
    const s = this.worldTransform.clone();
    return s.invert(), e.prepend(s), i.setFromMatrix(e), i;
  }
};
class Fl {
  constructor() {
    this.pipe = "filter", this.priority = 1;
  }
  destroy() {
    for (let t = 0; t < this.filters.length; t++)
      this.filters[t].destroy();
    this.filters = null, this.filterArea = null;
  }
}
class Sb {
  constructor() {
    this._effectClasses = [], this._tests = [], this._initialized = !1;
  }
  init() {
    this._initialized || (this._initialized = !0, this._effectClasses.forEach((t) => {
      this.add({
        test: t.test,
        maskClass: t
      });
    }));
  }
  add(t) {
    this._tests.push(t);
  }
  getMaskEffect(t) {
    this._initialized || this.init();
    for (let e = 0; e < this._tests.length; e++) {
      const s = this._tests[e];
      if (s.test(t))
        return Es.get(s.maskClass, t);
    }
    return t;
  }
  returnMaskEffect(t) {
    Es.return(t);
  }
}
const ng = new Sb();
Ee.handleByList(B.MaskEffect, ng._effectClasses);
const Ab = {
  _maskEffect: null,
  _maskOptions: {
    inverse: !1
  },
  _filterEffect: null,
  /**
   * @todo Needs docs.
   * @memberof scene.Container#
   * @type {Array<Effect>}
   */
  effects: [],
  /**
   * @todo Needs docs.
   * @param effect - The effect to add.
   * @memberof scene.Container#
   * @ignore
   */
  addEffect(i) {
    if (this.effects.indexOf(i) !== -1)
      return;
    this.effects.push(i), this.effects.sort((s, r) => s.priority - r.priority);
    const e = this.renderGroup || this.parentRenderGroup;
    e && (e.structureDidChange = !0), this._updateIsSimple();
  },
  /**
   * @todo Needs docs.
   * @param effect - The effect to remove.
   * @memberof scene.Container#
   * @ignore
   */
  removeEffect(i) {
    const t = this.effects.indexOf(i);
    t !== -1 && (this.effects.splice(t, 1), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateIsSimple());
  },
  set mask(i) {
    const t = this._maskEffect;
    (t == null ? void 0 : t.mask) !== i && (t && (this.removeEffect(t), ng.returnMaskEffect(t), this._maskEffect = null), i != null && (this._maskEffect = ng.getMaskEffect(i), this.addEffect(this._maskEffect)));
  },
  /**
   * Used to set mask and control mask options.
   * @param options
   * @example
   * import { Graphics, Sprite } from 'pixi.js';
   *
   * const graphics = new Graphics();
   * graphics.beginFill(0xFF3300);
   * graphics.drawRect(50, 250, 100, 100);
   * graphics.endFill();
   *
   * const sprite = new Sprite(texture);
   * sprite.setMask({
   *     mask: graphics,
   *     inverse: true,
   * });
   * @memberof scene.Container#
   */
  setMask(i) {
    this._maskOptions = {
      ...this._maskOptions,
      ...i
    }, i.mask && (this.mask = i.mask);
  },
  /**
   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
   * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it
   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
   * To remove a mask, set this property to `null`.
   *
   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
   * @example
   * import { Graphics, Sprite } from 'pixi.js';
   *
   * const graphics = new Graphics();
   * graphics.beginFill(0xFF3300);
   * graphics.drawRect(50, 250, 100, 100);
   * graphics.endFill();
   *
   * const sprite = new Sprite(texture);
   * sprite.mask = graphics;
   * @memberof scene.Container#
   */
  get mask() {
    var i;
    return (i = this._maskEffect) == null ? void 0 : i.mask;
  },
  set filters(i) {
    var n;
    !Array.isArray(i) && i && (i = [i]);
    const t = this._filterEffect || (this._filterEffect = new Fl());
    i = i;
    const e = (i == null ? void 0 : i.length) > 0, s = ((n = t.filters) == null ? void 0 : n.length) > 0, r = e !== s;
    i = Array.isArray(i) ? i.slice(0) : i, t.filters = Object.freeze(i), r && (e ? this.addEffect(t) : (this.removeEffect(t), t.filters = i ?? null));
  },
  /**
   * Sets the filters for the displayObject.
   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
   * To remove filters simply set this property to `'null'`.
   * @memberof scene.Container#
   */
  get filters() {
    var i;
    return (i = this._filterEffect) == null ? void 0 : i.filters;
  },
  set filterArea(i) {
    this._filterEffect || (this._filterEffect = new Fl()), this._filterEffect.filterArea = i;
  },
  /**
   * The area the filter is applied to. This is used as more of an optimization
   * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.
   *
   * Also works as an interaction mask.
   * @memberof scene.Container#
   */
  get filterArea() {
    var i;
    return (i = this._filterEffect) == null ? void 0 : i.filterArea;
  }
}, Rb = {
  /**
   * The instance label of the object.
   * @memberof scene.Container#
   * @member {string} label
   */
  label: null,
  /**
   * The instance name of the object.
   * @deprecated since 8.0.0
   * @see scene.Container#label
   * @member {string} name
   * @memberof scene.Container#
   */
  get name() {
    return dt(Se, "Container.name property has been removed, use Container.label instead"), this.label;
  },
  set name(i) {
    dt(Se, "Container.name property has been removed, use Container.label instead"), this.label = i;
  },
  /**
   * @method getChildByName
   * @deprecated since 8.0.0
   * @param {string} name - Instance name.
   * @param {boolean}[deep=false] - Whether to search recursively
   * @returns {Container} The child with the specified name.
   * @see scene.Container#getChildByLabel
   * @memberof scene.Container#
   */
  getChildByName(i, t = !1) {
    return this.getChildByLabel(i, t);
  },
  /**
   * Returns the first child in the container with the specified label.
   *
   * Recursive searches are done in a pre-order traversal.
   * @memberof scene.Container#
   * @param {string|RegExp} label - Instance label.
   * @param {boolean}[deep=false] - Whether to search recursively
   * @returns {Container} The child with the specified label.
   */
  getChildByLabel(i, t = !1) {
    const e = this.children;
    for (let s = 0; s < e.length; s++) {
      const r = e[s];
      if (r.label === i || i instanceof RegExp && i.test(r.label))
        return r;
    }
    if (t)
      for (let s = 0; s < e.length; s++) {
        const n = e[s].getChildByLabel(i, !0);
        if (n)
          return n;
      }
    return null;
  },
  /**
   * Returns all children in the container with the specified label.
   * @memberof scene.Container#
   * @param {string|RegExp} label - Instance label.
   * @param {boolean}[deep=false] - Whether to search recursively
   * @param {Container[]} [out=[]] - The array to store matching children in.
   * @returns {Container[]} An array of children with the specified label.
   */
  getChildrenByLabel(i, t = !1, e = []) {
    const s = this.children;
    for (let r = 0; r < s.length; r++) {
      const n = s[r];
      (n.label === i || i instanceof RegExp && i.test(n.label)) && e.push(n);
    }
    if (t)
      for (let r = 0; r < s.length; r++)
        s[r].getChildrenByLabel(i, !0, e);
    return e;
  }
}, Ar = new dT(ot), Uo = new dT(Zs);
function fT(i, t, e) {
  e.clear();
  let s, r;
  return i.parent ? t ? s = i.parent.worldTransform : (r = Ar.get().identity(), s = wl(i, r)) : s = ot.IDENTITY, zR(i, e, s, t), r && Ar.return(r), e.isValid || e.set(0, 0, 0, 0), e;
}
function zR(i, t, e, s) {
  var o, h;
  if (!i.visible || !i.measurable)
    return;
  let r;
  s ? r = i.worldTransform : (i.updateLocalTransform(), r = Ar.get(), r.appendFrom(i.localTransform, e));
  const n = t, a = !!i.effects.length;
  if (a && (t = Uo.get().clear()), i.boundsArea)
    t.addRect(i.boundsArea, r);
  else {
    i.addBounds && (t.matrix = r, i.addBounds(t));
    for (let u = 0; u < i.children.length; u++)
      zR(i.children[u], t, r, s);
  }
  if (a) {
    for (let u = 0; u < i.effects.length; u++)
      (h = (o = i.effects[u]).addBounds) == null || h.call(o, t);
    n.addBounds(t, ot.IDENTITY), Uo.return(t);
  }
  s || Ar.return(r);
}
function wl(i, t) {
  const e = i.parent;
  return e && (wl(e, t), e.updateLocalTransform(), t.append(e.localTransform)), t;
}
let rf = 0;
const cS = 500;
function ce(...i) {
  rf !== cS && (rf++, rf === cS ? console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.") : console.warn("PixiJS Warning: ", ...i));
}
function gT(i, t, e) {
  return t.clear(), e || (e = ot.IDENTITY), VR(i, t, e, i, !0), t.isValid || t.set(0, 0, 0, 0), t;
}
function VR(i, t, e, s, r) {
  var h, u;
  let n;
  if (r)
    n = Ar.get(), n = e.copyTo(n);
  else {
    if (!i.visible || !i.measurable)
      return;
    i.updateLocalTransform();
    const c = i.localTransform;
    n = Ar.get(), n.appendFrom(c, e);
  }
  const a = t, o = !!i.effects.length;
  if (o && (t = Uo.get().clear()), i.boundsArea)
    t.addRect(i.boundsArea, n);
  else {
    i.renderPipeId && (t.matrix = n, i.addBounds(t));
    const c = i.children;
    for (let l = 0; l < c.length; l++)
      VR(c[l], t, n, s, !1);
  }
  if (o) {
    for (let c = 0; c < i.effects.length; c++)
      (u = (h = i.effects[c]).addLocalBounds) == null || u.call(h, t, s);
    a.addBounds(t, ot.IDENTITY), Uo.return(t);
  }
  Ar.return(n);
}
function HR(i, t) {
  const e = i.children;
  for (let s = 0; s < e.length; s++) {
    const r = e[s], n = r.uid, a = (r._didViewChangeTick & 65535) << 16 | r._didContainerChangeTick & 65535, o = t.index;
    (t.data[o] !== n || t.data[o + 1] !== a) && (t.data[t.index] = n, t.data[t.index + 1] = a, t.didChange = !0), t.index = o + 2, r.children.length && HR(r, t);
  }
  return t.didChange;
}
const Ob = new ot(), yb = {
  _localBoundsCacheId: -1,
  _localBoundsCacheData: null,
  _setWidth(i, t) {
    const e = Math.sign(this.scale.x) || 1;
    t !== 0 ? this.scale.x = i / t * e : this.scale.x = e;
  },
  _setHeight(i, t) {
    const e = Math.sign(this.scale.y) || 1;
    t !== 0 ? this.scale.y = i / t * e : this.scale.y = e;
  },
  /**
   * Retrieves the local bounds of the container as a Bounds object.
   * @returns - The bounding area.
   * @memberof scene.Container#
   */
  getLocalBounds() {
    this._localBoundsCacheData || (this._localBoundsCacheData = {
      data: [],
      index: 1,
      didChange: !1,
      localBounds: new Zs()
    });
    const i = this._localBoundsCacheData;
    return i.index = 1, i.didChange = !1, i.data[0] !== this._didViewChangeTick && (i.didChange = !0, i.data[0] = this._didViewChangeTick), HR(this, i), i.didChange && gT(this, i.localBounds, Ob), i.localBounds;
  },
  /**
   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.
   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from
   *  being updated. This means the calculation returned MAY be out of date BUT will give you a
   *  nice performance boost.
   * @param bounds - Optional bounds to store the result of the bounds calculation.
   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.
   * @memberof scene.Container#
   */
  getBounds(i, t) {
    return fT(this, i, t || new Zs());
  }
}, vb = {
  _onRender: null,
  set onRender(i) {
    const t = this.renderGroup || this.parentRenderGroup;
    if (!i) {
      this._onRender && (t == null || t.removeOnRender(this)), this._onRender = null;
      return;
    }
    this._onRender || t == null || t.addOnRender(this), this._onRender = i;
  },
  /**
   * This callback is used when the container is rendered. This is where you should add your custom
   * logic that is needed to be run every frame.
   *
   * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different
   * and "updateTransform" is no longer called every frame
   * @example
   * const container = new Container();
   * container.onRender = () => {
   *    container.rotation += 0.01;
   * };
   * @memberof scene.Container#
   */
  get onRender() {
    return this._onRender;
  }
}, Cb = {
  _zIndex: 0,
  /**
   * Should children be sorted by zIndex at the next render call.
   *
   * Will get automatically set to true if a new child is added, or if a child's zIndex changes.
   * @type {boolean}
   * @memberof scene.Container#
   */
  sortDirty: !1,
  /**
   * If set to true, the container will sort its children by `zIndex` value
   * when the next render is called, or manually if `sortChildren()` is called.
   *
   * This actually changes the order of elements in the array, so should be treated
   * as a basic solution that is not performant compared to other solutions,
   * such as {@link https://github.com/pixijs/layers PixiJS Layers}
   *
   * Also be aware of that this may not work nicely with the `addChildAt()` function,
   * as the `zIndex` sorting may cause the child to automatically sorted to another position.
   * @type {boolean}
   * @memberof scene.Container#
   */
  sortableChildren: !1,
  /**
   * The zIndex of the container.
   *
   * Setting this value, will automatically set the parent to be sortable. Children will be automatically
   * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
   * and thus rendered on top of other display objects within the same container.
   * @see scene.Container#sortableChildren
   * @memberof scene.Container#
   */
  get zIndex() {
    return this._zIndex;
  },
  set zIndex(i) {
    this._zIndex !== i && (this._zIndex = i, this.depthOfChildModified());
  },
  depthOfChildModified() {
    this.parent && (this.parent.sortableChildren = !0, this.parent.sortDirty = !0), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0);
  },
  /**
   * Sorts children by zIndex.
   * @memberof scene.Container#
   */
  sortChildren() {
    this.sortDirty && (this.sortDirty = !1, this.children.sort(xb));
  }
};
function xb(i, t) {
  return i._zIndex - t._zIndex;
}
const Mb = {
  /**
   * Returns the global position of the container.
   * @param point - The optional point to write the global value to.
   * @param skipUpdate - Should we skip the update transform.
   * @returns - The updated point.
   * @memberof scene.Container#
   */
  getGlobalPosition(i = new st(), t = !1) {
    return this.parent ? this.parent.toGlobal(this._position, i, t) : (i.x = this._position.x, i.y = this._position.y), i;
  },
  /**
   * Calculates the global position of the container.
   * @param position - The world origin to calculate from.
   * @param point - A Point object in which to store the value, optional
   *  (otherwise will create a new Point).
   * @param skipUpdate - Should we skip the update transform.
   * @returns - A point object representing the position of this object.
   * @memberof scene.Container#
   */
  toGlobal(i, t, e = !1) {
    if (!e) {
      this.updateLocalTransform();
      const s = wl(this, new ot());
      return s.append(this.localTransform), s.apply(i, t);
    }
    return this.worldTransform.apply(i, t);
  },
  /**
   * Calculates the local position of the container relative to another point.
   * @param position - The world origin to calculate from.
   * @param from - The Container to calculate the global position from.
   * @param point - A Point object in which to store the value, optional
   *  (otherwise will create a new Point).
   * @param skipUpdate - Should we skip the update transform
   * @returns - A point object representing the position of this object
   * @memberof scene.Container#
   */
  toLocal(i, t, e, s) {
    if (t && (i = t.toGlobal(i, e, s)), !s) {
      this.updateLocalTransform();
      const r = wl(this, new ot());
      return r.append(this.localTransform), r.applyInverse(i, e);
    }
    return this.worldTransform.applyInverse(i, e);
  }
};
let bb = 0;
class YR {
  constructor() {
    this.uid = me("instructionSet"), this.instructions = [], this.instructionSize = 0, this.renderables = [], this.tick = 0;
  }
  /** reset the instruction set so it can be reused set size back to 0 */
  reset() {
    this.instructionSize = 0, this.tick = bb++;
  }
  /**
   * Add an instruction to the set
   * @param instruction - add an instruction to the set
   */
  add(t) {
    this.instructions[this.instructionSize++] = t;
  }
  /**
   * Log the instructions to the console (for debugging)
   * @internal
   * @ignore
   */
  log() {
    this.instructions.length = this.instructionSize, console.table(this.instructions, ["type", "action"]);
  }
}
class Pb {
  constructor() {
    this.renderPipeId = "renderGroup", this.root = null, this.canBundle = !1, this.renderGroupParent = null, this.renderGroupChildren = [], this.worldTransform = new ot(), this.worldColorAlpha = 4294967295, this.worldColor = 16777215, this.worldAlpha = 1, this.childrenToUpdate = /* @__PURE__ */ Object.create(null), this.updateTick = 0, this.childrenRenderablesToUpdate = { list: [], index: 0 }, this.structureDidChange = !0, this.instructionSet = new YR(), this._onRenderContainers = [];
  }
  init(t) {
    this.root = t, t._onRender && this.addOnRender(t), t.didChange = !0;
    const e = t.children;
    for (let s = 0; s < e.length; s++)
      this.addChild(e[s]);
  }
  reset() {
    this.renderGroupChildren.length = 0;
    for (const t in this.childrenToUpdate) {
      const e = this.childrenToUpdate[t];
      e.list.fill(null), e.index = 0;
    }
    this.childrenRenderablesToUpdate.index = 0, this.childrenRenderablesToUpdate.list.fill(null), this.root = null, this.updateTick = 0, this.structureDidChange = !0, this._onRenderContainers.length = 0, this.renderGroupParent = null;
  }
  get localTransform() {
    return this.root.localTransform;
  }
  addRenderGroupChild(t) {
    t.renderGroupParent && t.renderGroupParent._removeRenderGroupChild(t), t.renderGroupParent = this, this.renderGroupChildren.push(t);
  }
  _removeRenderGroupChild(t) {
    const e = this.renderGroupChildren.indexOf(t);
    e > -1 && this.renderGroupChildren.splice(e, 1), t.renderGroupParent = null;
  }
  addChild(t) {
    if (this.structureDidChange = !0, t.parentRenderGroup = this, t.updateTick = -1, t.parent === this.root ? t.relativeRenderGroupDepth = 1 : t.relativeRenderGroupDepth = t.parent.relativeRenderGroupDepth + 1, t.didChange = !0, this.onChildUpdate(t), t.renderGroup) {
      this.addRenderGroupChild(t.renderGroup);
      return;
    }
    t._onRender && this.addOnRender(t);
    const e = t.children;
    for (let s = 0; s < e.length; s++)
      this.addChild(e[s]);
  }
  removeChild(t) {
    if (this.structureDidChange = !0, t._onRender && (t.renderGroup || this.removeOnRender(t)), t.parentRenderGroup = null, t.renderGroup) {
      this._removeRenderGroupChild(t.renderGroup);
      return;
    }
    const e = t.children;
    for (let s = 0; s < e.length; s++)
      this.removeChild(e[s]);
  }
  removeChildren(t) {
    for (let e = 0; e < t.length; e++)
      this.removeChild(t[e]);
  }
  onChildUpdate(t) {
    let e = this.childrenToUpdate[t.relativeRenderGroupDepth];
    e || (e = this.childrenToUpdate[t.relativeRenderGroupDepth] = {
      index: 0,
      list: []
    }), e.list[e.index++] = t;
  }
  updateRenderable(t) {
    t.globalDisplayStatus < 7 || (this.instructionSet.renderPipes[t.renderPipeId].updateRenderable(t), t.didViewUpdate = !1);
  }
  onChildViewUpdate(t) {
    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = t;
  }
  get isRenderable() {
    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
  }
  /**
   * adding a container to the onRender list will make sure the user function
   * passed in to the user defined 'onRender` callBack
   * @param container - the container to add to the onRender list
   */
  addOnRender(t) {
    this._onRenderContainers.push(t);
  }
  removeOnRender(t) {
    this._onRenderContainers.splice(this._onRenderContainers.indexOf(t), 1);
  }
  runOnRender() {
    for (let t = 0; t < this._onRenderContainers.length; t++)
      this._onRenderContainers[t]._onRender();
  }
  destroy() {
    this.renderGroupParent = null, this.root = null, this.childrenRenderablesToUpdate = null, this.childrenToUpdate = null, this.renderGroupChildren = null, this._onRenderContainers = null, this.instructionSet = null;
  }
  getChildren(t = []) {
    const e = this.root.children;
    for (let s = 0; s < e.length; s++)
      this._getChildren(e[s], t);
    return t;
  }
  _getChildren(t, e = []) {
    if (e.push(t), t.renderGroup)
      return e;
    const s = t.children;
    for (let r = 0; r < s.length; r++)
      this._getChildren(s[r], e);
    return e;
  }
}
function Nb(i, t, e = {}) {
  for (const s in t)
    !e[s] && t[s] !== void 0 && (i[s] = t[s]);
}
const nf = new Me(null), af = new Me(null), of = new Me(null, 1, 1), Gl = 1, pT = 2, Eh = 4;
class Qt extends Js {
  constructor(t = {}) {
    var e, s;
    super(), this.uid = me("renderable"), this._updateFlags = 15, this.renderGroup = null, this.parentRenderGroup = null, this.parentRenderGroupIndex = 0, this.didChange = !1, this.didViewUpdate = !1, this.relativeRenderGroupDepth = 0, this.children = [], this.parent = null, this.includeInBuild = !0, this.measurable = !0, this.isSimple = !0, this.updateTick = -1, this.localTransform = new ot(), this.relativeGroupTransform = new ot(), this.groupTransform = this.relativeGroupTransform, this.destroyed = !1, this._position = new Me(this, 0, 0), this._scale = of, this._pivot = af, this._skew = nf, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._rotation = 0, this.localColor = 16777215, this.localAlpha = 1, this.groupAlpha = 1, this.groupColor = 16777215, this.groupColorAlpha = 4294967295, this.localBlendMode = "inherit", this.groupBlendMode = "normal", this.localDisplayStatus = 7, this.globalDisplayStatus = 7, this._didContainerChangeTick = 0, this._didViewChangeTick = 0, this._didLocalTransformChangeId = -1, this.effects = [], Nb(this, t, {
      children: !0,
      parent: !0,
      effects: !0
    }), (e = t.children) == null || e.forEach((r) => this.addChild(r)), (s = t.parent) == null || s.addChild(this);
  }
  /**
   * Mixes all enumerable properties and methods from a source object to Container.
   * @param source - The source of properties and methods to mix in.
   */
  static mixin(t) {
    Object.defineProperties(Qt.prototype, Object.getOwnPropertyDescriptors(t));
  }
  /**
   * We now use the _didContainerChangeTick and _didViewChangeTick to track changes
   * @deprecated since 8.2.6
   * @ignore
   */
  set _didChangeId(t) {
    this._didViewChangeTick = t >> 12 & 4095, this._didContainerChangeTick = t & 4095;
  }
  get _didChangeId() {
    return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
  }
  /**
   * Adds one or more children to the container.
   *
   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
   * @param {...Container} children - The Container(s) to add to the container
   * @returns {Container} - The first child that was added.
   */
  addChild(...t) {
    if (this.allowChildren || dt(Se, "addChild: Only Containers will be allowed to add children in v8.0.0"), t.length > 1) {
      for (let r = 0; r < t.length; r++)
        this.addChild(t[r]);
      return t[0];
    }
    const e = t[0];
    if (e.parent === this)
      return this.children.splice(this.children.indexOf(e), 1), this.children.push(e), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), e;
    e.parent && e.parent.removeChild(e), this.children.push(e), this.sortableChildren && (this.sortDirty = !0), e.parent = this, e.didChange = !0, e._updateFlags = 15;
    const s = this.renderGroup || this.parentRenderGroup;
    return s && s.addChild(e), this.emit("childAdded", e, this, this.children.length - 1), e.emit("added", this), this._didViewChangeTick++, e._zIndex !== 0 && e.depthOfChildModified(), e;
  }
  /**
   * Removes one or more children from the container.
   * @param {...Container} children - The Container(s) to remove
   * @returns {Container} The first child that was removed.
   */
  removeChild(...t) {
    if (t.length > 1) {
      for (let r = 0; r < t.length; r++)
        this.removeChild(t[r]);
      return t[0];
    }
    const e = t[0], s = this.children.indexOf(e);
    return s > -1 && (this._didViewChangeTick++, this.children.splice(s, 1), this.renderGroup ? this.renderGroup.removeChild(e) : this.parentRenderGroup && this.parentRenderGroup.removeChild(e), e.parent = null, this.emit("childRemoved", e, this, s), e.emit("removed", this)), e;
  }
  /** @ignore */
  _onUpdate(t) {
    t && t === this._skew && this._updateSkew(), this._didContainerChangeTick++, !this.didChange && (this.didChange = !0, this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this));
  }
  set isRenderGroup(t) {
    !!this.renderGroup !== t && (t ? this.enableRenderGroup() : this.disableRenderGroup());
  }
  /**
   * Returns true if this container is a render group.
   * This means that it will be rendered as a separate pass, with its own set of instructions
   */
  get isRenderGroup() {
    return !!this.renderGroup;
  }
  /**
   * Calling this enables a render group for this container.
   * This means it will be rendered as a separate set of instructions.
   * The transform of the container will also be handled on the GPU rather than the CPU.
   */
  enableRenderGroup() {
    if (this.renderGroup)
      return;
    const t = this.parentRenderGroup;
    t == null || t.removeChild(this), this.renderGroup = Es.get(Pb, this), this.groupTransform = ot.IDENTITY, t == null || t.addChild(this), this._updateIsSimple();
  }
  /** This will disable the render group for this container. */
  disableRenderGroup() {
    if (!this.renderGroup)
      return;
    const t = this.parentRenderGroup;
    t == null || t.removeChild(this), Es.return(this.renderGroup), this.renderGroup = null, this.groupTransform = this.relativeGroupTransform, t == null || t.addChild(this), this._updateIsSimple();
  }
  /** @ignore */
  _updateIsSimple() {
    this.isSimple = !this.renderGroup && this.effects.length === 0;
  }
  /**
   * Current transform of the object based on world (parent) factors.
   * @readonly
   */
  get worldTransform() {
    return this._worldTransform || (this._worldTransform = new ot()), this.renderGroup ? this._worldTransform.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform), this._worldTransform;
  }
  // / ////// transform related stuff
  /**
   * The position of the container on the x axis relative to the local coordinates of the parent.
   * An alias to position.x
   */
  get x() {
    return this._position.x;
  }
  set x(t) {
    this._position.x = t;
  }
  /**
   * The position of the container on the y axis relative to the local coordinates of the parent.
   * An alias to position.y
   */
  get y() {
    return this._position.y;
  }
  set y(t) {
    this._position.y = t;
  }
  /**
   * The coordinate of the object relative to the local coordinates of the parent.
   * @since 4.0.0
   */
  get position() {
    return this._position;
  }
  set position(t) {
    this._position.copyFrom(t);
  }
  /**
   * The rotation of the object in radians.
   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
   */
  get rotation() {
    return this._rotation;
  }
  set rotation(t) {
    this._rotation !== t && (this._rotation = t, this._onUpdate(this._skew));
  }
  /**
   * The angle of the object in degrees.
   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
   */
  get angle() {
    return this.rotation * JM;
  }
  set angle(t) {
    this.rotation = t * Po;
  }
  /**
   * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
   * is the projection of `pivot` in the parent's local space.
   *
   * By default, the pivot is the origin (0, 0).
   * @since 4.0.0
   */
  get pivot() {
    return this._pivot === af && (this._pivot = new Me(this, 0, 0)), this._pivot;
  }
  set pivot(t) {
    this._pivot === af && (this._pivot = new Me(this, 0, 0)), typeof t == "number" ? this._pivot.set(t) : this._pivot.copyFrom(t);
  }
  /**
   * The skew factor for the object in radians.
   * @since 4.0.0
   */
  get skew() {
    return this._skew === nf && (this._skew = new Me(this, 0, 0)), this._skew;
  }
  set skew(t) {
    this._skew === nf && (this._skew = new Me(this, 0, 0)), this._skew.copyFrom(t);
  }
  /**
   * The scale factors of this object along the local coordinate axes.
   *
   * The default scale is (1, 1).
   * @since 4.0.0
   */
  get scale() {
    return this._scale === of && (this._scale = new Me(this, 1, 1)), this._scale;
  }
  set scale(t) {
    this._scale === of && (this._scale = new Me(this, 0, 0)), typeof t == "number" ? this._scale.set(t) : this._scale.copyFrom(t);
  }
  /**
   * The width of the Container, setting this will actually modify the scale to achieve the value set.
   * @memberof scene.Container#
   */
  get width() {
    return Math.abs(this.scale.x * this.getLocalBounds().width);
  }
  set width(t) {
    const e = this.getLocalBounds().width;
    this._setWidth(t, e);
  }
  /**
   * The height of the Container, setting this will actually modify the scale to achieve the value set.
   * @memberof scene.Container#
   */
  get height() {
    return Math.abs(this.scale.y * this.getLocalBounds().height);
  }
  set height(t) {
    const e = this.getLocalBounds().height;
    this._setHeight(t, e);
  }
  /**
   * Retrieves the size of the container as a [Size]{@link Size} object.
   * This is faster than get the width and height separately.
   * @param out - Optional object to store the size in.
   * @returns - The size of the container.
   * @memberof scene.Container#
   */
  getSize(t) {
    t || (t = {});
    const e = this.getLocalBounds();
    return t.width = Math.abs(this.scale.x * e.width), t.height = Math.abs(this.scale.y * e.height), t;
  }
  /**
   * Sets the size of the container to the specified width and height.
   * This is faster than setting the width and height separately.
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   * @memberof scene.Container#
   */
  setSize(t, e) {
    const s = this.getLocalBounds();
    typeof t == "object" ? (e = t.height ?? t.width, t = t.width) : e ?? (e = t), t !== void 0 && this._setWidth(t, s.width), e !== void 0 && this._setHeight(e, s.height);
  }
  /** Called when the skew or the rotation changes. */
  _updateSkew() {
    const t = this._rotation, e = this._skew;
    this._cx = Math.cos(t + e._y), this._sx = Math.sin(t + e._y), this._cy = -Math.sin(t - e._x), this._sy = Math.cos(t - e._x);
  }
  /**
   * Updates the transform properties of the container (accepts partial values).
   * @param {object} opts - The options for updating the transform.
   * @param {number} opts.x - The x position of the container.
   * @param {number} opts.y - The y position of the container.
   * @param {number} opts.scaleX - The scale factor on the x-axis.
   * @param {number} opts.scaleY - The scale factor on the y-axis.
   * @param {number} opts.rotation - The rotation of the container, in radians.
   * @param {number} opts.skewX - The skew factor on the x-axis.
   * @param {number} opts.skewY - The skew factor on the y-axis.
   * @param {number} opts.pivotX - The x coordinate of the pivot point.
   * @param {number} opts.pivotY - The y coordinate of the pivot point.
   */
  updateTransform(t) {
    return this.position.set(
      typeof t.x == "number" ? t.x : this.position.x,
      typeof t.y == "number" ? t.y : this.position.y
    ), this.scale.set(
      typeof t.scaleX == "number" ? t.scaleX || 1 : this.scale.x,
      typeof t.scaleY == "number" ? t.scaleY || 1 : this.scale.y
    ), this.rotation = typeof t.rotation == "number" ? t.rotation : this.rotation, this.skew.set(
      typeof t.skewX == "number" ? t.skewX : this.skew.x,
      typeof t.skewY == "number" ? t.skewY : this.skew.y
    ), this.pivot.set(
      typeof t.pivotX == "number" ? t.pivotX : this.pivot.x,
      typeof t.pivotY == "number" ? t.pivotY : this.pivot.y
    ), this;
  }
  /**
   * Updates the local transform using the given matrix.
   * @param matrix - The matrix to use for updating the transform.
   */
  setFromMatrix(t) {
    t.decompose(this);
  }
  /** Updates the local transform. */
  updateLocalTransform() {
    const t = this._didContainerChangeTick;
    if (this._didLocalTransformChangeId === t)
      return;
    this._didLocalTransformChangeId = t;
    const e = this.localTransform, s = this._scale, r = this._pivot, n = this._position, a = s._x, o = s._y, h = r._x, u = r._y;
    e.a = this._cx * a, e.b = this._sx * a, e.c = this._cy * o, e.d = this._sy * o, e.tx = n._x - (h * e.a + u * e.c), e.ty = n._y - (h * e.b + u * e.d);
  }
  // / ///// color related stuff
  set alpha(t) {
    t !== this.localAlpha && (this.localAlpha = t, this._updateFlags |= Gl, this._onUpdate());
  }
  /** The opacity of the object. */
  get alpha() {
    return this.localAlpha;
  }
  set tint(t) {
    const s = Pt.shared.setValue(t ?? 16777215).toBgrNumber();
    s !== this.localColor && (this.localColor = s, this._updateFlags |= Gl, this._onUpdate());
  }
  /**
   * The tint applied to the sprite. This is a hex value.
   *
   * A value of 0xFFFFFF will remove any tint effect.
   * @default 0xFFFFFF
   */
  get tint() {
    const t = this.localColor;
    return ((t & 255) << 16) + (t & 65280) + (t >> 16 & 255);
  }
  // / //////////////// blend related stuff
  set blendMode(t) {
    this.localBlendMode !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= pT, this.localBlendMode = t, this._onUpdate());
  }
  /**
   * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.
   * @default 'normal'
   */
  get blendMode() {
    return this.localBlendMode;
  }
  // / ///////// VISIBILITY / RENDERABLE /////////////////
  /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */
  get visible() {
    return !!(this.localDisplayStatus & 2);
  }
  set visible(t) {
    const e = t ? 2 : 0;
    (this.localDisplayStatus & 2) !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= Eh, this.localDisplayStatus ^= 2, this._onUpdate());
  }
  /** @ignore */
  get culled() {
    return !(this.localDisplayStatus & 4);
  }
  /** @ignore */
  set culled(t) {
    const e = t ? 0 : 4;
    (this.localDisplayStatus & 4) !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= Eh, this.localDisplayStatus ^= 4, this._onUpdate());
  }
  /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */
  get renderable() {
    return !!(this.localDisplayStatus & 1);
  }
  set renderable(t) {
    const e = t ? 1 : 0;
    (this.localDisplayStatus & 1) !== e && (this._updateFlags |= Eh, this.localDisplayStatus ^= 1, this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._onUpdate());
  }
  /** Whether or not the object should be rendered. */
  get isRenderable() {
    return this.localDisplayStatus === 7 && this.groupAlpha > 0;
  }
  /**
   * Removes all internal references and listeners as well as removes children from the display list.
   * Do not use a Container after calling `destroy`.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
   *  method called as well. 'options' will be passed on to those calls.
   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children
   * is set to true it should destroy the texture of the child sprite
   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
   * If options.children is set to true it should destroy the texture source of the child sprite
   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
   * If options.children is set to true it should destroy the context of the child graphics
   */
  destroy(t = !1) {
    var r;
    if (this.destroyed)
      return;
    this.destroyed = !0;
    const e = this.removeChildren(0, this.children.length);
    if (this.removeFromParent(), this.parent = null, this._maskEffect = null, this._filterEffect = null, this.effects = null, this._position = null, this._scale = null, this._pivot = null, this._skew = null, this.emit("destroyed", this), this.removeAllListeners(), typeof t == "boolean" ? t : t == null ? void 0 : t.children)
      for (let n = 0; n < e.length; ++n)
        e[n].destroy(t);
    (r = this.renderGroup) == null || r.destroy(), this.renderGroup = null;
  }
}
Qt.mixin(Ib);
Qt.mixin(Mb);
Qt.mixin(vb);
Qt.mixin(yb);
Qt.mixin(Ab);
Qt.mixin(Rb);
Qt.mixin(Cb);
Qt.mixin(mb);
class mT extends Qt {
  constructor() {
    super(...arguments), this.canBundle = !0, this.allowChildren = !1, this._roundPixels = 0, this._lastUsed = 0, this._lastInstructionTick = -1, this._bounds = new Zs(0, 1, 0, 0), this._boundsDirty = !0;
  }
  /** @private */
  _updateBounds() {
  }
  /**
   * Whether or not to round the x/y position of the sprite.
   * @type {boolean}
   */
  get roundPixels() {
    return !!this._roundPixels;
  }
  set roundPixels(t) {
    this._roundPixels = t ? 1 : 0;
  }
  /**
   * Checks if the object contains the given point.
   * @param point - The point to check
   */
  containsPoint(t) {
    const e = this.bounds, { x: s, y: r } = t;
    return s >= e.minX && s <= e.maxX && r >= e.minY && r <= e.maxY;
  }
  /** @private */
  onViewUpdate() {
    if (this._didViewChangeTick++, this.didViewUpdate)
      return;
    this.didViewUpdate = !0;
    const t = this.renderGroup || this.parentRenderGroup;
    t && t.onChildViewUpdate(this);
  }
  destroy(t) {
    super.destroy(t), this._bounds = null;
  }
}
class Ft extends mT {
  /**
   * @param options - The options for creating the sprite.
   */
  constructor(t = W.EMPTY) {
    t instanceof W && (t = { texture: t });
    const { texture: e = W.EMPTY, anchor: s, roundPixels: r, width: n, height: a, ...o } = t;
    super({
      label: "Sprite",
      ...o
    }), this.renderPipeId = "sprite", this.batched = !0, this._sourceBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, this._sourceBoundsDirty = !0, this._anchor = new Me(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    ), s ? this.anchor = s : e.defaultAnchor && (this.anchor = e.defaultAnchor), this.texture = e, this.allowChildren = !1, this.roundPixels = r ?? !1, n !== void 0 && (this.width = n), a !== void 0 && (this.height = a);
  }
  /**
   * Helper function that creates a new sprite based on the source you provide.
   * The source can be - frame id, image, video, canvas element, video element, texture
   * @param source - Source to create texture from
   * @param [skipCache] - Whether to skip the cache or not
   * @returns The newly created sprite
   */
  static from(t, e = !1) {
    return t instanceof W ? new Ft(t) : new Ft(W.from(t, e));
  }
  set texture(t) {
    t || (t = W.EMPTY);
    const e = this._texture;
    e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this._texture = t, this._width && this._setWidth(this._width, this._texture.orig.width), this._height && this._setHeight(this._height, this._texture.orig.height), this.onViewUpdate());
  }
  /** The texture that the sprite is using. */
  get texture() {
    return this._texture;
  }
  /**
   * The local bounds of the sprite.
   * @type {rendering.Bounds}
   */
  get bounds() {
    return this._boundsDirty && (this._updateBounds(), this._boundsDirty = !1), this._bounds;
  }
  /**
   * The bounds of the sprite, taking the texture's trim into account.
   * @type {rendering.Bounds}
   */
  get sourceBounds() {
    return this._sourceBoundsDirty && (this._updateSourceBounds(), this._sourceBoundsDirty = !1), this._sourceBounds;
  }
  /**
   * Checks if the object contains the given point.
   * @param point - The point to check
   */
  containsPoint(t) {
    const e = this.sourceBounds;
    return t.x >= e.maxX && t.x <= e.minX && t.y >= e.maxY && t.y <= e.minY;
  }
  /**
   * Adds the bounds of this object to the bounds object.
   * @param bounds - The output bounds object.
   */
  addBounds(t) {
    const e = this._texture.trim ? this.sourceBounds : this.bounds;
    t.addFrame(e.minX, e.minY, e.maxX, e.maxY);
  }
  onViewUpdate() {
    this._sourceBoundsDirty = this._boundsDirty = !0, super.onViewUpdate();
  }
  _updateBounds() {
    ob(this._bounds, this._anchor, this._texture, 0);
  }
  _updateSourceBounds() {
    const t = this._anchor, e = this._texture, s = this._sourceBounds, { width: r, height: n } = e.orig;
    s.maxX = -t._x * r, s.minX = s.maxX + r, s.maxY = -t._y * n, s.minY = s.maxY + n;
  }
  /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
   */
  destroy(t = !1) {
    if (super.destroy(t), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
      const s = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
      this._texture.destroy(s);
    }
    this._texture = null, this._bounds = null, this._sourceBounds = null, this._anchor = null;
  }
  /**
   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
   * and passed to the constructor.
   *
   * The default is `(0,0)`, this means the sprite's origin is the top left.
   *
   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
   *
   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * import { Sprite } from 'pixi.js';
   *
   * const sprite = new Sprite({texture: Texture.WHITE});
   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(t) {
    typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
  }
  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
  get width() {
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(t) {
    this._setWidth(t, this._texture.orig.width), this._width = t;
  }
  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
  get height() {
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(t) {
    this._setHeight(t, this._texture.orig.height), this._height = t;
  }
  /**
   * Retrieves the size of the Sprite as a [Size]{@link Size} object.
   * This is faster than get the width and height separately.
   * @param out - Optional object to store the size in.
   * @returns - The size of the Sprite.
   */
  getSize(t) {
    return t || (t = {}), t.width = Math.abs(this.scale.x) * this._texture.orig.width, t.height = Math.abs(this.scale.y) * this._texture.orig.height, t;
  }
  /**
   * Sets the size of the Sprite to the specified width and height.
   * This is faster than setting the width and height separately.
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   */
  setSize(t, e) {
    typeof t == "object" ? (e = t.height ?? t.width, t = t.width) : e ?? (e = t), t !== void 0 && this._setWidth(t, this._texture.orig.width), e !== void 0 && this._setHeight(e, this._texture.orig.height);
  }
}
const Ub = new Zs();
function WR(i, t, e) {
  const s = Ub;
  i.measurable = !0, fT(i, e, s), t.addBoundsMask(s), i.measurable = !1;
}
function jR(i, t, e) {
  const s = Uo.get();
  i.measurable = !0;
  const r = Ar.get().identity(), n = XR(i, e, r);
  gT(i, s, n), i.measurable = !1, t.addBoundsMask(s), Ar.return(r), Uo.return(s);
}
function XR(i, t, e) {
  return i ? (i !== t && (XR(i.parent, t, e), i.updateLocalTransform(), e.append(i.localTransform)), e) : (ce("Mask bounds, renderable is not inside the root container"), e);
}
class KR {
  constructor(t) {
    this.priority = 0, this.inverse = !1, this.pipe = "alphaMask", t != null && t.mask && this.init(t.mask);
  }
  init(t) {
    this.mask = t, this.renderMaskToTexture = !(t instanceof Ft), this.mask.renderable = this.renderMaskToTexture, this.mask.includeInBuild = !this.renderMaskToTexture, this.mask.measurable = !1;
  }
  reset() {
    this.mask.measurable = !0, this.mask = null;
  }
  addBounds(t, e) {
    this.inverse || WR(this.mask, t, e);
  }
  addLocalBounds(t, e) {
    jR(this.mask, t, e);
  }
  containsPoint(t, e) {
    const s = this.mask;
    return e(s, t);
  }
  destroy() {
    this.reset();
  }
  static test(t) {
    return t instanceof Ft;
  }
}
KR.extension = B.MaskEffect;
class qR {
  constructor(t) {
    this.priority = 0, this.pipe = "colorMask", t != null && t.mask && this.init(t.mask);
  }
  init(t) {
    this.mask = t;
  }
  destroy() {
  }
  static test(t) {
    return typeof t == "number";
  }
}
qR.extension = B.MaskEffect;
class $R {
  constructor(t) {
    this.priority = 0, this.pipe = "stencilMask", t != null && t.mask && this.init(t.mask);
  }
  init(t) {
    this.mask = t, this.mask.includeInBuild = !1, this.mask.measurable = !1;
  }
  reset() {
    this.mask.measurable = !0, this.mask.includeInBuild = !0, this.mask = null;
  }
  addBounds(t, e) {
    WR(this.mask, t, e);
  }
  addLocalBounds(t, e) {
    jR(this.mask, t, e);
  }
  containsPoint(t, e) {
    const s = this.mask;
    return e(s, t);
  }
  destroy() {
    this.reset();
  }
  static test(t) {
    return t instanceof Qt;
  }
}
$R.extension = B.MaskEffect;
const ZR = {
  createCanvas: (i, t) => {
    const e = document.createElement("canvas");
    return e.width = i, e.height = t, e;
  },
  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
  getWebGLRenderingContext: () => WebGLRenderingContext,
  getNavigator: () => navigator,
  getBaseUrl: () => document.baseURI ?? window.location.href,
  getFontFaceSet: () => document.fonts,
  fetch: (i, t) => fetch(i, t),
  parseXML: (i) => new DOMParser().parseFromString(i, "text/xml")
};
let _S = ZR;
const Wt = {
  /**
   * Returns the current adapter.
   * @returns {environment.Adapter} The current adapter.
   */
  get() {
    return _S;
  },
  /**
   * Sets the current adapter.
   * @param adapter - The new adapter.
   */
  set(i) {
    _S = i;
  }
};
class Do extends ke {
  constructor(t) {
    t.resource || (t.resource = Wt.get().createCanvas()), t.width || (t.width = t.resource.width, t.autoDensity || (t.width /= t.resolution)), t.height || (t.height = t.resource.height, t.autoDensity || (t.height /= t.resolution)), super(t), this.uploadMethodId = "image", this.autoDensity = t.autoDensity;
    const e = t.resource;
    (this.pixelWidth !== e.width || this.pixelWidth !== e.height) && this.resizeCanvas(), this.transparent = !!t.transparent;
  }
  resizeCanvas() {
    this.autoDensity && (this.resource.style.width = `${this.width}px`, this.resource.style.height = `${this.height}px`), (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) && (this.resource.width = this.pixelWidth, this.resource.height = this.pixelHeight);
  }
  resize(t = this.width, e = this.height, s = this._resolution) {
    const r = super.resize(t, e, s);
    return r && this.resizeCanvas(), r;
  }
  static test(t) {
    return globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && t instanceof OffscreenCanvas;
  }
  /**
   * Returns the 2D rendering context for the canvas.
   * Caches the context after creating it.
   * @returns The 2D rendering context of the canvas.
   */
  get context2D() {
    return this._context2D || (this._context2D = this.resource.getContext("2d"));
  }
}
Do.extension = B.TextureSource;
class Ra extends ke {
  constructor(t) {
    if (t.resource && globalThis.HTMLImageElement && t.resource instanceof HTMLImageElement) {
      const e = Wt.get().createCanvas(t.resource.width, t.resource.height);
      e.getContext("2d").drawImage(t.resource, 0, 0, t.resource.width, t.resource.height), t.resource = e, ce("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");
    }
    super(t), this.uploadMethodId = "image", this.autoGarbageCollect = !0;
  }
  static test(t) {
    return globalThis.HTMLImageElement && t instanceof HTMLImageElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap || globalThis.VideoFrame && t instanceof VideoFrame;
  }
}
Ra.extension = B.TextureSource;
var Bl = /* @__PURE__ */ ((i) => (i[i.INTERACTION = 50] = "INTERACTION", i[i.HIGH = 25] = "HIGH", i[i.NORMAL = 0] = "NORMAL", i[i.LOW = -25] = "LOW", i[i.UTILITY = -50] = "UTILITY", i))(Bl || {});
class hf {
  /**
   * Constructor
   * @private
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param priority - The priority for emitting
   * @param once - If the handler should fire once
   */
  constructor(t, e = null, s = 0, r = !1) {
    this.next = null, this.previous = null, this._destroyed = !1, this._fn = t, this._context = e, this.priority = s, this._once = r;
  }
  /**
   * Simple compare function to figure out if a function and context match.
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @returns `true` if the listener match the arguments
   */
  match(t, e = null) {
    return this._fn === t && this._context === e;
  }
  /**
   * Emit by calling the current function.
   * @param ticker - The ticker emitting.
   * @returns Next ticker
   */
  emit(t) {
    this._fn && (this._context ? this._fn.call(this._context, t) : this._fn(t));
    const e = this.next;
    return this._once && this.destroy(!0), this._destroyed && (this.next = null), e;
  }
  /**
   * Connect to the list.
   * @param previous - Input node, previous listener
   */
  connect(t) {
    this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this;
  }
  /**
   * Destroy and don't use after this.
   * @param hard - `true` to remove the `next` reference, this
   *        is considered a hard destroy. Soft destroy maintains the next reference.
   * @returns The listener to redirect while emitting or removing.
   */
  destroy(t = !1) {
    this._destroyed = !0, this._fn = null, this._context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
    const e = this.next;
    return this.next = t ? null : e, this.previous = null, e;
  }
}
const QR = class Rs {
  constructor() {
    this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new hf(null, null, 1 / 0), this.deltaMS = 1 / Rs.targetFPMS, this.elapsedMS = 1 / Rs.targetFPMS, this._tick = (t) => {
      this._requestId = null, this.started && (this.update(t), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
    };
  }
  /**
   * Conditionally requests a new animation frame.
   * If a frame has not already been requested, and if the internal
   * emitter has listeners, a new frame is requested.
   * @private
   */
  _requestIfNeeded() {
    this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
  }
  /**
   * Conditionally cancels a pending animation frame.
   * @private
   */
  _cancelIfNeeded() {
    this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
  }
  /**
   * Conditionally requests a new animation frame.
   * If the ticker has been started it checks if a frame has not already
   * been requested, and if the internal emitter has listeners. If these
   * conditions are met, a new frame is requested. If the ticker has not
   * been started, but autoStart is `true`, then the ticker starts now,
   * and continues with the previous conditions to request a new frame.
   * @private
   */
  _startIfPossible() {
    this.started ? this._requestIfNeeded() : this.autoStart && this.start();
  }
  /**
   * Register a handler for tick events. Calls continuously unless
   * it is removed or the ticker is stopped.
   * @param fn - The listener function to be added for updates
   * @param context - The listener context
   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
   * @returns This instance of a ticker
   */
  add(t, e, s = Bl.NORMAL) {
    return this._addListener(new hf(t, e, s));
  }
  /**
   * Add a handler for the tick event which is only execute once.
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
   * @returns This instance of a ticker
   */
  addOnce(t, e, s = Bl.NORMAL) {
    return this._addListener(new hf(t, e, s, !0));
  }
  /**
   * Internally adds the event handler so that it can be sorted by priority.
   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
   * before the rendering.
   * @private
   * @param listener - Current listener being added.
   * @returns This instance of a ticker
   */
  _addListener(t) {
    let e = this._head.next, s = this._head;
    if (!e)
      t.connect(s);
    else {
      for (; e; ) {
        if (t.priority > e.priority) {
          t.connect(s);
          break;
        }
        s = e, e = e.next;
      }
      t.previous || t.connect(s);
    }
    return this._startIfPossible(), this;
  }
  /**
   * Removes any handlers matching the function and context parameters.
   * If no handlers are left after removing, then it cancels the animation frame.
   * @param fn - The listener function to be removed
   * @param context - The listener context to be removed
   * @returns This instance of a ticker
   */
  remove(t, e) {
    let s = this._head.next;
    for (; s; )
      s.match(t, e) ? s = s.destroy() : s = s.next;
    return this._head.next || this._cancelIfNeeded(), this;
  }
  /**
   * The number of listeners on this ticker, calculated by walking through linked list
   * @readonly
   * @member {number}
   */
  get count() {
    if (!this._head)
      return 0;
    let t = 0, e = this._head;
    for (; e = e.next; )
      t++;
    return t;
  }
  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */
  start() {
    this.started || (this.started = !0, this._requestIfNeeded());
  }
  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */
  stop() {
    this.started && (this.started = !1, this._cancelIfNeeded());
  }
  /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */
  destroy() {
    if (!this._protected) {
      this.stop();
      let t = this._head.next;
      for (; t; )
        t = t.destroy(!0);
      this._head.destroy(), this._head = null;
    }
  }
  /**
   * Triggers an update. An update entails setting the
   * current {@link ticker.Ticker#elapsedMS|elapsedMS},
   * the current {@link ticker.Ticker#deltaTime|deltaTime},
   * invoking all listeners with current deltaTime,
   * and then finally setting {@link ticker.Ticker#lastTime|lastTime}
   * with the value of currentTime that was provided.
   * This method will be called automatically by animation
   * frame callbacks if the ticker instance has been started
   * and listeners are added.
   * @param {number} [currentTime=performance.now()] - the current time of execution
   */
  update(t = performance.now()) {
    let e;
    if (t > this.lastTime) {
      if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
        const n = t - this._lastFrame | 0;
        if (n < this._minElapsedMS)
          return;
        this._lastFrame = t - n % this._minElapsedMS;
      }
      this.deltaMS = e, this.deltaTime = this.deltaMS * Rs.targetFPMS;
      const s = this._head;
      let r = s.next;
      for (; r; )
        r = r.emit(this);
      s.next || this._cancelIfNeeded();
    } else
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    this.lastTime = t;
  }
  /**
   * The frames per second at which this ticker is running.
   * The default is approximately 60 in most modern browsers.
   * **Note:** This does not factor in the value of
   * {@link ticker.Ticker#speed|speed}, which is specific
   * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.
   * @member {number}
   * @readonly
   */
  get FPS() {
    return 1e3 / this.elapsedMS;
  }
  /**
   * Manages the maximum amount of milliseconds allowed to
   * elapse between invoking {@link ticker.Ticker#update|update}.
   * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},
   * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.
   * When setting this property it is clamped to a value between
   * `0` and `Ticker.targetFPMS * 1000`.
   * @member {number}
   * @default 10
   */
  get minFPS() {
    return 1e3 / this._maxElapsedMS;
  }
  set minFPS(t) {
    const e = Math.min(this.maxFPS, t), s = Math.min(Math.max(0, e) / 1e3, Rs.targetFPMS);
    this._maxElapsedMS = 1 / s;
  }
  /**
   * Manages the minimum amount of milliseconds required to
   * elapse between invoking {@link ticker.Ticker#update|update}.
   * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.
   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
   * Otherwise it will be at least `minFPS`
   * @member {number}
   * @default 0
   */
  get maxFPS() {
    return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
  }
  set maxFPS(t) {
    if (t === 0)
      this._minElapsedMS = 0;
    else {
      const e = Math.max(this.minFPS, t);
      this._minElapsedMS = 1 / (e / 1e3);
    }
  }
  /**
   * The shared ticker instance used by {@link AnimatedSprite} and by
   * {@link VideoResource} to update animation frames / video textures.
   *
   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.
   *
   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.
   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
   * @example
   * import { Ticker } from 'pixi.js';
   *
   * const ticker = Ticker.shared;
   * // Set this to prevent starting this ticker when listeners are added.
   * // By default this is true only for the Ticker.shared instance.
   * ticker.autoStart = false;
   *
   * // FYI, call this to ensure the ticker is stopped. It should be stopped
   * // if you have not attempted to render anything yet.
   * ticker.stop();
   *
   * // Call this when you are ready for a running shared ticker.
   * ticker.start();
   * @example
   * import { autoDetectRenderer, Container } from 'pixi.js';
   *
   * // You may use the shared ticker to render...
   * const renderer = autoDetectRenderer();
   * const stage = new Container();
   * document.body.appendChild(renderer.view);
   * ticker.add((time) => renderer.render(stage));
   *
   * // Or you can just update it manually.
   * ticker.autoStart = false;
   * ticker.stop();
   * const animate = (time) => {
   *     ticker.update(time);
   *     renderer.render(stage);
   *     requestAnimationFrame(animate);
   * };
   * animate(performance.now());
   * @member {ticker.Ticker}
   * @readonly
   * @static
   */
  static get shared() {
    if (!Rs._shared) {
      const t = Rs._shared = new Rs();
      t.autoStart = !0, t._protected = !0;
    }
    return Rs._shared;
  }
  /**
   * The system ticker instance used by {@link BasePrepare} for core timing
   * functionality that shouldn't usually need to be paused, unlike the `shared`
   * ticker which drives visual animations and rendering which may want to be paused.
   *
   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.
   * @member {ticker.Ticker}
   * @readonly
   * @static
   */
  static get system() {
    if (!Rs._system) {
      const t = Rs._system = new Rs();
      t.autoStart = !0, t._protected = !0;
    }
    return Rs._system;
  }
};
QR.targetFPMS = 0.06;
let js = QR, uf;
async function JR() {
  return uf ?? (uf = (async () => {
    var a;
    const t = document.createElement("canvas").getContext("webgl");
    if (!t)
      return "premultiply-alpha-on-upload";
    const e = await new Promise((o) => {
      const h = document.createElement("video");
      h.onloadeddata = () => o(h), h.onerror = () => o(null), h.autoplay = !1, h.crossOrigin = "anonymous", h.preload = "auto", h.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", h.load();
    });
    if (!e)
      return "premultiply-alpha-on-upload";
    const s = t.createTexture();
    t.bindTexture(t.TEXTURE_2D, s);
    const r = t.createFramebuffer();
    t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(
      t.FRAMEBUFFER,
      t.COLOR_ATTACHMENT0,
      t.TEXTURE_2D,
      s,
      0
    ), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e);
    const n = new Uint8Array(4);
    return t.readPixels(0, 0, 1, 1, t.RGBA, t.UNSIGNED_BYTE, n), t.deleteFramebuffer(r), t.deleteTexture(s), (a = t.getExtension("WEBGL_lose_context")) == null || a.loseContext(), n[0] <= n[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
  })()), uf;
}
const bd = class t0 extends ke {
  constructor(t) {
    super(t), this.isReady = !1, this.uploadMethodId = "video", t = {
      ...t0.defaultOptions,
      ...t
    }, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = t.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = t.autoPlay !== !1, this.alphaMode = t.alphaMode ?? "premultiply-alpha-on-upload", this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onCanPlayThrough = this._onCanPlayThrough.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), t.autoLoad !== !1 && this.load();
  }
  /** Update the video frame if the source is not destroyed and meets certain conditions. */
  updateFrame() {
    if (!this.destroyed) {
      if (this._updateFPS) {
        const t = js.shared.elapsedMS * this.resource.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - t);
      }
      (!this._updateFPS || this._msToNextUpdate <= 0) && (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0), this.isValid && this.update();
    }
  }
  /** Callback to update the video frame and potentially request the next frame update. */
  _videoFrameRequestCallback() {
    this.updateFrame(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
      this._videoFrameRequestCallback
    );
  }
  /**
   * Checks if the resource has valid dimensions.
   * @returns {boolean} True if width and height are set, otherwise false.
   */
  get isValid() {
    return !!this.resource.videoWidth && !!this.resource.videoHeight;
  }
  /**
   * Start preloading the video resource.
   * @returns {Promise<this>} Handle the validate event
   */
  async load() {
    if (this._load)
      return this._load;
    const t = this.resource, e = this.options;
    return (t.readyState === t.HAVE_ENOUGH_DATA || t.readyState === t.HAVE_FUTURE_DATA) && t.width && t.height && (t.complete = !0), t.addEventListener("play", this._onPlayStart), t.addEventListener("pause", this._onPlayStop), t.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._mediaReady() : (e.preload || t.addEventListener("canplay", this._onCanPlay), t.addEventListener("canplaythrough", this._onCanPlayThrough), t.addEventListener("error", this._onError, !0)), this.alphaMode = await JR(), this._load = new Promise((s, r) => {
      this.isValid ? s(this) : (this._resolve = s, this._reject = r, e.preloadTimeoutMs !== void 0 && (this._preloadTimeout = setTimeout(() => {
        this._onError(new ErrorEvent(`Preload exceeded timeout of ${e.preloadTimeoutMs}ms`));
      })), t.load());
    }), this._load;
  }
  /**
   * Handle video error events.
   * @param event - The error event
   */
  _onError(t) {
    this.resource.removeEventListener("error", this._onError, !0), this.emit("error", t), this._reject && (this._reject(t), this._reject = null, this._resolve = null);
  }
  /**
   * Checks if the underlying source is playing.
   * @returns True if playing.
   */
  _isSourcePlaying() {
    const t = this.resource;
    return !t.paused && !t.ended;
  }
  /**
   * Checks if the underlying source is ready for playing.
   * @returns True if ready.
   */
  _isSourceReady() {
    return this.resource.readyState > 2;
  }
  /** Runs the update loop when the video is ready to play. */
  _onPlayStart() {
    this.isValid || this._mediaReady(), this._configureAutoUpdate();
  }
  /** Stops the update loop when a pause event is triggered. */
  _onPlayStop() {
    this._configureAutoUpdate();
  }
  /** Handles behavior when the video completes seeking to the current playback position. */
  _onSeeked() {
    this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0);
  }
  _onCanPlay() {
    this.resource.removeEventListener("canplay", this._onCanPlay), this._mediaReady();
  }
  _onCanPlayThrough() {
    this.resource.removeEventListener("canplaythrough", this._onCanPlay), this._preloadTimeout && (clearTimeout(this._preloadTimeout), this._preloadTimeout = void 0), this._mediaReady();
  }
  /** Fired when the video is loaded and ready to play. */
  _mediaReady() {
    const t = this.resource;
    this.isValid && (this.isReady = !0, this.resize(t.videoWidth, t.videoHeight)), this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0, this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play();
  }
  /** Cleans up resources and event listeners associated with this texture. */
  destroy() {
    this._configureAutoUpdate();
    const t = this.resource;
    t && (t.removeEventListener("play", this._onPlayStart), t.removeEventListener("pause", this._onPlayStop), t.removeEventListener("seeked", this._onSeeked), t.removeEventListener("canplay", this._onCanPlay), t.removeEventListener("canplaythrough", this._onCanPlayThrough), t.removeEventListener("error", this._onError, !0), t.pause(), t.src = "", t.load()), super.destroy();
  }
  /** Should the base texture automatically update itself, set to true by default. */
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(t) {
    t !== this._autoUpdate && (this._autoUpdate = t, this._configureAutoUpdate());
  }
  /**
   * How many times a second to update the texture from the video.
   * Leave at 0 to update at every render.
   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
   */
  get updateFPS() {
    return this._updateFPS;
  }
  set updateFPS(t) {
    t !== this._updateFPS && (this._updateFPS = t, this._configureAutoUpdate());
  }
  /**
   * Configures the updating mechanism based on the current state and settings.
   *
   * This method decides between using the browser's native video frame callback or a custom ticker
   * for updating the video frame. It ensures optimal performance and responsiveness
   * based on the video's state, playback status, and the desired frames-per-second setting.
   *
   * - If `_autoUpdate` is enabled and the video source is playing:
   *   - It will prefer the native video frame callback if available and no specific FPS is set.
   *   - Otherwise, it will use a custom ticker for manual updates.
   * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.
   */
  _configureAutoUpdate() {
    this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && (js.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
      this._videoFrameRequestCallback
    ))) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (js.shared.add(this.updateFrame, this), this._isConnectedToTicker = !0, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (js.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0));
  }
  static test(t) {
    return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement;
  }
};
bd.extension = B.TextureSource;
bd.defaultOptions = {
  ...ke.defaultOptions,
  /** If true, the video will start loading immediately. */
  autoLoad: !0,
  /** If true, the video will start playing as soon as it is loaded. */
  autoPlay: !0,
  /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */
  updateFPS: 0,
  /** If true, the video will be loaded with the `crossorigin` attribute. */
  crossorigin: !0,
  /** If true, the video will loop when it ends. */
  loop: !1,
  /** If true, the video will be muted. */
  muted: !0,
  /** If true, the video will play inline. */
  playsinline: !0,
  /** If true, the video will be preloaded. */
  preload: !1
};
bd.MIME_TYPES = {
  ogv: "video/ogg",
  mov: "video/quicktime",
  m4v: "video/mp4"
};
let Tl = bd;
const li = (i, t, e = !1) => (Array.isArray(i) || (i = [i]), t ? i.map((s) => typeof s == "string" || e ? t(s) : s) : i);
class Db {
  constructor() {
    this._parsers = [], this._cache = /* @__PURE__ */ new Map(), this._cacheMap = /* @__PURE__ */ new Map();
  }
  /** Clear all entries. */
  reset() {
    this._cacheMap.clear(), this._cache.clear();
  }
  /**
   * Check if the key exists
   * @param key - The key to check
   */
  has(t) {
    return this._cache.has(t);
  }
  /**
   * Fetch entry by key
   * @param key - The key of the entry to get
   */
  get(t) {
    const e = this._cache.get(t);
    return e || ce(`[Assets] Asset id ${t} was not found in the Cache`), e;
  }
  /**
   * Set a value by key or keys name
   * @param key - The key or keys to set
   * @param value - The value to store in the cache or from which cacheable assets will be derived.
   */
  set(t, e) {
    const s = li(t);
    let r;
    for (let h = 0; h < this.parsers.length; h++) {
      const u = this.parsers[h];
      if (u.test(e)) {
        r = u.getCacheableAssets(s, e);
        break;
      }
    }
    const n = new Map(Object.entries(r || {}));
    r || s.forEach((h) => {
      n.set(h, e);
    });
    const a = [...n.keys()], o = {
      cacheKeys: a,
      keys: s
    };
    s.forEach((h) => {
      this._cacheMap.set(h, o);
    }), a.forEach((h) => {
      const u = r ? r[h] : e;
      this._cache.has(h) && this._cache.get(h) !== u && ce("[Cache] already has key:", h), this._cache.set(h, n.get(h));
    });
  }
  /**
   * Remove entry by key
   *
   * This function will also remove any associated alias from the cache also.
   * @param key - The key of the entry to remove
   */
  remove(t) {
    if (!this._cacheMap.has(t)) {
      ce(`[Assets] Asset id ${t} was not found in the Cache`);
      return;
    }
    const e = this._cacheMap.get(t);
    e.cacheKeys.forEach((r) => {
      this._cache.delete(r);
    }), e.keys.forEach((r) => {
      this._cacheMap.delete(r);
    });
  }
  /** All loader parsers registered */
  get parsers() {
    return this._parsers;
  }
}
const ge = new Db(), ag = [];
Ee.handleByList(B.TextureSource, ag);
function e0(i = {}) {
  const t = i && i.resource, e = t ? i.resource : i, s = t ? i : { resource: i };
  for (let r = 0; r < ag.length; r++) {
    const n = ag[r];
    if (n.test(e))
      return new n(s);
  }
  throw new Error(`Could not find a source type for resource: ${s.resource}`);
}
function Lb(i = {}, t = !1) {
  const e = i && i.resource, s = e ? i.resource : i, r = e ? i : { resource: i };
  if (!t && ge.has(s))
    return ge.get(s);
  const n = new W({ source: e0(r) });
  return n.on("destroy", () => {
    ge.has(s) && ge.remove(s);
  }), t || ge.set(s, n), n;
}
function Fb(i, t = !1) {
  return typeof i == "string" ? ge.get(i) : i instanceof ke ? new W({ source: i }) : Lb(i, t);
}
W.from = Fb;
ke.from = e0;
Ee.add(KR, qR, $R, Tl, Ra, Do, Md);
var pn = /* @__PURE__ */ ((i) => (i[i.Low = 0] = "Low", i[i.Normal = 1] = "Normal", i[i.High = 2] = "High", i))(pn || {});
function ei(i) {
  if (typeof i != "string")
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(i)}`);
}
function nh(i) {
  return i.split("?")[0].split("#")[0];
}
function wb(i) {
  return i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Gb(i, t, e) {
  return i.replace(new RegExp(wb(t), "g"), e);
}
function Bb(i, t) {
  let e = "", s = 0, r = -1, n = 0, a = -1;
  for (let o = 0; o <= i.length; ++o) {
    if (o < i.length)
      a = i.charCodeAt(o);
    else {
      if (a === 47)
        break;
      a = 47;
    }
    if (a === 47) {
      if (!(r === o - 1 || n === 1)) if (r !== o - 1 && n === 2) {
        if (e.length < 2 || s !== 2 || e.charCodeAt(e.length - 1) !== 46 || e.charCodeAt(e.length - 2) !== 46) {
          if (e.length > 2) {
            const h = e.lastIndexOf("/");
            if (h !== e.length - 1) {
              h === -1 ? (e = "", s = 0) : (e = e.slice(0, h), s = e.length - 1 - e.lastIndexOf("/")), r = o, n = 0;
              continue;
            }
          } else if (e.length === 2 || e.length === 1) {
            e = "", s = 0, r = o, n = 0;
            continue;
          }
        }
      } else
        e.length > 0 ? e += `/${i.slice(r + 1, o)}` : e = i.slice(r + 1, o), s = o - r - 1;
      r = o, n = 0;
    } else a === 46 && n !== -1 ? ++n : n = -1;
  }
  return e;
}
const Ts = {
  /**
   * Converts a path to posix format.
   * @param path - The path to convert to posix
   */
  toPosix(i) {
    return Gb(i, "\\", "/");
  },
  /**
   * Checks if the path is a URL e.g. http://, https://
   * @param path - The path to check
   */
  isUrl(i) {
    return /^https?:/.test(this.toPosix(i));
  },
  /**
   * Checks if the path is a data URL
   * @param path - The path to check
   */
  isDataUrl(i) {
    return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(i);
  },
  /**
   * Checks if the path is a blob URL
   * @param path - The path to check
   */
  isBlobUrl(i) {
    return i.startsWith("blob:");
  },
  /**
   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
   * This will return true for windows file paths
   * @param path - The path to check
   */
  hasProtocol(i) {
    return /^[^/:]+:/.test(this.toPosix(i));
  },
  /**
   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
   * @param path - The path to get the protocol from
   */
  getProtocol(i) {
    ei(i), i = this.toPosix(i);
    const t = /^file:\/\/\//.exec(i);
    if (t)
      return t[0];
    const e = /^[^/:]+:\/{0,2}/.exec(i);
    return e ? e[0] : "";
  },
  /**
   * Converts URL to an absolute path.
   * When loading from a Web Worker, we must use absolute paths.
   * If the URL is already absolute we return it as is
   * If it's not, we convert it
   * @param url - The URL to test
   * @param customBaseUrl - The base URL to use
   * @param customRootUrl - The root URL to use
   */
  toAbsolute(i, t, e) {
    if (ei(i), this.isDataUrl(i) || this.isBlobUrl(i))
      return i;
    const s = nh(this.toPosix(t ?? Wt.get().getBaseUrl())), r = nh(this.toPosix(e ?? this.rootname(s)));
    return i = this.toPosix(i), i.startsWith("/") ? Ts.join(r, i.slice(1)) : this.isAbsolute(i) ? i : this.join(s, i);
  },
  /**
   * Normalizes the given path, resolving '..' and '.' segments
   * @param path - The path to normalize
   */
  normalize(i) {
    if (ei(i), i.length === 0)
      return ".";
    if (this.isDataUrl(i) || this.isBlobUrl(i))
      return i;
    i = this.toPosix(i);
    let t = "";
    const e = i.startsWith("/");
    this.hasProtocol(i) && (t = this.rootname(i), i = i.slice(t.length));
    const s = i.endsWith("/");
    return i = Bb(i), i.length > 0 && s && (i += "/"), e ? `/${i}` : t + i;
  },
  /**
   * Determines if path is an absolute path.
   * Absolute paths can be urls, data urls, or paths on disk
   * @param path - The path to test
   */
  isAbsolute(i) {
    return ei(i), i = this.toPosix(i), this.hasProtocol(i) ? !0 : i.startsWith("/");
  },
  /**
   * Joins all given path segments together using the platform-specific separator as a delimiter,
   * then normalizes the resulting path
   * @param segments - The segments of the path to join
   */
  join(...i) {
    if (i.length === 0)
      return ".";
    let t;
    for (let e = 0; e < i.length; ++e) {
      const s = i[e];
      if (ei(s), s.length > 0)
        if (t === void 0)
          t = s;
        else {
          const r = i[e - 1] ?? "";
          this.joinExtensions.includes(this.extname(r).toLowerCase()) ? t += `/../${s}` : t += `/${s}`;
        }
    }
    return t === void 0 ? "." : this.normalize(t);
  },
  /**
   * Returns the directory name of a path
   * @param path - The path to parse
   */
  dirname(i) {
    if (ei(i), i.length === 0)
      return ".";
    i = this.toPosix(i);
    let t = i.charCodeAt(0);
    const e = t === 47;
    let s = -1, r = !0;
    const n = this.getProtocol(i), a = i;
    i = i.slice(n.length);
    for (let o = i.length - 1; o >= 1; --o)
      if (t = i.charCodeAt(o), t === 47) {
        if (!r) {
          s = o;
          break;
        }
      } else
        r = !1;
    return s === -1 ? e ? "/" : this.isUrl(a) ? n + i : n : e && s === 1 ? "//" : n + i.slice(0, s);
  },
  /**
   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
   * @param path - The path to parse
   */
  rootname(i) {
    ei(i), i = this.toPosix(i);
    let t = "";
    if (i.startsWith("/") ? t = "/" : t = this.getProtocol(i), this.isUrl(i)) {
      const e = i.indexOf("/", t.length);
      e !== -1 ? t = i.slice(0, e) : t = i, t.endsWith("/") || (t += "/");
    }
    return t;
  },
  /**
   * Returns the last portion of a path
   * @param path - The path to test
   * @param ext - Optional extension to remove
   */
  basename(i, t) {
    ei(i), t && ei(t), i = nh(this.toPosix(i));
    let e = 0, s = -1, r = !0, n;
    if (t !== void 0 && t.length > 0 && t.length <= i.length) {
      if (t.length === i.length && t === i)
        return "";
      let a = t.length - 1, o = -1;
      for (n = i.length - 1; n >= 0; --n) {
        const h = i.charCodeAt(n);
        if (h === 47) {
          if (!r) {
            e = n + 1;
            break;
          }
        } else
          o === -1 && (r = !1, o = n + 1), a >= 0 && (h === t.charCodeAt(a) ? --a === -1 && (s = n) : (a = -1, s = o));
      }
      return e === s ? s = o : s === -1 && (s = i.length), i.slice(e, s);
    }
    for (n = i.length - 1; n >= 0; --n)
      if (i.charCodeAt(n) === 47) {
        if (!r) {
          e = n + 1;
          break;
        }
      } else s === -1 && (r = !1, s = n + 1);
    return s === -1 ? "" : i.slice(e, s);
  },
  /**
   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
   * the first character of the basename of path, an empty string is returned.
   * @param path - The path to parse
   */
  extname(i) {
    ei(i), i = nh(this.toPosix(i));
    let t = -1, e = 0, s = -1, r = !0, n = 0;
    for (let a = i.length - 1; a >= 0; --a) {
      const o = i.charCodeAt(a);
      if (o === 47) {
        if (!r) {
          e = a + 1;
          break;
        }
        continue;
      }
      s === -1 && (r = !1, s = a + 1), o === 46 ? t === -1 ? t = a : n !== 1 && (n = 1) : t !== -1 && (n = -1);
    }
    return t === -1 || s === -1 || n === 0 || n === 1 && t === s - 1 && t === e + 1 ? "" : i.slice(t, s);
  },
  /**
   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
   * @param path - The path to parse
   */
  parse(i) {
    ei(i);
    const t = { root: "", dir: "", base: "", ext: "", name: "" };
    if (i.length === 0)
      return t;
    i = nh(this.toPosix(i));
    let e = i.charCodeAt(0);
    const s = this.isAbsolute(i);
    let r;
    t.root = this.rootname(i), s || this.hasProtocol(i) ? r = 1 : r = 0;
    let n = -1, a = 0, o = -1, h = !0, u = i.length - 1, c = 0;
    for (; u >= r; --u) {
      if (e = i.charCodeAt(u), e === 47) {
        if (!h) {
          a = u + 1;
          break;
        }
        continue;
      }
      o === -1 && (h = !1, o = u + 1), e === 46 ? n === -1 ? n = u : c !== 1 && (c = 1) : n !== -1 && (c = -1);
    }
    return n === -1 || o === -1 || c === 0 || c === 1 && n === o - 1 && n === a + 1 ? o !== -1 && (a === 0 && s ? t.base = t.name = i.slice(1, o) : t.base = t.name = i.slice(a, o)) : (a === 0 && s ? (t.name = i.slice(1, n), t.base = i.slice(1, o)) : (t.name = i.slice(a, n), t.base = i.slice(a, o)), t.ext = i.slice(n, o)), t.dir = this.dirname(i), t;
  },
  sep: "/",
  delimiter: ":",
  joinExtensions: [".html"]
};
function s0(i, t, e, s, r) {
  const n = t[e];
  for (let a = 0; a < n.length; a++) {
    const o = n[a];
    e < t.length - 1 ? s0(i.replace(s[e], o), t, e + 1, s, r) : r.push(i.replace(s[e], o));
  }
}
function kb(i) {
  const t = /\{(.*?)\}/g, e = i.match(t), s = [];
  if (e) {
    const r = [];
    e.forEach((n) => {
      const a = n.substring(1, n.length - 1).split(",");
      r.push(a);
    }), s0(i, r, 0, e, s);
  } else
    s.push(i);
  return s;
}
const kl = (i) => !Array.isArray(i);
class qo {
  constructor() {
    this._defaultBundleIdentifierOptions = {
      connector: "-",
      createBundleAssetId: (t, e) => `${t}${this._bundleIdConnector}${e}`,
      extractAssetIdFromBundle: (t, e) => e.replace(`${t}${this._bundleIdConnector}`, "")
    }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {};
  }
  /**
   * Override how the resolver deals with generating bundle ids.
   * must be called before any bundles are added
   * @param bundleIdentifier - the bundle identifier options
   */
  setBundleIdentifier(t) {
    if (this._bundleIdConnector = t.connector ?? this._bundleIdConnector, this._createBundleAssetId = t.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = t.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar")
      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
  }
  /**
   * Let the resolver know which assets you prefer to use when resolving assets.
   * Multiple prefer user defined rules can be added.
   * @example
   * resolver.prefer({
   *     // first look for something with the correct format, and then then correct resolution
   *     priority: ['format', 'resolution'],
   *     params:{
   *         format:'webp', // prefer webp images
   *         resolution: 2, // prefer a resolution of 2
   *     }
   * })
   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
   * resolver.resolveUrl('foo') // => 'bar@2x.webp'
   * @param preferOrders - the prefer options
   */
  prefer(...t) {
    t.forEach((e) => {
      this._preferredOrder.push(e), e.priority || (e.priority = Object.keys(e.params));
    }), this._resolverHash = {};
  }
  /**
   * Set the base path to prepend to all urls when resolving
   * @example
   * resolver.basePath = 'https://home.com/';
   * resolver.add('foo', 'bar.ong');
   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
   * @param basePath - the base path to use
   */
  set basePath(t) {
    this._basePath = t;
  }
  get basePath() {
    return this._basePath;
  }
  /**
   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
   * default value for browsers is `window.location.origin`
   * @example
   * // Application hosted on https://home.com/some-path/index.html
   * resolver.basePath = 'https://home.com/some-path/';
   * resolver.rootPath = 'https://home.com/';
   * resolver.add('foo', '/bar.png');
   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
   * @param rootPath - the root path to use
   */
  set rootPath(t) {
    this._rootPath = t;
  }
  get rootPath() {
    return this._rootPath;
  }
  /**
   * All the active URL parsers that help the parser to extract information and create
   * an asset object-based on parsing the URL itself.
   *
   * Can be added using the extensions API
   * @example
   * resolver.add('foo', [
   *     {
   *         resolution: 2,
   *         format: 'png',
   *         src: 'image@2x.png',
   *     },
   *     {
   *         resolution:1,
   *         format:'png',
   *         src: 'image.png',
   *     },
   * ]);
   *
   * // With a url parser the information such as resolution and file format could extracted from the url itself:
   * extensions.add({
   *     extension: ExtensionType.ResolveParser,
   *     test: loadTextures.test, // test if url ends in an image
   *     parse: (value: string) =>
   *     ({
   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
   *         format: value.split('.').pop(),
   *         src: value,
   *     }),
   * });
   *
   * // Now resolution and format can be extracted from the url
   * resolver.add('foo', [
   *     'image@2x.png',
   *     'image.png',
   * ]);
   */
  get parsers() {
    return this._parsers;
  }
  /** Used for testing, this resets the resolver to its initial state */
  reset() {
    this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null;
  }
  /**
   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
   * @param searchParams - the default url parameters to append when resolving urls
   */
  setDefaultSearchParams(t) {
    if (typeof t == "string")
      this._defaultSearchParams = t;
    else {
      const e = t;
      this._defaultSearchParams = Object.keys(e).map((s) => `${encodeURIComponent(s)}=${encodeURIComponent(e[s])}`).join("&");
    }
  }
  /**
   * Returns the aliases for a given asset
   * @param asset - the asset to get the aliases for
   */
  getAlias(t) {
    const { alias: e, src: s } = t;
    return li(
      e || s,
      (n) => typeof n == "string" ? n : Array.isArray(n) ? n.map((a) => (a == null ? void 0 : a.src) ?? a) : n != null && n.src ? n.src : n,
      !0
    );
  }
  /**
   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
   * generally a manifest would be built using a tool.
   * @param manifest - the manifest to add to the resolver
   */
  addManifest(t) {
    this._manifest && ce("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = t, t.bundles.forEach((e) => {
      this.addBundle(e.name, e.assets);
    });
  }
  /**
   * This adds a bundle of assets in one go so that you can resolve them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * resolver.addBundle('animals', [
   *  { alias: 'bunny', src: 'bunny.png' },
   *  { alias: 'chicken', src: 'chicken.png' },
   *  { alias: 'thumper', src: 'thumper.png' },
   * ]);
   * // or
   * resolver.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const resolvedAssets = await resolver.resolveBundle('animals');
   * @param bundleId - The id of the bundle to add
   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
   */
  addBundle(t, e) {
    const s = [];
    let r = e;
    Array.isArray(e) || (r = Object.entries(e).map(([n, a]) => typeof a == "string" || Array.isArray(a) ? { alias: n, src: a } : { alias: n, ...a })), r.forEach((n) => {
      const a = n.src, o = n.alias;
      let h;
      if (typeof o == "string") {
        const u = this._createBundleAssetId(t, o);
        s.push(u), h = [o, u];
      } else {
        const u = o.map((c) => this._createBundleAssetId(t, c));
        s.push(...u), h = [...o, ...u];
      }
      this.add({
        ...n,
        alias: h,
        src: a
      });
    }), this._bundles[t] = s;
  }
  /**
   * Tells the resolver what keys are associated with witch asset.
   * The most important thing the resolver does
   * @example
   * // Single key, single asset:
   * resolver.add({alias: 'foo', src: 'bar.png');
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Multiple keys, single asset:
   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});
   * resolver.resolveUrl('foo') // => 'bar.png'
   * resolver.resolveUrl('boo') // => 'bar.png'
   *
   * // Multiple keys, multiple assets:
   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Add custom data attached to the resolver
   * Resolver.add({
   *     alias: 'bunnyBooBooSmooth',
   *     src: 'bunny{png,webp}',
   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options
   * });
   *
   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }
   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver
   */
  add(t) {
    const e = [];
    Array.isArray(t) ? e.push(...t) : e.push(t);
    let s;
    s = (n) => {
      this.hasKey(n) && ce(`[Resolver] already has key: ${n} overwriting`);
    }, li(e).forEach((n) => {
      const { src: a } = n;
      let { data: o, format: h, loadParser: u } = n;
      const c = li(a).map((d) => typeof d == "string" ? kb(d) : Array.isArray(d) ? d : [d]), l = this.getAlias(n);
      Array.isArray(l) ? l.forEach(s) : s(l);
      const _ = [];
      c.forEach((d) => {
        d.forEach((f) => {
          let p = {};
          if (typeof f != "object") {
            p.src = f;
            for (let g = 0; g < this._parsers.length; g++) {
              const m = this._parsers[g];
              if (m.test(f)) {
                p = m.parse(f);
                break;
              }
            }
          } else
            o = f.data ?? o, h = f.format ?? h, u = f.loadParser ?? u, p = {
              ...p,
              ...f
            };
          if (!l)
            throw new Error(`[Resolver] alias is undefined for this asset: ${p.src}`);
          p = this._buildResolvedAsset(p, {
            aliases: l,
            data: o,
            format: h,
            loadParser: u
          }), _.push(p);
        });
      }), l.forEach((d) => {
        this._assetMap[d] = _;
      });
    });
  }
  // TODO: this needs an overload like load did in Assets
  /**
   * If the resolver has had a manifest set via setManifest, this will return the assets urls for
   * a given bundleId or bundleIds.
   * @example
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * resolver.setManifest(manifest);
   * const resolved = resolver.resolveBundle('load-screen');
   * @param bundleIds - The bundle ids to resolve
   * @returns All the bundles assets or a hash of assets for each bundle specified
   */
  resolveBundle(t) {
    const e = kl(t);
    t = li(t);
    const s = {};
    return t.forEach((r) => {
      const n = this._bundles[r];
      if (n) {
        const a = this.resolve(n), o = {};
        for (const h in a) {
          const u = a[h];
          o[this._extractAssetIdFromBundle(r, h)] = u;
        }
        s[r] = o;
      }
    }), e ? s[t[0]] : s;
  }
  /**
   * Does exactly what resolve does, but returns just the URL rather than the whole asset object
   * @param key - The key or keys to resolve
   * @returns - The URLs associated with the key(s)
   */
  resolveUrl(t) {
    const e = this.resolve(t);
    if (typeof t != "string") {
      const s = {};
      for (const r in e)
        s[r] = e[r].src;
      return s;
    }
    return e.src;
  }
  resolve(t) {
    const e = kl(t);
    t = li(t);
    const s = {};
    return t.forEach((r) => {
      if (!this._resolverHash[r])
        if (this._assetMap[r]) {
          let n = this._assetMap[r];
          const a = this._getPreferredOrder(n);
          a == null || a.priority.forEach((o) => {
            a.params[o].forEach((h) => {
              const u = n.filter((c) => c[o] ? c[o] === h : !1);
              u.length && (n = u);
            });
          }), this._resolverHash[r] = n[0];
        } else
          this._resolverHash[r] = this._buildResolvedAsset({
            alias: [r],
            src: r
          }, {});
      s[r] = this._resolverHash[r];
    }), e ? s[t[0]] : s;
  }
  /**
   * Checks if an asset with a given key exists in the resolver
   * @param key - The key of the asset
   */
  hasKey(t) {
    return !!this._assetMap[t];
  }
  /**
   * Checks if a bundle with the given key exists in the resolver
   * @param key - The key of the bundle
   */
  hasBundle(t) {
    return !!this._bundles[t];
  }
  /**
   * Internal function for figuring out what prefer criteria an asset should use.
   * @param assets
   */
  _getPreferredOrder(t) {
    for (let e = 0; e < t.length; e++) {
      const s = t[0], r = this._preferredOrder.find((n) => n.params.format.includes(s.format));
      if (r)
        return r;
    }
    return this._preferredOrder[0];
  }
  /**
   * Appends the default url parameters to the url
   * @param url - The url to append the default parameters to
   * @returns - The url with the default parameters appended
   */
  _appendDefaultSearchParams(t) {
    if (!this._defaultSearchParams)
      return t;
    const e = /\?/.test(t) ? "&" : "?";
    return `${t}${e}${this._defaultSearchParams}`;
  }
  _buildResolvedAsset(t, e) {
    const { aliases: s, data: r, loadParser: n, format: a } = e;
    return (this._basePath || this._rootPath) && (t.src = Ts.toAbsolute(t.src, this._basePath, this._rootPath)), t.alias = s ?? t.alias ?? [t.src], t.src = this._appendDefaultSearchParams(t.src), t.data = { ...r || {}, ...t.data }, t.loadParser = n ?? t.loadParser, t.format = a ?? t.format ?? zb(t.src), t;
  }
}
qo.RETINA_PREFIX = /@([0-9\.]+)x/;
function zb(i) {
  return i.split(".").pop().split("?").shift().split("#").shift();
}
const og = (i, t) => {
  const e = t.split("?")[1];
  return e && (i += `?${e}`), i;
}, i0 = class _h {
  /**
   * @param texture - Reference to the source BaseTexture object.
   * @param {object} data - Spritesheet image data.
   */
  constructor(t, e) {
    this.linkedSheets = [], this._texture = t instanceof W ? t : null, this.textureSource = t.source, this.textures = {}, this.animations = {}, this.data = e;
    const s = parseFloat(e.meta.scale);
    s ? (this.resolution = s, t.source.resolution = this.resolution) : this.resolution = t.source._resolution, this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
  }
  /**
   * Parser spritesheet from loaded data. This is done asynchronously
   * to prevent creating too many Texture within a single process.
   */
  parse() {
    return new Promise((t) => {
      this._callback = t, this._batchIndex = 0, this._frameKeys.length <= _h.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
    });
  }
  /**
   * Process a batch of frames
   * @param initialFrameIndex - The index of frame to start.
   */
  _processFrames(t) {
    let e = t;
    const s = _h.BATCH_SIZE;
    for (; e - t < s && e < this._frameKeys.length; ) {
      const r = this._frameKeys[e], n = this._frames[r], a = n.frame;
      if (a) {
        let o = null, h = null;
        const u = n.trimmed !== !1 && n.sourceSize ? n.sourceSize : n.frame, c = new Kt(
          0,
          0,
          Math.floor(u.w) / this.resolution,
          Math.floor(u.h) / this.resolution
        );
        n.rotated ? o = new Kt(
          Math.floor(a.x) / this.resolution,
          Math.floor(a.y) / this.resolution,
          Math.floor(a.h) / this.resolution,
          Math.floor(a.w) / this.resolution
        ) : o = new Kt(
          Math.floor(a.x) / this.resolution,
          Math.floor(a.y) / this.resolution,
          Math.floor(a.w) / this.resolution,
          Math.floor(a.h) / this.resolution
        ), n.trimmed !== !1 && n.spriteSourceSize && (h = new Kt(
          Math.floor(n.spriteSourceSize.x) / this.resolution,
          Math.floor(n.spriteSourceSize.y) / this.resolution,
          Math.floor(a.w) / this.resolution,
          Math.floor(a.h) / this.resolution
        )), this.textures[r] = new W({
          source: this.textureSource,
          frame: o,
          orig: c,
          trim: h,
          rotate: n.rotated ? 2 : 0,
          defaultAnchor: n.anchor,
          defaultBorders: n.borders,
          label: r.toString()
        });
      }
      e++;
    }
  }
  /** Parse animations config. */
  _processAnimations() {
    const t = this.data.animations || {};
    for (const e in t) {
      this.animations[e] = [];
      for (let s = 0; s < t[e].length; s++) {
        const r = t[e][s];
        this.animations[e].push(this.textures[r]);
      }
    }
  }
  /** The parse has completed. */
  _parseComplete() {
    const t = this._callback;
    this._callback = null, this._batchIndex = 0, t.call(this, this.textures);
  }
  /** Begin the next batch of textures. */
  _nextBatch() {
    this._processFrames(this._batchIndex * _h.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
      this._batchIndex * _h.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
    }, 0);
  }
  /**
   * Destroy Spritesheet and don't use after this.
   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
   */
  destroy(t = !1) {
    var e;
    for (const s in this.textures)
      this.textures[s].destroy();
    this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && ((e = this._texture) == null || e.destroy(), this.textureSource.destroy()), this._texture = null, this.textureSource = null, this.linkedSheets = [];
  }
};
i0.BATCH_SIZE = 1e3;
let hg = i0;
const Vb = [
  "jpg",
  "png",
  "jpeg",
  "avif",
  "webp",
  "basis",
  "etc2",
  "bc7",
  "bc6h",
  "bc5",
  "bc4",
  "bc3",
  "bc2",
  "bc1",
  "eac",
  "astc"
];
function r0(i, t, e) {
  const s = {};
  if (i.forEach((r) => {
    s[r] = t;
  }), Object.keys(t.textures).forEach((r) => {
    s[r] = t.textures[r];
  }), !e) {
    const r = Ts.dirname(i[0]);
    t.linkedSheets.forEach((n, a) => {
      const o = r0([`${r}/${t.data.meta.related_multi_packs[a]}`], n, !0);
      Object.assign(s, o);
    });
  }
  return s;
}
const Hb = {
  extension: B.Asset,
  /** Handle the caching of the related Spritesheet Textures */
  cache: {
    test: (i) => i instanceof hg,
    getCacheableAssets: (i, t) => r0(i, t, !1)
  },
  /** Resolve the resolution of the asset. */
  resolver: {
    extension: {
      type: B.ResolveParser,
      name: "resolveSpritesheet"
    },
    test: (i) => {
      const e = i.split("?")[0].split("."), s = e.pop(), r = e.pop();
      return s === "json" && Vb.includes(r);
    },
    parse: (i) => {
      var e;
      const t = i.split(".");
      return {
        resolution: parseFloat(((e = qo.RETINA_PREFIX.exec(i)) == null ? void 0 : e[1]) ?? "1"),
        format: t[t.length - 2],
        src: i
      };
    }
  },
  /**
   * Loader plugin that parses sprite sheets!
   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
   * If it is, we load the spritesheets image and parse the data into Spritesheet
   * All textures in the sprite sheet are then added to the cache
   */
  loader: {
    name: "spritesheetLoader",
    extension: {
      type: B.LoadParser,
      priority: pn.Normal,
      name: "spritesheetLoader"
    },
    async testParse(i, t) {
      return Ts.extname(t.src).toLowerCase() === ".json" && !!i.frames;
    },
    async parse(i, t, e) {
      var u, c;
      const {
        texture: s,
        // if user need to use preloaded texture
        imageFilename: r
        // if user need to use custom filename (not from jsonFile.meta.image)
      } = (t == null ? void 0 : t.data) ?? {};
      let n = Ts.dirname(t.src);
      n && n.lastIndexOf("/") !== n.length - 1 && (n += "/");
      let a;
      if (s instanceof W)
        a = s;
      else {
        const l = og(n + (r ?? i.meta.image), t.src);
        a = (await e.load([l]))[l];
      }
      const o = new hg(
        a.source,
        i
      );
      await o.parse();
      const h = (u = i == null ? void 0 : i.meta) == null ? void 0 : u.related_multi_packs;
      if (Array.isArray(h)) {
        const l = [];
        for (const d of h) {
          if (typeof d != "string")
            continue;
          let f = n + d;
          (c = t.data) != null && c.ignoreMultiPack || (f = og(f, t.src), l.push(e.load({
            src: f,
            data: {
              ignoreMultiPack: !0
            }
          })));
        }
        const _ = await Promise.all(l);
        o.linkedSheets = _, _.forEach((d) => {
          d.linkedSheets = [o].concat(o.linkedSheets.filter((f) => f !== d));
        });
      }
      return o;
    },
    async unload(i, t, e) {
      await e.unload(i.textureSource._sourceOrigin), i.destroy(!1);
    }
  }
};
Ee.add(Hb);
const lf = /* @__PURE__ */ Object.create(null), dS = /* @__PURE__ */ Object.create(null);
function cu(i, t) {
  let e = dS[i];
  return e === void 0 && (lf[t] === void 0 && (lf[t] = 1), dS[i] = e = lf[t]++), e;
}
let Ma;
function n0() {
  return (!Ma || Ma != null && Ma.isContextLost()) && (Ma = Wt.get().createCanvas().getContext("webgl", {})), Ma;
}
let tl;
function Yb() {
  if (!tl) {
    tl = "mediump";
    const i = n0();
    i && i.getShaderPrecisionFormat && (tl = i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision ? "highp" : "mediump");
  }
  return tl;
}
function Wb(i, t, e) {
  return t ? i : e ? (i = i.replace("out vec4 finalColor;", ""), `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${i}
        `) : `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${i}
        `;
}
function jb(i, t, e) {
  const s = e ? t.maxSupportedFragmentPrecision : t.maxSupportedVertexPrecision;
  if (i.substring(0, 9) !== "precision") {
    let r = e ? t.requestedFragmentPrecision : t.requestedVertexPrecision;
    return r === "highp" && s !== "highp" && (r = "mediump"), `precision ${r} float;
${i}`;
  } else if (s !== "highp" && i.substring(0, 15) === "precision highp")
    return i.replace("precision highp", "precision mediump");
  return i;
}
function Xb(i, t) {
  return t ? `#version 300 es
${i}` : i;
}
const Kb = {}, qb = {};
function $b(i, { name: t = "pixi-program" }, e = !0) {
  t = t.replace(/\s+/g, "-"), t += e ? "-fragment" : "-vertex";
  const s = e ? Kb : qb;
  return s[t] ? (s[t]++, t += `-${s[t]}`) : s[t] = 1, i.indexOf("#define SHADER_NAME") !== -1 ? i : `${`#define SHADER_NAME ${t}`}
${i}`;
}
function Zb(i, t) {
  return t ? i.replace("#version 300 es", "") : i;
}
const cf = {
  // strips any version headers..
  stripVersion: Zb,
  // adds precision string if not already present
  ensurePrecision: jb,
  // add some defines if WebGL1 to make it more compatible with WebGL2 shaders
  addProgramDefines: Wb,
  // add the program name to the shader
  setProgramName: $b,
  // add the version string to the shader header
  insertVersion: Xb
}, _f = /* @__PURE__ */ Object.create(null), a0 = class ug {
  /**
   * Creates a shiny new GlProgram. Used by WebGL renderer.
   * @param options - The options for the program.
   */
  constructor(t) {
    t = { ...ug.defaultOptions, ...t };
    const e = t.fragment.indexOf("#version 300 es") !== -1, s = {
      stripVersion: e,
      ensurePrecision: {
        requestedFragmentPrecision: t.preferredFragmentPrecision,
        requestedVertexPrecision: t.preferredVertexPrecision,
        maxSupportedVertexPrecision: "highp",
        maxSupportedFragmentPrecision: Yb()
      },
      setProgramName: {
        name: t.name
      },
      addProgramDefines: e,
      insertVersion: e
    };
    let r = t.fragment, n = t.vertex;
    Object.keys(cf).forEach((a) => {
      const o = s[a];
      r = cf[a](r, o, !0), n = cf[a](n, o, !1);
    }), this.fragment = r, this.vertex = n, this._key = cu(`${this.vertex}:${this.fragment}`, "gl-program");
  }
  /** destroys the program */
  destroy() {
    this.fragment = null, this.vertex = null, this._attributeData = null, this._uniformData = null, this._uniformBlockData = null, this.transformFeedbackVaryings = null;
  }
  /**
   * Helper function that creates a program for a given source.
   * It will check the program cache if the program has already been created.
   * If it has that one will be returned, if not a new one will be created and cached.
   * @param options - The options for the program.
   * @returns A program using the same source
   */
  static from(t) {
    const e = `${t.vertex}:${t.fragment}`;
    return _f[e] || (_f[e] = new ug(t)), _f[e];
  }
};
a0.defaultOptions = {
  preferredVertexPrecision: "highp",
  preferredFragmentPrecision: "mediump"
};
let It = a0;
const fS = {
  uint8x2: { size: 2, stride: 2, normalised: !1 },
  uint8x4: { size: 4, stride: 4, normalised: !1 },
  sint8x2: { size: 2, stride: 2, normalised: !1 },
  sint8x4: { size: 4, stride: 4, normalised: !1 },
  unorm8x2: { size: 2, stride: 2, normalised: !0 },
  unorm8x4: { size: 4, stride: 4, normalised: !0 },
  snorm8x2: { size: 2, stride: 2, normalised: !0 },
  snorm8x4: { size: 4, stride: 4, normalised: !0 },
  uint16x2: { size: 2, stride: 4, normalised: !1 },
  uint16x4: { size: 4, stride: 8, normalised: !1 },
  sint16x2: { size: 2, stride: 4, normalised: !1 },
  sint16x4: { size: 4, stride: 8, normalised: !1 },
  unorm16x2: { size: 2, stride: 4, normalised: !0 },
  unorm16x4: { size: 4, stride: 8, normalised: !0 },
  snorm16x2: { size: 2, stride: 4, normalised: !0 },
  snorm16x4: { size: 4, stride: 8, normalised: !0 },
  float16x2: { size: 2, stride: 4, normalised: !1 },
  float16x4: { size: 4, stride: 8, normalised: !1 },
  float32: { size: 1, stride: 4, normalised: !1 },
  float32x2: { size: 2, stride: 8, normalised: !1 },
  float32x3: { size: 3, stride: 12, normalised: !1 },
  float32x4: { size: 4, stride: 16, normalised: !1 },
  uint32: { size: 1, stride: 4, normalised: !1 },
  uint32x2: { size: 2, stride: 8, normalised: !1 },
  uint32x3: { size: 3, stride: 12, normalised: !1 },
  uint32x4: { size: 4, stride: 16, normalised: !1 },
  sint32: { size: 1, stride: 4, normalised: !1 },
  sint32x2: { size: 2, stride: 8, normalised: !1 },
  sint32x3: { size: 3, stride: 12, normalised: !1 },
  sint32x4: { size: 4, stride: 16, normalised: !1 }
};
function lg(i) {
  return fS[i] ?? fS.float32;
}
const Qb = {
  f32: "float32",
  "vec2<f32>": "float32x2",
  "vec3<f32>": "float32x3",
  "vec4<f32>": "float32x4",
  vec2f: "float32x2",
  vec3f: "float32x3",
  vec4f: "float32x4",
  i32: "sint32",
  "vec2<i32>": "sint32x2",
  "vec3<i32>": "sint32x3",
  "vec4<i32>": "sint32x4",
  u32: "uint32",
  "vec2<u32>": "uint32x2",
  "vec3<u32>": "uint32x3",
  "vec4<u32>": "uint32x4",
  bool: "uint32",
  "vec2<bool>": "uint32x2",
  "vec3<bool>": "uint32x3",
  "vec4<bool>": "uint32x4"
};
function Jb({ source: i, entryPoint: t }) {
  const e = {}, s = i.indexOf(`fn ${t}`);
  if (s !== -1) {
    const r = i.indexOf("->", s);
    if (r !== -1) {
      const n = i.substring(s, r), a = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
      let o;
      for (; (o = a.exec(n)) !== null; ) {
        const h = Qb[o[3]] ?? "float32";
        e[o[2]] = {
          location: parseInt(o[1], 10),
          format: h,
          stride: lg(h).stride,
          offset: 0,
          instance: !1,
          start: 0
        };
      }
    }
  }
  return e;
}
function df(i) {
  var l, _;
  const t = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g, e = /@group\((\d+)\)/, s = /@binding\((\d+)\)/, r = /var(<[^>]+>)? (\w+)/, n = /:\s*(\w+)/, a = /struct\s+(\w+)\s*{([^}]+)}/g, o = /(\w+)\s*:\s*([\w\<\>]+)/g, h = /struct\s+(\w+)/, u = (l = i.match(t)) == null ? void 0 : l.map((d) => ({
    group: parseInt(d.match(e)[1], 10),
    binding: parseInt(d.match(s)[1], 10),
    name: d.match(r)[2],
    isUniform: d.match(r)[1] === "<uniform>",
    type: d.match(n)[1]
  }));
  if (!u)
    return {
      groups: [],
      structs: []
    };
  const c = ((_ = i.match(a)) == null ? void 0 : _.map((d) => {
    const f = d.match(h)[1], p = d.match(o).reduce((g, m) => {
      const [O, y] = m.split(":");
      return g[O.trim()] = y.trim(), g;
    }, {});
    return p ? { name: f, members: p } : null;
  }).filter(({ name: d }) => u.some((f) => f.type === d))) ?? [];
  return {
    groups: u,
    structs: c
  };
}
var dh = /* @__PURE__ */ ((i) => (i[i.VERTEX = 1] = "VERTEX", i[i.FRAGMENT = 2] = "FRAGMENT", i[i.COMPUTE = 4] = "COMPUTE", i))(dh || {});
function tP({ groups: i }) {
  const t = [];
  for (let e = 0; e < i.length; e++) {
    const s = i[e];
    t[s.group] || (t[s.group] = []), s.isUniform ? t[s.group].push({
      binding: s.binding,
      visibility: dh.VERTEX | dh.FRAGMENT,
      buffer: {
        type: "uniform"
      }
    }) : s.type === "sampler" ? t[s.group].push({
      binding: s.binding,
      visibility: dh.FRAGMENT,
      sampler: {
        type: "filtering"
      }
    }) : s.type === "texture_2d" && t[s.group].push({
      binding: s.binding,
      visibility: dh.FRAGMENT,
      texture: {
        sampleType: "float",
        viewDimension: "2d",
        multisampled: !1
      }
    });
  }
  return t;
}
function eP({ groups: i }) {
  const t = [];
  for (let e = 0; e < i.length; e++) {
    const s = i[e];
    t[s.group] || (t[s.group] = {}), t[s.group][s.name] = s.binding;
  }
  return t;
}
function sP(i, t) {
  const e = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set(), r = [...i.structs, ...t.structs].filter((a) => e.has(a.name) ? !1 : (e.add(a.name), !0)), n = [...i.groups, ...t.groups].filter((a) => {
    const o = `${a.name}-${a.binding}`;
    return s.has(o) ? !1 : (s.add(o), !0);
  });
  return { structs: r, groups: n };
}
const ff = /* @__PURE__ */ Object.create(null);
class Ot {
  /**
   * Create a new GpuProgram
   * @param options - The options for the gpu program
   */
  constructor(t) {
    var o, h;
    this._layoutKey = 0, this._attributeLocationsKey = 0;
    const { fragment: e, vertex: s, layout: r, gpuLayout: n, name: a } = t;
    if (this.name = a, this.fragment = e, this.vertex = s, e.source === s.source) {
      const u = df(e.source);
      this.structsAndGroups = u;
    } else {
      const u = df(s.source), c = df(e.source);
      this.structsAndGroups = sP(u, c);
    }
    this.layout = r ?? eP(this.structsAndGroups), this.gpuLayout = n ?? tP(this.structsAndGroups), this.autoAssignGlobalUniforms = ((o = this.layout[0]) == null ? void 0 : o.globalUniforms) !== void 0, this.autoAssignLocalUniforms = ((h = this.layout[1]) == null ? void 0 : h.localUniforms) !== void 0, this._generateProgramKey();
  }
  // TODO maker this pure
  _generateProgramKey() {
    const { vertex: t, fragment: e } = this, s = t.source + e.source + t.entryPoint + e.entryPoint;
    this._layoutKey = cu(s, "program");
  }
  get attributeData() {
    return this._attributeData ?? (this._attributeData = Jb(this.vertex)), this._attributeData;
  }
  /** destroys the program */
  destroy() {
    this.gpuLayout = null, this.layout = null, this.structsAndGroups = null, this.fragment = null, this.vertex = null;
  }
  /**
   * Helper function that creates a program for a given source.
   * It will check the program cache if the program has already been created.
   * If it has that one will be returned, if not a new one will be created and cached.
   * @param options - The options for the program.
   * @returns A program using the same source
   */
  static from(t) {
    const e = `${t.vertex.source}:${t.fragment.source}:${t.fragment.entryPoint}:${t.vertex.entryPoint}`;
    return ff[e] || (ff[e] = new Ot(t)), ff[e];
  }
}
const o0 = [
  "f32",
  "i32",
  "vec2<f32>",
  "vec3<f32>",
  "vec4<f32>",
  "mat2x2<f32>",
  "mat3x3<f32>",
  "mat4x4<f32>",
  "mat3x2<f32>",
  "mat4x2<f32>",
  "mat2x3<f32>",
  "mat4x3<f32>",
  "mat2x4<f32>",
  "mat3x4<f32>"
], iP = o0.reduce((i, t) => (i[t] = !0, i), {});
function rP(i, t) {
  switch (i) {
    case "f32":
      return 0;
    case "vec2<f32>":
      return new Float32Array(2 * t);
    case "vec3<f32>":
      return new Float32Array(3 * t);
    case "vec4<f32>":
      return new Float32Array(4 * t);
    case "mat2x2<f32>":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3x3<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4x4<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
const h0 = class u0 {
  /**
   * Create a new Uniform group
   * @param uniformStructures - The structures of the uniform group
   * @param options - The optional parameters of this uniform group
   */
  constructor(t, e) {
    this._touched = 0, this.uid = me("uniform"), this._resourceType = "uniformGroup", this._resourceId = me("resource"), this.isUniformGroup = !0, this._dirtyId = 0, this.destroyed = !1, e = { ...u0.defaultOptions, ...e }, this.uniformStructures = t;
    const s = {};
    for (const r in t) {
      const n = t[r];
      if (n.name = r, n.size = n.size ?? 1, !iP[n.type])
        throw new Error(`Uniform type ${n.type} is not supported. Supported uniform types are: ${o0.join(", ")}`);
      n.value ?? (n.value = rP(n.type, n.size)), s[r] = n.value;
    }
    this.uniforms = s, this._dirtyId = 1, this.ubo = e.ubo, this.isStatic = e.isStatic, this._signature = cu(Object.keys(s).map(
      (r) => `${r}-${t[r].type}`
    ).join("-"), "uniform-group");
  }
  /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */
  update() {
    this._dirtyId++;
  }
};
h0.defaultOptions = {
  /** if true the UniformGroup is handled as an Uniform buffer object. */
  ubo: !1,
  /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */
  isStatic: !1
};
let mn = h0;
class la {
  /**
   * Create a new instance eof the Bind Group.
   * @param resources - The resources that are bound together for use by a shader.
   */
  constructor(t) {
    this.resources = /* @__PURE__ */ Object.create(null), this._dirty = !0;
    let e = 0;
    for (const s in t) {
      const r = t[s];
      this.setResource(r, e++);
    }
    this._updateKey();
  }
  /**
   * Updates the key if its flagged as dirty. This is used internally to
   * match this bind group to a WebGPU BindGroup.
   * @internal
   * @ignore
   */
  _updateKey() {
    if (!this._dirty)
      return;
    this._dirty = !1;
    const t = [];
    let e = 0;
    for (const s in this.resources)
      t[e++] = this.resources[s]._resourceId;
    this._key = t.join("|");
  }
  /**
   * Set a resource at a given index. this function will
   * ensure that listeners will be removed from the current resource
   * and added to the new resource.
   * @param resource - The resource to set.
   * @param index - The index to set the resource at.
   */
  setResource(t, e) {
    var r, n;
    const s = this.resources[e];
    t !== s && (s && ((r = t.off) == null || r.call(t, "change", this.onResourceChange, this)), (n = t.on) == null || n.call(t, "change", this.onResourceChange, this), this.resources[e] = t, this._dirty = !0);
  }
  /**
   * Returns the resource at the current specified index.
   * @param index - The index of the resource to get.
   * @returns - The resource at the specified index.
   */
  getResource(t) {
    return this.resources[t];
  }
  /**
   * Used internally to 'touch' each resource, to ensure that the GC
   * knows that all resources in this bind group are still being used.
   * @param tick - The current tick.
   * @internal
   * @ignore
   */
  _touch(t) {
    const e = this.resources;
    for (const s in e)
      e[s]._touched = t;
  }
  /** Destroys this bind group and removes all listeners. */
  destroy() {
    var e;
    const t = this.resources;
    for (const s in t) {
      const r = t[s];
      (e = r.off) == null || e.call(r, "change", this.onResourceChange, this);
    }
    this.resources = null;
  }
  onResourceChange(t) {
    if (this._dirty = !0, t.destroyed) {
      const e = this.resources;
      for (const s in e)
        e[s] === t && (e[s] = null);
    } else
      this._updateKey();
  }
}
var Or = /* @__PURE__ */ ((i) => (i[i.WEBGL = 1] = "WEBGL", i[i.WEBGPU = 2] = "WEBGPU", i[i.BOTH = 3] = "BOTH", i))(Or || {});
class $o extends Js {
  constructor(t) {
    super(), this._uniformBindMap = /* @__PURE__ */ Object.create(null), this._ownedBindGroups = [];
    let {
      gpuProgram: e,
      glProgram: s,
      groups: r,
      resources: n,
      compatibleRenderers: a,
      groupMap: o
    } = t;
    this.gpuProgram = e, this.glProgram = s, a === void 0 && (a = 0, e && (a |= Or.WEBGPU), s && (a |= Or.WEBGL)), this.compatibleRenderers = a;
    const h = {};
    if (!n && !r && (n = {}), n && r)
      throw new Error("[Shader] Cannot have both resources and groups");
    if (!e && r && !o)
      throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
    if (!e && r && o)
      for (const u in o)
        for (const c in o[u]) {
          const l = o[u][c];
          h[l] = {
            group: u,
            binding: c,
            name: l
          };
        }
    else if (e && r && !o) {
      const u = e.structsAndGroups.groups;
      o = {}, u.forEach((c) => {
        o[c.group] = o[c.group] || {}, o[c.group][c.binding] = c.name, h[c.name] = c;
      });
    } else if (n) {
      r = {}, o = {}, e && e.structsAndGroups.groups.forEach((l) => {
        o[l.group] = o[l.group] || {}, o[l.group][l.binding] = l.name, h[l.name] = l;
      });
      let u = 0;
      for (const c in n)
        h[c] || (r[99] || (r[99] = new la(), this._ownedBindGroups.push(r[99])), h[c] = { group: 99, binding: u, name: c }, o[99] = o[99] || {}, o[99][u] = c, u++);
      for (const c in n) {
        const l = c;
        let _ = n[c];
        !_.source && !_._resourceType && (_ = new mn(_));
        const d = h[l];
        d && (r[d.group] || (r[d.group] = new la(), this._ownedBindGroups.push(r[d.group])), r[d.group].setResource(_, d.binding));
      }
    }
    this.groups = r, this._uniformBindMap = o, this.resources = this._buildResourceAccessor(r, h);
  }
  /**
   * Sometimes a resource group will be provided later (for example global uniforms)
   * In such cases, this method can be used to let the shader know about the group.
   * @param name - the name of the resource group
   * @param groupIndex - the index of the group (should match the webGPU shader group location)
   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)
   */
  addResource(t, e, s) {
    var r, n;
    (r = this._uniformBindMap)[e] || (r[e] = {}), (n = this._uniformBindMap[e])[s] || (n[s] = t), this.groups[e] || (this.groups[e] = new la(), this._ownedBindGroups.push(this.groups[e]));
  }
  _buildResourceAccessor(t, e) {
    const s = {};
    for (const r in e) {
      const n = e[r];
      Object.defineProperty(s, n.name, {
        get() {
          return t[n.group].getResource(n.binding);
        },
        set(a) {
          t[n.group].setResource(a, n.binding);
        }
      });
    }
    return s;
  }
  /**
   * Use to destroy the shader when its not longer needed.
   * It will destroy the resources and remove listeners.
   * @param destroyPrograms - if the programs should be destroyed as well.
   * Make sure its not being used by other shaders!
   */
  destroy(t = !1) {
    var e, s;
    this.emit("destroy", this), t && ((e = this.gpuProgram) == null || e.destroy(), (s = this.glProgram) == null || s.destroy()), this.gpuProgram = null, this.glProgram = null, this.removeAllListeners(), this._uniformBindMap = null, this._ownedBindGroups.forEach((r) => {
      r.destroy();
    }), this._ownedBindGroups = null, this.resources = null, this.groups = null;
  }
  static from(t) {
    const { gpu: e, gl: s, ...r } = t;
    let n, a;
    return e && (n = Ot.from(e)), s && (a = It.from(s)), new $o({
      gpuProgram: n,
      glProgram: a,
      ...r
    });
  }
}
const nP = {
  normal: 0,
  add: 1,
  multiply: 2,
  screen: 3,
  overlay: 4,
  erase: 5,
  "normal-npm": 6,
  "add-npm": 7,
  "screen-npm": 8,
  min: 9,
  max: 10
}, gf = 0, pf = 1, mf = 2, Ef = 3, Tf = 4, If = 5, cg = class l0 {
  constructor() {
    this.data = 0, this.blendMode = "normal", this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;
  }
  /**
   * Activates blending of the computed fragment color values.
   * @default true
   */
  get blend() {
    return !!(this.data & 1 << gf);
  }
  set blend(t) {
    !!(this.data & 1 << gf) !== t && (this.data ^= 1 << gf);
  }
  /**
   * Activates adding an offset to depth values of polygon's fragments
   * @default false
   */
  get offsets() {
    return !!(this.data & 1 << pf);
  }
  set offsets(t) {
    !!(this.data & 1 << pf) !== t && (this.data ^= 1 << pf);
  }
  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */
  set cullMode(t) {
    if (t === "none") {
      this.culling = !1;
      return;
    }
    this.culling = !0, this.clockwiseFrontFace = t === "front";
  }
  get cullMode() {
    return this.culling ? this.clockwiseFrontFace ? "front" : "back" : "none";
  }
  /**
   * Activates culling of polygons.
   * @default false
   */
  get culling() {
    return !!(this.data & 1 << mf);
  }
  set culling(t) {
    !!(this.data & 1 << mf) !== t && (this.data ^= 1 << mf);
  }
  /**
   * Activates depth comparisons and updates to the depth buffer.
   * @default false
   */
  get depthTest() {
    return !!(this.data & 1 << Ef);
  }
  set depthTest(t) {
    !!(this.data & 1 << Ef) !== t && (this.data ^= 1 << Ef);
  }
  /**
   * Enables or disables writing to the depth buffer.
   * @default true
   */
  get depthMask() {
    return !!(this.data & 1 << If);
  }
  set depthMask(t) {
    !!(this.data & 1 << If) !== t && (this.data ^= 1 << If);
  }
  /**
   * Specifies whether or not front or back-facing polygons can be culled.
   * @default false
   */
  get clockwiseFrontFace() {
    return !!(this.data & 1 << Tf);
  }
  set clockwiseFrontFace(t) {
    !!(this.data & 1 << Tf) !== t && (this.data ^= 1 << Tf);
  }
  /**
   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.
   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
   * @default 'normal'
   */
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(t) {
    this.blend = t !== "none", this._blendMode = t, this._blendModeId = nP[t] || 0;
  }
  /**
   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
   * @default 0
   */
  get polygonOffset() {
    return this._polygonOffset;
  }
  set polygonOffset(t) {
    this.offsets = !!t, this._polygonOffset = t;
  }
  toString() {
    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
  }
  /**
   * A quickly getting an instance of a State that is configured for 2d rendering.
   * @returns a new State with values set for 2d rendering
   */
  static for2d() {
    const t = new l0();
    return t.depthTest = !1, t.blend = !0, t;
  }
};
cg.default2d = cg.for2d();
let Pd = cg;
const c0 = class _g extends $o {
  /**
   * @param options - The optional parameters of this filter.
   */
  constructor(t) {
    t = { ..._g.defaultOptions, ...t }, super(t), this.enabled = !0, this._state = Pd.for2d(), this.blendMode = t.blendMode, this.padding = t.padding, typeof t.antialias == "boolean" ? this.antialias = t.antialias ? "on" : "off" : this.antialias = t.antialias, this.resolution = t.resolution, this.blendRequired = t.blendRequired, this.clipToViewport = t.clipToViewport, this.addResource("uTexture", 0, 1);
  }
  /**
   * Applies the filter
   * @param filterManager - The renderer to retrieve the filter from
   * @param input - The input render target.
   * @param output - The target to output to.
   * @param clearMode - Should the output be cleared before rendering to it
   */
  apply(t, e, s, r) {
    t.applyFilter(this, e, s, r);
  }
  /**
   * Get the blend mode of the filter.
   * @default "normal"
   */
  get blendMode() {
    return this._state.blendMode;
  }
  /** Sets the blend mode of the filter. */
  set blendMode(t) {
    this._state.blendMode = t;
  }
  /**
   * A short hand function to create a filter based of a vertex and fragment shader src.
   * @param options
   * @returns A shiny new PixiJS filter!
   */
  static from(t) {
    const { gpu: e, gl: s, ...r } = t;
    let n, a;
    return e && (n = Ot.from(e)), s && (a = It.from(s)), new _g({
      gpuProgram: n,
      glProgram: a,
      ...r
    });
  }
};
c0.defaultOptions = {
  blendMode: "normal",
  resolution: 1,
  padding: 0,
  antialias: "off",
  blendRequired: !1,
  clipToViewport: !0
};
let xt = c0;
const dg = [];
Ee.handleByNamedList(B.Environment, dg);
async function aP(i) {
  if (!i)
    for (let t = 0; t < dg.length; t++) {
      const e = dg[t];
      if (e.value.test()) {
        await e.value.load();
        return;
      }
    }
}
let ah;
function _0() {
  if (typeof ah == "boolean")
    return ah;
  try {
    ah = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({ a: "b" }, "a", "b") === !0;
  } catch {
    ah = !1;
  }
  return ah;
}
var ET = { exports: {} };
ET.exports = Nd;
ET.exports.default = Nd;
function Nd(i, t, e) {
  e = e || 2;
  var s = t && t.length, r = s ? t[0] * e : i.length, n = d0(i, 0, r, e, !0), a = [];
  if (!n || n.next === n.prev) return a;
  var o, h, u, c, l, _, d;
  if (s && (n = cP(i, t, n, e)), i.length > 80 * e) {
    o = u = i[0], h = c = i[1];
    for (var f = e; f < r; f += e)
      l = i[f], _ = i[f + 1], l < o && (o = l), _ < h && (h = _), l > u && (u = l), _ > c && (c = _);
    d = Math.max(u - o, c - h), d = d !== 0 ? 32767 / d : 0;
  }
  return _u(n, a, e, o, h, d, 0), a;
}
function d0(i, t, e, s, r) {
  var n, a;
  if (r === pg(i, t, e, s) > 0)
    for (n = t; n < e; n += s) a = gS(n, i[n], i[n + 1], a);
  else
    for (n = e - s; n >= t; n -= s) a = gS(n, i[n], i[n + 1], a);
  return a && Ud(a, a.next) && (fu(a), a = a.next), a;
}
function fa(i, t) {
  if (!i) return i;
  t || (t = i);
  var e = i, s;
  do
    if (s = !1, !e.steiner && (Ud(e, e.next) || pe(e.prev, e, e.next) === 0)) {
      if (fu(e), e = t = e.prev, e === e.next) break;
      s = !0;
    } else
      e = e.next;
  while (s || e !== t);
  return t;
}
function _u(i, t, e, s, r, n, a) {
  if (i) {
    !a && n && pP(i, s, r, n);
    for (var o = i, h, u; i.prev !== i.next; ) {
      if (h = i.prev, u = i.next, n ? hP(i, s, r, n) : oP(i)) {
        t.push(h.i / e | 0), t.push(i.i / e | 0), t.push(u.i / e | 0), fu(i), i = u.next, o = u.next;
        continue;
      }
      if (i = u, i === o) {
        a ? a === 1 ? (i = uP(fa(i), t, e), _u(i, t, e, s, r, n, 2)) : a === 2 && lP(i, t, e, s, r, n) : _u(fa(i), t, e, s, r, n, 1);
        break;
      }
    }
  }
}
function oP(i) {
  var t = i.prev, e = i, s = i.next;
  if (pe(t, e, s) >= 0) return !1;
  for (var r = t.x, n = e.x, a = s.x, o = t.y, h = e.y, u = s.y, c = r < n ? r < a ? r : a : n < a ? n : a, l = o < h ? o < u ? o : u : h < u ? h : u, _ = r > n ? r > a ? r : a : n > a ? n : a, d = o > h ? o > u ? o : u : h > u ? h : u, f = s.next; f !== t; ) {
    if (f.x >= c && f.x <= _ && f.y >= l && f.y <= d && za(r, o, n, h, a, u, f.x, f.y) && pe(f.prev, f, f.next) >= 0) return !1;
    f = f.next;
  }
  return !0;
}
function hP(i, t, e, s) {
  var r = i.prev, n = i, a = i.next;
  if (pe(r, n, a) >= 0) return !1;
  for (var o = r.x, h = n.x, u = a.x, c = r.y, l = n.y, _ = a.y, d = o < h ? o < u ? o : u : h < u ? h : u, f = c < l ? c < _ ? c : _ : l < _ ? l : _, p = o > h ? o > u ? o : u : h > u ? h : u, g = c > l ? c > _ ? c : _ : l > _ ? l : _, m = fg(d, f, t, e, s), O = fg(p, g, t, e, s), y = i.prevZ, C = i.nextZ; y && y.z >= m && C && C.z <= O; ) {
    if (y.x >= d && y.x <= p && y.y >= f && y.y <= g && y !== r && y !== a && za(o, c, h, l, u, _, y.x, y.y) && pe(y.prev, y, y.next) >= 0 || (y = y.prevZ, C.x >= d && C.x <= p && C.y >= f && C.y <= g && C !== r && C !== a && za(o, c, h, l, u, _, C.x, C.y) && pe(C.prev, C, C.next) >= 0)) return !1;
    C = C.nextZ;
  }
  for (; y && y.z >= m; ) {
    if (y.x >= d && y.x <= p && y.y >= f && y.y <= g && y !== r && y !== a && za(o, c, h, l, u, _, y.x, y.y) && pe(y.prev, y, y.next) >= 0) return !1;
    y = y.prevZ;
  }
  for (; C && C.z <= O; ) {
    if (C.x >= d && C.x <= p && C.y >= f && C.y <= g && C !== r && C !== a && za(o, c, h, l, u, _, C.x, C.y) && pe(C.prev, C, C.next) >= 0) return !1;
    C = C.nextZ;
  }
  return !0;
}
function uP(i, t, e) {
  var s = i;
  do {
    var r = s.prev, n = s.next.next;
    !Ud(r, n) && f0(r, s, s.next, n) && du(r, n) && du(n, r) && (t.push(r.i / e | 0), t.push(s.i / e | 0), t.push(n.i / e | 0), fu(s), fu(s.next), s = i = n), s = s.next;
  } while (s !== i);
  return fa(s);
}
function lP(i, t, e, s, r, n) {
  var a = i;
  do {
    for (var o = a.next.next; o !== a.prev; ) {
      if (a.i !== o.i && TP(a, o)) {
        var h = g0(a, o);
        a = fa(a, a.next), h = fa(h, h.next), _u(a, t, e, s, r, n, 0), _u(h, t, e, s, r, n, 0);
        return;
      }
      o = o.next;
    }
    a = a.next;
  } while (a !== i);
}
function cP(i, t, e, s) {
  var r = [], n, a, o, h, u;
  for (n = 0, a = t.length; n < a; n++)
    o = t[n] * s, h = n < a - 1 ? t[n + 1] * s : i.length, u = d0(i, o, h, s, !1), u === u.next && (u.steiner = !0), r.push(EP(u));
  for (r.sort(_P), n = 0; n < r.length; n++)
    e = dP(r[n], e);
  return e;
}
function _P(i, t) {
  return i.x - t.x;
}
function dP(i, t) {
  var e = fP(i, t);
  if (!e)
    return t;
  var s = g0(e, i);
  return fa(s, s.next), fa(e, e.next);
}
function fP(i, t) {
  var e = t, s = i.x, r = i.y, n = -1 / 0, a;
  do {
    if (r <= e.y && r >= e.next.y && e.next.y !== e.y) {
      var o = e.x + (r - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (o <= s && o > n && (n = o, a = e.x < e.next.x ? e : e.next, o === s))
        return a;
    }
    e = e.next;
  } while (e !== t);
  if (!a) return null;
  var h = a, u = a.x, c = a.y, l = 1 / 0, _;
  e = a;
  do
    s >= e.x && e.x >= u && s !== e.x && za(r < c ? s : n, r, u, c, r < c ? n : s, r, e.x, e.y) && (_ = Math.abs(r - e.y) / (s - e.x), du(e, i) && (_ < l || _ === l && (e.x > a.x || e.x === a.x && gP(a, e))) && (a = e, l = _)), e = e.next;
  while (e !== h);
  return a;
}
function gP(i, t) {
  return pe(i.prev, i, t.prev) < 0 && pe(t.next, i, i.next) < 0;
}
function pP(i, t, e, s) {
  var r = i;
  do
    r.z === 0 && (r.z = fg(r.x, r.y, t, e, s)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== i);
  r.prevZ.nextZ = null, r.prevZ = null, mP(r);
}
function mP(i) {
  var t, e, s, r, n, a, o, h, u = 1;
  do {
    for (e = i, i = null, n = null, a = 0; e; ) {
      for (a++, s = e, o = 0, t = 0; t < u && (o++, s = s.nextZ, !!s); t++)
        ;
      for (h = u; o > 0 || h > 0 && s; )
        o !== 0 && (h === 0 || !s || e.z <= s.z) ? (r = e, e = e.nextZ, o--) : (r = s, s = s.nextZ, h--), n ? n.nextZ = r : i = r, r.prevZ = n, n = r;
      e = s;
    }
    n.nextZ = null, u *= 2;
  } while (a > 1);
  return i;
}
function fg(i, t, e, s, r) {
  return i = (i - e) * r | 0, t = (t - s) * r | 0, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, i | t << 1;
}
function EP(i) {
  var t = i, e = i;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== i);
  return e;
}
function za(i, t, e, s, r, n, a, o) {
  return (r - a) * (t - o) >= (i - a) * (n - o) && (i - a) * (s - o) >= (e - a) * (t - o) && (e - a) * (n - o) >= (r - a) * (s - o);
}
function TP(i, t) {
  return i.next.i !== t.i && i.prev.i !== t.i && !IP(i, t) && // dones't intersect other edges
  (du(i, t) && du(t, i) && SP(i, t) && // locally visible
  (pe(i.prev, i, t.prev) || pe(i, t.prev, t)) || // does not create opposite-facing sectors
  Ud(i, t) && pe(i.prev, i, i.next) > 0 && pe(t.prev, t, t.next) > 0);
}
function pe(i, t, e) {
  return (t.y - i.y) * (e.x - t.x) - (t.x - i.x) * (e.y - t.y);
}
function Ud(i, t) {
  return i.x === t.x && i.y === t.y;
}
function f0(i, t, e, s) {
  var r = sl(pe(i, t, e)), n = sl(pe(i, t, s)), a = sl(pe(e, s, i)), o = sl(pe(e, s, t));
  return !!(r !== n && a !== o || r === 0 && el(i, e, t) || n === 0 && el(i, s, t) || a === 0 && el(e, i, s) || o === 0 && el(e, t, s));
}
function el(i, t, e) {
  return t.x <= Math.max(i.x, e.x) && t.x >= Math.min(i.x, e.x) && t.y <= Math.max(i.y, e.y) && t.y >= Math.min(i.y, e.y);
}
function sl(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function IP(i, t) {
  var e = i;
  do {
    if (e.i !== i.i && e.next.i !== i.i && e.i !== t.i && e.next.i !== t.i && f0(e, e.next, i, t)) return !0;
    e = e.next;
  } while (e !== i);
  return !1;
}
function du(i, t) {
  return pe(i.prev, i, i.next) < 0 ? pe(i, t, i.next) >= 0 && pe(i, i.prev, t) >= 0 : pe(i, t, i.prev) < 0 || pe(i, i.next, t) < 0;
}
function SP(i, t) {
  var e = i, s = !1, r = (i.x + t.x) / 2, n = (i.y + t.y) / 2;
  do
    e.y > n != e.next.y > n && e.next.y !== e.y && r < (e.next.x - e.x) * (n - e.y) / (e.next.y - e.y) + e.x && (s = !s), e = e.next;
  while (e !== i);
  return s;
}
function g0(i, t) {
  var e = new gg(i.i, i.x, i.y), s = new gg(t.i, t.x, t.y), r = i.next, n = t.prev;
  return i.next = t, t.prev = i, e.next = r, r.prev = e, s.next = e, e.prev = s, n.next = s, s.prev = n, s;
}
function gS(i, t, e, s) {
  var r = new gg(i, t, e);
  return s ? (r.next = s.next, r.prev = s, s.next.prev = r, s.next = r) : (r.prev = r, r.next = r), r;
}
function fu(i) {
  i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
}
function gg(i, t, e) {
  this.i = i, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
Nd.deviation = function(i, t, e, s) {
  var r = t && t.length, n = r ? t[0] * e : i.length, a = Math.abs(pg(i, 0, n, e));
  if (r)
    for (var o = 0, h = t.length; o < h; o++) {
      var u = t[o] * e, c = o < h - 1 ? t[o + 1] * e : i.length;
      a -= Math.abs(pg(i, u, c, e));
    }
  var l = 0;
  for (o = 0; o < s.length; o += 3) {
    var _ = s[o] * e, d = s[o + 1] * e, f = s[o + 2] * e;
    l += Math.abs(
      (i[_] - i[f]) * (i[d + 1] - i[_ + 1]) - (i[_] - i[d]) * (i[f + 1] - i[_ + 1])
    );
  }
  return a === 0 && l === 0 ? 0 : Math.abs((l - a) / a);
};
function pg(i, t, e, s) {
  for (var r = 0, n = t, a = e - s; n < e; n += s)
    r += (i[a] - i[n]) * (i[n + 1] + i[a + 1]), a = n;
  return r;
}
Nd.flatten = function(i) {
  for (var t = i[0][0].length, e = { vertices: [], holes: [], dimensions: t }, s = 0, r = 0; r < i.length; r++) {
    for (var n = 0; n < i[r].length; n++)
      for (var a = 0; a < t; a++) e.vertices.push(i[r][n][a]);
    r > 0 && (s += i[r - 1].length, e.holes.push(s));
  }
  return e;
};
var AP = ET.exports;
const RP = /* @__PURE__ */ _T(AP);
var Bi = /* @__PURE__ */ ((i) => (i[i.NONE = 0] = "NONE", i[i.COLOR = 16384] = "COLOR", i[i.STENCIL = 1024] = "STENCIL", i[i.DEPTH = 256] = "DEPTH", i[i.COLOR_DEPTH = 16640] = "COLOR_DEPTH", i[i.COLOR_STENCIL = 17408] = "COLOR_STENCIL", i[i.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL", i[i.ALL = 17664] = "ALL", i))(Bi || {});
class p0 {
  /**
   * @param name - The function name that will be executed on the listeners added to this Runner.
   */
  constructor(t) {
    this.items = [], this._name = t;
  }
  /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */
  /**
   * Dispatch/Broadcast Runner to all listeners added to the queue.
   * @param {...any} params - (optional) parameters to pass to each listener
   */
  /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */
  emit(t, e, s, r, n, a, o, h) {
    const { name: u, items: c } = this;
    for (let l = 0, _ = c.length; l < _; l++)
      c[l][u](t, e, s, r, n, a, o, h);
    return this;
  }
  /**
   * Add a listener to the Runner
   *
   * Runners do not need to have scope or functions passed to them.
   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
   * as the name provided to the Runner when it was created.
   *
   * Eg A listener passed to this Runner will require a 'complete' function.
   *
   * ```
   * import { Runner } from 'pixi.js';
   *
   * const complete = new Runner('complete');
   * ```
   *
   * The scope used will be the object itself.
   * @param {any} item - The object that will be listening.
   */
  add(t) {
    return t[this._name] && (this.remove(t), this.items.push(t)), this;
  }
  /**
   * Remove a single listener from the dispatch queue.
   * @param {any} item - The listener that you would like to remove.
   */
  remove(t) {
    const e = this.items.indexOf(t);
    return e !== -1 && this.items.splice(e, 1), this;
  }
  /**
   * Check to see if the listener is already in the Runner
   * @param {any} item - The listener that you would like to check.
   */
  contains(t) {
    return this.items.indexOf(t) !== -1;
  }
  /** Remove all listeners from the Runner */
  removeAll() {
    return this.items.length = 0, this;
  }
  /** Remove all references, don't use after this. */
  destroy() {
    this.removeAll(), this.items = null, this._name = null;
  }
  /**
   * `true` if there are no this Runner contains no listeners
   * @readonly
   */
  get empty() {
    return this.items.length === 0;
  }
  /**
   * The name of the runner.
   * @readonly
   */
  get name() {
    return this._name;
  }
}
const OP = [
  "init",
  "destroy",
  "contextChange",
  "resolutionChange",
  "reset",
  "renderEnd",
  "renderStart",
  "render",
  "update",
  "postrender",
  "prerender"
], m0 = class E0 extends Js {
  /**
   * Set up a system with a collection of SystemClasses and runners.
   * Systems are attached dynamically to this class when added.
   * @param config - the config for the system manager
   */
  constructor(t) {
    super(), this.runners = /* @__PURE__ */ Object.create(null), this.renderPipes = /* @__PURE__ */ Object.create(null), this._initOptions = {}, this._systemsHash = /* @__PURE__ */ Object.create(null), this.type = t.type, this.name = t.name, this.config = t;
    const e = [...OP, ...this.config.runners ?? []];
    this._addRunners(...e), this._unsafeEvalCheck();
  }
  /**
   * Initialize the renderer.
   * @param options - The options to use to create the renderer.
   */
  async init(t = {}) {
    const e = t.skipExtensionImports === !0 ? !0 : t.manageImports === !1;
    await aP(e), this._addSystems(this.config.systems), this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
    for (const s in this._systemsHash)
      t = { ...this._systemsHash[s].constructor.defaultOptions, ...t };
    t = { ...E0.defaultOptions, ...t }, this._roundPixels = t.roundPixels ? 1 : 0;
    for (let s = 0; s < this.runners.init.items.length; s++)
      await this.runners.init.items[s].init(t);
    this._initOptions = t;
  }
  render(t, e) {
    let s = t;
    if (s instanceof Qt && (s = { container: s }, e && (dt(Se, "passing a second argument is deprecated, please use render options instead"), s.target = e.renderTexture)), s.target || (s.target = this.view.renderTarget), s.target === this.view.renderTarget && (this._lastObjectRendered = s.container, s.clearColor = this.background.colorRgba), s.clearColor) {
      const r = Array.isArray(s.clearColor) && s.clearColor.length === 4;
      s.clearColor = r ? s.clearColor : Pt.shared.setValue(s.clearColor).toArray();
    }
    s.transform || (s.container.updateLocalTransform(), s.transform = s.container.localTransform), this.runners.prerender.emit(s), this.runners.renderStart.emit(s), this.runners.render.emit(s), this.runners.renderEnd.emit(s), this.runners.postrender.emit(s);
  }
  /**
   * Resizes the WebGL view to the specified width and height.
   * @param desiredScreenWidth - The desired width of the screen.
   * @param desiredScreenHeight - The desired height of the screen.
   * @param resolution - The resolution / device pixel ratio of the renderer.
   */
  resize(t, e, s) {
    const r = this.view.resolution;
    this.view.resize(t, e, s), this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution), s !== void 0 && s !== r && this.runners.resolutionChange.emit(s);
  }
  clear(t = {}) {
    const e = this;
    t.target || (t.target = e.renderTarget.renderTarget), t.clearColor || (t.clearColor = this.background.colorRgba), t.clear ?? (t.clear = Bi.ALL);
    const { clear: s, clearColor: r, target: n } = t;
    Pt.shared.setValue(r ?? this.background.colorRgba), e.renderTarget.clear(n, s, Pt.shared.toArray());
  }
  /** The resolution / device pixel ratio of the renderer. */
  get resolution() {
    return this.view.resolution;
  }
  set resolution(t) {
    this.view.resolution = t, this.runners.resolutionChange.emit(t);
  }
  /**
   * Same as view.width, actual number of pixels in the canvas by horizontal.
   * @member {number}
   * @readonly
   * @default 800
   */
  get width() {
    return this.view.texture.frame.width;
  }
  /**
   * Same as view.height, actual number of pixels in the canvas by vertical.
   * @default 600
   */
  get height() {
    return this.view.texture.frame.height;
  }
  // NOTE: this was `view` in v7
  /**
   * The canvas element that everything is drawn to.
   * @type {environment.ICanvas}
   */
  get canvas() {
    return this.view.canvas;
  }
  /**
   * the last object rendered by the renderer. Useful for other plugins like interaction managers
   * @readonly
   */
  get lastObjectRendered() {
    return this._lastObjectRendered;
  }
  /**
   * Flag if we are rendering to the screen vs renderTexture
   * @readonly
   * @default true
   */
  get renderingToScreen() {
    return this.renderTarget.renderingToScreen;
  }
  /**
   * Measurements of the screen. (0, 0, screenWidth, screenHeight).
   *
   * Its safe to use as filterArea or hitArea for the whole stage.
   */
  get screen() {
    return this.view.screen;
  }
  /**
   * Create a bunch of runners based of a collection of ids
   * @param runnerIds - the runner ids to add
   */
  _addRunners(...t) {
    t.forEach((e) => {
      this.runners[e] = new p0(e);
    });
  }
  _addSystems(t) {
    let e;
    for (e in t) {
      const s = t[e];
      this._addSystem(s.value, s.name);
    }
  }
  /**
   * Add a new system to the renderer.
   * @param ClassRef - Class reference
   * @param name - Property name for system, if not specified
   *        will use a static `name` property on the class itself. This
   *        name will be assigned as s property on the Renderer so make
   *        sure it doesn't collide with properties on Renderer.
   * @returns Return instance of renderer
   */
  _addSystem(t, e) {
    const s = new t(this);
    if (this[e])
      throw new Error(`Whoops! The name "${e}" is already in use`);
    this[e] = s, this._systemsHash[e] = s;
    for (const r in this.runners)
      this.runners[r].add(s);
    return this;
  }
  _addPipes(t, e) {
    const s = e.reduce((r, n) => (r[n.name] = n.value, r), {});
    t.forEach((r) => {
      const n = r.value, a = r.name, o = s[a];
      this.renderPipes[a] = new n(
        this,
        o ? new o() : null
      );
    });
  }
  destroy(t = !1) {
    this.runners.destroy.items.reverse(), this.runners.destroy.emit(t), Object.values(this.runners).forEach((e) => {
      e.destroy();
    }), this._systemsHash = null, this.renderPipes = null;
  }
  /**
   * Generate a texture from a container.
   * @param options - options or container target to use when generating the texture
   * @returns a texture
   */
  generateTexture(t) {
    return this.textureGenerator.generateTexture(t);
  }
  /**
   * Whether the renderer will round coordinates to whole pixels when rendering.
   * Can be overridden on a per scene item basis.
   */
  get roundPixels() {
    return !!this._roundPixels;
  }
  /**
   * Overridable function by `pixi.js/unsafe-eval` to silence
   * throwing an error if platform doesn't support unsafe-evals.
   * @private
   * @ignore
   */
  _unsafeEvalCheck() {
    if (!_0())
      throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
  }
};
m0.defaultOptions = {
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @default 1
   */
  resolution: 1,
  /**
   * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`
   * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be
   * performance issues when using WebGL.
   *
   * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many
   * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or
   * driver version blacklisted by the
   * browser.
   *
   * If your application requires high performance rendering, you may wish to set this to false.
   * We recommend one of two options if you decide to set this flag to false:
   *
   * 1: Use the Canvas renderer as a fallback in case high performance WebGL is
   *    not supported.
   *
   * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a
   *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their
   *    device & browser combination does not support high performance WebGL.
   *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.
   * @default false
   */
  failIfMajorPerformanceCaveat: !1,
  /**
   * Should round pixels be forced when rendering?
   * @default false
   */
  roundPixels: !1
};
let TT = m0, il;
function yP(i) {
  return il !== void 0 || (il = (() => {
    var e;
    const t = {
      stencil: !0,
      failIfMajorPerformanceCaveat: i ?? TT.defaultOptions.failIfMajorPerformanceCaveat
    };
    try {
      if (!Wt.get().getWebGLRenderingContext())
        return !1;
      let r = Wt.get().createCanvas().getContext("webgl", t);
      const n = !!((e = r == null ? void 0 : r.getContextAttributes()) != null && e.stencil);
      if (r) {
        const a = r.getExtension("WEBGL_lose_context");
        a && a.loseContext();
      }
      return r = null, n;
    } catch {
      return !1;
    }
  })()), il;
}
let rl;
async function vP(i = {}) {
  return rl !== void 0 || (rl = await (async () => {
    const t = Wt.get().getNavigator().gpu;
    if (!t)
      return !1;
    try {
      return await (await t.requestAdapter(i)).requestDevice(), !0;
    } catch {
      return !1;
    }
  })()), rl;
}
const pS = ["webgl", "webgpu", "canvas"];
async function T0(i) {
  let t = [];
  i.preference ? (t.push(i.preference), pS.forEach((n) => {
    n !== i.preference && t.push(n);
  })) : t = pS.slice();
  let e, s = {};
  for (let n = 0; n < t.length; n++) {
    const a = t[n];
    if (a === "webgpu" && await vP()) {
      const { WebGPURenderer: o } = await Promise.resolve().then(() => y1);
      e = o, s = { ...i, ...i.webgpu };
      break;
    } else if (a === "webgl" && yP(
      i.failIfMajorPerformanceCaveat ?? TT.defaultOptions.failIfMajorPerformanceCaveat
    )) {
      const { WebGLRenderer: o } = await import("./WebGLRenderer-BgDoi40n.js");
      e = o, s = { ...i, ...i.webgl };
      break;
    } else if (a === "canvas")
      throw s = { ...i }, new Error("CanvasRenderer is not yet implemented");
  }
  if (delete s.webgpu, delete s.webgl, !e)
    throw new Error("No available renderer for the current environment");
  const r = new e();
  return await r.init(s), r;
}
const zl = "8.5.1";
class I0 {
  static init() {
    var t;
    (t = globalThis.__PIXI_APP_INIT__) == null || t.call(globalThis, this, zl);
  }
  static destroy() {
  }
}
I0.extension = B.Application;
class S0 {
  constructor(t) {
    this._renderer = t;
  }
  init() {
    var t;
    (t = globalThis.__PIXI_RENDERER_INIT__) == null || t.call(globalThis, this._renderer, zl);
  }
  destroy() {
    this._renderer = null;
  }
}
S0.extension = {
  type: [
    B.WebGLSystem,
    B.WebGPUSystem
  ],
  name: "initHook",
  priority: -10
};
const A0 = class mg {
  /** @ignore */
  constructor(...t) {
    this.stage = new Qt(), t[0] !== void 0 && dt(Se, "Application constructor options are deprecated, please use Application.init() instead.");
  }
  /**
   * @param options - The optional application and renderer parameters.
   */
  async init(t) {
    t = { ...t }, this.renderer = await T0(t), mg._plugins.forEach((e) => {
      e.init.call(this, t);
    });
  }
  /** Render the current stage. */
  render() {
    this.renderer.render({ container: this.stage });
  }
  /**
   * Reference to the renderer's canvas element.
   * @readonly
   * @member {HTMLCanvasElement}
   */
  get canvas() {
    return this.renderer.canvas;
  }
  /**
   * Reference to the renderer's canvas element.
   * @member {HTMLCanvasElement}
   * @deprecated since 8.0.0
   */
  get view() {
    return dt(Se, "Application.view is deprecated, please use Application.canvas instead."), this.renderer.canvas;
  }
  /**
   * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
   * @readonly
   */
  get screen() {
    return this.renderer.screen;
  }
  /**
   * Destroys the application and all of its resources.
   * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.
   * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.
   * @param {object|boolean} [options=false] - The options for destroying the stage.
   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method
   * called as well. `options` will be passed on to those calls.
   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.
   * If options.children is set to true,
   * it should destroy the texture of the child sprite.
   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
   *  If options.children is set to true,
   * it should destroy the texture source of the child sprite.
   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
   * If options.children is set to true,
   * it should destroy the context of the child graphics.
   */
  destroy(t = !1, e = !1) {
    const s = mg._plugins.slice(0);
    s.reverse(), s.forEach((r) => {
      r.destroy.call(this);
    }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null;
  }
};
A0._plugins = [];
let R0 = A0;
Ee.handleByList(B.Application, R0._plugins);
Ee.add(I0);
class O0 extends Js {
  constructor() {
    super(...arguments), this.chars = /* @__PURE__ */ Object.create(null), this.lineHeight = 0, this.fontFamily = "", this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 }, this.baseLineOffset = 0, this.distanceField = { type: "none", range: 0 }, this.pages = [], this.applyFillAsTint = !0, this.baseMeasurementFontSize = 100, this.baseRenderedFontSize = 100;
  }
  /**
   * The name of the font face.
   * @deprecated since 8.0.0 Use `fontFamily` instead.
   */
  get font() {
    return dt(Se, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."), this.fontFamily;
  }
  /**
   * The map of base page textures (i.e., sheets of glyphs).
   * @deprecated since 8.0.0 Use `pages` instead.
   */
  get pageTextures() {
    return dt(Se, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages;
  }
  /**
   * The size of the font face in pixels.
   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.
   */
  get size() {
    return dt(Se, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."), this.fontMetrics.fontSize;
  }
  /**
   * The kind of distance field for this font or "none".
   * @deprecated since 8.0.0 Use `distanceField.type` instead.
   */
  get distanceFieldRange() {
    return dt(Se, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."), this.distanceField.range;
  }
  /**
   * The range of the distance field in pixels.
   * @deprecated since 8.0.0 Use `distanceField.range` instead.
   */
  get distanceFieldType() {
    return dt(Se, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."), this.distanceField.type;
  }
  destroy(t = !1) {
    var e;
    this.emit("destroy", this), this.removeAllListeners();
    for (const s in this.chars)
      (e = this.chars[s].texture) == null || e.destroy();
    this.chars = null, t && (this.pages.forEach((s) => s.texture.destroy(!0)), this.pages = null);
  }
}
const y0 = class Eg {
  constructor(t, e, s, r) {
    this.uid = me("fillGradient"), this.type = "linear", this.gradientStops = [], this._styleKey = null, this.x0 = t, this.y0 = e, this.x1 = s, this.y1 = r;
  }
  addColorStop(t, e) {
    return this.gradientStops.push({ offset: t, color: Pt.shared.setValue(e).toHexa() }), this._styleKey = null, this;
  }
  // TODO move to the system!
  buildLinearGradient() {
    const t = Eg.defaultTextureSize, { gradientStops: e } = this, s = Wt.get().createCanvas();
    s.width = t, s.height = t;
    const r = s.getContext("2d"), n = r.createLinearGradient(0, 0, Eg.defaultTextureSize, 1);
    for (let p = 0; p < e.length; p++) {
      const g = e[p];
      n.addColorStop(g.offset, g.color);
    }
    r.fillStyle = n, r.fillRect(0, 0, t, t), this.texture = new W({
      source: new Ra({
        resource: s,
        addressModeU: "clamp-to-edge",
        addressModeV: "repeat"
      })
    });
    const { x0: a, y0: o, x1: h, y1: u } = this, c = new ot(), l = h - a, _ = u - o, d = Math.sqrt(l * l + _ * _), f = Math.atan2(_, l);
    c.translate(-a, -o), c.scale(1 / t, 1 / t), c.rotate(-f), c.scale(256 / d, 1), this.transform = c, this._styleKey = null;
  }
  get styleKey() {
    if (this._styleKey)
      return this._styleKey;
    const t = this.gradientStops.map((r) => `${r.offset}-${r.color}`).join("-"), e = this.texture.uid, s = this.transform.toArray().join("-");
    return `fill-gradient-${this.uid}-${t}-${e}-${s}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`;
  }
};
y0.defaultTextureSize = 256;
let gu = y0;
const mS = {
  repeat: {
    addressModeU: "repeat",
    addressModeV: "repeat"
  },
  "repeat-x": {
    addressModeU: "repeat",
    addressModeV: "clamp-to-edge"
  },
  "repeat-y": {
    addressModeU: "clamp-to-edge",
    addressModeV: "repeat"
  },
  "no-repeat": {
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge"
  }
};
class Dd {
  constructor(t, e) {
    this.uid = me("fillPattern"), this.transform = new ot(), this._styleKey = null, this.texture = t, this.transform.scale(
      1 / t.frame.width,
      1 / t.frame.height
    ), e && (t.source.style.addressModeU = mS[e].addressModeU, t.source.style.addressModeV = mS[e].addressModeV);
  }
  setTransform(t) {
    const e = this.texture;
    this.transform.copyFrom(t), this.transform.invert(), this.transform.scale(
      1 / e.frame.width,
      1 / e.frame.height
    ), this._styleKey = null;
  }
  get styleKey() {
    return this._styleKey ? this._styleKey : (this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`, this._styleKey);
  }
}
var CP = MP, Sf = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, xP = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
function MP(i) {
  var t = [];
  return i.replace(xP, function(e, s, r) {
    var n = s.toLowerCase();
    for (r = PP(r), n == "m" && r.length > 2 && (t.push([s].concat(r.splice(0, 2))), n = "l", s = s == "m" ? "l" : "L"); ; ) {
      if (r.length == Sf[n])
        return r.unshift(s), t.push(r);
      if (r.length < Sf[n]) throw new Error("malformed path data");
      t.push([s].concat(r.splice(0, Sf[n])));
    }
  }), t;
}
var bP = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
function PP(i) {
  var t = i.match(bP);
  return t ? t.map(Number) : [];
}
const NP = /* @__PURE__ */ _T(CP);
function UP(i, t) {
  const e = NP(i), s = [];
  let r = null, n = 0, a = 0;
  for (let o = 0; o < e.length; o++) {
    const h = e[o], u = h[0], c = h;
    switch (u) {
      case "M":
        n = c[1], a = c[2], t.moveTo(n, a);
        break;
      case "m":
        n += c[1], a += c[2], t.moveTo(n, a);
        break;
      case "H":
        n = c[1], t.lineTo(n, a);
        break;
      case "h":
        n += c[1], t.lineTo(n, a);
        break;
      case "V":
        a = c[1], t.lineTo(n, a);
        break;
      case "v":
        a += c[1], t.lineTo(n, a);
        break;
      case "L":
        n = c[1], a = c[2], t.lineTo(n, a);
        break;
      case "l":
        n += c[1], a += c[2], t.lineTo(n, a);
        break;
      case "C":
        n = c[5], a = c[6], t.bezierCurveTo(
          c[1],
          c[2],
          c[3],
          c[4],
          n,
          a
        );
        break;
      case "c":
        t.bezierCurveTo(
          n + c[1],
          a + c[2],
          n + c[3],
          a + c[4],
          n + c[5],
          a + c[6]
        ), n += c[5], a += c[6];
        break;
      case "S":
        n = c[3], a = c[4], t.bezierCurveToShort(
          c[1],
          c[2],
          n,
          a
        );
        break;
      case "s":
        t.bezierCurveToShort(
          n + c[1],
          a + c[2],
          n + c[3],
          a + c[4]
        ), n += c[3], a += c[4];
        break;
      case "Q":
        n = c[3], a = c[4], t.quadraticCurveTo(
          c[1],
          c[2],
          n,
          a
        );
        break;
      case "q":
        t.quadraticCurveTo(
          n + c[1],
          a + c[2],
          n + c[3],
          a + c[4]
        ), n += c[3], a += c[4];
        break;
      case "T":
        n = c[1], a = c[2], t.quadraticCurveToShort(
          n,
          a
        );
        break;
      case "t":
        n += c[1], a += c[2], t.quadraticCurveToShort(
          n,
          a
        );
        break;
      case "A":
        n = c[6], a = c[7], t.arcToSvg(
          c[1],
          c[2],
          c[3],
          c[4],
          c[5],
          n,
          a
        );
        break;
      case "a":
        n += c[6], a += c[7], t.arcToSvg(
          c[1],
          c[2],
          c[3],
          c[4],
          c[5],
          n,
          a
        );
        break;
      case "Z":
      case "z":
        t.closePath(), s.length > 0 && (r = s.pop(), r ? (n = r.startX, a = r.startY) : (n = 0, a = 0)), r = null;
        break;
      default:
        ce(`Unknown SVG path command: ${u}`);
    }
    u !== "Z" && u !== "z" && r === null && (r = { startX: n, startY: a }, s.push(r));
  }
  return t;
}
class IT {
  /**
   * @param x - The X coordinate of the center of this circle
   * @param y - The Y coordinate of the center of this circle
   * @param radius - The radius of the circle
   */
  constructor(t = 0, e = 0, s = 0) {
    this.type = "circle", this.x = t, this.y = e, this.radius = s;
  }
  /**
   * Creates a clone of this Circle instance
   * @returns A copy of the Circle
   */
  clone() {
    return new IT(this.x, this.y, this.radius);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Circle
   */
  contains(t, e) {
    if (this.radius <= 0)
      return !1;
    const s = this.radius * this.radius;
    let r = this.x - t, n = this.y - e;
    return r *= r, n *= n, r + n <= s;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle including the stroke.
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param width - The width of the line to check
   * @returns Whether the x/y coordinates are within this Circle
   */
  strokeContains(t, e, s) {
    if (this.radius === 0)
      return !1;
    const r = this.x - t, n = this.y - e, a = this.radius, o = s / 2, h = Math.sqrt(r * r + n * n);
    return h < a + o && h > a - o;
  }
  /**
   * Returns the framing rectangle of the circle as a Rectangle object
   * @param out
   * @returns The framing rectangle
   */
  getBounds(t) {
    return t = t || new Kt(), t.x = this.x - this.radius, t.y = this.y - this.radius, t.width = this.radius * 2, t.height = this.radius * 2, t;
  }
  /**
   * Copies another circle to this one.
   * @param circle - The circle to copy from.
   * @returns Returns itself.
   */
  copyFrom(t) {
    return this.x = t.x, this.y = t.y, this.radius = t.radius, this;
  }
  /**
   * Copies this circle to another one.
   * @param circle - The circle to copy to.
   * @returns Returns given parameter.
   */
  copyTo(t) {
    return t.copyFrom(this), t;
  }
  toString() {
    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
  }
}
class ST {
  /**
   * @param x - The X coordinate of the center of this ellipse
   * @param y - The Y coordinate of the center of this ellipse
   * @param halfWidth - The half width of this ellipse
   * @param halfHeight - The half height of this ellipse
   */
  constructor(t = 0, e = 0, s = 0, r = 0) {
    this.type = "ellipse", this.x = t, this.y = e, this.halfWidth = s, this.halfHeight = r;
  }
  /**
   * Creates a clone of this Ellipse instance
   * @returns {Ellipse} A copy of the ellipse
   */
  clone() {
    return new ST(this.x, this.y, this.halfWidth, this.halfHeight);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coords are within this ellipse
   */
  contains(t, e) {
    if (this.halfWidth <= 0 || this.halfHeight <= 0)
      return !1;
    let s = (t - this.x) / this.halfWidth, r = (e - this.y) / this.halfHeight;
    return s *= s, r *= r, s + r <= 1;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse including stroke
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param width
   * @returns Whether the x/y coords are within this ellipse
   */
  strokeContains(t, e, s) {
    const { halfWidth: r, halfHeight: n } = this;
    if (r <= 0 || n <= 0)
      return !1;
    const a = s / 2, o = r - a, h = n - a, u = r + a, c = n + a, l = t - this.x, _ = e - this.y, d = l * l / (o * o) + _ * _ / (h * h), f = l * l / (u * u) + _ * _ / (c * c);
    return d > 1 && f <= 1;
  }
  /**
   * Returns the framing rectangle of the ellipse as a Rectangle object
   * @param out
   * @returns The framing rectangle
   */
  getBounds(t) {
    return t = t || new Kt(), t.x = this.x - this.halfWidth, t.y = this.y - this.halfHeight, t.width = this.halfWidth * 2, t.height = this.halfHeight * 2, t;
  }
  /**
   * Copies another ellipse to this one.
   * @param ellipse - The ellipse to copy from.
   * @returns Returns itself.
   */
  copyFrom(t) {
    return this.x = t.x, this.y = t.y, this.halfWidth = t.halfWidth, this.halfHeight = t.halfHeight, this;
  }
  /**
   * Copies this ellipse to another one.
   * @param ellipse - The ellipse to copy to.
   * @returns Returns given parameter.
   */
  copyTo(t) {
    return t.copyFrom(this), t;
  }
  toString() {
    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
  }
}
function DP(i, t, e, s, r, n) {
  const a = i - e, o = t - s, h = r - e, u = n - s, c = a * h + o * u, l = h * h + u * u;
  let _ = -1;
  l !== 0 && (_ = c / l);
  let d, f;
  _ < 0 ? (d = e, f = s) : _ > 1 ? (d = r, f = n) : (d = e + _ * h, f = s + _ * u);
  const p = i - d, g = t - f;
  return p * p + g * g;
}
class Th {
  /**
   * @param points - This can be an array of Points
   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
   *  the arguments passed can be all the points of the polygon e.g.
   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
   */
  constructor(...t) {
    this.type = "polygon";
    let e = Array.isArray(t[0]) ? t[0] : t;
    if (typeof e[0] != "number") {
      const s = [];
      for (let r = 0, n = e.length; r < n; r++)
        s.push(e[r].x, e[r].y);
      e = s;
    }
    this.points = e, this.closePath = !0;
  }
  /**
   * Creates a clone of this polygon.
   * @returns - A copy of the polygon.
   */
  clone() {
    const t = this.points.slice(), e = new Th(t);
    return e.closePath = this.closePath, e;
  }
  /**
   * Checks whether the x and y coordinates passed to this function are contained within this polygon.
   * @param x - The X coordinate of the point to test.
   * @param y - The Y coordinate of the point to test.
   * @returns - Whether the x/y coordinates are within this polygon.
   */
  contains(t, e) {
    let s = !1;
    const r = this.points.length / 2;
    for (let n = 0, a = r - 1; n < r; a = n++) {
      const o = this.points[n * 2], h = this.points[n * 2 + 1], u = this.points[a * 2], c = this.points[a * 2 + 1];
      h > e != c > e && t < (u - o) * ((e - h) / (c - h)) + o && (s = !s);
    }
    return s;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @returns Whether the x/y coordinates are within this polygon
   */
  strokeContains(t, e, s) {
    const r = s / 2, n = r * r, { points: a } = this, o = a.length - (this.closePath ? 0 : 2);
    for (let h = 0; h < o; h += 2) {
      const u = a[h], c = a[h + 1], l = a[(h + 2) % a.length], _ = a[(h + 3) % a.length];
      if (DP(t, e, u, c, l, _) <= n)
        return !0;
    }
    return !1;
  }
  /**
   * Returns the framing rectangle of the polygon as a Rectangle object
   * @param out - optional rectangle to store the result
   * @returns The framing rectangle
   */
  getBounds(t) {
    t = t || new Kt();
    const e = this.points;
    let s = 1 / 0, r = -1 / 0, n = 1 / 0, a = -1 / 0;
    for (let o = 0, h = e.length; o < h; o += 2) {
      const u = e[o], c = e[o + 1];
      s = u < s ? u : s, r = u > r ? u : r, n = c < n ? c : n, a = c > a ? c : a;
    }
    return t.x = s, t.width = r - s, t.y = n, t.height = a - n, t;
  }
  /**
   * Copies another polygon to this one.
   * @param polygon - The polygon to copy from.
   * @returns Returns itself.
   */
  copyFrom(t) {
    return this.points = t.points.slice(), this.closePath = t.closePath, this;
  }
  /**
   * Copies this polygon to another one.
   * @param polygon - The polygon to copy to.
   * @returns Returns given parameter.
   */
  copyTo(t) {
    return t.copyFrom(this), t;
  }
  toString() {
    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((t, e) => `${t}, ${e}`, "")}]`;
  }
  /**
   * Get the last X coordinate of the polygon
   * @readonly
   */
  get lastX() {
    return this.points[this.points.length - 2];
  }
  /**
   * Get the last Y coordinate of the polygon
   * @readonly
   */
  get lastY() {
    return this.points[this.points.length - 1];
  }
  /**
   * Get the first X coordinate of the polygon
   * @readonly
   */
  get x() {
    return this.points[this.points.length - 2];
  }
  /**
   * Get the first Y coordinate of the polygon
   * @readonly
   */
  get y() {
    return this.points[this.points.length - 1];
  }
}
const nl = (i, t, e, s, r, n) => {
  const a = i - e, o = t - s, h = Math.sqrt(a * a + o * o);
  return h >= r - n && h <= r + n;
};
class AT {
  /**
   * @param x - The X coordinate of the upper-left corner of the rounded rectangle
   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
   * @param width - The overall width of this rounded rectangle
   * @param height - The overall height of this rounded rectangle
   * @param radius - Controls the radius of the rounded corners
   */
  constructor(t = 0, e = 0, s = 0, r = 0, n = 20) {
    this.type = "roundedRectangle", this.x = t, this.y = e, this.width = s, this.height = r, this.radius = n;
  }
  /**
   * Returns the framing rectangle of the rounded rectangle as a Rectangle object
   * @param out - optional rectangle to store the result
   * @returns The framing rectangle
   */
  getBounds(t) {
    return t = t || new Kt(), t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t;
  }
  /**
   * Creates a clone of this Rounded Rectangle.
   * @returns - A copy of the rounded rectangle.
   */
  clone() {
    return new AT(this.x, this.y, this.width, this.height, this.radius);
  }
  /**
   * Copies another rectangle to this one.
   * @param rectangle - The rectangle to copy from.
   * @returns Returns itself.
   */
  copyFrom(t) {
    return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
  }
  /**
   * Copies this rectangle to another one.
   * @param rectangle - The rectangle to copy to.
   * @returns Returns given parameter.
   */
  copyTo(t) {
    return t.copyFrom(this), t;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
   * @param x - The X coordinate of the point to test.
   * @param y - The Y coordinate of the point to test.
   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.
   */
  contains(t, e) {
    if (this.width <= 0 || this.height <= 0)
      return !1;
    if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
      const s = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
      if (e >= this.y + s && e <= this.y + this.height - s || t >= this.x + s && t <= this.x + this.width - s)
        return !0;
      let r = t - (this.x + s), n = e - (this.y + s);
      const a = s * s;
      if (r * r + n * n <= a || (r = t - (this.x + this.width - s), r * r + n * n <= a) || (n = e - (this.y + this.height - s), r * r + n * n <= a) || (r = t - (this.x + s), r * r + n * n <= a))
        return !0;
    }
    return !1;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @param pX - The X coordinate of the point to test
   * @param pY - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @returns Whether the x/y coordinates are within this rectangle
   */
  strokeContains(t, e, s) {
    const { x: r, y: n, width: a, height: o, radius: h } = this, u = s / 2, c = r + h, l = n + h, _ = a - h * 2, d = o - h * 2, f = r + a, p = n + o;
    return (t >= r - u && t <= r + u || t >= f - u && t <= f + u) && e >= l && e <= l + d || (e >= n - u && e <= n + u || e >= p - u && e <= p + u) && t >= c && t <= c + _ ? !0 : (
      // Top-left
      t < c && e < l && nl(t, e, c, l, h, u) || t > f - h && e < l && nl(t, e, f - h, l, h, u) || t > f - h && e > p - h && nl(t, e, f - h, p - h, h, u) || t < c && e > p - h && nl(t, e, c, p - h, h, u)
    );
  }
  toString() {
    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
  }
}
const LP = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join(`
`);
function FP(i) {
  let t = "";
  for (let e = 0; e < i; ++e)
    e > 0 && (t += `
else `), e < i - 1 && (t += `if(test == ${e}.0){}`);
  return t;
}
function wP(i, t) {
  if (i === 0)
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  const e = t.createShader(t.FRAGMENT_SHADER);
  try {
    for (; ; ) {
      const s = LP.replace(/%forloop%/gi, FP(i));
      if (t.shaderSource(e, s), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS))
        i = i / 2 | 0;
      else
        break;
    }
  } finally {
    t.deleteShader(e);
  }
  return i;
}
let ba = null;
function RT() {
  var t;
  if (ba)
    return ba;
  const i = n0();
  return ba = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS), ba = wP(
    ba,
    i
  ), (t = i.getExtension("WEBGL_lose_context")) == null || t.loseContext(), ba;
}
const v0 = {};
function OT(i, t) {
  let e = 2166136261;
  for (let s = 0; s < t; s++)
    e ^= i[s].uid, e = Math.imul(e, 16777619), e >>>= 0;
  return v0[e] || GP(i, t, e);
}
let Af = 0;
function GP(i, t, e) {
  const s = {};
  let r = 0;
  Af || (Af = RT());
  for (let a = 0; a < Af; a++) {
    const o = a < t ? i[a] : W.EMPTY.source;
    s[r++] = o.source, s[r++] = o.style;
  }
  const n = new la(s);
  return v0[e] = n, n;
}
class ES {
  constructor(t) {
    typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData), this.size = this.rawBinaryData.byteLength;
  }
  /** View on the raw binary data as a `Int8Array`. */
  get int8View() {
    return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
  }
  /** View on the raw binary data as a `Uint8Array`. */
  get uint8View() {
    return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
  }
  /**  View on the raw binary data as a `Int16Array`. */
  get int16View() {
    return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
  }
  /** View on the raw binary data as a `Int32Array`. */
  get int32View() {
    return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
  }
  /** View on the raw binary data as a `Float64Array`. */
  get float64View() {
    return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)), this._float64Array;
  }
  /** View on the raw binary data as a `BigUint64Array`. */
  get bigUint64View() {
    return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)), this._bigUint64Array;
  }
  /**
   * Returns the view of the given type.
   * @param type - One of `int8`, `uint8`, `int16`,
   *    `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - typed array of given type
   */
  view(t) {
    return this[`${t}View`];
  }
  /** Destroys all buffer references. Do not use after calling this. */
  destroy() {
    this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this.uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
  }
  /**
   * Returns the size of the given type in bytes.
   * @param type - One of `int8`, `uint8`, `int16`,
   *   `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - size of the type in bytes
   */
  static sizeOf(t) {
    switch (t) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(`${t} isn't a valid view type`);
    }
  }
}
function Tg(i, t) {
  const e = i.byteLength / 8 | 0, s = new Float64Array(i, 0, e);
  new Float64Array(t, 0, e).set(s);
  const n = i.byteLength - e * 8;
  if (n > 0) {
    const a = new Uint8Array(i, e * 8, n);
    new Uint8Array(t, e * 8, n).set(a);
  }
}
const BP = {
  normal: "normal-npm",
  add: "add-npm",
  screen: "screen-npm"
};
var Xe = /* @__PURE__ */ ((i) => (i[i.DISABLED = 0] = "DISABLED", i[i.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD", i[i.MASK_ACTIVE = 2] = "MASK_ACTIVE", i[i.INVERSE_MASK_ACTIVE = 3] = "INVERSE_MASK_ACTIVE", i[i.RENDERING_MASK_REMOVE = 4] = "RENDERING_MASK_REMOVE", i[i.NONE = 5] = "NONE", i))(Xe || {});
function TS(i, t) {
  return t.alphaMode === "no-premultiply-alpha" && BP[i] || i;
}
class kP {
  constructor() {
    this.ids = /* @__PURE__ */ Object.create(null), this.textures = [], this.count = 0;
  }
  /** Clear the textures and their locations. */
  clear() {
    for (let t = 0; t < this.count; t++) {
      const e = this.textures[t];
      this.textures[t] = null, this.ids[e.uid] = null;
    }
    this.count = 0;
  }
}
class zP {
  constructor() {
    this.renderPipeId = "batch", this.action = "startBatch", this.start = 0, this.size = 0, this.textures = new kP(), this.blendMode = "normal", this.canBundle = !0;
  }
  destroy() {
    this.textures = null, this.gpuBindGroup = null, this.bindGroup = null, this.batcher = null;
  }
}
const C0 = [];
let Ig = 0;
function IS() {
  return Ig > 0 ? C0[--Ig] : new zP();
}
function SS(i) {
  C0[Ig++] = i;
}
let oh = 0;
const x0 = class Il {
  constructor(t = {}) {
    this.uid = me("batcher"), this.dirty = !0, this.batchIndex = 0, this.batches = [], this._elements = [], Il.defaultOptions.maxTextures = Il.defaultOptions.maxTextures ?? RT(), t = { ...Il.defaultOptions, ...t };
    const { maxTextures: e, attributesInitialSize: s, indicesInitialSize: r } = t;
    this.attributeBuffer = new ES(s * 4), this.indexBuffer = new Uint16Array(r), this.maxTextures = e;
  }
  begin() {
    this.elementSize = 0, this.elementStart = 0, this.indexSize = 0, this.attributeSize = 0;
    for (let t = 0; t < this.batchIndex; t++)
      SS(this.batches[t]);
    this.batchIndex = 0, this._batchIndexStart = 0, this._batchIndexSize = 0, this.dirty = !0;
  }
  add(t) {
    this._elements[this.elementSize++] = t, t._indexStart = this.indexSize, t._attributeStart = this.attributeSize, t._batcher = this, this.indexSize += t.indexSize, this.attributeSize += t.attributeSize * this.vertexSize;
  }
  checkAndUpdateTexture(t, e) {
    const s = t._batch.textures.ids[e._source.uid];
    return !s && s !== 0 ? !1 : (t._textureId = s, t.texture = e, !0);
  }
  updateElement(t) {
    this.dirty = !0;
    const e = this.attributeBuffer;
    t.packAsQuad ? this.packQuadAttributes(
      t,
      e.float32View,
      e.uint32View,
      t._attributeStart,
      t._textureId
    ) : this.packAttributes(
      t,
      e.float32View,
      e.uint32View,
      t._attributeStart,
      t._textureId
    );
  }
  /**
   * breaks the batcher. This happens when a batch gets too big,
   * or we need to switch to a different type of rendering (a filter for example)
   * @param instructionSet
   */
  break(t) {
    const e = this._elements;
    if (!e[this.elementStart])
      return;
    let s = IS(), r = s.textures;
    r.clear();
    const n = e[this.elementStart];
    let a = TS(n.blendMode, n.texture._source);
    this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4), this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize);
    const o = this.attributeBuffer.float32View, h = this.attributeBuffer.uint32View, u = this.indexBuffer;
    let c = this._batchIndexSize, l = this._batchIndexStart, _ = "startBatch";
    const d = this.maxTextures;
    for (let f = this.elementStart; f < this.elementSize; ++f) {
      const p = e[f];
      e[f] = null;
      const m = p.texture._source, O = TS(p.blendMode, m), y = a !== O;
      if (m._batchTick === oh && !y) {
        p._textureId = m._textureBindLocation, c += p.indexSize, p.packAsQuad ? (this.packQuadAttributes(
          p,
          o,
          h,
          p._attributeStart,
          p._textureId
        ), this.packQuadIndex(
          u,
          p._indexStart,
          p._attributeStart / this.vertexSize
        )) : (this.packAttributes(
          p,
          o,
          h,
          p._attributeStart,
          p._textureId
        ), this.packIndex(
          p,
          u,
          p._indexStart,
          p._attributeStart / this.vertexSize
        )), p._batch = s;
        continue;
      }
      m._batchTick = oh, (r.count >= d || y) && (this._finishBatch(
        s,
        l,
        c - l,
        r,
        a,
        t,
        _
      ), _ = "renderBatch", l = c, a = O, s = IS(), r = s.textures, r.clear(), ++oh), p._textureId = m._textureBindLocation = r.count, r.ids[m.uid] = r.count, r.textures[r.count++] = m, p._batch = s, c += p.indexSize, p.packAsQuad ? (this.packQuadAttributes(
        p,
        o,
        h,
        p._attributeStart,
        p._textureId
      ), this.packQuadIndex(
        u,
        p._indexStart,
        p._attributeStart / this.vertexSize
      )) : (this.packAttributes(
        p,
        o,
        h,
        p._attributeStart,
        p._textureId
      ), this.packIndex(
        p,
        u,
        p._indexStart,
        p._attributeStart / this.vertexSize
      ));
    }
    r.count > 0 && (this._finishBatch(
      s,
      l,
      c - l,
      r,
      a,
      t,
      _
    ), l = c, ++oh), this.elementStart = this.elementSize, this._batchIndexStart = l, this._batchIndexSize = c;
  }
  _finishBatch(t, e, s, r, n, a, o) {
    t.gpuBindGroup = null, t.bindGroup = null, t.action = o, t.batcher = this, t.textures = r, t.blendMode = n, t.start = e, t.size = s, ++oh, this.batches[this.batchIndex++] = t, a.add(t);
  }
  finish(t) {
    this.break(t);
  }
  /**
   * Resizes the attribute buffer to the given size (1 = 1 float32)
   * @param size - the size in vertices to ensure (not bytes!)
   */
  ensureAttributeBuffer(t) {
    t * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(t * 4);
  }
  /**
   * Resizes the index buffer to the given size (1 = 1 float32)
   * @param size - the size in vertices to ensure (not bytes!)
   */
  ensureIndexBuffer(t) {
    t <= this.indexBuffer.length || this._resizeIndexBuffer(t);
  }
  _resizeAttributeBuffer(t) {
    const e = Math.max(t, this.attributeBuffer.size * 2), s = new ES(e);
    Tg(this.attributeBuffer.rawBinaryData, s.rawBinaryData), this.attributeBuffer = s;
  }
  _resizeIndexBuffer(t) {
    const e = this.indexBuffer;
    let s = Math.max(t, e.length * 1.5);
    s += s % 2;
    const r = s > 65535 ? new Uint32Array(s) : new Uint16Array(s);
    if (r.BYTES_PER_ELEMENT !== e.BYTES_PER_ELEMENT)
      for (let n = 0; n < e.length; n++)
        r[n] = e[n];
    else
      Tg(e.buffer, r.buffer);
    this.indexBuffer = r;
  }
  packQuadIndex(t, e, s) {
    t[e] = s + 0, t[e + 1] = s + 1, t[e + 2] = s + 2, t[e + 3] = s + 0, t[e + 4] = s + 2, t[e + 5] = s + 3;
  }
  packIndex(t, e, s, r) {
    const n = t.indices, a = t.indexSize, o = t.indexOffset, h = t.attributeOffset;
    for (let u = 0; u < a; u++)
      e[s++] = r + n[u + o] - h;
  }
  destroy() {
    for (let t = 0; t < this.batches.length; t++)
      SS(this.batches[t]);
    this.batches = null;
    for (let t = 0; t < this._elements.length; t++)
      this._elements[t]._batch = null;
    this._elements = null, this.indexBuffer = null, this.attributeBuffer.destroy(), this.attributeBuffer = null;
  }
};
x0.defaultOptions = {
  maxTextures: null,
  attributesInitialSize: 4,
  indicesInitialSize: 6
};
let VP = x0;
var ve = /* @__PURE__ */ ((i) => (i[i.MAP_READ = 1] = "MAP_READ", i[i.MAP_WRITE = 2] = "MAP_WRITE", i[i.COPY_SRC = 4] = "COPY_SRC", i[i.COPY_DST = 8] = "COPY_DST", i[i.INDEX = 16] = "INDEX", i[i.VERTEX = 32] = "VERTEX", i[i.UNIFORM = 64] = "UNIFORM", i[i.STORAGE = 128] = "STORAGE", i[i.INDIRECT = 256] = "INDIRECT", i[i.QUERY_RESOLVE = 512] = "QUERY_RESOLVE", i[i.STATIC = 1024] = "STATIC", i))(ve || {});
class gn extends Js {
  /**
   * Creates a new Buffer with the given options
   * @param options - the options for the buffer
   */
  constructor(t) {
    let { data: e, size: s } = t;
    const { usage: r, label: n, shrinkToFit: a } = t;
    super(), this.uid = me("buffer"), this._resourceType = "buffer", this._resourceId = me("resource"), this._touched = 0, this._updateID = 1, this.shrinkToFit = !0, this.destroyed = !1, e instanceof Array && (e = new Float32Array(e)), this._data = e, s = s ?? (e == null ? void 0 : e.byteLength);
    const o = !!e;
    this.descriptor = {
      size: s,
      usage: r,
      mappedAtCreation: o,
      label: n
    }, this.shrinkToFit = a ?? !0;
  }
  /** the data in the buffer */
  get data() {
    return this._data;
  }
  set data(t) {
    this.setDataWithSize(t, t.length, !0);
  }
  /** whether the buffer is static or not */
  get static() {
    return !!(this.descriptor.usage & ve.STATIC);
  }
  set static(t) {
    t ? this.descriptor.usage |= ve.STATIC : this.descriptor.usage &= ~ve.STATIC;
  }
  /**
   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.
   * If you only want to update a subset of the buffer, you can pass in the size of the data.
   * @param value - the data to set
   * @param size - the size of the data in bytes
   * @param syncGPU - should the buffer be updated on the GPU immediately?
   */
  setDataWithSize(t, e, s) {
    if (this._updateID++, this._updateSize = e * t.BYTES_PER_ELEMENT, this._data === t) {
      s && this.emit("update", this);
      return;
    }
    const r = this._data;
    if (this._data = t, r.length !== t.length) {
      !this.shrinkToFit && t.byteLength < r.byteLength ? s && this.emit("update", this) : (this.descriptor.size = t.byteLength, this._resourceId = me("resource"), this.emit("change", this));
      return;
    }
    s && this.emit("update", this);
  }
  /**
   * updates the buffer on the GPU to reflect the data in the buffer.
   * By default it will update the entire buffer. If you only want to update a subset of the buffer,
   * you can pass in the size of the buffer to update.
   * @param sizeInBytes - the new size of the buffer in bytes
   */
  update(t) {
    this._updateSize = t ?? this._updateSize, this._updateID++, this.emit("update", this);
  }
  /** Destroys the buffer */
  destroy() {
    this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._data = null, this.descriptor = null, this.removeAllListeners();
  }
}
function M0(i, t) {
  if (!(i instanceof gn)) {
    let e = t ? ve.INDEX : ve.VERTEX;
    i instanceof Array && (t ? (i = new Uint32Array(i), e = ve.INDEX | ve.COPY_DST) : (i = new Float32Array(i), e = ve.VERTEX | ve.COPY_DST)), i = new gn({
      data: i,
      label: t ? "index-mesh-buffer" : "vertex-mesh-buffer",
      usage: e
    });
  }
  return i;
}
function HP(i, t, e) {
  const s = i.getAttribute(t);
  if (!s)
    return e.minX = 0, e.minY = 0, e.maxX = 0, e.maxY = 0, e;
  const r = s.buffer.data;
  let n = 1 / 0, a = 1 / 0, o = -1 / 0, h = -1 / 0;
  const u = r.BYTES_PER_ELEMENT, c = (s.offset || 0) / u, l = (s.stride || 2 * 4) / u;
  for (let _ = c; _ < r.length; _ += l) {
    const d = r[_], f = r[_ + 1];
    d > o && (o = d), f > h && (h = f), d < n && (n = d), f < a && (a = f);
  }
  return e.minX = n, e.minY = a, e.maxX = o, e.maxY = h, e;
}
function YP(i) {
  return (i instanceof gn || Array.isArray(i) || i.BYTES_PER_ELEMENT) && (i = {
    buffer: i
  }), i.buffer = M0(i.buffer, !1), i;
}
class WP extends Js {
  /**
   * Create a new instance of a geometry
   * @param options - The options for the geometry.
   */
  constructor(t = {}) {
    super(), this.uid = me("geometry"), this._layoutKey = 0, this.instanceCount = 1, this._bounds = new Zs(), this._boundsDirty = !0;
    const { attributes: e, indexBuffer: s, topology: r } = t;
    if (this.buffers = [], this.attributes = {}, e)
      for (const n in e)
        this.addAttribute(n, e[n]);
    this.instanceCount = t.instanceCount || 1, s && this.addIndex(s), this.topology = r || "triangle-list";
  }
  onBufferUpdate() {
    this._boundsDirty = !0, this.emit("update", this);
  }
  /**
   * Returns the requested attribute.
   * @param id - The name of the attribute required
   * @returns - The attribute requested.
   */
  getAttribute(t) {
    return this.attributes[t];
  }
  /**
   * Returns the index buffer
   * @returns - The index buffer.
   */
  getIndex() {
    return this.indexBuffer;
  }
  /**
   * Returns the requested buffer.
   * @param id - The name of the buffer required.
   * @returns - The buffer requested.
   */
  getBuffer(t) {
    return this.getAttribute(t).buffer;
  }
  /**
   * Used to figure out how many vertices there are in this geometry
   * @returns the number of vertices in the geometry
   */
  getSize() {
    for (const t in this.attributes) {
      const e = this.attributes[t];
      return e.buffer.data.length / (e.stride / 4 || e.size);
    }
    return 0;
  }
  /**
   * Adds an attribute to the geometry.
   * @param name - The name of the attribute to add.
   * @param attributeOption - The attribute option to add.
   */
  addAttribute(t, e) {
    const s = YP(e);
    this.buffers.indexOf(s.buffer) === -1 && (this.buffers.push(s.buffer), s.buffer.on("update", this.onBufferUpdate, this), s.buffer.on("change", this.onBufferUpdate, this)), this.attributes[t] = s;
  }
  /**
   * Adds an index buffer to the geometry.
   * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.
   */
  addIndex(t) {
    this.indexBuffer = M0(t, !0), this.buffers.push(this.indexBuffer);
  }
  /** Returns the bounds of the geometry. */
  get bounds() {
    return this._boundsDirty ? (this._boundsDirty = !1, HP(this, "aPosition", this._bounds)) : this._bounds;
  }
  /**
   * destroys the geometry.
   * @param destroyBuffers - destroy the buffers associated with this geometry
   */
  destroy(t = !1) {
    this.emit("destroy", this), this.removeAllListeners(), t && this.buffers.forEach((e) => e.destroy()), this.attributes = null, this.buffers = null, this.indexBuffer = null, this._bounds = null;
  }
}
const jP = new Float32Array(1), XP = new Uint32Array(1);
class KP extends WP {
  constructor() {
    const e = new gn({
      data: jP,
      label: "attribute-batch-buffer",
      usage: ve.VERTEX | ve.COPY_DST,
      shrinkToFit: !1
    }), s = new gn({
      data: XP,
      label: "index-batch-buffer",
      usage: ve.INDEX | ve.COPY_DST,
      // | BufferUsage.STATIC,
      shrinkToFit: !1
    }), r = 6 * 4;
    super({
      attributes: {
        aPosition: {
          buffer: e,
          format: "float32x2",
          stride: r,
          offset: 0
        },
        aUV: {
          buffer: e,
          format: "float32x2",
          stride: r,
          offset: 2 * 4
        },
        aColor: {
          buffer: e,
          format: "unorm8x4",
          stride: r,
          offset: 4 * 4
        },
        aTextureIdAndRound: {
          buffer: e,
          format: "uint16x2",
          stride: r,
          offset: 5 * 4
        }
      },
      indexBuffer: s
    });
  }
}
function AS(i, t, e) {
  if (i)
    for (const s in i) {
      const r = s.toLocaleLowerCase(), n = t[r];
      if (n) {
        let a = i[s];
        s === "header" && (a = a.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")), e && n.push(`//----${e}----//`), n.push(a);
      } else
        ce(`${s} placement hook does not exist in shader`);
    }
}
const qP = /\{\{(.*?)\}\}/g;
function RS(i) {
  var s;
  const t = {};
  return (((s = i.match(qP)) == null ? void 0 : s.map((r) => r.replace(/[{()}]/g, ""))) ?? []).forEach((r) => {
    t[r] = [];
  }), t;
}
function OS(i, t) {
  let e;
  const s = /@in\s+([^;]+);/g;
  for (; (e = s.exec(i)) !== null; )
    t.push(e[1]);
}
function yS(i, t, e = !1) {
  const s = [];
  OS(t, s), i.forEach((o) => {
    o.header && OS(o.header, s);
  });
  const r = s;
  e && r.sort();
  const n = r.map((o, h) => `       @location(${h}) ${o},`).join(`
`);
  let a = t.replace(/@in\s+[^;]+;\s*/g, "");
  return a = a.replace("{{in}}", `
${n}
`), a;
}
function vS(i, t) {
  let e;
  const s = /@out\s+([^;]+);/g;
  for (; (e = s.exec(i)) !== null; )
    t.push(e[1]);
}
function $P(i) {
  const e = /\b(\w+)\s*:/g.exec(i);
  return e ? e[1] : "";
}
function ZP(i) {
  const t = /@.*?\s+/g;
  return i.replace(t, "");
}
function QP(i, t) {
  const e = [];
  vS(t, e), i.forEach((h) => {
    h.header && vS(h.header, e);
  });
  let s = 0;
  const r = e.sort().map((h) => h.indexOf("builtin") > -1 ? h : `@location(${s++}) ${h}`).join(`,
`), n = e.sort().map((h) => `       var ${ZP(h)};`).join(`
`), a = `return VSOutput(
                ${e.sort().map((h) => ` ${$P(h)}`).join(`,
`)});`;
  let o = t.replace(/@out\s+[^;]+;\s*/g, "");
  return o = o.replace("{{struct}}", `
${r}
`), o = o.replace("{{start}}", `
${n}
`), o = o.replace("{{return}}", `
${a}
`), o;
}
function CS(i, t) {
  let e = i;
  for (const s in t) {
    const r = t[s];
    r.join(`
`).length ? e = e.replace(`{{${s}}}`, `//-----${s} START-----//
${r.join(`
`)}
//----${s} FINISH----//`) : e = e.replace(`{{${s}}}`, "");
  }
  return e;
}
const Qr = /* @__PURE__ */ Object.create(null), Rf = /* @__PURE__ */ new Map();
let JP = 0;
function tN({
  template: i,
  bits: t
}) {
  const e = b0(i, t);
  if (Qr[e])
    return Qr[e];
  const { vertex: s, fragment: r } = sN(i, t);
  return Qr[e] = P0(s, r, t), Qr[e];
}
function eN({
  template: i,
  bits: t
}) {
  const e = b0(i, t);
  return Qr[e] || (Qr[e] = P0(i.vertex, i.fragment, t)), Qr[e];
}
function sN(i, t) {
  const e = t.map((a) => a.vertex).filter((a) => !!a), s = t.map((a) => a.fragment).filter((a) => !!a);
  let r = yS(e, i.vertex, !0);
  r = QP(e, r);
  const n = yS(s, i.fragment, !0);
  return {
    vertex: r,
    fragment: n
  };
}
function b0(i, t) {
  return t.map((e) => (Rf.has(e) || Rf.set(e, JP++), Rf.get(e))).sort((e, s) => e - s).join("-") + i.vertex + i.fragment;
}
function P0(i, t, e) {
  const s = RS(i), r = RS(t);
  return e.forEach((n) => {
    AS(n.vertex, s, n.name), AS(n.fragment, r, n.name);
  }), {
    vertex: CS(i, s),
    fragment: CS(t, r)
  };
}
const iN = (
  /* wgsl */
  `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`
), rN = (
  /* wgsl */
  `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`
), nN = (
  /* glsl */
  `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`
), aN = (
  /* glsl */
  `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`
), oN = {
  name: "global-uniforms-bit",
  vertex: {
    header: (
      /* wgsl */
      `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
    )
  }
}, hN = {
  name: "global-uniforms-bit",
  vertex: {
    header: (
      /* glsl */
      `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
    )
  }
};
function yT({ bits: i, name: t }) {
  const e = tN({
    template: {
      fragment: rN,
      vertex: iN
    },
    bits: [
      oN,
      ...i
    ]
  });
  return Ot.from({
    name: t,
    vertex: {
      source: e.vertex,
      entryPoint: "main"
    },
    fragment: {
      source: e.fragment,
      entryPoint: "main"
    }
  });
}
function uN({ bits: i, name: t }) {
  return new It({
    name: t,
    ...eN({
      template: {
        vertex: nN,
        fragment: aN
      },
      bits: [
        hN,
        ...i
      ]
    })
  });
}
const N0 = {
  name: "color-bit",
  vertex: {
    header: (
      /* wgsl */
      `
            @in aColor: vec4<f32>;
        `
    ),
    main: (
      /* wgsl */
      `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
    )
  }
}, lN = {
  name: "color-bit",
  vertex: {
    header: (
      /* glsl */
      `
            in vec4 aColor;
        `
    ),
    main: (
      /* glsl */
      `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
    )
  }
}, Of = {};
function cN(i) {
  const t = [];
  if (i === 1)
    t.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"), t.push("@group(1) @binding(1) var textureSampler1: sampler;");
  else {
    let e = 0;
    for (let s = 0; s < i; s++)
      t.push(`@group(1) @binding(${e++}) var textureSource${s + 1}: texture_2d<f32>;`), t.push(`@group(1) @binding(${e++}) var textureSampler${s + 1}: sampler;`);
  }
  return t.join(`
`);
}
function _N(i) {
  const t = [];
  if (i === 1)
    t.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
  else {
    t.push("switch vTextureId {");
    for (let e = 0; e < i; e++)
      e === i - 1 ? t.push("  default:{") : t.push(`  case ${e}:{`), t.push(`      outColor = textureSampleGrad(textureSource${e + 1}, textureSampler${e + 1}, vUV, uvDx, uvDy);`), t.push("      break;}");
    t.push("}");
  }
  return t.join(`
`);
}
function U0(i) {
  return Of[i] || (Of[i] = {
    name: "texture-batch-bit",
    vertex: {
      header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
      main: `
                vTextureId = aTextureIdAndRound.y;
            `,
      end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
    },
    fragment: {
      header: `
                @in @interpolate(flat) vTextureId: u32;

                ${cN(i)}
            `,
      main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${_N(i)}
            `
    }
  }), Of[i];
}
const yf = {};
function dN(i) {
  const t = [];
  for (let e = 0; e < i; e++)
    e > 0 && t.push("else"), e < i - 1 && t.push(`if(vTextureId < ${e}.5)`), t.push("{"), t.push(`	outColor = texture(uTextures[${e}], vUV);`), t.push("}");
  return t.join(`
`);
}
function fN(i) {
  return yf[i] || (yf[i] = {
    name: "texture-batch-bit",
    vertex: {
      header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
      main: `
                vTextureId = aTextureIdAndRound.y;
            `,
      end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
    },
    fragment: {
      header: `
                in float vTextureId;

                uniform sampler2D uTextures[${i}];

            `,
      main: `

                ${dN(i)}
            `
    }
  }), yf[i];
}
const vT = {
  name: "round-pixels-bit",
  vertex: {
    header: (
      /* wgsl */
      `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    )
  }
}, gN = {
  name: "round-pixels-bit",
  vertex: {
    header: (
      /* glsl */
      `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    )
  }
}, xS = {};
function pN(i) {
  let t = xS[i];
  if (t)
    return t;
  const e = new Int32Array(i);
  for (let s = 0; s < i; s++)
    e[s] = s;
  return t = xS[i] = new mn({
    uTextures: { value: e, type: "i32", size: i }
  }, { isStatic: !0 }), t;
}
class mN extends $o {
  constructor(t) {
    const e = uN({
      name: "batch",
      bits: [
        lN,
        fN(t),
        gN
      ]
    }), s = yT({
      name: "batch",
      bits: [
        N0,
        U0(t),
        vT
      ]
    });
    super({
      glProgram: e,
      gpuProgram: s,
      resources: {
        batchSamplers: pN(t)
      }
    });
  }
}
let MS = null;
const D0 = class L0 extends VP {
  constructor() {
    super(...arguments), this.geometry = new KP(), this.shader = MS || (MS = new mN(this.maxTextures)), this.name = L0.extension.name, this.vertexSize = 6;
  }
  /**
   * Packs the attributes of a DefaultBatchableMeshElement into the provided views.
   * @param element - The DefaultBatchableMeshElement to pack.
   * @param float32View - The Float32Array view to pack into.
   * @param uint32View - The Uint32Array view to pack into.
   * @param index - The starting index in the views.
   * @param textureId - The texture ID to use.
   */
  packAttributes(t, e, s, r, n) {
    const a = n << 16 | t.roundPixels & 65535, o = t.transform, h = o.a, u = o.b, c = o.c, l = o.d, _ = o.tx, d = o.ty, { positions: f, uvs: p } = t, g = t.color, m = t.attributeOffset, O = m + t.attributeSize;
    for (let y = m; y < O; y++) {
      const C = y * 2, b = f[C], D = f[C + 1];
      e[r++] = h * b + c * D + _, e[r++] = l * D + u * b + d, e[r++] = p[C], e[r++] = p[C + 1], s[r++] = g, s[r++] = a;
    }
  }
  /**
   * Packs the attributes of a DefaultBatchableQuadElement into the provided views.
   * @param element - The DefaultBatchableQuadElement to pack.
   * @param float32View - The Float32Array view to pack into.
   * @param uint32View - The Uint32Array view to pack into.
   * @param index - The starting index in the views.
   * @param textureId - The texture ID to use.
   */
  packQuadAttributes(t, e, s, r, n) {
    const a = t.texture, o = t.transform, h = o.a, u = o.b, c = o.c, l = o.d, _ = o.tx, d = o.ty, f = t.bounds, p = f.maxX, g = f.minX, m = f.maxY, O = f.minY, y = a.uvs, C = t.color, b = n << 16 | t.roundPixels & 65535;
    e[r + 0] = h * g + c * O + _, e[r + 1] = l * O + u * g + d, e[r + 2] = y.x0, e[r + 3] = y.y0, s[r + 4] = C, s[r + 5] = b, e[r + 6] = h * p + c * O + _, e[r + 7] = l * O + u * p + d, e[r + 8] = y.x1, e[r + 9] = y.y1, s[r + 10] = C, s[r + 11] = b, e[r + 12] = h * p + c * m + _, e[r + 13] = l * m + u * p + d, e[r + 14] = y.x2, e[r + 15] = y.y2, s[r + 16] = C, s[r + 17] = b, e[r + 18] = h * g + c * m + _, e[r + 19] = l * m + u * g + d, e[r + 20] = y.x3, e[r + 21] = y.y3, s[r + 22] = C, s[r + 23] = b;
  }
};
D0.extension = {
  type: [
    B.Batcher
  ],
  name: "default"
};
let CT = D0;
function EN(i, t, e, s, r, n, a, o = null) {
  let h = 0;
  e *= t, r *= n;
  const u = o.a, c = o.b, l = o.c, _ = o.d, d = o.tx, f = o.ty;
  for (; h < a; ) {
    const p = i[e], g = i[e + 1];
    s[r] = u * p + l * g + d, s[r + 1] = c * p + _ * g + f, r += n, e += t, h++;
  }
}
function TN(i, t, e, s) {
  let r = 0;
  for (t *= e; r < s; )
    i[t] = 0, i[t + 1] = 0, t += e, r++;
}
function F0(i, t, e, s, r) {
  const n = t.a, a = t.b, o = t.c, h = t.d, u = t.tx, c = t.ty;
  e = e || 0, s = s || 2, r = r || i.length / s - e;
  let l = e * s;
  for (let _ = 0; _ < r; _++) {
    const d = i[l], f = i[l + 1];
    i[l] = n * d + o * f + u, i[l + 1] = a * d + h * f + c, l += s;
  }
}
function IN(i, t) {
  if (i === 16777215 || !t)
    return t;
  if (t === 16777215 || !i)
    return i;
  const e = i >> 16 & 255, s = i >> 8 & 255, r = i & 255, n = t >> 16 & 255, a = t >> 8 & 255, o = t & 255, h = e * n / 255, u = s * a / 255, c = r * o / 255;
  return (h << 16) + (u << 8) + c;
}
const SN = new ot();
class w0 {
  constructor() {
    this.packAsQuad = !1, this.batcherName = "default", this.applyTransform = !0, this.roundPixels = 0, this._batcher = null, this._batch = null;
  }
  get uvs() {
    return this.geometryData.uvs;
  }
  get positions() {
    return this.geometryData.vertices;
  }
  get indices() {
    return this.geometryData.indices;
  }
  get blendMode() {
    return this.applyTransform ? this.renderable.groupBlendMode : "normal";
  }
  get color() {
    const t = this.baseColor, e = t >> 16 | t & 65280 | (t & 255) << 16, s = this.renderable;
    return s ? IN(e, s.groupColor) + (this.alpha * s.groupAlpha * 255 << 24) : e + (this.alpha * 255 << 24);
  }
  get transform() {
    var t;
    return ((t = this.renderable) == null ? void 0 : t.groupTransform) || SN;
  }
  copyTo(t) {
    t.indexOffset = this.indexOffset, t.indexSize = this.indexSize, t.attributeOffset = this.attributeOffset, t.attributeSize = this.attributeSize, t.baseColor = this.baseColor, t.alpha = this.alpha, t.texture = this.texture, t.geometryData = this.geometryData;
  }
  reset() {
    this.applyTransform = !0, this.renderable = null;
  }
}
const pu = {
  extension: {
    type: B.ShapeBuilder,
    name: "circle"
  },
  build(i, t) {
    let e, s, r, n, a, o;
    if (i.type === "circle") {
      const C = i;
      e = C.x, s = C.y, a = o = C.radius, r = n = 0;
    } else if (i.type === "ellipse") {
      const C = i;
      e = C.x, s = C.y, a = C.halfWidth, o = C.halfHeight, r = n = 0;
    } else {
      const C = i, b = C.width / 2, D = C.height / 2;
      e = C.x + b, s = C.y + D, a = o = Math.max(0, Math.min(C.radius, Math.min(b, D))), r = b - a, n = D - o;
    }
    if (!(a >= 0 && o >= 0 && r >= 0 && n >= 0))
      return t;
    const h = Math.ceil(2.3 * Math.sqrt(a + o)), u = h * 8 + (r ? 4 : 0) + (n ? 4 : 0);
    if (u === 0)
      return t;
    if (h === 0)
      return t[0] = t[6] = e + r, t[1] = t[3] = s + n, t[2] = t[4] = e - r, t[5] = t[7] = s - n, t;
    let c = 0, l = h * 4 + (r ? 2 : 0) + 2, _ = l, d = u, f = r + a, p = n, g = e + f, m = e - f, O = s + p;
    if (t[c++] = g, t[c++] = O, t[--l] = O, t[--l] = m, n) {
      const C = s - p;
      t[_++] = m, t[_++] = C, t[--d] = C, t[--d] = g;
    }
    for (let C = 1; C < h; C++) {
      const b = Math.PI / 2 * (C / h), D = r + Math.cos(b) * a, P = n + Math.sin(b) * o, F = e + D, M = e - D, U = s + P, k = s - P;
      t[c++] = F, t[c++] = U, t[--l] = U, t[--l] = M, t[_++] = M, t[_++] = k, t[--d] = k, t[--d] = F;
    }
    f = r, p = n + o, g = e + f, m = e - f, O = s + p;
    const y = s - p;
    return t[c++] = g, t[c++] = O, t[--d] = y, t[--d] = g, r && (t[c++] = m, t[c++] = O, t[--d] = y, t[--d] = m), t;
  },
  triangulate(i, t, e, s, r, n) {
    if (i.length === 0)
      return;
    let a = 0, o = 0;
    for (let c = 0; c < i.length; c += 2)
      a += i[c], o += i[c + 1];
    a /= i.length / 2, o /= i.length / 2;
    let h = s;
    t[h * e] = a, t[h * e + 1] = o;
    const u = h++;
    for (let c = 0; c < i.length; c += 2)
      t[h * e] = i[c], t[h * e + 1] = i[c + 1], c > 0 && (r[n++] = h, r[n++] = u, r[n++] = h - 1), h++;
    r[n++] = u + 1, r[n++] = u, r[n++] = h - 1;
  }
}, AN = { ...pu, extension: { ...pu.extension, name: "ellipse" } }, RN = { ...pu, extension: { ...pu.extension, name: "roundedRectangle" } }, ON = 1e-4, bS = 1e-4;
function yN(i) {
  const t = i.length;
  if (t < 6)
    return 1;
  let e = 0;
  for (let s = 0, r = i[t - 2], n = i[t - 1]; s < t; s += 2) {
    const a = i[s], o = i[s + 1];
    e += (a - r) * (o + n), r = a, n = o;
  }
  return e < 0 ? -1 : 1;
}
function PS(i, t, e, s, r, n, a, o) {
  const h = i - e * r, u = t - s * r, c = i + e * n, l = t + s * n;
  let _, d;
  a ? (_ = s, d = -e) : (_ = -s, d = e);
  const f = h + _, p = u + d, g = c + _, m = l + d;
  return o.push(f, p), o.push(g, m), 2;
}
function yn(i, t, e, s, r, n, a, o) {
  const h = e - i, u = s - t;
  let c = Math.atan2(h, u), l = Math.atan2(r - i, n - t);
  o && c < l ? c += Math.PI * 2 : !o && c > l && (l += Math.PI * 2);
  let _ = c;
  const d = l - c, f = Math.abs(d), p = Math.sqrt(h * h + u * u), g = (15 * f * Math.sqrt(p) / Math.PI >> 0) + 1, m = d / g;
  if (_ += m, o) {
    a.push(i, t), a.push(e, s);
    for (let O = 1, y = _; O < g; O++, y += m)
      a.push(i, t), a.push(
        i + Math.sin(y) * p,
        t + Math.cos(y) * p
      );
    a.push(i, t), a.push(r, n);
  } else {
    a.push(e, s), a.push(i, t);
    for (let O = 1, y = _; O < g; O++, y += m)
      a.push(
        i + Math.sin(y) * p,
        t + Math.cos(y) * p
      ), a.push(i, t);
    a.push(r, n), a.push(i, t);
  }
  return g * 2;
}
function vN(i, t, e, s, r, n, a, o, h) {
  const u = ON;
  if (i.length === 0)
    return;
  const c = t;
  let l = c.alignment;
  if (t.alignment !== 0.5) {
    let ie = yN(i);
    l = (l - 0.5) * ie + 0.5;
  }
  const _ = new st(i[0], i[1]), d = new st(i[i.length - 2], i[i.length - 1]), f = s, p = Math.abs(_.x - d.x) < u && Math.abs(_.y - d.y) < u;
  if (f) {
    i = i.slice(), p && (i.pop(), i.pop(), d.set(i[i.length - 2], i[i.length - 1]));
    const ie = (_.x + d.x) * 0.5, Ki = (d.y + _.y) * 0.5;
    i.unshift(ie, Ki), i.push(ie, Ki);
  }
  const g = r, m = i.length / 2;
  let O = i.length;
  const y = g.length / 2, C = c.width / 2, b = C * C, D = c.miterLimit * c.miterLimit;
  let P = i[0], F = i[1], M = i[2], U = i[3], k = 0, ft = 0, K = -(F - U), Y = P - M, ut = 0, Gt = 0, V = Math.sqrt(K * K + Y * Y);
  K /= V, Y /= V, K *= C, Y *= C;
  const Mt = l, X = (1 - Mt) * 2, ht = Mt * 2;
  f || (c.cap === "round" ? O += yn(
    P - K * (X - ht) * 0.5,
    F - Y * (X - ht) * 0.5,
    P - K * X,
    F - Y * X,
    P + K * ht,
    F + Y * ht,
    g,
    !0
  ) + 2 : c.cap === "square" && (O += PS(P, F, K, Y, X, ht, !0, g))), g.push(
    P - K * X,
    F - Y * X
  ), g.push(
    P + K * ht,
    F + Y * ht
  );
  for (let ie = 1; ie < m - 1; ++ie) {
    P = i[(ie - 1) * 2], F = i[(ie - 1) * 2 + 1], M = i[ie * 2], U = i[ie * 2 + 1], k = i[(ie + 1) * 2], ft = i[(ie + 1) * 2 + 1], K = -(F - U), Y = P - M, V = Math.sqrt(K * K + Y * Y), K /= V, Y /= V, K *= C, Y *= C, ut = -(U - ft), Gt = M - k, V = Math.sqrt(ut * ut + Gt * Gt), ut /= V, Gt /= V, ut *= C, Gt *= C;
    const Ki = M - P, Ls = F - U, As = M - k, pi = ft - U, ih = Ki * As + Ls * pi, In = Ls * As - pi * Ki, qi = In < 0;
    if (Math.abs(In) < 1e-3 * Math.abs(ih)) {
      g.push(
        M - K * X,
        U - Y * X
      ), g.push(
        M + K * ht,
        U + Y * ht
      ), ih >= 0 && (c.join === "round" ? O += yn(
        M,
        U,
        M - K * X,
        U - Y * X,
        M - ut * X,
        U - Gt * X,
        g,
        !1
      ) + 4 : O += 2, g.push(
        M - ut * ht,
        U - Gt * ht
      ), g.push(
        M + ut * X,
        U + Gt * X
      ));
      continue;
    }
    const xa = (-K + P) * (-Y + U) - (-K + M) * (-Y + F), ZI = (-ut + k) * (-Gt + U) - (-ut + M) * (-Gt + ft), Ku = (Ki * ZI - As * xa) / In, qu = (pi * xa - Ls * ZI) / In, Zd = (Ku - M) * (Ku - M) + (qu - U) * (qu - U), Sn = M + (Ku - M) * X, An = U + (qu - U) * X, Rn = M - (Ku - M) * ht, On = U - (qu - U) * ht, XM = Math.min(Ki * Ki + Ls * Ls, As * As + pi * pi), QI = qi ? X : ht, KM = XM + QI * QI * b;
    Zd <= KM ? c.join === "bevel" || Zd / b > D ? (qi ? (g.push(Sn, An), g.push(M + K * ht, U + Y * ht), g.push(Sn, An), g.push(M + ut * ht, U + Gt * ht)) : (g.push(M - K * X, U - Y * X), g.push(Rn, On), g.push(M - ut * X, U - Gt * X), g.push(Rn, On)), O += 2) : c.join === "round" ? qi ? (g.push(Sn, An), g.push(M + K * ht, U + Y * ht), O += yn(
      M,
      U,
      M + K * ht,
      U + Y * ht,
      M + ut * ht,
      U + Gt * ht,
      g,
      !0
    ) + 4, g.push(Sn, An), g.push(M + ut * ht, U + Gt * ht)) : (g.push(M - K * X, U - Y * X), g.push(Rn, On), O += yn(
      M,
      U,
      M - K * X,
      U - Y * X,
      M - ut * X,
      U - Gt * X,
      g,
      !1
    ) + 4, g.push(M - ut * X, U - Gt * X), g.push(Rn, On)) : (g.push(Sn, An), g.push(Rn, On)) : (g.push(M - K * X, U - Y * X), g.push(M + K * ht, U + Y * ht), c.join === "round" ? qi ? O += yn(
      M,
      U,
      M + K * ht,
      U + Y * ht,
      M + ut * ht,
      U + Gt * ht,
      g,
      !0
    ) + 2 : O += yn(
      M,
      U,
      M - K * X,
      U - Y * X,
      M - ut * X,
      U - Gt * X,
      g,
      !1
    ) + 2 : c.join === "miter" && Zd / b <= D && (qi ? (g.push(Rn, On), g.push(Rn, On)) : (g.push(Sn, An), g.push(Sn, An)), O += 2), g.push(M - ut * X, U - Gt * X), g.push(M + ut * ht, U + Gt * ht), O += 2);
  }
  P = i[(m - 2) * 2], F = i[(m - 2) * 2 + 1], M = i[(m - 1) * 2], U = i[(m - 1) * 2 + 1], K = -(F - U), Y = P - M, V = Math.sqrt(K * K + Y * Y), K /= V, Y /= V, K *= C, Y *= C, g.push(M - K * X, U - Y * X), g.push(M + K * ht, U + Y * ht), f || (c.cap === "round" ? O += yn(
    M - K * (X - ht) * 0.5,
    U - Y * (X - ht) * 0.5,
    M - K * X,
    U - Y * X,
    M + K * ht,
    U + Y * ht,
    g,
    !1
  ) + 2 : c.cap === "square" && (O += PS(M, U, K, Y, X, ht, !1, g)));
  const vr = bS * bS;
  for (let ie = y; ie < O + y - 2; ++ie)
    P = g[ie * 2], F = g[ie * 2 + 1], M = g[(ie + 1) * 2], U = g[(ie + 1) * 2 + 1], k = g[(ie + 2) * 2], ft = g[(ie + 2) * 2 + 1], !(Math.abs(P * (U - ft) + M * (ft - F) + k * (F - U)) < vr) && o.push(ie, ie + 1, ie + 2);
}
function G0(i, t, e, s, r, n, a) {
  const o = RP(i, t, 2);
  if (!o)
    return;
  for (let u = 0; u < o.length; u += 3)
    n[a++] = o[u] + r, n[a++] = o[u + 1] + r, n[a++] = o[u + 2] + r;
  let h = r * s;
  for (let u = 0; u < i.length; u += 2)
    e[h] = i[u], e[h + 1] = i[u + 1], h += s;
}
const CN = [], xN = {
  extension: {
    type: B.ShapeBuilder,
    name: "polygon"
  },
  build(i, t) {
    for (let e = 0; e < i.points.length; e++)
      t[e] = i.points[e];
    return t;
  },
  triangulate(i, t, e, s, r, n) {
    G0(i, CN, t, e, s, r, n);
  }
}, MN = {
  extension: {
    type: B.ShapeBuilder,
    name: "rectangle"
  },
  build(i, t) {
    const e = i, s = e.x, r = e.y, n = e.width, a = e.height;
    return n >= 0 && a >= 0 && (t[0] = s, t[1] = r, t[2] = s + n, t[3] = r, t[4] = s + n, t[5] = r + a, t[6] = s, t[7] = r + a), t;
  },
  triangulate(i, t, e, s, r, n) {
    let a = 0;
    s *= e, t[s + a] = i[0], t[s + a + 1] = i[1], a += e, t[s + a] = i[2], t[s + a + 1] = i[3], a += e, t[s + a] = i[6], t[s + a + 1] = i[7], a += e, t[s + a] = i[4], t[s + a + 1] = i[5], a += e;
    const o = s / e;
    r[n++] = o, r[n++] = o + 1, r[n++] = o + 2, r[n++] = o + 1, r[n++] = o + 3, r[n++] = o + 2;
  }
}, bN = {
  extension: {
    type: B.ShapeBuilder,
    name: "triangle"
  },
  build(i, t) {
    return t[0] = i.x, t[1] = i.y, t[2] = i.x2, t[3] = i.y2, t[4] = i.x3, t[5] = i.y3, t;
  },
  triangulate(i, t, e, s, r, n) {
    let a = 0;
    s *= e, t[s + a] = i[0], t[s + a + 1] = i[1], a += e, t[s + a] = i[2], t[s + a + 1] = i[3], a += e, t[s + a] = i[4], t[s + a + 1] = i[5];
    const o = s / e;
    r[n++] = o, r[n++] = o + 1, r[n++] = o + 2;
  }
}, Ld = {};
Ee.handleByMap(B.ShapeBuilder, Ld);
Ee.add(MN, xN, bN, pu, AN, RN);
const PN = new Kt();
function NN(i, t) {
  const { geometryData: e, batches: s } = t;
  s.length = 0, e.indices.length = 0, e.vertices.length = 0, e.uvs.length = 0;
  for (let r = 0; r < i.instructions.length; r++) {
    const n = i.instructions[r];
    if (n.action === "texture")
      UN(n.data, s, e);
    else if (n.action === "fill" || n.action === "stroke") {
      const a = n.action === "stroke", o = n.data.path.shapePath, h = n.data.style, u = n.data.hole;
      a && u && NS(u.shapePath, h, null, !0, s, e), NS(o, h, u, a, s, e);
    }
  }
}
function UN(i, t, e) {
  const { vertices: s, uvs: r, indices: n } = e, a = n.length, o = s.length / 2, h = [], u = Ld.rectangle, c = PN, l = i.image;
  c.x = i.dx, c.y = i.dy, c.width = i.dw, c.height = i.dh;
  const _ = i.transform;
  u.build(c, h), _ && F0(h, _), u.triangulate(h, s, 2, o, n, a);
  const d = l.uvs;
  r.push(
    d.x0,
    d.y0,
    d.x1,
    d.y1,
    d.x3,
    d.y3,
    d.x2,
    d.y2
  );
  const f = Es.get(w0);
  f.indexOffset = a, f.indexSize = n.length - a, f.attributeOffset = o, f.attributeSize = s.length / 2 - o, f.baseColor = i.style, f.alpha = i.alpha, f.texture = l, f.geometryData = e, t.push(f);
}
function NS(i, t, e, s, r, n) {
  const { vertices: a, uvs: o, indices: h } = n, u = i.shapePrimitives.length - 1;
  i.shapePrimitives.forEach(({ shape: c, transform: l }, _) => {
    const d = h.length, f = a.length / 2, p = [], g = Ld[c.type];
    if (g.build(c, p), l && F0(p, l), s) {
      const C = c.closePath ?? !0;
      vN(p, t, !1, C, a, 2, f, h);
    } else if (e && u === _) {
      u !== 0 && console.warn("[Pixi Graphics] only the last shape have be cut out");
      const C = [], b = p.slice();
      DN(e.shapePath).forEach((P) => {
        C.push(b.length / 2), b.push(...P);
      }), G0(b, C, a, 2, f, h, d);
    } else
      g.triangulate(p, a, 2, f, h, d);
    const m = o.length / 2, O = t.texture;
    if (O !== W.WHITE) {
      const C = t.matrix;
      C && (l && C.append(l.clone().invert()), EN(a, 2, f, o, m, 2, a.length / 2 - f, C));
    } else
      TN(o, m, 2, a.length / 2 - f);
    const y = Es.get(w0);
    y.indexOffset = d, y.indexSize = h.length - d, y.attributeOffset = f, y.attributeSize = a.length / 2 - f, y.baseColor = t.color, y.alpha = t.alpha, y.texture = O, y.geometryData = n, r.push(y);
  });
}
function DN(i) {
  if (!i)
    return [];
  const t = i.shapePrimitives, e = [];
  for (let s = 0; s < t.length; s++) {
    const r = t[s].shape, n = [];
    Ld[r.type].build(r, n), e.push(n);
  }
  return e;
}
class LN {
  constructor() {
    this.batches = [], this.geometryData = {
      vertices: [],
      uvs: [],
      indices: []
    };
  }
}
class FN {
  constructor() {
    this.batcher = new CT(), this.instructions = new YR();
  }
  init() {
    this.instructions.reset();
  }
  /**
   * @deprecated since version 8.0.0
   * Use `batcher.geometry` instead.
   * @see {Batcher#geometry}
   */
  get geometry() {
    return dt(ib, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."), this.batcher.geometry;
  }
}
const xT = class Sg {
  constructor(t) {
    this._gpuContextHash = {}, this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null), t.renderableGC.addManagedHash(this, "_gpuContextHash"), t.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
  }
  /**
   * Runner init called, update the default options
   * @ignore
   */
  init(t) {
    Sg.defaultOptions.bezierSmoothness = (t == null ? void 0 : t.bezierSmoothness) ?? Sg.defaultOptions.bezierSmoothness;
  }
  getContextRenderData(t) {
    return this._graphicsDataContextHash[t.uid] || this._initContextRenderData(t);
  }
  // Context management functions
  updateGpuContext(t) {
    let e = this._gpuContextHash[t.uid] || this._initContext(t);
    if (t.dirty) {
      e ? this._cleanGraphicsContextData(t) : e = this._initContext(t), NN(t, e);
      const s = t.batchMode;
      t.customShader || s === "no-batch" ? e.isBatchable = !1 : s === "auto" && (e.isBatchable = e.geometryData.vertices.length < 400), t.dirty = !1;
    }
    return e;
  }
  getGpuContext(t) {
    return this._gpuContextHash[t.uid] || this._initContext(t);
  }
  _initContextRenderData(t) {
    const e = Es.get(FN), { batches: s, geometryData: r } = this._gpuContextHash[t.uid], n = r.vertices.length, a = r.indices.length;
    for (let c = 0; c < s.length; c++)
      s[c].applyTransform = !1;
    const o = e.batcher;
    o.ensureAttributeBuffer(n), o.ensureIndexBuffer(a), o.begin();
    for (let c = 0; c < s.length; c++) {
      const l = s[c];
      o.add(l);
    }
    o.finish(e.instructions);
    const h = o.geometry;
    h.indexBuffer.setDataWithSize(o.indexBuffer, o.indexSize, !0), h.buffers[0].setDataWithSize(o.attributeBuffer.float32View, o.attributeSize, !0);
    const u = o.batches;
    for (let c = 0; c < u.length; c++) {
      const l = u[c];
      l.bindGroup = OT(l.textures.textures, l.textures.count);
    }
    return this._graphicsDataContextHash[t.uid] = e, e;
  }
  _initContext(t) {
    const e = new LN();
    return e.context = t, this._gpuContextHash[t.uid] = e, t.on("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[t.uid];
  }
  onGraphicsContextDestroy(t) {
    this._cleanGraphicsContextData(t), t.off("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[t.uid] = null;
  }
  _cleanGraphicsContextData(t) {
    const e = this._gpuContextHash[t.uid];
    e.isBatchable || this._graphicsDataContextHash[t.uid] && (Es.return(this.getContextRenderData(t)), this._graphicsDataContextHash[t.uid] = null), e.batches && e.batches.forEach((s) => {
      Es.return(s);
    });
  }
  destroy() {
    for (const t in this._gpuContextHash)
      this._gpuContextHash[t] && this.onGraphicsContextDestroy(this._gpuContextHash[t].context);
  }
};
xT.extension = {
  type: [
    B.WebGLSystem,
    B.WebGPUSystem,
    B.CanvasSystem
  ],
  name: "graphicsContext"
};
xT.defaultOptions = {
  /**
   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)
   * @default 0.5
   */
  bezierSmoothness: 0.5
};
let B0 = xT;
const wN = 8, al = 11920929e-14, GN = 1;
function k0(i, t, e, s, r, n, a, o, h, u) {
  const l = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, u ?? B0.defaultOptions.bezierSmoothness)
  );
  let _ = (GN - l) / 1;
  return _ *= _, BN(t, e, s, r, n, a, o, h, i, _), i;
}
function BN(i, t, e, s, r, n, a, o, h, u) {
  Ag(i, t, e, s, r, n, a, o, h, u, 0), h.push(a, o);
}
function Ag(i, t, e, s, r, n, a, o, h, u, c) {
  if (c > wN)
    return;
  const l = (i + e) / 2, _ = (t + s) / 2, d = (e + r) / 2, f = (s + n) / 2, p = (r + a) / 2, g = (n + o) / 2, m = (l + d) / 2, O = (_ + f) / 2, y = (d + p) / 2, C = (f + g) / 2, b = (m + y) / 2, D = (O + C) / 2;
  if (c > 0) {
    let P = a - i, F = o - t;
    const M = Math.abs((e - a) * F - (s - o) * P), U = Math.abs((r - a) * F - (n - o) * P);
    if (M > al && U > al) {
      if ((M + U) * (M + U) <= u * (P * P + F * F)) {
        h.push(b, D);
        return;
      }
    } else if (M > al) {
      if (M * M <= u * (P * P + F * F)) {
        h.push(b, D);
        return;
      }
    } else if (U > al) {
      if (U * U <= u * (P * P + F * F)) {
        h.push(b, D);
        return;
      }
    } else if (P = b - (i + a) / 2, F = D - (t + o) / 2, P * P + F * F <= u) {
      h.push(b, D);
      return;
    }
  }
  Ag(i, t, l, _, m, O, b, D, h, u, c + 1), Ag(b, D, y, C, p, g, a, o, h, u, c + 1);
}
const kN = 8, zN = 11920929e-14, VN = 1;
function HN(i, t, e, s, r, n, a, o) {
  const u = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, o ?? B0.defaultOptions.bezierSmoothness)
  );
  let c = (VN - u) / 1;
  return c *= c, YN(t, e, s, r, n, a, i, c), i;
}
function YN(i, t, e, s, r, n, a, o) {
  Rg(a, i, t, e, s, r, n, o, 0), a.push(r, n);
}
function Rg(i, t, e, s, r, n, a, o, h) {
  if (h > kN)
    return;
  const u = (t + s) / 2, c = (e + r) / 2, l = (s + n) / 2, _ = (r + a) / 2, d = (u + l) / 2, f = (c + _) / 2;
  let p = n - t, g = a - e;
  const m = Math.abs((s - n) * g - (r - a) * p);
  if (m > zN) {
    if (m * m <= o * (p * p + g * g)) {
      i.push(d, f);
      return;
    }
  } else if (p = d - (t + n) / 2, g = f - (e + a) / 2, p * p + g * g <= o) {
    i.push(d, f);
    return;
  }
  Rg(i, t, e, u, c, d, f, o, h + 1), Rg(i, d, f, l, _, n, a, o, h + 1);
}
function z0(i, t, e, s, r, n, a, o) {
  let h = Math.abs(r - n);
  (!a && r > n || a && n > r) && (h = 2 * Math.PI - h), o = o || Math.max(6, Math.floor(6 * Math.pow(s, 1 / 3) * (h / Math.PI))), o = Math.max(o, 3);
  let u = h / o, c = r;
  u *= a ? -1 : 1;
  for (let l = 0; l < o + 1; l++) {
    const _ = Math.cos(c), d = Math.sin(c), f = t + _ * s, p = e + d * s;
    i.push(f, p), c += u;
  }
}
function WN(i, t, e, s, r, n) {
  const a = i[i.length - 2], h = i[i.length - 1] - e, u = a - t, c = r - e, l = s - t, _ = Math.abs(h * l - u * c);
  if (_ < 1e-8 || n === 0) {
    (i[i.length - 2] !== t || i[i.length - 1] !== e) && i.push(t, e);
    return;
  }
  const d = h * h + u * u, f = c * c + l * l, p = h * c + u * l, g = n * Math.sqrt(d) / _, m = n * Math.sqrt(f) / _, O = g * p / d, y = m * p / f, C = g * l + m * u, b = g * c + m * h, D = u * (m + O), P = h * (m + O), F = l * (g + y), M = c * (g + y), U = Math.atan2(P - b, D - C), k = Math.atan2(M - b, F - C);
  z0(
    i,
    C + t,
    b + e,
    n,
    U,
    k,
    u * c > l * h
  );
}
const Ih = Math.PI * 2, vf = {
  centerX: 0,
  centerY: 0,
  ang1: 0,
  ang2: 0
}, Cf = ({ x: i, y: t }, e, s, r, n, a, o, h) => {
  i *= e, t *= s;
  const u = r * i - n * t, c = n * i + r * t;
  return h.x = u + a, h.y = c + o, h;
};
function jN(i, t) {
  const e = t === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(t / 4), s = t === 1.5707963267948966 ? 0.551915024494 : e, r = Math.cos(i), n = Math.sin(i), a = Math.cos(i + t), o = Math.sin(i + t);
  return [
    {
      x: r - n * s,
      y: n + r * s
    },
    {
      x: a + o * s,
      y: o - a * s
    },
    {
      x: a,
      y: o
    }
  ];
}
const US = (i, t, e, s) => {
  const r = i * s - t * e < 0 ? -1 : 1;
  let n = i * e + t * s;
  return n > 1 && (n = 1), n < -1 && (n = -1), r * Math.acos(n);
}, XN = (i, t, e, s, r, n, a, o, h, u, c, l, _) => {
  const d = Math.pow(r, 2), f = Math.pow(n, 2), p = Math.pow(c, 2), g = Math.pow(l, 2);
  let m = d * f - d * g - f * p;
  m < 0 && (m = 0), m /= d * g + f * p, m = Math.sqrt(m) * (a === o ? -1 : 1);
  const O = m * r / n * l, y = m * -n / r * c, C = u * O - h * y + (i + e) / 2, b = h * O + u * y + (t + s) / 2, D = (c - O) / r, P = (l - y) / n, F = (-c - O) / r, M = (-l - y) / n, U = US(1, 0, D, P);
  let k = US(D, P, F, M);
  o === 0 && k > 0 && (k -= Ih), o === 1 && k < 0 && (k += Ih), _.centerX = C, _.centerY = b, _.ang1 = U, _.ang2 = k;
};
function KN(i, t, e, s, r, n, a, o = 0, h = 0, u = 0) {
  if (n === 0 || a === 0)
    return;
  const c = Math.sin(o * Ih / 360), l = Math.cos(o * Ih / 360), _ = l * (t - s) / 2 + c * (e - r) / 2, d = -c * (t - s) / 2 + l * (e - r) / 2;
  if (_ === 0 && d === 0)
    return;
  n = Math.abs(n), a = Math.abs(a);
  const f = Math.pow(_, 2) / Math.pow(n, 2) + Math.pow(d, 2) / Math.pow(a, 2);
  f > 1 && (n *= Math.sqrt(f), a *= Math.sqrt(f)), XN(
    t,
    e,
    s,
    r,
    n,
    a,
    h,
    u,
    c,
    l,
    _,
    d,
    vf
  );
  let { ang1: p, ang2: g } = vf;
  const { centerX: m, centerY: O } = vf;
  let y = Math.abs(g) / (Ih / 4);
  Math.abs(1 - y) < 1e-7 && (y = 1);
  const C = Math.max(Math.ceil(y), 1);
  g /= C;
  let b = i[i.length - 2], D = i[i.length - 1];
  const P = { x: 0, y: 0 };
  for (let F = 0; F < C; F++) {
    const M = jN(p, g), { x: U, y: k } = Cf(M[0], n, a, l, c, m, O, P), { x: ft, y: K } = Cf(M[1], n, a, l, c, m, O, P), { x: Y, y: ut } = Cf(M[2], n, a, l, c, m, O, P);
    k0(
      i,
      b,
      D,
      U,
      k,
      ft,
      K,
      Y,
      ut
    ), b = Y, D = ut, p += g;
  }
}
function qN(i, t, e) {
  const s = (a, o) => {
    const h = o.x - a.x, u = o.y - a.y, c = Math.sqrt(h * h + u * u), l = h / c, _ = u / c;
    return { len: c, nx: l, ny: _ };
  }, r = (a, o) => {
    a === 0 ? i.moveTo(o.x, o.y) : i.lineTo(o.x, o.y);
  };
  let n = t[t.length - 1];
  for (let a = 0; a < t.length; a++) {
    const o = t[a % t.length], h = o.radius ?? e;
    if (h <= 0) {
      r(a, o), n = o;
      continue;
    }
    const u = t[(a + 1) % t.length], c = s(o, n), l = s(o, u);
    if (c.len < 1e-4 || l.len < 1e-4) {
      r(a, o), n = o;
      continue;
    }
    let _ = Math.asin(c.nx * l.ny - c.ny * l.nx), d = 1, f = !1;
    c.nx * l.nx - c.ny * -l.ny < 0 ? _ < 0 ? _ = Math.PI + _ : (_ = Math.PI - _, d = -1, f = !0) : _ > 0 && (d = -1, f = !0);
    const p = _ / 2;
    let g, m = Math.abs(
      Math.cos(p) * h / Math.sin(p)
    );
    m > Math.min(c.len / 2, l.len / 2) ? (m = Math.min(c.len / 2, l.len / 2), g = Math.abs(m * Math.sin(p) / Math.cos(p))) : g = h;
    const O = o.x + l.nx * m + -l.ny * g * d, y = o.y + l.ny * m + l.nx * g * d, C = Math.atan2(c.ny, c.nx) + Math.PI / 2 * d, b = Math.atan2(l.ny, l.nx) - Math.PI / 2 * d;
    a === 0 && i.moveTo(
      O + Math.cos(C) * g,
      y + Math.sin(C) * g
    ), i.arc(O, y, g, C, b, f), n = o;
  }
}
function $N(i, t, e, s) {
  const r = (o, h) => Math.sqrt((o.x - h.x) ** 2 + (o.y - h.y) ** 2), n = (o, h, u) => ({
    x: o.x + (h.x - o.x) * u,
    y: o.y + (h.y - o.y) * u
  }), a = t.length;
  for (let o = 0; o < a; o++) {
    const h = t[(o + 1) % a], u = h.radius ?? e;
    if (u <= 0) {
      o === 0 ? i.moveTo(h.x, h.y) : i.lineTo(h.x, h.y);
      continue;
    }
    const c = t[o], l = t[(o + 2) % a], _ = r(c, h);
    let d;
    if (_ < 1e-4)
      d = h;
    else {
      const g = Math.min(_ / 2, u);
      d = n(
        h,
        c,
        g / _
      );
    }
    const f = r(l, h);
    let p;
    if (f < 1e-4)
      p = h;
    else {
      const g = Math.min(f / 2, u);
      p = n(
        h,
        l,
        g / f
      );
    }
    o === 0 ? i.moveTo(d.x, d.y) : i.lineTo(d.x, d.y), i.quadraticCurveTo(h.x, h.y, p.x, p.y, s);
  }
}
const ZN = new Kt();
class QN {
  constructor(t) {
    this.shapePrimitives = [], this._currentPoly = null, this._bounds = new Zs(), this._graphicsPath2D = t;
  }
  /**
   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
   * @param x - The x-coordinate for the starting point.
   * @param y - The y-coordinate for the starting point.
   * @returns The instance of the current object for chaining.
   */
  moveTo(t, e) {
    return this.startPoly(t, e), this;
  }
  /**
   * Connects the current point to a new point with a straight line. This method updates the current path.
   * @param x - The x-coordinate of the new point to connect to.
   * @param y - The y-coordinate of the new point to connect to.
   * @returns The instance of the current object for chaining.
   */
  lineTo(t, e) {
    this._ensurePoly();
    const s = this._currentPoly.points, r = s[s.length - 2], n = s[s.length - 1];
    return (r !== t || n !== e) && s.push(t, e), this;
  }
  /**
   * Adds an arc to the path. The arc is centered at (x, y)
   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.
   * @param x - The x-coordinate of the arc's center.
   * @param y - The y-coordinate of the arc's center.
   * @param radius - The radius of the arc.
   * @param startAngle - The starting angle of the arc, in radians.
   * @param endAngle - The ending angle of the arc, in radians.
   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.
   * @returns The instance of the current object for chaining.
   */
  arc(t, e, s, r, n, a) {
    this._ensurePoly(!1);
    const o = this._currentPoly.points;
    return z0(o, t, e, s, r, n, a), this;
  }
  /**
   * Adds an arc to the path with the arc tangent to the line joining two specified points.
   * The arc radius is specified by `radius`.
   * @param x1 - The x-coordinate of the first point.
   * @param y1 - The y-coordinate of the first point.
   * @param x2 - The x-coordinate of the second point.
   * @param y2 - The y-coordinate of the second point.
   * @param radius - The radius of the arc.
   * @returns The instance of the current object for chaining.
   */
  arcTo(t, e, s, r, n) {
    this._ensurePoly();
    const a = this._currentPoly.points;
    return WN(a, t, e, s, r, n), this;
  }
  /**
   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
   * @param rx - The x-radius of the ellipse.
   * @param ry - The y-radius of the ellipse.
   * @param xAxisRotation - The rotation of the ellipse's x-axis relative
   * to the x-axis of the coordinate system, in degrees.
   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
   * @param x - The x-coordinate of the arc's end point.
   * @param y - The y-coordinate of the arc's end point.
   * @returns The instance of the current object for chaining.
   */
  arcToSvg(t, e, s, r, n, a, o) {
    const h = this._currentPoly.points;
    return KN(
      h,
      this._currentPoly.lastX,
      this._currentPoly.lastY,
      a,
      o,
      t,
      e,
      s,
      r,
      n
    ), this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires three points: the first two are control points and the third one is the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the first control point.
   * @param cp1y - The y-coordinate of the first control point.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveTo(t, e, s, r, n, a, o) {
    this._ensurePoly();
    const h = this._currentPoly;
    return k0(
      this._currentPoly.points,
      h.lastX,
      h.lastY,
      t,
      e,
      s,
      r,
      n,
      a,
      o
    ), this;
  }
  /**
   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the control point.
   * @param cp1y - The y-coordinate of the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothing - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveTo(t, e, s, r, n) {
    this._ensurePoly();
    const a = this._currentPoly;
    return HN(
      this._currentPoly.points,
      a.lastX,
      a.lastY,
      t,
      e,
      s,
      r,
      n
    ), this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    return this.endPoly(!0), this;
  }
  /**
   * Adds another path to the current path. This method allows for the combination of multiple paths into one.
   * @param path - The `GraphicsPath` object representing the path to add.
   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.
   * @returns The instance of the current object for chaining.
   */
  addPath(t, e) {
    this.endPoly(), e && !e.isIdentity() && (t = t.clone(!0), t.transform(e));
    for (let s = 0; s < t.instructions.length; s++) {
      const r = t.instructions[s];
      this[r.action](...r.data);
    }
    return this;
  }
  /**
   * Finalizes the drawing of the current path. Optionally, it can close the path.
   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.
   */
  finish(t = !1) {
    this.endPoly(t);
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(t, e, s, r, n) {
    return this.drawShape(new Kt(t, e, s, r), n), this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @param transform - An optional `Matrix` object to apply a transformation to the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(t, e, s, r) {
    return this.drawShape(new IT(t, e, s), r), this;
  }
  /**
   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.
   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
   * representing the x and y coordinates of the polygon's vertices, in sequence.
   * @param close - A boolean indicating whether to close the polygon path. True by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  poly(t, e, s) {
    const r = new Th(t);
    return r.closePath = e, this.drawShape(r, s), this;
  }
  /**
   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  regularPoly(t, e, s, r, n = 0, a) {
    r = Math.max(r | 0, 3);
    const o = -1 * Math.PI / 2 + n, h = Math.PI * 2 / r, u = [];
    for (let c = 0; c < r; c++) {
      const l = c * h + o;
      u.push(
        t + s * Math.cos(l),
        e + s * Math.sin(l)
      );
    }
    return this.poly(u, !0, a), this;
  }
  /**
   * Draws a polygon with rounded corners.
   * Similar to `regularPoly` but with the ability to round the corners of the polygon.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param corner - The radius of the rounding of the corners.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.
   * @returns The instance of the current object for chaining.
   */
  roundPoly(t, e, s, r, n, a = 0, o) {
    if (r = Math.max(r | 0, 3), n <= 0)
      return this.regularPoly(t, e, s, r, a);
    const h = s * Math.sin(Math.PI / r) - 1e-3;
    n = Math.min(n, h);
    const u = -1 * Math.PI / 2 + a, c = Math.PI * 2 / r, l = (r - 2) * Math.PI / r / 2;
    for (let _ = 0; _ < r; _++) {
      const d = _ * c + u, f = t + s * Math.cos(d), p = e + s * Math.sin(d), g = d + Math.PI + l, m = d - Math.PI - l, O = f + n * Math.cos(g), y = p + n * Math.sin(g), C = f + n * Math.cos(m), b = p + n * Math.sin(m);
      _ === 0 ? this.moveTo(O, y) : this.lineTo(O, y), this.quadraticCurveTo(f, p, C, b, o);
    }
    return this.closePath();
  }
  /**
   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
   * A minimum of 3 points is required.
   * @param radius - The default radius for the corners.
   * This radius is applied to all corners unless overridden in `points`.
   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
   *  method instead of an arc method. Defaults to false.
   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
   * Higher values make the curve smoother.
   * @returns The instance of the current object for chaining.
   */
  roundShape(t, e, s = !1, r) {
    return t.length < 3 ? this : (s ? $N(this, t, e, r) : qN(this, t, e), this.closePath());
  }
  /**
   * Draw Rectangle with fillet corners. This is much like rounded rectangle
   * however it support negative numbers as well for the corner radius.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param fillet - accept negative or positive values
   */
  filletRect(t, e, s, r, n) {
    if (n === 0)
      return this.rect(t, e, s, r);
    const a = Math.min(s, r) / 2, o = Math.min(a, Math.max(-a, n)), h = t + s, u = e + r, c = o < 0 ? -o : 0, l = Math.abs(o);
    return this.moveTo(t, e + l).arcTo(t + c, e + c, t + l, e, l).lineTo(h - l, e).arcTo(h - c, e + c, h, e + l, l).lineTo(h, u - l).arcTo(h - c, u - c, t + s - l, u, l).lineTo(t + l, u).arcTo(t + c, u - c, t, u - l, l).closePath();
  }
  /**
   * Draw Rectangle with chamfer corners. These are angled corners.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param chamfer - non-zero real number, size of corner cutout
   * @param transform
   */
  chamferRect(t, e, s, r, n, a) {
    if (n <= 0)
      return this.rect(t, e, s, r);
    const o = Math.min(n, Math.min(s, r) / 2), h = t + s, u = e + r, c = [
      t + o,
      e,
      h - o,
      e,
      h,
      e + o,
      h,
      u - o,
      h - o,
      u,
      t + o,
      u,
      t,
      u - o,
      t,
      e + o
    ];
    for (let l = c.length - 1; l >= 2; l -= 2)
      c[l] === c[l - 2] && c[l - 1] === c[l - 3] && c.splice(l - 1, 2);
    return this.poly(c, !0, a);
  }
  /**
   * Draws an ellipse at the specified location and with the given x and y radii.
   * An optional transformation can be applied, allowing for rotation, scaling, and translation.
   * @param x - The x-coordinate of the center of the ellipse.
   * @param y - The y-coordinate of the center of the ellipse.
   * @param radiusX - The horizontal radius of the ellipse.
   * @param radiusY - The vertical radius of the ellipse.
   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.
   * @returns The instance of the current object for chaining.
   */
  ellipse(t, e, s, r, n) {
    return this.drawShape(new ST(t, e, s, r), n), this;
  }
  /**
   * Draws a rectangle with rounded corners.
   * The corner radius can be specified to determine how rounded the corners should be.
   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  roundRect(t, e, s, r, n, a) {
    return this.drawShape(new AT(t, e, s, r, n), a), this;
  }
  /**
   * Draws a given shape on the canvas.
   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.
   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.
   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.
   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,
   * scaling, and translations.
   * @returns The instance of the current object for chaining.
   */
  drawShape(t, e) {
    return this.endPoly(), this.shapePrimitives.push({ shape: t, transform: e }), this;
  }
  /**
   * Starts a new polygon path from the specified starting point.
   * This method initializes a new polygon or ends the current one if it exists.
   * @param x - The x-coordinate of the starting point of the new polygon.
   * @param y - The y-coordinate of the starting point of the new polygon.
   * @returns The instance of the current object for chaining.
   */
  startPoly(t, e) {
    let s = this._currentPoly;
    return s && this.endPoly(), s = new Th(), s.points.push(t, e), this._currentPoly = s, this;
  }
  /**
   * Ends the current polygon path. If `closePath` is set to true,
   * the path is closed by connecting the last point to the first one.
   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.
   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point
   *  back to the starting point. False by default.
   * @returns The instance of the current object for chaining.
   */
  endPoly(t = !1) {
    const e = this._currentPoly;
    return e && e.points.length > 2 && (e.closePath = t, this.shapePrimitives.push({ shape: e })), this._currentPoly = null, this;
  }
  _ensurePoly(t = !0) {
    if (!this._currentPoly && (this._currentPoly = new Th(), t)) {
      const e = this.shapePrimitives[this.shapePrimitives.length - 1];
      if (e) {
        let s = e.shape.x, r = e.shape.y;
        if (e.transform && !e.transform.isIdentity()) {
          const n = e.transform, a = s;
          s = n.a * s + n.c * r + n.tx, r = n.b * a + n.d * r + n.ty;
        }
        this._currentPoly.points.push(s, r);
      } else
        this._currentPoly.points.push(0, 0);
    }
  }
  /** Builds the path. */
  buildPath() {
    const t = this._graphicsPath2D;
    this.shapePrimitives.length = 0, this._currentPoly = null;
    for (let e = 0; e < t.instructions.length; e++) {
      const s = t.instructions[e];
      this[s.action](...s.data);
    }
    this.finish();
  }
  /** Gets the bounds of the path. */
  get bounds() {
    const t = this._bounds;
    t.clear();
    const e = this.shapePrimitives;
    for (let s = 0; s < e.length; s++) {
      const r = e[s], n = r.shape.getBounds(ZN);
      r.transform ? t.addRect(n, r.transform) : t.addRect(n);
    }
    return t;
  }
}
class Lo {
  /**
   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.
   * @param instructions - An SVG path string or an array of `PathInstruction` objects.
   */
  constructor(t) {
    this.instructions = [], this.uid = me("graphicsPath"), this._dirty = !0, typeof t == "string" ? UP(t, this) : this.instructions = (t == null ? void 0 : t.slice()) ?? [];
  }
  /**
   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.
   * @returns The `ShapePath` instance associated with this `GraphicsPath`.
   */
  get shapePath() {
    return this._shapePath || (this._shapePath = new QN(this)), this._dirty && (this._dirty = !1, this._shapePath.buildPath()), this._shapePath;
  }
  /**
   * Adds another `GraphicsPath` to this path, optionally applying a transformation.
   * @param path - The `GraphicsPath` to add.
   * @param transform - An optional transformation to apply to the added path.
   * @returns The instance of the current object for chaining.
   */
  addPath(t, e) {
    return t = t.clone(), this.instructions.push({ action: "addPath", data: [t, e] }), this._dirty = !0, this;
  }
  arc(...t) {
    return this.instructions.push({ action: "arc", data: t }), this._dirty = !0, this;
  }
  arcTo(...t) {
    return this.instructions.push({ action: "arcTo", data: t }), this._dirty = !0, this;
  }
  arcToSvg(...t) {
    return this.instructions.push({ action: "arcToSvg", data: t }), this._dirty = !0, this;
  }
  bezierCurveTo(...t) {
    return this.instructions.push({ action: "bezierCurveTo", data: t }), this._dirty = !0, this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires two points: the second control point and the end point. The first control point is assumed to be
   * The starting point is the last point in the current path.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveToShort(t, e, s, r, n) {
    const a = this.instructions[this.instructions.length - 1], o = this.getLastPoint(st.shared);
    let h = 0, u = 0;
    if (!a || a.action !== "bezierCurveTo")
      h = o.x, u = o.y;
    else {
      h = a.data[2], u = a.data[3];
      const c = o.x, l = o.y;
      h = c + (c - h), u = l + (l - u);
    }
    return this.instructions.push({ action: "bezierCurveTo", data: [h, u, t, e, s, r, n] }), this._dirty = !0, this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    return this.instructions.push({ action: "closePath", data: [] }), this._dirty = !0, this;
  }
  ellipse(...t) {
    return this.instructions.push({ action: "ellipse", data: t }), this._dirty = !0, this;
  }
  lineTo(...t) {
    return this.instructions.push({ action: "lineTo", data: t }), this._dirty = !0, this;
  }
  moveTo(...t) {
    return this.instructions.push({ action: "moveTo", data: t }), this;
  }
  quadraticCurveTo(...t) {
    return this.instructions.push({ action: "quadraticCurveTo", data: t }), this._dirty = !0, this;
  }
  /**
   * Adds a quadratic curve to the path. It uses the previous point as the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveToShort(t, e, s) {
    const r = this.instructions[this.instructions.length - 1], n = this.getLastPoint(st.shared);
    let a = 0, o = 0;
    if (!r || r.action !== "quadraticCurveTo")
      a = n.x, o = n.y;
    else {
      a = r.data[0], o = r.data[1];
      const h = n.x, u = n.y;
      a = h + (h - a), o = u + (u - o);
    }
    return this.instructions.push({ action: "quadraticCurveTo", data: [a, o, t, e, s] }), this._dirty = !0, this;
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(t, e, s, r, n) {
    return this.instructions.push({ action: "rect", data: [t, e, s, r, n] }), this._dirty = !0, this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @param transform - An optional `Matrix` object to apply a transformation to the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(t, e, s, r) {
    return this.instructions.push({ action: "circle", data: [t, e, s, r] }), this._dirty = !0, this;
  }
  roundRect(...t) {
    return this.instructions.push({ action: "roundRect", data: t }), this._dirty = !0, this;
  }
  poly(...t) {
    return this.instructions.push({ action: "poly", data: t }), this._dirty = !0, this;
  }
  regularPoly(...t) {
    return this.instructions.push({ action: "regularPoly", data: t }), this._dirty = !0, this;
  }
  roundPoly(...t) {
    return this.instructions.push({ action: "roundPoly", data: t }), this._dirty = !0, this;
  }
  roundShape(...t) {
    return this.instructions.push({ action: "roundShape", data: t }), this._dirty = !0, this;
  }
  filletRect(...t) {
    return this.instructions.push({ action: "filletRect", data: t }), this._dirty = !0, this;
  }
  chamferRect(...t) {
    return this.instructions.push({ action: "chamferRect", data: t }), this._dirty = !0, this;
  }
  /**
   * Draws a star shape centered at a specified location. This method allows for the creation
   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
   * An optional transformation can be applied to scale, rotate, or translate the star as needed.
   * @param x - The x-coordinate of the center of the star.
   * @param y - The y-coordinate of the center of the star.
   * @param points - The number of points of the star.
   * @param radius - The outer radius of the star (distance from the center to the outer points).
   * @param innerRadius - Optional. The inner radius of the star
   * (distance from the center to the inner points between the outer points).
   * If not provided, defaults to half of the `radius`.
   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
   * Defaults to 0, meaning one point is directly upward.
   * @param transform - An optional `Matrix` object to apply a transformation to the star.
   * This can include rotations, scaling, and translations.
   * @returns The instance of the current object for chaining further drawing commands.
   */
  // eslint-disable-next-line max-len
  star(t, e, s, r, n, a, o) {
    n = n || r / 2;
    const h = -1 * Math.PI / 2 + a, u = s * 2, c = Math.PI * 2 / u, l = [];
    for (let _ = 0; _ < u; _++) {
      const d = _ % 2 ? n : r, f = _ * c + h;
      l.push(
        t + d * Math.cos(f),
        e + d * Math.sin(f)
      );
    }
    return this.poly(l, !0, o), this;
  }
  /**
   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.
   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and
   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`
   * do not affect the original `GraphicsPath` and vice versa.
   * @param deep - A boolean flag indicating whether the clone should be deep.
   * @returns A new `GraphicsPath` instance that is a clone of the current instance.
   */
  clone(t = !1) {
    const e = new Lo();
    if (!t)
      e.instructions = this.instructions.slice();
    else
      for (let s = 0; s < this.instructions.length; s++) {
        const r = this.instructions[s];
        e.instructions.push({ action: r.action, data: r.data.slice() });
      }
    return e;
  }
  clear() {
    return this.instructions.length = 0, this._dirty = !0, this;
  }
  /**
   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.
   * This method enables the modification of the path's geometry according to the provided
   * transformation matrix, which can include translations, rotations, scaling, and skewing.
   *
   * Each drawing instruction in the path is updated to reflect the transformation,
   * ensuring the visual representation of the path is consistent with the applied matrix.
   *
   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,
   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,
   * allowing for fine-grained control over the path's appearance.
   * @param matrix - A `Matrix` object representing the transformation to apply.
   * @returns The instance of the current object for chaining further operations.
   */
  transform(t) {
    if (t.isIdentity())
      return this;
    const e = t.a, s = t.b, r = t.c, n = t.d, a = t.tx, o = t.ty;
    let h = 0, u = 0, c = 0, l = 0, _ = 0, d = 0, f = 0, p = 0;
    for (let g = 0; g < this.instructions.length; g++) {
      const m = this.instructions[g], O = m.data;
      switch (m.action) {
        case "moveTo":
        case "lineTo":
          h = O[0], u = O[1], O[0] = e * h + r * u + a, O[1] = s * h + n * u + o;
          break;
        case "bezierCurveTo":
          c = O[0], l = O[1], _ = O[2], d = O[3], h = O[4], u = O[5], O[0] = e * c + r * l + a, O[1] = s * c + n * l + o, O[2] = e * _ + r * d + a, O[3] = s * _ + n * d + o, O[4] = e * h + r * u + a, O[5] = s * h + n * u + o;
          break;
        case "quadraticCurveTo":
          c = O[0], l = O[1], h = O[2], u = O[3], O[0] = e * c + r * l + a, O[1] = s * c + n * l + o, O[2] = e * h + r * u + a, O[3] = s * h + n * u + o;
          break;
        case "arcToSvg":
          h = O[5], u = O[6], f = O[0], p = O[1], O[0] = e * f + r * p, O[1] = s * f + n * p, O[5] = e * h + r * u + a, O[6] = s * h + n * u + o;
          break;
        case "circle":
          O[4] = hh(O[3], t);
          break;
        case "rect":
          O[4] = hh(O[4], t);
          break;
        case "ellipse":
          O[8] = hh(O[8], t);
          break;
        case "roundRect":
          O[5] = hh(O[5], t);
          break;
        case "addPath":
          O[0].transform(t);
          break;
        case "poly":
          O[2] = hh(O[2], t);
          break;
        default:
          ce("unknown transform action", m.action);
          break;
      }
    }
    return this._dirty = !0, this;
  }
  get bounds() {
    return this.shapePath.bounds;
  }
  /**
   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.
   * This method is useful for operations that depend on the path's current endpoint,
   * such as connecting subsequent shapes or paths. It supports various drawing instructions,
   * ensuring the last point's position is accurately determined regardless of the path's complexity.
   *
   * If the last instruction is a `closePath`, the method iterates backward through the instructions
   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,
   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves
   * the last point from the nested path.
   * @param out - A `Point` object where the last point's coordinates will be stored.
   * This object is modified directly to contain the result.
   * @returns The `Point` object containing the last point's coordinates.
   */
  getLastPoint(t) {
    let e = this.instructions.length - 1, s = this.instructions[e];
    if (!s)
      return t.x = 0, t.y = 0, t;
    for (; s.action === "closePath"; ) {
      if (e--, e < 0)
        return t.x = 0, t.y = 0, t;
      s = this.instructions[e];
    }
    switch (s.action) {
      case "moveTo":
      case "lineTo":
        t.x = s.data[0], t.y = s.data[1];
        break;
      case "quadraticCurveTo":
        t.x = s.data[2], t.y = s.data[3];
        break;
      case "bezierCurveTo":
        t.x = s.data[4], t.y = s.data[5];
        break;
      case "arc":
      case "arcToSvg":
        t.x = s.data[5], t.y = s.data[6];
        break;
      case "addPath":
        s.data[0].getLastPoint(t);
        break;
    }
    return t;
  }
}
function hh(i, t) {
  return i ? i.prepend(t) : t.clone();
}
function JN(i, t) {
  if (typeof i == "string") {
    const s = document.createElement("div");
    s.innerHTML = i.trim(), i = s.querySelector("svg");
  }
  const e = {
    context: t,
    path: new Lo()
  };
  return V0(i, e, null, null), t;
}
function V0(i, t, e, s) {
  const r = i.children, { fillStyle: n, strokeStyle: a } = tU(i);
  n && e ? e = { ...e, ...n } : n && (e = n), a && s ? s = { ...s, ...a } : a && (s = a), t.context.fillStyle = e, t.context.strokeStyle = s;
  let o, h, u, c, l, _, d, f, p, g, m, O, y, C, b, D, P;
  switch (i.nodeName.toLowerCase()) {
    case "path":
      C = i.getAttribute("d"), b = new Lo(C), t.context.path(b), e && t.context.fill(), s && t.context.stroke();
      break;
    case "circle":
      d = Ue(i, "cx", 0), f = Ue(i, "cy", 0), p = Ue(i, "r", 0), t.context.ellipse(d, f, p, p), e && t.context.fill(), s && t.context.stroke();
      break;
    case "rect":
      o = Ue(i, "x", 0), h = Ue(i, "y", 0), D = Ue(i, "width", 0), P = Ue(i, "height", 0), g = Ue(i, "rx", 0), m = Ue(i, "ry", 0), g || m ? t.context.roundRect(o, h, D, P, g || m) : t.context.rect(o, h, D, P), e && t.context.fill(), s && t.context.stroke();
      break;
    case "ellipse":
      d = Ue(i, "cx", 0), f = Ue(i, "cy", 0), g = Ue(i, "rx", 0), m = Ue(i, "ry", 0), t.context.beginPath(), t.context.ellipse(d, f, g, m), e && t.context.fill(), s && t.context.stroke();
      break;
    case "line":
      u = Ue(i, "x1", 0), c = Ue(i, "y1", 0), l = Ue(i, "x2", 0), _ = Ue(i, "y2", 0), t.context.beginPath(), t.context.moveTo(u, c), t.context.lineTo(l, _), s && t.context.stroke();
      break;
    case "polygon":
      y = i.getAttribute("points"), O = y.match(/\d+/g).map((F) => parseInt(F, 10)), t.context.poly(O, !0), e && t.context.fill(), s && t.context.stroke();
      break;
    case "polyline":
      y = i.getAttribute("points"), O = y.match(/\d+/g).map((F) => parseInt(F, 10)), t.context.poly(O, !1), s && t.context.stroke();
      break;
    case "g":
    case "svg":
      break;
    default: {
      console.info(`[SVG parser] <${i.nodeName}> elements unsupported`);
      break;
    }
  }
  for (let F = 0; F < r.length; F++)
    V0(r[F], t, e, s);
}
function Ue(i, t, e) {
  const s = i.getAttribute(t);
  return s ? Number(s) : e;
}
function tU(i) {
  const t = i.getAttribute("style"), e = {}, s = {};
  let r = !1, n = !1;
  if (t) {
    const a = t.split(";");
    for (let o = 0; o < a.length; o++) {
      const h = a[o], [u, c] = h.split(":");
      switch (u) {
        case "stroke":
          c !== "none" && (e.color = Pt.shared.setValue(c).toNumber(), n = !0);
          break;
        case "stroke-width":
          e.width = Number(c);
          break;
        case "fill":
          c !== "none" && (r = !0, s.color = Pt.shared.setValue(c).toNumber());
          break;
        case "fill-opacity":
          s.alpha = Number(c);
          break;
        case "stroke-opacity":
          e.alpha = Number(c);
          break;
        case "opacity":
          s.alpha = Number(c), e.alpha = Number(c);
          break;
      }
    }
  } else {
    const a = i.getAttribute("stroke");
    a && a !== "none" && (n = !0, e.color = Pt.shared.setValue(a).toNumber(), e.width = Ue(i, "stroke-width", 1));
    const o = i.getAttribute("fill");
    o && o !== "none" && (r = !0, s.color = Pt.shared.setValue(o).toNumber());
  }
  return {
    strokeStyle: n ? e : null,
    fillStyle: r ? s : null
  };
}
function eU(i) {
  return Pt.isColorLike(i);
}
function DS(i) {
  return i instanceof Dd;
}
function LS(i) {
  return i instanceof gu;
}
function sU(i, t, e) {
  const s = Pt.shared.setValue(t ?? 0);
  return i.color = s.toNumber(), i.alpha = s.alpha === 1 ? e.alpha : s.alpha, i.texture = W.WHITE, { ...e, ...i };
}
function FS(i, t, e) {
  return i.fill = t, i.color = 16777215, i.texture = t.texture, i.matrix = t.transform, { ...e, ...i };
}
function wS(i, t, e) {
  return t.buildLinearGradient(), i.fill = t, i.color = 16777215, i.texture = t.texture, i.matrix = t.transform, { ...e, ...i };
}
function iU(i, t) {
  var r;
  const e = { ...t, ...i };
  if (e.texture) {
    if (e.texture !== W.WHITE) {
      const a = ((r = e.matrix) == null ? void 0 : r.invert()) || new ot();
      a.translate(e.texture.frame.x, e.texture.frame.y), a.scale(1 / e.texture.source.width, 1 / e.texture.source.height), e.matrix = a;
    }
    const n = e.texture.source.style;
    n.addressMode === "clamp-to-edge" && (n.addressMode = "repeat", n.update());
  }
  const s = Pt.shared.setValue(e.color);
  return e.alpha *= s.alpha, e.color = s.toNumber(), e.matrix = e.matrix ? e.matrix.clone() : null, e;
}
function ia(i, t) {
  if (i == null)
    return null;
  const e = {}, s = i;
  return eU(i) ? sU(e, i, t) : DS(i) ? FS(e, i, t) : LS(i) ? wS(e, i, t) : s.fill && DS(s.fill) ? FS(s, s.fill, t) : s.fill && LS(s.fill) ? wS(s, s.fill, t) : iU(s, t);
}
function Vl(i, t) {
  const { width: e, alignment: s, miterLimit: r, cap: n, join: a, ...o } = t, h = ia(i, o);
  return h ? {
    width: e,
    alignment: s,
    miterLimit: r,
    cap: n,
    join: a,
    ...h
  } : null;
}
const rU = new st(), GS = new ot(), MT = class Ti extends Js {
  constructor() {
    super(...arguments), this.uid = me("graphicsContext"), this.dirty = !0, this.batchMode = "auto", this.instructions = [], this._activePath = new Lo(), this._transform = new ot(), this._fillStyle = { ...Ti.defaultFillStyle }, this._strokeStyle = { ...Ti.defaultStrokeStyle }, this._stateStack = [], this._tick = 0, this._bounds = new Zs(), this._boundsDirty = !0;
  }
  /**
   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,
   * including the current drawing state, transformations, styles, and instructions.
   * @returns A new GraphicsContext instance with the same properties and state as this one.
   */
  clone() {
    const t = new Ti();
    return t.batchMode = this.batchMode, t.instructions = this.instructions.slice(), t._activePath = this._activePath.clone(), t._transform = this._transform.clone(), t._fillStyle = { ...this._fillStyle }, t._strokeStyle = { ...this._strokeStyle }, t._stateStack = this._stateStack.slice(), t._bounds = this._bounds.clone(), t._boundsDirty = !0, t;
  }
  /**
   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.
   */
  get fillStyle() {
    return this._fillStyle;
  }
  set fillStyle(t) {
    this._fillStyle = ia(t, Ti.defaultFillStyle);
  }
  /**
   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
   */
  get strokeStyle() {
    return this._strokeStyle;
  }
  set strokeStyle(t) {
    this._strokeStyle = Vl(t, Ti.defaultStrokeStyle);
  }
  /**
   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
   * pattern, or a more complex style defined by a FillStyle object.
   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,
   *                or a FillStyle or ConvertedFillStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setFillStyle(t) {
    return this._fillStyle = ia(t, Ti.defaultFillStyle), this;
  }
  /**
   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,
   *                or a StrokeStyle or ConvertedStrokeStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setStrokeStyle(t) {
    return this._strokeStyle = ia(t, Ti.defaultStrokeStyle), this;
  }
  texture(t, e, s, r, n, a) {
    return this.instructions.push({
      action: "texture",
      data: {
        image: t,
        dx: s || 0,
        dy: r || 0,
        dw: n || t.frame.width,
        dh: a || t.frame.height,
        transform: this._transform.clone(),
        alpha: this._fillStyle.alpha,
        style: e ? Pt.shared.setValue(e).toNumber() : 16777215
      }
    }), this.onUpdate(), this;
  }
  /**
   * Resets the current path. Any previous path and its commands are discarded and a new path is
   * started. This is typically called before beginning a new shape or series of drawing commands.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  beginPath() {
    return this._activePath = new Lo(), this;
  }
  fill(t, e) {
    let s;
    const r = this.instructions[this.instructions.length - 1];
    return this._tick === 0 && r && r.action === "stroke" ? s = r.data.path : s = this._activePath.clone(), s ? (t != null && (e !== void 0 && typeof t == "number" && (dt(Se, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), t = { color: t, alpha: e }), this._fillStyle = ia(t, Ti.defaultFillStyle)), this.instructions.push({
      action: "fill",
      // TODO copy fill style!
      data: { style: this.fillStyle, path: s }
    }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
  }
  _initNextPathLocation() {
    const { x: t, y: e } = this._activePath.getLastPoint(st.shared);
    this._activePath.clear(), this._activePath.moveTo(t, e);
  }
  /**
   * Strokes the current path with the current stroke style. This method can take an optional
   * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.
   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  stroke(t) {
    let e;
    const s = this.instructions[this.instructions.length - 1];
    return this._tick === 0 && s && s.action === "fill" ? e = s.data.path : e = this._activePath.clone(), e ? (t != null && (this._strokeStyle = Vl(t, Ti.defaultStrokeStyle)), this.instructions.push({
      action: "stroke",
      // TODO copy fill style!
      data: { style: this.strokeStyle, path: e }
    }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
  }
  /**
   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
   * fail to cut correctly!
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  cut() {
    for (let t = 0; t < 2; t++) {
      const e = this.instructions[this.instructions.length - 1 - t], s = this._activePath.clone();
      if (e && (e.action === "stroke" || e.action === "fill"))
        if (e.data.hole)
          e.data.hole.addPath(s);
        else {
          e.data.hole = s;
          break;
        }
    }
    return this._initNextPathLocation(), this;
  }
  /**
   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,
   * starting and ending angles, and direction.
   * @param x - The x-coordinate of the arc's center.
   * @param y - The y-coordinate of the arc's center.
   * @param radius - The arc's radius.
   * @param startAngle - The starting angle, in radians.
   * @param endAngle - The ending angle, in radians.
   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  arc(t, e, s, r, n, a) {
    this._tick++;
    const o = this._transform;
    return this._activePath.arc(
      o.a * t + o.c * e + o.tx,
      o.b * t + o.d * e + o.ty,
      s,
      r,
      n,
      a
    ), this;
  }
  /**
   * Adds an arc to the current path with the given control points and radius, connected to the previous point
   * by a straight line if necessary.
   * @param x1 - The x-coordinate of the first control point.
   * @param y1 - The y-coordinate of the first control point.
   * @param x2 - The x-coordinate of the second control point.
   * @param y2 - The y-coordinate of the second control point.
   * @param radius - The arc's radius.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  arcTo(t, e, s, r, n) {
    this._tick++;
    const a = this._transform;
    return this._activePath.arcTo(
      a.a * t + a.c * e + a.tx,
      a.b * t + a.d * e + a.ty,
      a.a * s + a.c * r + a.tx,
      a.b * s + a.d * r + a.ty,
      n
    ), this;
  }
  /**
   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
   * @param rx - The x-radius of the ellipse.
   * @param ry - The y-radius of the ellipse.
   * @param xAxisRotation - The rotation of the ellipse's x-axis relative
   * to the x-axis of the coordinate system, in degrees.
   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
   * @param x - The x-coordinate of the arc's end point.
   * @param y - The y-coordinate of the arc's end point.
   * @returns The instance of the current object for chaining.
   */
  arcToSvg(t, e, s, r, n, a, o) {
    this._tick++;
    const h = this._transform;
    return this._activePath.arcToSvg(
      t,
      e,
      s,
      // should we rotate this with transform??
      r,
      n,
      h.a * a + h.c * o + h.tx,
      h.b * a + h.d * o + h.ty
    ), this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires three points: the first two are control points and the third one is the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the first control point.
   * @param cp1y - The y-coordinate of the first control point.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveTo(t, e, s, r, n, a, o) {
    this._tick++;
    const h = this._transform;
    return this._activePath.bezierCurveTo(
      h.a * t + h.c * e + h.tx,
      h.b * t + h.d * e + h.ty,
      h.a * s + h.c * r + h.tx,
      h.b * s + h.d * r + h.ty,
      h.a * n + h.c * a + h.tx,
      h.b * n + h.d * a + h.ty,
      o
    ), this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    var t;
    return this._tick++, (t = this._activePath) == null || t.closePath(), this;
  }
  /**
   * Draws an ellipse at the specified location and with the given x and y radii.
   * An optional transformation can be applied, allowing for rotation, scaling, and translation.
   * @param x - The x-coordinate of the center of the ellipse.
   * @param y - The y-coordinate of the center of the ellipse.
   * @param radiusX - The horizontal radius of the ellipse.
   * @param radiusY - The vertical radius of the ellipse.
   * @returns The instance of the current object for chaining.
   */
  ellipse(t, e, s, r) {
    return this._tick++, this._activePath.ellipse(t, e, s, r, this._transform.clone()), this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(t, e, s) {
    return this._tick++, this._activePath.circle(t, e, s, this._transform.clone()), this;
  }
  /**
   * Adds another `GraphicsPath` to this path, optionally applying a transformation.
   * @param path - The `GraphicsPath` to add.
   * @returns The instance of the current object for chaining.
   */
  path(t) {
    return this._tick++, this._activePath.addPath(t, this._transform.clone()), this;
  }
  /**
   * Connects the current point to a new point with a straight line. This method updates the current path.
   * @param x - The x-coordinate of the new point to connect to.
   * @param y - The y-coordinate of the new point to connect to.
   * @returns The instance of the current object for chaining.
   */
  lineTo(t, e) {
    this._tick++;
    const s = this._transform;
    return this._activePath.lineTo(
      s.a * t + s.c * e + s.tx,
      s.b * t + s.d * e + s.ty
    ), this;
  }
  /**
   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
   * @param x - The x-coordinate for the starting point.
   * @param y - The y-coordinate for the starting point.
   * @returns The instance of the current object for chaining.
   */
  moveTo(t, e) {
    this._tick++;
    const s = this._transform, r = this._activePath.instructions, n = s.a * t + s.c * e + s.tx, a = s.b * t + s.d * e + s.ty;
    return r.length === 1 && r[0].action === "moveTo" ? (r[0].data[0] = n, r[0].data[1] = a, this) : (this._activePath.moveTo(
      n,
      a
    ), this);
  }
  /**
   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
   * The starting point is the last point in the current path.
   * @param cpx - The x-coordinate of the control point.
   * @param cpy - The y-coordinate of the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveTo(t, e, s, r, n) {
    this._tick++;
    const a = this._transform;
    return this._activePath.quadraticCurveTo(
      a.a * t + a.c * e + a.tx,
      a.b * t + a.d * e + a.ty,
      a.a * s + a.c * r + a.tx,
      a.b * s + a.d * r + a.ty,
      n
    ), this;
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(t, e, s, r) {
    return this._tick++, this._activePath.rect(t, e, s, r, this._transform.clone()), this;
  }
  /**
   * Draws a rectangle with rounded corners.
   * The corner radius can be specified to determine how rounded the corners should be.
   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
   * @returns The instance of the current object for chaining.
   */
  roundRect(t, e, s, r, n) {
    return this._tick++, this._activePath.roundRect(t, e, s, r, n, this._transform.clone()), this;
  }
  /**
   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,
   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,
   * rotated, or translated as needed.
   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
   * representing the x and y coordinates, of the polygon's vertices, in sequence.
   * @param close - A boolean indicating whether to close the polygon path. True by default.
   */
  poly(t, e) {
    return this._tick++, this._activePath.poly(t, e, this._transform.clone()), this;
  }
  /**
   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  regularPoly(t, e, s, r, n = 0, a) {
    return this._tick++, this._activePath.regularPoly(t, e, s, r, n, a), this;
  }
  /**
   * Draws a polygon with rounded corners.
   * Similar to `regularPoly` but with the ability to round the corners of the polygon.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param corner - The radius of the rounding of the corners.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @returns The instance of the current object for chaining.
   */
  roundPoly(t, e, s, r, n, a) {
    return this._tick++, this._activePath.roundPoly(t, e, s, r, n, a), this;
  }
  /**
   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
   * A minimum of 3 points is required.
   * @param radius - The default radius for the corners.
   * This radius is applied to all corners unless overridden in `points`.
   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
   *  method instead of an arc method. Defaults to false.
   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
   * Higher values make the curve smoother.
   * @returns The instance of the current object for chaining.
   */
  roundShape(t, e, s, r) {
    return this._tick++, this._activePath.roundShape(t, e, s, r), this;
  }
  /**
   * Draw Rectangle with fillet corners. This is much like rounded rectangle
   * however it support negative numbers as well for the corner radius.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param fillet - accept negative or positive values
   */
  filletRect(t, e, s, r, n) {
    return this._tick++, this._activePath.filletRect(t, e, s, r, n), this;
  }
  /**
   * Draw Rectangle with chamfer corners. These are angled corners.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param chamfer - non-zero real number, size of corner cutout
   * @param transform
   */
  chamferRect(t, e, s, r, n, a) {
    return this._tick++, this._activePath.chamferRect(t, e, s, r, n, a), this;
  }
  /**
   * Draws a star shape centered at a specified location. This method allows for the creation
   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
   * An optional transformation can be applied to scale, rotate, or translate the star as needed.
   * @param x - The x-coordinate of the center of the star.
   * @param y - The y-coordinate of the center of the star.
   * @param points - The number of points of the star.
   * @param radius - The outer radius of the star (distance from the center to the outer points).
   * @param innerRadius - Optional. The inner radius of the star
   * (distance from the center to the inner points between the outer points).
   * If not provided, defaults to half of the `radius`.
   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
   * Defaults to 0, meaning one point is directly upward.
   * @returns The instance of the current object for chaining further drawing commands.
   */
  star(t, e, s, r, n = 0, a = 0) {
    return this._tick++, this._activePath.star(t, e, s, r, n, a, this._transform.clone()), this;
  }
  /**
   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths
   * defined in SVG format to be drawn within the graphics context.
   * @param svg - The SVG string to be parsed and rendered.
   */
  svg(t) {
    return this._tick++, JN(t, this), this;
  }
  /**
   * Restores the most recently saved graphics state by popping the top of the graphics state stack.
   * This includes transformations, fill styles, and stroke styles.
   */
  restore() {
    const t = this._stateStack.pop();
    return t && (this._transform = t.transform, this._fillStyle = t.fillStyle, this._strokeStyle = t.strokeStyle), this;
  }
  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
  save() {
    return this._stateStack.push({
      transform: this._transform.clone(),
      fillStyle: { ...this._fillStyle },
      strokeStyle: { ...this._strokeStyle }
    }), this;
  }
  /**
   * Returns the current transformation matrix of the graphics context.
   * @returns The current transformation matrix.
   */
  getTransform() {
    return this._transform;
  }
  /**
   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  resetTransform() {
    return this._transform.identity(), this;
  }
  /**
   * Applies a rotation transformation to the graphics context around the current origin.
   * @param angle - The angle of rotation in radians.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  rotate(t) {
    return this._transform.rotate(t), this;
  }
  /**
   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.
   * @param x - The scale factor in the horizontal direction.
   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  scale(t, e = t) {
    return this._transform.scale(t, e), this;
  }
  setTransform(t, e, s, r, n, a) {
    return t instanceof ot ? (this._transform.set(t.a, t.b, t.c, t.d, t.tx, t.ty), this) : (this._transform.set(t, e, s, r, n, a), this);
  }
  transform(t, e, s, r, n, a) {
    return t instanceof ot ? (this._transform.append(t), this) : (GS.set(t, e, s, r, n, a), this._transform.append(GS), this);
  }
  /**
   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.
   * @param x - The amount to translate in the horizontal direction.
   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  translate(t, e = t) {
    return this._transform.translate(t, e), this;
  }
  /**
   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
   * and optionally resetting transformations to the identity matrix.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  clear() {
    return this._activePath.clear(), this.instructions.length = 0, this.resetTransform(), this.onUpdate(), this;
  }
  onUpdate() {
    this.dirty || (this.emit("update", this, 16), this.dirty = !0, this._boundsDirty = !0);
  }
  /** The bounds of the graphic shape. */
  get bounds() {
    if (!this._boundsDirty)
      return this._bounds;
    const t = this._bounds;
    t.clear();
    for (let e = 0; e < this.instructions.length; e++) {
      const s = this.instructions[e], r = s.action;
      if (r === "fill") {
        const n = s.data;
        t.addBounds(n.path.bounds);
      } else if (r === "texture") {
        const n = s.data;
        t.addFrame(n.dx, n.dy, n.dx + n.dw, n.dy + n.dh, n.transform);
      }
      if (r === "stroke") {
        const n = s.data, a = n.style.width / 2, o = n.path.bounds;
        t.addFrame(
          o.minX - a,
          o.minY - a,
          o.maxX + a,
          o.maxY + a
        );
      }
    }
    return t;
  }
  /**
   * Check to see if a point is contained within this geometry.
   * @param point - Point to check if it's contained.
   * @returns {boolean} `true` if the point is contained within geometry.
   */
  containsPoint(t) {
    var r;
    if (!this.bounds.containsPoint(t.x, t.y))
      return !1;
    const e = this.instructions;
    let s = !1;
    for (let n = 0; n < e.length; n++) {
      const a = e[n], o = a.data, h = o.path;
      if (!a.action || !h)
        continue;
      const u = o.style, c = h.shapePath.shapePrimitives;
      for (let l = 0; l < c.length; l++) {
        const _ = c[l].shape;
        if (!u || !_)
          continue;
        const d = c[l].transform, f = d ? d.applyInverse(t, rU) : t;
        a.action === "fill" ? s = _.contains(f.x, f.y) : s = _.strokeContains(f.x, f.y, u.width);
        const p = o.hole;
        if (p) {
          const g = (r = p.shapePath) == null ? void 0 : r.shapePrimitives;
          if (g)
            for (let m = 0; m < g.length; m++)
              g[m].shape.contains(f.x, f.y) && (s = !1);
        }
        if (s)
          return !0;
      }
    }
    return s;
  }
  /**
   * Destroys the GraphicsData object.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?
   * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?
   */
  destroy(t = !1) {
    if (this._stateStack.length = 0, this._transform = null, this.emit("destroy", this), this.removeAllListeners(), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
      const s = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
      this._fillStyle.texture && this._fillStyle.texture.destroy(s), this._strokeStyle.texture && this._strokeStyle.texture.destroy(s);
    }
    this._fillStyle = null, this._strokeStyle = null, this.instructions = null, this._activePath = null, this._bounds = null, this._stateStack = null, this.customShader = null, this._transform = null;
  }
};
MT.defaultFillStyle = {
  /** The color to use for the fill. */
  color: 16777215,
  /** The alpha value to use for the fill. */
  alpha: 1,
  /** The texture to use for the fill. */
  texture: W.WHITE,
  /** The matrix to apply. */
  matrix: null,
  /** The fill pattern to use. */
  fill: null
};
MT.defaultStrokeStyle = {
  /** The width of the stroke. */
  width: 1,
  /** The color to use for the stroke. */
  color: 16777215,
  /** The alpha value to use for the stroke. */
  alpha: 1,
  /** The alignment of the stroke. */
  alignment: 0.5,
  /** The miter limit to use. */
  miterLimit: 10,
  /** The line cap style to use. */
  cap: "butt",
  /** The line join style to use. */
  join: "miter",
  /** The texture to use for the fill. */
  texture: W.WHITE,
  /** The matrix to apply. */
  matrix: null,
  /** The fill pattern to use. */
  fill: null
};
let bn = MT;
const BS = [
  "align",
  "breakWords",
  "cssOverrides",
  "fontVariant",
  "fontWeight",
  "leading",
  "letterSpacing",
  "lineHeight",
  "padding",
  "textBaseline",
  "trim",
  "whiteSpace",
  "wordWrap",
  "wordWrapWidth",
  "fontFamily",
  "fontStyle",
  "fontSize"
];
function nU(i) {
  const t = [];
  let e = 0;
  for (let s = 0; s < BS.length; s++) {
    const r = `_${BS[s]}`;
    t[e++] = i[r];
  }
  return e = H0(i._fill, t, e), e = aU(i._stroke, t, e), e = oU(i.dropShadow, t, e), t.join("-");
}
function H0(i, t, e) {
  var s;
  return i && (t[e++] = i.color, t[e++] = i.alpha, t[e++] = (s = i.fill) == null ? void 0 : s.styleKey), e;
}
function aU(i, t, e) {
  return i && (e = H0(i, t, e), t[e++] = i.width, t[e++] = i.alignment, t[e++] = i.cap, t[e++] = i.join, t[e++] = i.miterLimit), e;
}
function oU(i, t, e) {
  return i && (t[e++] = i.alpha, t[e++] = i.angle, t[e++] = i.blur, t[e++] = i.distance, t[e++] = Pt.shared.setValue(i.color).toNumber()), e;
}
const bT = class Da extends Js {
  constructor(t = {}) {
    super(), hU(t);
    const e = { ...Da.defaultTextStyle, ...t };
    for (const s in e) {
      const r = s;
      this[r] = e[s];
    }
    this.update();
  }
  /**
   * Alignment for multiline text, does not affect single line text.
   * @member {'left'|'center'|'right'|'justify'}
   */
  get align() {
    return this._align;
  }
  set align(t) {
    this._align = t, this.update();
  }
  /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
  get breakWords() {
    return this._breakWords;
  }
  set breakWords(t) {
    this._breakWords = t, this.update();
  }
  /** Set a drop shadow for the text. */
  get dropShadow() {
    return this._dropShadow;
  }
  set dropShadow(t) {
    t !== null && typeof t == "object" ? this._dropShadow = this._createProxy({ ...Da.defaultDropShadow, ...t }) : this._dropShadow = t ? this._createProxy({ ...Da.defaultDropShadow }) : null, this.update();
  }
  /** The font family, can be a single font name, or a list of names where the first is the preferred font. */
  get fontFamily() {
    return this._fontFamily;
  }
  set fontFamily(t) {
    this._fontFamily = t, this.update();
  }
  /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(t) {
    typeof t == "string" ? this._fontSize = parseInt(t, 10) : this._fontSize = t, this.update();
  }
  /**
   * The font style.
   * @member {'normal'|'italic'|'oblique'}
   */
  get fontStyle() {
    return this._fontStyle;
  }
  set fontStyle(t) {
    this._fontStyle = t.toLowerCase(), this.update();
  }
  /**
   * The font variant.
   * @member {'normal'|'small-caps'}
   */
  get fontVariant() {
    return this._fontVariant;
  }
  set fontVariant(t) {
    this._fontVariant = t, this.update();
  }
  /**
   * The font weight.
   * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
   */
  get fontWeight() {
    return this._fontWeight;
  }
  set fontWeight(t) {
    this._fontWeight = t, this.update();
  }
  /** The space between lines. */
  get leading() {
    return this._leading;
  }
  set leading(t) {
    this._leading = t, this.update();
  }
  /** The amount of spacing between letters, default is 0. */
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(t) {
    this._letterSpacing = t, this.update();
  }
  /** The line height, a number that represents the vertical space that a letter uses. */
  get lineHeight() {
    return this._lineHeight;
  }
  set lineHeight(t) {
    this._lineHeight = t, this.update();
  }
  /**
   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
   * by adding padding to all sides of the text.
   */
  get padding() {
    return this._padding;
  }
  set padding(t) {
    this._padding = t, this.update();
  }
  /** Trim transparent borders. This is an expensive operation so only use this if you have to! */
  get trim() {
    return this._trim;
  }
  set trim(t) {
    this._trim = t, this.update();
  }
  /**
   * The baseline of the text that is rendered.
   * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
   */
  get textBaseline() {
    return this._textBaseline;
  }
  set textBaseline(t) {
    this._textBaseline = t, this.update();
  }
  /**
   * How newlines and spaces should be handled.
   * Default is 'pre' (preserve, preserve).
   *
   *  value       | New lines     |   Spaces
   *  ---         | ---           |   ---
   * 'normal'     | Collapse      |   Collapse
   * 'pre'        | Preserve      |   Preserve
   * 'pre-line'   | Preserve      |   Collapse
   * @member {'normal'|'pre'|'pre-line'}
   */
  get whiteSpace() {
    return this._whiteSpace;
  }
  set whiteSpace(t) {
    this._whiteSpace = t, this.update();
  }
  /** Indicates if word wrap should be used. */
  get wordWrap() {
    return this._wordWrap;
  }
  set wordWrap(t) {
    this._wordWrap = t, this.update();
  }
  /** The width at which text will wrap, it needs wordWrap to be set to true. */
  get wordWrapWidth() {
    return this._wordWrapWidth;
  }
  set wordWrapWidth(t) {
    this._wordWrapWidth = t, this.update();
  }
  /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */
  get fill() {
    return this._originalFill;
  }
  set fill(t) {
    t !== this._originalFill && (this._originalFill = t, this._isFillStyle(t) && (this._originalFill = this._createProxy({ ...bn.defaultFillStyle, ...t }, () => {
      this._fill = ia(
        { ...this._originalFill },
        bn.defaultFillStyle
      );
    })), this._fill = ia(
      t === 0 ? "black" : t,
      bn.defaultFillStyle
    ), this.update());
  }
  /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */
  get stroke() {
    return this._originalStroke;
  }
  set stroke(t) {
    t !== this._originalStroke && (this._originalStroke = t, this._isFillStyle(t) && (this._originalStroke = this._createProxy({ ...bn.defaultStrokeStyle, ...t }, () => {
      this._stroke = Vl(
        { ...this._originalStroke },
        bn.defaultStrokeStyle
      );
    })), this._stroke = Vl(t, bn.defaultStrokeStyle), this.update());
  }
  _generateKey() {
    return this._styleKey = nU(this), this._styleKey;
  }
  update() {
    this._styleKey = null, this.emit("update", this);
  }
  /** Resets all properties to the default values */
  reset() {
    const t = Da.defaultTextStyle;
    for (const e in t)
      this[e] = t[e];
  }
  get styleKey() {
    return this._styleKey || this._generateKey();
  }
  /**
   * Creates a new TextStyle object with the same values as this one.
   * @returns New cloned TextStyle object
   */
  clone() {
    return new Da({
      align: this.align,
      breakWords: this.breakWords,
      dropShadow: this._dropShadow ? { ...this._dropShadow } : null,
      fill: this._fill,
      fontFamily: this.fontFamily,
      fontSize: this.fontSize,
      fontStyle: this.fontStyle,
      fontVariant: this.fontVariant,
      fontWeight: this.fontWeight,
      leading: this.leading,
      letterSpacing: this.letterSpacing,
      lineHeight: this.lineHeight,
      padding: this.padding,
      stroke: this._stroke,
      textBaseline: this.textBaseline,
      whiteSpace: this.whiteSpace,
      wordWrap: this.wordWrap,
      wordWrapWidth: this.wordWrapWidth
    });
  }
  /**
   * Destroys this text style.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style
   */
  destroy(t = !1) {
    var s, r, n, a;
    if (this.removeAllListeners(), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
      const o = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
      (s = this._fill) != null && s.texture && this._fill.texture.destroy(o), (r = this._originalFill) != null && r.texture && this._originalFill.texture.destroy(o), (n = this._stroke) != null && n.texture && this._stroke.texture.destroy(o), (a = this._originalStroke) != null && a.texture && this._originalStroke.texture.destroy(o);
    }
    this._fill = null, this._stroke = null, this.dropShadow = null, this._originalStroke = null, this._originalFill = null;
  }
  _createProxy(t, e) {
    return new Proxy(t, {
      set: (s, r, n) => (s[r] = n, e == null || e(r, n), this.update(), !0)
    });
  }
  _isFillStyle(t) {
    return (t ?? null) !== null && !(Pt.isColorLike(t) || t instanceof gu || t instanceof Dd);
  }
};
bT.defaultDropShadow = {
  /** Set alpha for the drop shadow */
  alpha: 1,
  /** Set a angle of the drop shadow */
  angle: Math.PI / 6,
  /** Set a shadow blur radius */
  blur: 0,
  /** A fill style to be used on the  e.g., 'red', '#00FF00' */
  color: "black",
  /** Set a distance of the drop shadow */
  distance: 5
};
bT.defaultTextStyle = {
  /**
   * See {@link TextStyle.align}
   * @type {'left'|'center'|'right'|'justify'}
   */
  align: "left",
  /** See {@link TextStyle.breakWords} */
  breakWords: !1,
  /** See {@link TextStyle.dropShadow} */
  dropShadow: null,
  /**
   * See {@link TextStyle.fill}
   * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
   */
  fill: "black",
  /**
   * See {@link TextStyle.fontFamily}
   * @type {string|string[]}
   */
  fontFamily: "Arial",
  /**
   * See {@link TextStyle.fontSize}
   * @type {number|string}
   */
  fontSize: 26,
  /**
   * See {@link TextStyle.fontStyle}
   * @type {'normal'|'italic'|'oblique'}
   */
  fontStyle: "normal",
  /**
   * See {@link TextStyle.fontVariant}
   * @type {'normal'|'small-caps'}
   */
  fontVariant: "normal",
  /**
   * See {@link TextStyle.fontWeight}
   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
   */
  fontWeight: "normal",
  /** See {@link TextStyle.leading} */
  leading: 0,
  /** See {@link TextStyle.letterSpacing} */
  letterSpacing: 0,
  /** See {@link TextStyle.lineHeight} */
  lineHeight: 0,
  /** See {@link TextStyle.padding} */
  padding: 0,
  /**
   * See {@link TextStyle.stroke}
   * @type {string|number}
   */
  stroke: null,
  /**
   * See {@link TextStyle.textBaseline}
   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
   */
  textBaseline: "alphabetic",
  /** See {@link TextStyle.trim} */
  trim: !1,
  /**
   * See {@link TextStyle.whiteSpace}
   * @type {'normal'|'pre'|'pre-line'}
   */
  whiteSpace: "pre",
  /** See {@link TextStyle.wordWrap} */
  wordWrap: !1,
  /** See {@link TextStyle.wordWrapWidth} */
  wordWrapWidth: 100
};
let ga = bT;
function hU(i) {
  const t = i;
  if (typeof t.dropShadow == "boolean" && t.dropShadow) {
    const e = ga.defaultDropShadow;
    i.dropShadow = {
      alpha: t.dropShadowAlpha ?? e.alpha,
      angle: t.dropShadowAngle ?? e.angle,
      blur: t.dropShadowBlur ?? e.blur,
      color: t.dropShadowColor ?? e.color,
      distance: t.dropShadowDistance ?? e.distance
    };
  }
  if (t.strokeThickness !== void 0) {
    dt(Se, "strokeThickness is now a part of stroke");
    const e = t.stroke;
    let s = {};
    if (Pt.isColorLike(e))
      s.color = e;
    else if (e instanceof gu || e instanceof Dd)
      s.fill = e;
    else if (Object.hasOwnProperty.call(e, "color") || Object.hasOwnProperty.call(e, "fill"))
      s = e;
    else
      throw new Error("Invalid stroke value.");
    i.stroke = {
      ...s,
      width: t.strokeThickness
    };
  }
  if (Array.isArray(t.fillGradientStops)) {
    dt(Se, "gradient fill is now a fill pattern: `new FillGradient(...)`");
    let e;
    i.fontSize == null ? i.fontSize = ga.defaultTextStyle.fontSize : typeof i.fontSize == "string" ? e = parseInt(i.fontSize, 10) : e = i.fontSize;
    const s = new gu(0, 0, 0, e * 1.7), r = t.fillGradientStops.map((n) => Pt.shared.setValue(n).toNumber());
    r.forEach((n, a) => {
      const o = a / (r.length - 1);
      s.addColorStop(o, n);
    }), i.fill = {
      fill: s
    };
  }
}
class uU {
  constructor(t) {
    this._canvasPool = /* @__PURE__ */ Object.create(null), this.canvasOptions = t || {}, this.enableFullScreen = !1;
  }
  /**
   * Creates texture with params that were specified in pool constructor.
   * @param pixelWidth - Width of texture in pixels.
   * @param pixelHeight - Height of texture in pixels.
   */
  _createCanvasAndContext(t, e) {
    const s = Wt.get().createCanvas();
    s.width = t, s.height = e;
    const r = s.getContext("2d");
    return { canvas: s, context: r };
  }
  /**
   * Gets a Power-of-Two render texture or fullScreen texture
   * @param minWidth - The minimum width of the render texture.
   * @param minHeight - The minimum height of the render texture.
   * @param resolution - The resolution of the render texture.
   * @returns The new render texture.
   */
  getOptimalCanvasAndContext(t, e, s = 1) {
    t = Math.ceil(t * s - 1e-6), e = Math.ceil(e * s - 1e-6), t = Ll(t), e = Ll(e);
    const r = (t << 17) + (e << 1);
    this._canvasPool[r] || (this._canvasPool[r] = []);
    let n = this._canvasPool[r].pop();
    return n || (n = this._createCanvasAndContext(t, e)), n;
  }
  /**
   * Place a render texture back into the pool.
   * @param canvasAndContext
   */
  returnCanvasAndContext(t) {
    const e = t.canvas, { width: s, height: r } = e, n = (s << 17) + (r << 1);
    t.context.clearRect(0, 0, s, r), this._canvasPool[n].push(t);
  }
  clear() {
    this._canvasPool = {};
  }
}
const Hl = new uU(), lU = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
function Og(i) {
  const t = typeof i.fontSize == "number" ? `${i.fontSize}px` : i.fontSize;
  let e = i.fontFamily;
  Array.isArray(i.fontFamily) || (e = i.fontFamily.split(","));
  for (let s = e.length - 1; s >= 0; s--) {
    let r = e[s].trim();
    !/([\"\'])[^\'\"]+\1/.test(r) && !lU.includes(r) && (r = `"${r}"`), e[s] = r;
  }
  return `${i.fontStyle} ${i.fontVariant} ${i.fontWeight} ${t} ${e.join(",")}`;
}
const xf = {
  // TextMetrics requires getImageData readback for measuring fonts.
  willReadFrequently: !0
}, fi = class it {
  /**
   * Checking that we can use modern canvas 2D API.
   *
   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.
   * @see TextMetrics.experimentalLetterSpacing
   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing
   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441
   */
  static get experimentalLetterSpacingSupported() {
    let t = it._experimentalLetterSpacingSupported;
    if (t !== void 0) {
      const e = Wt.get().getCanvasRenderingContext2D().prototype;
      t = it._experimentalLetterSpacingSupported = "letterSpacing" in e || "textLetterSpacing" in e;
    }
    return t;
  }
  /**
   * @param text - the text that was measured
   * @param style - the style that was measured
   * @param width - the measured width of the text
   * @param height - the measured height of the text
   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style
   * @param lineWidths - an array of the line widths for each line matched to `lines`
   * @param lineHeight - the measured line height for this style
   * @param maxLineWidth - the maximum line width for all measured lines
   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont
   */
  constructor(t, e, s, r, n, a, o, h, u) {
    this.text = t, this.style = e, this.width = s, this.height = r, this.lines = n, this.lineWidths = a, this.lineHeight = o, this.maxLineWidth = h, this.fontProperties = u;
  }
  /**
   * Measures the supplied string of text and returns a Rectangle.
   * @param text - The text to measure.
   * @param style - The text style to use for measuring
   * @param canvas - optional specification of the canvas to use for measuring.
   * @param wordWrap
   * @returns Measured width and height of the text.
   */
  static measureText(t = " ", e, s = it._canvas, r = e.wordWrap) {
    var O;
    const n = `${t}:${e.styleKey}`;
    if (it._measurementCache[n])
      return it._measurementCache[n];
    const a = Og(e), o = it.measureFont(a);
    o.fontSize === 0 && (o.fontSize = e.fontSize, o.ascent = e.fontSize);
    const h = it.__context;
    h.font = a;
    const c = (r ? it._wordWrap(t, e, s) : t).split(/(?:\r\n|\r|\n)/), l = new Array(c.length);
    let _ = 0;
    for (let y = 0; y < c.length; y++) {
      const C = it._measureText(c[y], e.letterSpacing, h);
      l[y] = C, _ = Math.max(_, C);
    }
    const d = ((O = e._stroke) == null ? void 0 : O.width) || 0;
    let f = _ + d;
    e.dropShadow && (f += e.dropShadow.distance);
    const p = e.lineHeight || o.fontSize;
    let g = Math.max(p, o.fontSize + d) + (c.length - 1) * (p + e.leading);
    return e.dropShadow && (g += e.dropShadow.distance), new it(
      t,
      e,
      f,
      g,
      c,
      l,
      p + e.leading,
      _,
      o
    );
  }
  static _measureText(t, e, s) {
    let r = !1;
    it.experimentalLetterSpacingSupported && (it.experimentalLetterSpacing ? (s.letterSpacing = `${e}px`, s.textLetterSpacing = `${e}px`, r = !0) : (s.letterSpacing = "0px", s.textLetterSpacing = "0px"));
    const n = s.measureText(t);
    let a = n.width;
    const o = -n.actualBoundingBoxLeft;
    let u = n.actualBoundingBoxRight - o;
    if (a > 0)
      if (r)
        a -= e, u -= e;
      else {
        const c = (it.graphemeSegmenter(t).length - 1) * e;
        a += c, u += c;
      }
    return Math.max(a, u);
  }
  /**
   * Applies newlines to a string to have it optimally fit into the horizontal
   * bounds set by the Text object's wordWrapWidth property.
   * @param text - String to apply word wrapping to
   * @param style - the style to use when wrapping
   * @param canvas - optional specification of the canvas to use for measuring.
   * @returns New string with new lines applied where required
   */
  static _wordWrap(t, e, s = it._canvas) {
    const r = s.getContext("2d", xf);
    let n = 0, a = "", o = "";
    const h = /* @__PURE__ */ Object.create(null), { letterSpacing: u, whiteSpace: c } = e, l = it._collapseSpaces(c), _ = it._collapseNewlines(c);
    let d = !l;
    const f = e.wordWrapWidth + u, p = it._tokenize(t);
    for (let g = 0; g < p.length; g++) {
      let m = p[g];
      if (it._isNewline(m)) {
        if (!_) {
          o += it._addLine(a), d = !l, a = "", n = 0;
          continue;
        }
        m = " ";
      }
      if (l) {
        const y = it.isBreakingSpace(m), C = it.isBreakingSpace(a[a.length - 1]);
        if (y && C)
          continue;
      }
      const O = it._getFromCache(m, u, h, r);
      if (O > f)
        if (a !== "" && (o += it._addLine(a), a = "", n = 0), it.canBreakWords(m, e.breakWords)) {
          const y = it.wordWrapSplit(m);
          for (let C = 0; C < y.length; C++) {
            let b = y[C], D = b, P = 1;
            for (; y[C + P]; ) {
              const M = y[C + P];
              if (!it.canBreakChars(D, M, m, C, e.breakWords))
                b += M;
              else
                break;
              D = M, P++;
            }
            C += P - 1;
            const F = it._getFromCache(b, u, h, r);
            F + n > f && (o += it._addLine(a), d = !1, a = "", n = 0), a += b, n += F;
          }
        } else {
          a.length > 0 && (o += it._addLine(a), a = "", n = 0);
          const y = g === p.length - 1;
          o += it._addLine(m, !y), d = !1, a = "", n = 0;
        }
      else
        O + n > f && (d = !1, o += it._addLine(a), a = "", n = 0), (a.length > 0 || !it.isBreakingSpace(m) || d) && (a += m, n += O);
    }
    return o += it._addLine(a, !1), o;
  }
  /**
   * Convenience function for logging each line added during the wordWrap method.
   * @param line    - The line of text to add
   * @param newLine - Add new line character to end
   * @returns A formatted line
   */
  static _addLine(t, e = !0) {
    return t = it._trimRight(t), t = e ? `${t}
` : t, t;
  }
  /**
   * Gets & sets the widths of calculated characters in a cache object
   * @param key            - The key
   * @param letterSpacing  - The letter spacing
   * @param cache          - The cache
   * @param context        - The canvas context
   * @returns The from cache.
   */
  static _getFromCache(t, e, s, r) {
    let n = s[t];
    return typeof n != "number" && (n = it._measureText(t, e, r) + e, s[t] = n), n;
  }
  /**
   * Determines whether we should collapse breaking spaces.
   * @param whiteSpace - The TextStyle property whiteSpace
   * @returns Should collapse
   */
  static _collapseSpaces(t) {
    return t === "normal" || t === "pre-line";
  }
  /**
   * Determines whether we should collapse newLine chars.
   * @param whiteSpace - The white space
   * @returns should collapse
   */
  static _collapseNewlines(t) {
    return t === "normal";
  }
  /**
   * Trims breaking whitespaces from string.
   * @param text - The text
   * @returns Trimmed string
   */
  static _trimRight(t) {
    if (typeof t != "string")
      return "";
    for (let e = t.length - 1; e >= 0; e--) {
      const s = t[e];
      if (!it.isBreakingSpace(s))
        break;
      t = t.slice(0, -1);
    }
    return t;
  }
  /**
   * Determines if char is a newline.
   * @param char - The character
   * @returns True if newline, False otherwise.
   */
  static _isNewline(t) {
    return typeof t != "string" ? !1 : it._newlines.includes(t.charCodeAt(0));
  }
  /**
   * Determines if char is a breaking whitespace.
   *
   * It allows one to determine whether char should be a breaking whitespace
   * For example certain characters in CJK langs or numbers.
   * It must return a boolean.
   * @param char - The character
   * @param [_nextChar] - The next character
   * @returns True if whitespace, False otherwise.
   */
  static isBreakingSpace(t, e) {
    return typeof t != "string" ? !1 : it._breakingSpaces.includes(t.charCodeAt(0));
  }
  /**
   * Splits a string into words, breaking-spaces and newLine characters
   * @param text - The text
   * @returns A tokenized array
   */
  static _tokenize(t) {
    const e = [];
    let s = "";
    if (typeof t != "string")
      return e;
    for (let r = 0; r < t.length; r++) {
      const n = t[r], a = t[r + 1];
      if (it.isBreakingSpace(n, a) || it._isNewline(n)) {
        s !== "" && (e.push(s), s = ""), e.push(n);
        continue;
      }
      s += n;
    }
    return s !== "" && e.push(s), e;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It allows one to customise which words should break
   * Examples are if the token is CJK or numbers.
   * It must return a boolean.
   * @param _token - The token
   * @param breakWords - The style attr break words
   * @returns Whether to break word or not
   */
  static canBreakWords(t, e) {
    return e;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It allows one to determine whether a pair of characters
   * should be broken by newlines
   * For example certain characters in CJK langs or numbers.
   * It must return a boolean.
   * @param _char - The character
   * @param _nextChar - The next character
   * @param _token - The token/word the characters are from
   * @param _index - The index in the token of the char
   * @param _breakWords - The style attr break words
   * @returns whether to break word or not
   */
  static canBreakChars(t, e, s, r, n) {
    return !0;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It is called when a token (usually a word) has to be split into separate pieces
   * in order to determine the point to break a word.
   * It must return an array of characters.
   * @param token - The token to split
   * @returns The characters of the token
   * @see CanvasTextMetrics.graphemeSegmenter
   */
  static wordWrapSplit(t) {
    return it.graphemeSegmenter(t);
  }
  /**
   * Calculates the ascent, descent and fontSize of a given font-style
   * @param font - String representing the style of the font
   * @returns Font properties object
   */
  static measureFont(t) {
    if (it._fonts[t])
      return it._fonts[t];
    const e = it._context;
    e.font = t;
    const s = e.measureText(it.METRICS_STRING + it.BASELINE_SYMBOL), r = {
      ascent: s.actualBoundingBoxAscent,
      descent: s.actualBoundingBoxDescent,
      fontSize: s.actualBoundingBoxAscent + s.actualBoundingBoxDescent
    };
    return it._fonts[t] = r, r;
  }
  /**
   * Clear font metrics in metrics cache.
   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
   */
  static clearMetrics(t = "") {
    t ? delete it._fonts[t] : it._fonts = {};
  }
  /**
   * Cached canvas element for measuring text
   * TODO: this should be private, but isn't because of backward compat, will fix later.
   * @ignore
   */
  static get _canvas() {
    if (!it.__canvas) {
      let t;
      try {
        const e = new OffscreenCanvas(0, 0), s = e.getContext("2d", xf);
        if (s != null && s.measureText)
          return it.__canvas = e, e;
        t = Wt.get().createCanvas();
      } catch {
        t = Wt.get().createCanvas();
      }
      t.width = t.height = 10, it.__canvas = t;
    }
    return it.__canvas;
  }
  /**
   * TODO: this should be private, but isn't because of backward compat, will fix later.
   * @ignore
   */
  static get _context() {
    return it.__context || (it.__context = it._canvas.getContext("2d", xf)), it.__context;
  }
};
fi.METRICS_STRING = "|ÉqÅ";
fi.BASELINE_SYMBOL = "M";
fi.BASELINE_MULTIPLIER = 1.4;
fi.HEIGHT_MULTIPLIER = 2;
fi.graphemeSegmenter = (() => {
  if (typeof (Intl == null ? void 0 : Intl.Segmenter) == "function") {
    const i = new Intl.Segmenter();
    return (t) => [...i.segment(t)].map((e) => e.segment);
  }
  return (i) => [...i];
})();
fi.experimentalLetterSpacing = !1;
fi._fonts = {};
fi._newlines = [
  10,
  // line feed
  13
  // carriage return
];
fi._breakingSpaces = [
  9,
  // character tabulation
  32,
  // space
  8192,
  // en quad
  8193,
  // em quad
  8194,
  // en space
  8195,
  // em space
  8196,
  // three-per-em space
  8197,
  // four-per-em space
  8198,
  // six-per-em space
  8200,
  // punctuation space
  8201,
  // thin space
  8202,
  // hair space
  8287,
  // medium mathematical space
  12288
  // ideographic space
];
fi._measurementCache = {};
let yg = fi;
function kS(i, t) {
  if (i.texture === W.WHITE && !i.fill)
    return Pt.shared.setValue(i.color).setAlpha(i.alpha ?? 1).toHexa();
  if (i.fill) {
    if (i.fill instanceof Dd) {
      const e = i.fill, s = t.createPattern(e.texture.source.resource, "repeat"), r = e.transform.copyTo(ot.shared);
      return r.scale(
        e.texture.frame.width,
        e.texture.frame.height
      ), s.setTransform(r), s;
    } else if (i.fill instanceof gu) {
      const e = i.fill;
      if (e.type === "linear") {
        const s = t.createLinearGradient(
          e.x0,
          e.y0,
          e.x1,
          e.y1
        );
        return e.gradientStops.forEach((r) => {
          s.addColorStop(r.offset, Pt.shared.setValue(r.color).toHex());
        }), s;
      }
    }
  } else {
    const e = t.createPattern(i.texture.source.resource, "repeat"), s = i.matrix.copyTo(ot.shared);
    return s.scale(i.texture.frame.width, i.texture.frame.height), e.setTransform(s), e;
  }
  return ce("FillStyle not recognised", i), "red";
}
function Y0(i) {
  if (i === "")
    return [];
  typeof i == "string" && (i = [i]);
  const t = [];
  for (let e = 0, s = i.length; e < s; e++) {
    const r = i[e];
    if (Array.isArray(r)) {
      if (r.length !== 2)
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${r.length}.`);
      if (r[0].length === 0 || r[1].length === 0)
        throw new Error("[BitmapFont]: Invalid character delimiter.");
      const n = r[0].charCodeAt(0), a = r[1].charCodeAt(0);
      if (a < n)
        throw new Error("[BitmapFont]: Invalid character range.");
      for (let o = n, h = a; o <= h; o++)
        t.push(String.fromCharCode(o));
    } else
      t.push(...Array.from(r));
  }
  if (t.length === 0)
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  return t;
}
const W0 = class j0 extends O0 {
  /**
   * @param options - The options for the dynamic bitmap font.
   */
  constructor(t) {
    super(), this.resolution = 1, this.pages = [], this._padding = 0, this._measureCache = /* @__PURE__ */ Object.create(null), this._currentChars = [], this._currentX = 0, this._currentY = 0, this._currentPageIndex = -1, this._skipKerning = !1;
    const e = { ...j0.defaultOptions, ...t };
    this._textureSize = e.textureSize, this._mipmap = e.mipmap;
    const s = e.style.clone();
    e.overrideFill && (s._fill.color = 16777215, s._fill.alpha = 1, s._fill.texture = W.WHITE, s._fill.fill = null), this.applyFillAsTint = e.overrideFill;
    const r = s.fontSize;
    s.fontSize = this.baseMeasurementFontSize;
    const n = Og(s);
    e.overrideSize ? s._stroke && (s._stroke.width *= this.baseRenderedFontSize / r) : s.fontSize = this.baseRenderedFontSize = r, this._style = s, this._skipKerning = e.skipKerning ?? !1, this.resolution = e.resolution ?? 1, this._padding = e.padding ?? 4, this.fontMetrics = yg.measureFont(n), this.lineHeight = s.lineHeight || this.fontMetrics.fontSize || s.fontSize;
  }
  ensureCharacters(t) {
    var f, p;
    const e = Y0(t).filter((g) => !this._currentChars.includes(g)).filter((g, m, O) => O.indexOf(g) === m);
    if (!e.length)
      return;
    this._currentChars = [...this._currentChars, ...e];
    let s;
    this._currentPageIndex === -1 ? s = this._nextPage() : s = this.pages[this._currentPageIndex];
    let { canvas: r, context: n } = s.canvasAndContext, a = s.texture.source;
    const o = this._style;
    let h = this._currentX, u = this._currentY;
    const c = this.baseRenderedFontSize / this.baseMeasurementFontSize, l = this._padding * c;
    let _ = 0, d = !1;
    for (let g = 0; g < e.length; g++) {
      const m = e[g], O = yg.measureText(m, o, r, !1), y = Math.ceil((o.fontStyle === "italic" ? 2 : 1) * O.width);
      O.lineHeight = O.height;
      const C = O.width * c, b = O.height * c, D = y + l * 2, P = b + l * 2;
      if (d = !1, m !== `
` && m !== "\r" && m !== "	" && m !== " " && (d = !0, _ = Math.ceil(Math.max(P, _))), h + D > this._textureSize && (u += _, _ = P, h = 0, u + _ > this._textureSize)) {
        a.update();
        const M = this._nextPage();
        r = M.canvasAndContext.canvas, n = M.canvasAndContext.context, a = M.texture.source, u = 0;
      }
      const F = C / c - (((f = o.dropShadow) == null ? void 0 : f.distance) ?? 0) - (((p = o._stroke) == null ? void 0 : p.width) ?? 0);
      if (this.chars[m] = {
        id: m.codePointAt(0),
        xOffset: -this._padding,
        yOffset: -this._padding,
        xAdvance: F,
        kerning: {}
      }, d) {
        this._drawGlyph(
          n,
          O,
          h + l,
          u + l,
          c,
          o
        );
        const M = a.width * c, U = a.height * c, k = new Kt(
          h / M * a.width,
          u / U * a.height,
          D / M * a.width,
          P / U * a.height
        );
        this.chars[m].texture = new W({
          source: a,
          frame: k
        }), h += Math.ceil(D);
      }
    }
    a.update(), this._currentX = h, this._currentY = u, this._skipKerning && this._applyKerning(e, n);
  }
  /**
   * @deprecated since 8.0.0
   * The map of base page textures (i.e., sheets of glyphs).
   */
  get pageTextures() {
    return dt(Se, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages;
  }
  _applyKerning(t, e) {
    const s = this._measureCache;
    for (let r = 0; r < t.length; r++) {
      const n = t[r];
      for (let a = 0; a < this._currentChars.length; a++) {
        const o = this._currentChars[a];
        let h = s[n];
        h || (h = s[n] = e.measureText(n).width);
        let u = s[o];
        u || (u = s[o] = e.measureText(o).width);
        let c = e.measureText(n + o).width, l = c - (h + u);
        l && (this.chars[n].kerning[o] = l), c = e.measureText(n + o).width, l = c - (h + u), l && (this.chars[o].kerning[n] = l);
      }
    }
  }
  _nextPage() {
    this._currentPageIndex++;
    const t = this.resolution, e = Hl.getOptimalCanvasAndContext(
      this._textureSize,
      this._textureSize,
      t
    );
    this._setupContext(e.context, this._style, t);
    const s = t * (this.baseRenderedFontSize / this.baseMeasurementFontSize), r = new W({
      source: new Ra({
        resource: e.canvas,
        resolution: s,
        alphaMode: "premultiply-alpha-on-upload",
        autoGenerateMipmaps: this._mipmap
      })
    }), n = {
      canvasAndContext: e,
      texture: r
    };
    return this.pages[this._currentPageIndex] = n, n;
  }
  // canvas style!
  _setupContext(t, e, s) {
    e.fontSize = this.baseRenderedFontSize, t.scale(s, s), t.font = Og(e), e.fontSize = this.baseMeasurementFontSize, t.textBaseline = e.textBaseline;
    const r = e._stroke, n = (r == null ? void 0 : r.width) ?? 0;
    if (r && (t.lineWidth = n, t.lineJoin = r.join, t.miterLimit = r.miterLimit, t.strokeStyle = kS(r, t)), e._fill && (t.fillStyle = kS(e._fill, t)), e.dropShadow) {
      const a = e.dropShadow, o = Pt.shared.setValue(a.color).toArray(), h = a.blur * s, u = a.distance * s;
      t.shadowColor = `rgba(${o[0] * 255},${o[1] * 255},${o[2] * 255},${a.alpha})`, t.shadowBlur = h, t.shadowOffsetX = Math.cos(a.angle) * u, t.shadowOffsetY = Math.sin(a.angle) * u;
    } else
      t.shadowColor = "black", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;
  }
  _drawGlyph(t, e, s, r, n, a) {
    const o = e.text, h = e.fontProperties, u = a._stroke, c = ((u == null ? void 0 : u.width) ?? 0) * n, l = s + c / 2, _ = r - c / 2, d = h.descent * n, f = e.lineHeight * n;
    a.stroke && c && t.strokeText(o, l, _ + f - d), a._fill && t.fillText(o, l, _ + f - d);
  }
  destroy() {
    super.destroy();
    for (let t = 0; t < this.pages.length; t++) {
      const { canvasAndContext: e, texture: s } = this.pages[t];
      Hl.returnCanvasAndContext(e), s.destroy(!0);
    }
    this.pages = null;
  }
};
W0.defaultOptions = {
  textureSize: 512,
  style: new ga(),
  mipmap: !0
};
let zS = W0;
function cU(i, t, e, s) {
  const r = {
    width: 0,
    height: 0,
    offsetY: 0,
    scale: t.fontSize / e.baseMeasurementFontSize,
    lines: [{
      width: 0,
      charPositions: [],
      spaceWidth: 0,
      spacesIndex: [],
      chars: []
    }]
  };
  r.offsetY = e.baseLineOffset;
  let n = r.lines[0], a = null, o = !0;
  const h = {
    spaceWord: !1,
    width: 0,
    start: 0,
    index: 0,
    // use index to not modify the array as we use it a lot!
    positions: [],
    chars: []
  }, u = (f) => {
    const p = n.width;
    for (let g = 0; g < h.index; g++) {
      const m = f.positions[g];
      n.chars.push(f.chars[g]), n.charPositions.push(m + p);
    }
    n.width += f.width, o = !1, h.width = 0, h.index = 0, h.chars.length = 0;
  }, c = () => {
    let f = n.chars.length - 1;
    if (s) {
      let p = n.chars[f];
      for (; p === " "; )
        n.width -= e.chars[p].xAdvance, p = n.chars[--f];
    }
    r.width = Math.max(r.width, n.width), n = {
      width: 0,
      charPositions: [],
      chars: [],
      spaceWidth: 0,
      spacesIndex: []
    }, o = !0, r.lines.push(n), r.height += e.lineHeight;
  }, l = e.baseMeasurementFontSize / t.fontSize, _ = t.letterSpacing * l, d = t.wordWrapWidth * l;
  for (let f = 0; f < i.length + 1; f++) {
    let p;
    const g = f === i.length;
    g || (p = i[f]);
    const m = e.chars[p] || e.chars[" "];
    if (/(?:\s)/.test(p) || p === "\r" || p === `
` || g) {
      if (!o && t.wordWrap && n.width + h.width - _ > d ? (c(), u(h), g || n.charPositions.push(0)) : (h.start = n.width, u(h), g || n.charPositions.push(0)), p === "\r" || p === `
`)
        n.width !== 0 && c();
      else if (!g) {
        const b = m.xAdvance + (m.kerning[a] || 0) + _;
        n.width += b, n.spaceWidth = b, n.spacesIndex.push(n.charPositions.length), n.chars.push(p);
      }
    } else {
      const C = m.kerning[a] || 0, b = m.xAdvance + C + _;
      h.positions[h.index++] = h.width + C, h.chars.push(p), h.width += b;
    }
    a = p;
  }
  return c(), t.align === "center" ? _U(r) : t.align === "right" ? dU(r) : t.align === "justify" && fU(r), r;
}
function _U(i) {
  for (let t = 0; t < i.lines.length; t++) {
    const e = i.lines[t], s = i.width / 2 - e.width / 2;
    for (let r = 0; r < e.charPositions.length; r++)
      e.charPositions[r] += s;
  }
}
function dU(i) {
  for (let t = 0; t < i.lines.length; t++) {
    const e = i.lines[t], s = i.width - e.width;
    for (let r = 0; r < e.charPositions.length; r++)
      e.charPositions[r] += s;
  }
}
function fU(i) {
  const t = i.width;
  for (let e = 0; e < i.lines.length; e++) {
    const s = i.lines[e];
    let r = 0, n = s.spacesIndex[r++], a = 0;
    const o = s.spacesIndex.length, u = (t - s.width) / o;
    for (let c = 0; c < s.charPositions.length; c++)
      c === n && (n = s.spacesIndex[r++], a += u), s.charPositions[c] += a;
  }
}
let ol = 0;
class gU {
  constructor() {
    this.ALPHA = [["a", "z"], ["A", "Z"], " "], this.NUMERIC = [["0", "9"]], this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], this.ASCII = [[" ", "~"]], this.defaultOptions = {
      chars: this.ALPHANUMERIC,
      resolution: 1,
      padding: 4,
      skipKerning: !1
    };
  }
  /**
   * Get a font for the specified text and style.
   * @param text - The text to get the font for
   * @param style - The style to use
   */
  getFont(t, e) {
    var a;
    let s = `${e.fontFamily}-bitmap`, r = !0;
    if (e._fill.fill && !e._stroke)
      s += e._fill.fill.styleKey, r = !1;
    else if (e._stroke || e.dropShadow) {
      let o = e.styleKey;
      o = o.substring(0, o.lastIndexOf("-")), s = `${o}-bitmap`, r = !1;
    }
    if (!ge.has(s)) {
      const o = new zS({
        style: e,
        overrideFill: r,
        overrideSize: !0,
        ...this.defaultOptions
      });
      ol++, ol > 50 && ce("BitmapText", `You have dynamically created ${ol} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``), o.once("destroy", () => {
        ol--, ge.remove(s);
      }), ge.set(
        s,
        o
      );
    }
    const n = ge.get(s);
    return (a = n.ensureCharacters) == null || a.call(n, t), n;
  }
  /**
   * Get the layout of a text for the specified style.
   * @param text - The text to get the layout for
   * @param style - The style to use
   * @param trimEnd - Whether to ignore whitespaces at the end of each line
   */
  getLayout(t, e, s = !0) {
    const r = this.getFont(t, e);
    return cU([...t], e, r, s);
  }
  /**
   * Measure the text using the specified style.
   * @param text - The text to measure
   * @param style - The style to use
   * @param trimEnd - Whether to ignore whitespaces at the end of each line
   */
  measureText(t, e, s = !0) {
    return this.getLayout(t, e, s);
  }
  // eslint-disable-next-line max-len
  install(...t) {
    var u, c, l, _;
    let e = t[0];
    typeof e == "string" && (e = {
      name: e,
      style: t[1],
      chars: (u = t[2]) == null ? void 0 : u.chars,
      resolution: (c = t[2]) == null ? void 0 : c.resolution,
      padding: (l = t[2]) == null ? void 0 : l.padding,
      skipKerning: (_ = t[2]) == null ? void 0 : _.skipKerning
    }, dt(Se, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));
    const s = e == null ? void 0 : e.name;
    if (!s)
      throw new Error("[BitmapFontManager] Property `name` is required.");
    e = { ...this.defaultOptions, ...e };
    const r = e.style, n = r instanceof ga ? r : new ga(r), a = n._fill.fill !== null && n._fill.fill !== void 0, o = new zS({
      style: n,
      overrideFill: a,
      skipKerning: e.skipKerning,
      padding: e.padding,
      resolution: e.resolution,
      overrideSize: !1
    }), h = Y0(e.chars);
    return o.ensureCharacters(h.join("")), ge.set(`${s}-bitmap`, o), o.once("destroy", () => ge.remove(`${s}-bitmap`)), o;
  }
  /**
   * Uninstalls a bitmap font from the cache.
   * @param {string} name - The name of the bitmap font to uninstall.
   */
  uninstall(t) {
    const e = `${t}-bitmap`, s = ge.get(e);
    s && s.destroy();
  }
}
const VS = new gU();
class X0 extends O0 {
  constructor(t, e) {
    super();
    const { textures: s, data: r } = t;
    Object.keys(r.pages).forEach((n) => {
      const a = r.pages[parseInt(n, 10)], o = s[a.id];
      this.pages.push({ texture: o });
    }), Object.keys(r.chars).forEach((n) => {
      const a = r.chars[n], {
        frame: o,
        source: h
      } = s[a.page], u = new Kt(
        a.x + o.x,
        a.y + o.y,
        a.width,
        a.height
      ), c = new W({
        source: h,
        frame: u
      });
      this.chars[n] = {
        id: n.codePointAt(0),
        xOffset: a.xOffset,
        yOffset: a.yOffset,
        xAdvance: a.xAdvance,
        kerning: a.kerning ?? {},
        texture: c
      };
    }), this.baseRenderedFontSize = r.fontSize, this.baseMeasurementFontSize = r.fontSize, this.fontMetrics = {
      ascent: 0,
      descent: 0,
      fontSize: r.fontSize
    }, this.baseLineOffset = r.baseLineOffset, this.lineHeight = r.lineHeight, this.fontFamily = r.fontFamily, this.distanceField = r.distanceField ?? {
      type: "none",
      range: 0
    }, this.url = e;
  }
  /** Destroys the BitmapFont object. */
  destroy() {
    super.destroy();
    for (let t = 0; t < this.pages.length; t++) {
      const { texture: e } = this.pages[t];
      e.destroy(!0);
    }
    this.pages = null;
  }
  /**
   * Generates a bitmap-font for the given style and character set
   * @param options - Setup options for font generation.
   * @returns Font generated by style options.
   * @example
   * import { BitmapFont, BitmapText } from 'pixi.js';
   *
   * BitmapFont.install('TitleFont', {
   *     fontFamily: 'Arial',
   *     fontSize: 12,
   *     strokeThickness: 2,
   *     fill: 'purple',
   * });
   *
   * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });
   */
  static install(t) {
    VS.install(t);
  }
  /**
   * Uninstalls a bitmap font from the cache.
   * @param {string} name - The name of the bitmap font to uninstall.
   */
  static uninstall(t) {
    VS.uninstall(t);
  }
}
const Mf = {
  test(i) {
    return typeof i == "string" && i.startsWith("info face=");
  },
  parse(i) {
    const t = i.match(/^[a-z]+\s+.+$/gm), e = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: [],
      distanceField: []
    };
    for (const l in t) {
      const _ = t[l].match(/^[a-z]+/gm)[0], d = t[l].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), f = {};
      for (const p in d) {
        const g = d[p].split("="), m = g[0], O = g[1].replace(/"/gm, ""), y = parseFloat(O), C = isNaN(y) ? O : y;
        f[m] = C;
      }
      e[_].push(f);
    }
    const s = {
      chars: {},
      pages: [],
      lineHeight: 0,
      fontSize: 0,
      fontFamily: "",
      distanceField: null,
      baseLineOffset: 0
    }, [r] = e.info, [n] = e.common, [a] = e.distanceField ?? [];
    a && (s.distanceField = {
      range: parseInt(a.distanceRange, 10),
      type: a.fieldType
    }), s.fontSize = parseInt(r.size, 10), s.fontFamily = r.face, s.lineHeight = parseInt(n.lineHeight, 10);
    const o = e.page;
    for (let l = 0; l < o.length; l++)
      s.pages.push({
        id: parseInt(o[l].id, 10) || 0,
        file: o[l].file
      });
    const h = {};
    s.baseLineOffset = s.lineHeight - parseInt(n.base, 10);
    const u = e.char;
    for (let l = 0; l < u.length; l++) {
      const _ = u[l], d = parseInt(_.id, 10);
      let f = _.letter ?? _.char ?? String.fromCharCode(d);
      f === "space" && (f = " "), h[d] = f, s.chars[f] = {
        id: d,
        // texture deets..
        page: parseInt(_.page, 10) || 0,
        x: parseInt(_.x, 10),
        y: parseInt(_.y, 10),
        width: parseInt(_.width, 10),
        height: parseInt(_.height, 10),
        xOffset: parseInt(_.xoffset, 10),
        yOffset: parseInt(_.yoffset, 10),
        xAdvance: parseInt(_.xadvance, 10),
        kerning: {}
      };
    }
    const c = e.kerning || [];
    for (let l = 0; l < c.length; l++) {
      const _ = parseInt(c[l].first, 10), d = parseInt(c[l].second, 10), f = parseInt(c[l].amount, 10);
      s.chars[h[d]].kerning[h[_]] = f;
    }
    return s;
  }
}, HS = {
  test(i) {
    const t = i;
    return typeof t != "string" && "getElementsByTagName" in t && t.getElementsByTagName("page").length && t.getElementsByTagName("info")[0].getAttribute("face") !== null;
  },
  parse(i) {
    const t = {
      chars: {},
      pages: [],
      lineHeight: 0,
      fontSize: 0,
      fontFamily: "",
      distanceField: null,
      baseLineOffset: 0
    }, e = i.getElementsByTagName("info")[0], s = i.getElementsByTagName("common")[0], r = i.getElementsByTagName("distanceField")[0];
    r && (t.distanceField = {
      type: r.getAttribute("fieldType"),
      range: parseInt(r.getAttribute("distanceRange"), 10)
    });
    const n = i.getElementsByTagName("page"), a = i.getElementsByTagName("char"), o = i.getElementsByTagName("kerning");
    t.fontSize = parseInt(e.getAttribute("size"), 10), t.fontFamily = e.getAttribute("face"), t.lineHeight = parseInt(s.getAttribute("lineHeight"), 10);
    for (let u = 0; u < n.length; u++)
      t.pages.push({
        id: parseInt(n[u].getAttribute("id"), 10) || 0,
        file: n[u].getAttribute("file")
      });
    const h = {};
    t.baseLineOffset = t.lineHeight - parseInt(s.getAttribute("base"), 10);
    for (let u = 0; u < a.length; u++) {
      const c = a[u], l = parseInt(c.getAttribute("id"), 10);
      let _ = c.getAttribute("letter") ?? c.getAttribute("char") ?? String.fromCharCode(l);
      _ === "space" && (_ = " "), h[l] = _, t.chars[_] = {
        id: l,
        // texture deets..
        page: parseInt(c.getAttribute("page"), 10) || 0,
        x: parseInt(c.getAttribute("x"), 10),
        y: parseInt(c.getAttribute("y"), 10),
        width: parseInt(c.getAttribute("width"), 10),
        height: parseInt(c.getAttribute("height"), 10),
        // render deets..
        xOffset: parseInt(c.getAttribute("xoffset"), 10),
        yOffset: parseInt(c.getAttribute("yoffset"), 10),
        // + baseLineOffset,
        xAdvance: parseInt(c.getAttribute("xadvance"), 10),
        kerning: {}
      };
    }
    for (let u = 0; u < o.length; u++) {
      const c = parseInt(o[u].getAttribute("first"), 10), l = parseInt(o[u].getAttribute("second"), 10), _ = parseInt(o[u].getAttribute("amount"), 10);
      t.chars[h[l]].kerning[h[c]] = _;
    }
    return t;
  }
}, YS = {
  test(i) {
    return typeof i == "string" && i.includes("<font>") ? HS.test(Wt.get().parseXML(i)) : !1;
  },
  parse(i) {
    return HS.parse(Wt.get().parseXML(i));
  }
}, pU = [".xml", ".fnt"], mU = {
  extension: {
    type: B.CacheParser,
    name: "cacheBitmapFont"
  },
  test: (i) => i instanceof X0,
  getCacheableAssets(i, t) {
    const e = {};
    return i.forEach((s) => {
      e[s] = t, e[`${s}-bitmap`] = t;
    }), e[`${t.fontFamily}-bitmap`] = t, e;
  }
}, EU = {
  extension: {
    type: B.LoadParser,
    priority: pn.Normal
  },
  name: "loadBitmapFont",
  test(i) {
    return pU.includes(Ts.extname(i).toLowerCase());
  },
  async testParse(i) {
    return Mf.test(i) || YS.test(i);
  },
  async parse(i, t, e) {
    const s = Mf.test(i) ? Mf.parse(i) : YS.parse(i), { src: r } = t, { pages: n } = s, a = [], o = s.distanceField ? {
      scaleMode: "linear",
      alphaMode: "premultiply-alpha-on-upload",
      autoGenerateMipmaps: !1,
      resolution: 1
    } : {};
    for (let l = 0; l < n.length; ++l) {
      const _ = n[l].file;
      let d = Ts.join(Ts.dirname(r), _);
      d = og(d, r), a.push({
        src: d,
        data: o
      });
    }
    const h = await e.load(a), u = a.map((l) => h[l.src]);
    return new X0({
      data: s,
      textures: u
    }, r);
  },
  async load(i, t) {
    return await (await Wt.get().fetch(i)).text();
  },
  async unload(i, t, e) {
    await Promise.all(i.pages.map((s) => e.unload(s.texture.source._sourceOrigin))), i.destroy();
  }
};
class TU {
  /**
   * @param loader
   * @param verbose - should the loader log to the console
   */
  constructor(t, e = !1) {
    this._loader = t, this._assetList = [], this._isLoading = !1, this._maxConcurrent = 1, this.verbose = e;
  }
  /**
   * Adds an array of assets to load.
   * @param assetUrls - assets to load
   */
  add(t) {
    t.forEach((e) => {
      this._assetList.push(e);
    }), this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList), this._isActive && !this._isLoading && this._next();
  }
  /**
   * Loads the next set of assets. Will try to load as many assets as it can at the same time.
   *
   * The max assets it will try to load at one time will be 4.
   */
  async _next() {
    if (this._assetList.length && this._isActive) {
      this._isLoading = !0;
      const t = [], e = Math.min(this._assetList.length, this._maxConcurrent);
      for (let s = 0; s < e; s++)
        t.push(this._assetList.pop());
      await this._loader.load(t), this._isLoading = !1, this._next();
    }
  }
  /**
   * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.
   * @returns whether the class is active
   */
  get active() {
    return this._isActive;
  }
  set active(t) {
    this._isActive !== t && (this._isActive = t, t && !this._isLoading && this._next());
  }
}
const IU = {
  extension: {
    type: B.CacheParser,
    name: "cacheTextureArray"
  },
  test: (i) => Array.isArray(i) && i.every((t) => t instanceof W),
  getCacheableAssets: (i, t) => {
    const e = {};
    return i.forEach((s) => {
      t.forEach((r, n) => {
        e[s + (n === 0 ? "" : n + 1)] = r;
      });
    }), e;
  }
};
async function K0(i) {
  if ("Image" in globalThis)
    return new Promise((t) => {
      const e = new Image();
      e.onload = () => {
        t(!0);
      }, e.onerror = () => {
        t(!1);
      }, e.src = i;
    });
  if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
    try {
      const t = await (await fetch(i)).blob();
      await createImageBitmap(t);
    } catch {
      return !1;
    }
    return !0;
  }
  return !1;
}
const SU = {
  extension: {
    type: B.DetectionParser,
    priority: 1
  },
  test: async () => K0(
    // eslint-disable-next-line max-len
    "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
  ),
  add: async (i) => [...i, "avif"],
  remove: async (i) => i.filter((t) => t !== "avif")
}, WS = ["png", "jpg", "jpeg"], AU = {
  extension: {
    type: B.DetectionParser,
    priority: -1
  },
  test: () => Promise.resolve(!0),
  add: async (i) => [...i, ...WS],
  remove: async (i) => i.filter((t) => !WS.includes(t))
}, RU = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
function PT(i) {
  return RU ? !1 : document.createElement("video").canPlayType(i) !== "";
}
const OU = {
  extension: {
    type: B.DetectionParser,
    priority: 0
  },
  test: async () => PT("video/mp4"),
  add: async (i) => [...i, "mp4", "m4v"],
  remove: async (i) => i.filter((t) => t !== "mp4" && t !== "m4v")
}, yU = {
  extension: {
    type: B.DetectionParser,
    priority: 0
  },
  test: async () => PT("video/ogg"),
  add: async (i) => [...i, "ogv"],
  remove: async (i) => i.filter((t) => t !== "ogv")
}, vU = {
  extension: {
    type: B.DetectionParser,
    priority: 0
  },
  test: async () => PT("video/webm"),
  add: async (i) => [...i, "webm"],
  remove: async (i) => i.filter((t) => t !== "webm")
}, CU = {
  extension: {
    type: B.DetectionParser,
    priority: 0
  },
  test: async () => K0(
    "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
  ),
  add: async (i) => [...i, "webp"],
  remove: async (i) => i.filter((t) => t !== "webp")
};
class xU {
  constructor() {
    this._parsers = [], this._parsersValidated = !1, this.parsers = new Proxy(this._parsers, {
      set: (t, e, s) => (this._parsersValidated = !1, t[e] = s, !0)
    }), this.promiseCache = {};
  }
  /** function used for testing */
  reset() {
    this._parsersValidated = !1, this.promiseCache = {};
  }
  /**
   * Used internally to generate a promise for the asset to be loaded.
   * @param url - The URL to be loaded
   * @param data - any custom additional information relevant to the asset being loaded
   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object
   */
  _getLoadPromiseAndParser(t, e) {
    const s = {
      promise: null,
      parser: null
    };
    return s.promise = (async () => {
      var a, o;
      let r = null, n = null;
      if (e.loadParser && (n = this._parserHash[e.loadParser], n || ce(`[Assets] specified load parser "${e.loadParser}" not found while loading ${t}`)), !n) {
        for (let h = 0; h < this.parsers.length; h++) {
          const u = this.parsers[h];
          if (u.load && ((a = u.test) != null && a.call(u, t, e, this))) {
            n = u;
            break;
          }
        }
        if (!n)
          return ce(`[Assets] ${t} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`), null;
      }
      r = await n.load(t, e, this), s.parser = n;
      for (let h = 0; h < this.parsers.length; h++) {
        const u = this.parsers[h];
        u.parse && u.parse && await ((o = u.testParse) == null ? void 0 : o.call(u, r, e, this)) && (r = await u.parse(r, e, this) || r, s.parser = u);
      }
      return r;
    })(), s;
  }
  async load(t, e) {
    this._parsersValidated || this._validateParsers();
    let s = 0;
    const r = {}, n = kl(t), a = li(t, (u) => ({
      alias: [u],
      src: u,
      data: {}
    })), o = a.length, h = a.map(async (u) => {
      const c = Ts.toAbsolute(u.src);
      if (!r[u.src])
        try {
          this.promiseCache[c] || (this.promiseCache[c] = this._getLoadPromiseAndParser(c, u)), r[u.src] = await this.promiseCache[c].promise, e && e(++s / o);
        } catch (l) {
          throw delete this.promiseCache[c], delete r[u.src], new Error(`[Loader.load] Failed to load ${c}.
${l}`);
        }
    });
    return await Promise.all(h), n ? r[a[0].src] : r;
  }
  /**
   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.
   * The parser that created the asset, will be the one that unloads it.
   * @example
   * // Single asset:
   * const asset = await Loader.load('cool.png');
   *
   * await Loader.unload('cool.png');
   *
   * console.log(asset.destroyed); // true
   * @param assetsToUnloadIn - urls that you want to unload, or a single one!
   */
  async unload(t) {
    const s = li(t, (r) => ({
      alias: [r],
      src: r
    })).map(async (r) => {
      var o, h;
      const n = Ts.toAbsolute(r.src), a = this.promiseCache[n];
      if (a) {
        const u = await a.promise;
        delete this.promiseCache[n], await ((h = (o = a.parser) == null ? void 0 : o.unload) == null ? void 0 : h.call(o, u, r, this));
      }
    });
    await Promise.all(s);
  }
  /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */
  _validateParsers() {
    this._parsersValidated = !0, this._parserHash = this._parsers.filter((t) => t.name).reduce((t, e) => (e.name ? t[e.name] && ce(`[Assets] loadParser name conflict "${e.name}"`) : ce("[Assets] loadParser should have a name"), { ...t, [e.name]: e }), {});
  }
}
function Zo(i, t) {
  if (Array.isArray(t)) {
    for (const e of t)
      if (i.startsWith(`data:${e}`))
        return !0;
    return !1;
  }
  return i.startsWith(`data:${t}`);
}
function Qo(i, t) {
  const e = i.split("?")[0], s = Ts.extname(e).toLowerCase();
  return Array.isArray(t) ? t.includes(s) : s === t;
}
const MU = ".json", bU = "application/json", PU = {
  extension: {
    type: B.LoadParser,
    priority: pn.Low
  },
  name: "loadJson",
  test(i) {
    return Zo(i, bU) || Qo(i, MU);
  },
  async load(i) {
    return await (await Wt.get().fetch(i)).json();
  }
}, NU = ".txt", UU = "text/plain", DU = {
  name: "loadTxt",
  extension: {
    type: B.LoadParser,
    priority: pn.Low,
    name: "loadTxt"
  },
  test(i) {
    return Zo(i, UU) || Qo(i, NU);
  },
  async load(i) {
    return await (await Wt.get().fetch(i)).text();
  }
}, LU = [
  "normal",
  "bold",
  "100",
  "200",
  "300",
  "400",
  "500",
  "600",
  "700",
  "800",
  "900"
], FU = [".ttf", ".otf", ".woff", ".woff2"], wU = [
  "font/ttf",
  "font/otf",
  "font/woff",
  "font/woff2"
], GU = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
function BU(i) {
  const t = Ts.extname(i), r = Ts.basename(i, t).replace(/(-|_)/g, " ").toLowerCase().split(" ").map((o) => o.charAt(0).toUpperCase() + o.slice(1));
  let n = r.length > 0;
  for (const o of r)
    if (!o.match(GU)) {
      n = !1;
      break;
    }
  let a = r.join(" ");
  return n || (a = `"${a.replace(/[\\"]/g, "\\$&")}"`), a;
}
const kU = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
function zU(i) {
  return kU.test(i) ? i : encodeURI(i);
}
const VU = {
  extension: {
    type: B.LoadParser,
    priority: pn.Low
  },
  name: "loadWebFont",
  test(i) {
    return Zo(i, wU) || Qo(i, FU);
  },
  async load(i, t) {
    var s, r, n;
    const e = Wt.get().getFontFaceSet();
    if (e) {
      const a = [], o = ((s = t.data) == null ? void 0 : s.family) ?? BU(i), h = ((n = (r = t.data) == null ? void 0 : r.weights) == null ? void 0 : n.filter((c) => LU.includes(c))) ?? ["normal"], u = t.data ?? {};
      for (let c = 0; c < h.length; c++) {
        const l = h[c], _ = new FontFace(o, `url(${zU(i)})`, {
          ...u,
          weight: l
        });
        await _.load(), e.add(_), a.push(_);
      }
      return ge.set(`${o}-and-url`, {
        url: i,
        fontFaces: a
      }), a.length === 1 ? a[0] : a;
    }
    return ce("[loadWebFont] FontFace API is not supported. Skipping loading font"), null;
  },
  unload(i) {
    (Array.isArray(i) ? i : [i]).forEach((t) => {
      ge.remove(t.family), Wt.get().getFontFaceSet().delete(t);
    });
  }
};
function NT(i, t = 1) {
  var s;
  const e = (s = qo.RETINA_PREFIX) == null ? void 0 : s.exec(i);
  return e ? parseFloat(e[1]) : t;
}
function UT(i, t, e) {
  i.label = e, i._sourceOrigin = e;
  const s = new W({
    source: i,
    label: e
  }), r = () => {
    delete t.promiseCache[e], ge.has(e) && ge.remove(e);
  };
  return s.source.once("destroy", () => {
    t.promiseCache[e] && (ce("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource."), r());
  }), s.once("destroy", () => {
    i.destroyed || (ce("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."), r());
  }), s;
}
const HU = ".svg", YU = "image/svg+xml", WU = {
  extension: {
    type: B.LoadParser,
    priority: pn.Low,
    name: "loadSVG"
  },
  name: "loadSVG",
  config: {
    crossOrigin: "anonymous",
    parseAsGraphicsContext: !1
  },
  test(i) {
    return Zo(i, YU) || Qo(i, HU);
  },
  async load(i, t, e) {
    return t.data.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext ? XU(i) : jU(i, t, e, this.config.crossOrigin);
  },
  unload(i) {
    i.destroy(!0);
  }
};
async function jU(i, t, e, s) {
  var g, m, O;
  const n = await (await Wt.get().fetch(i)).blob(), a = URL.createObjectURL(n), o = new Image();
  o.src = a, o.crossOrigin = s, await o.decode(), URL.revokeObjectURL(a);
  const h = document.createElement("canvas"), u = h.getContext("2d"), c = ((g = t.data) == null ? void 0 : g.resolution) || NT(i), l = ((m = t.data) == null ? void 0 : m.width) ?? o.width, _ = ((O = t.data) == null ? void 0 : O.height) ?? o.height;
  h.width = l * c, h.height = _ * c, u.drawImage(o, 0, 0, l * c, _ * c);
  const { parseAsGraphicsContext: d, ...f } = t.data, p = new Ra({
    resource: h,
    alphaMode: "premultiply-alpha-on-upload",
    resolution: c,
    ...f
  });
  return UT(p, e, i);
}
async function XU(i) {
  const e = await (await Wt.get().fetch(i)).text(), s = new bn();
  return s.svg(e), s;
}
const KU = `(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;
let xo = null, vg = class {
  constructor() {
    xo || (xo = URL.createObjectURL(new Blob([KU], { type: "application/javascript" }))), this.worker = new Worker(xo);
  }
};
vg.revokeObjectURL = function() {
  xo && (URL.revokeObjectURL(xo), xo = null);
};
const qU = `(function () {
    'use strict';

    async function loadImageBitmap(url, alphaMode) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
      }
      const imageBlob = await response.blob();
      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
    }
    self.onmessage = async (event) => {
      try {
        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);
        self.postMessage({
          data: imageBitmap,
          uuid: event.data.uuid,
          id: event.data.id
        }, [imageBitmap]);
      } catch (e) {
        self.postMessage({
          error: e,
          uuid: event.data.uuid,
          id: event.data.id
        });
      }
    };

})();
`;
let Mo = null;
class q0 {
  constructor() {
    Mo || (Mo = URL.createObjectURL(new Blob([qU], { type: "application/javascript" }))), this.worker = new Worker(Mo);
  }
}
q0.revokeObjectURL = function() {
  Mo && (URL.revokeObjectURL(Mo), Mo = null);
};
let jS = 0, bf;
class $U {
  constructor() {
    this._initialized = !1, this._createdWorkers = 0, this._workerPool = [], this._queue = [], this._resolveHash = {};
  }
  isImageBitmapSupported() {
    return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise((t) => {
      const { worker: e } = new vg();
      e.addEventListener("message", (s) => {
        e.terminate(), vg.revokeObjectURL(), t(s.data);
      });
    }), this._isImageBitmapSupported);
  }
  loadImageBitmap(t, e) {
    var s;
    return this._run("loadImageBitmap", [t, (s = e == null ? void 0 : e.data) == null ? void 0 : s.alphaMode]);
  }
  async _initWorkers() {
    this._initialized || (this._initialized = !0);
  }
  _getWorker() {
    bf === void 0 && (bf = navigator.hardwareConcurrency || 4);
    let t = this._workerPool.pop();
    return !t && this._createdWorkers < bf && (this._createdWorkers++, t = new q0().worker, t.addEventListener("message", (e) => {
      this._complete(e.data), this._returnWorker(e.target), this._next();
    })), t;
  }
  _returnWorker(t) {
    this._workerPool.push(t);
  }
  _complete(t) {
    t.error !== void 0 ? this._resolveHash[t.uuid].reject(t.error) : this._resolveHash[t.uuid].resolve(t.data), this._resolveHash[t.uuid] = null;
  }
  async _run(t, e) {
    await this._initWorkers();
    const s = new Promise((r, n) => {
      this._queue.push({ id: t, arguments: e, resolve: r, reject: n });
    });
    return this._next(), s;
  }
  _next() {
    if (!this._queue.length)
      return;
    const t = this._getWorker();
    if (!t)
      return;
    const e = this._queue.pop(), s = e.id;
    this._resolveHash[jS] = { resolve: e.resolve, reject: e.reject }, t.postMessage({
      data: e.arguments,
      uuid: jS++,
      id: s
    });
  }
}
const XS = new $U(), ZU = [".jpeg", ".jpg", ".png", ".webp", ".avif"], QU = [
  "image/jpeg",
  "image/png",
  "image/webp",
  "image/avif"
];
async function JU(i, t) {
  var r;
  const e = await Wt.get().fetch(i);
  if (!e.ok)
    throw new Error(`[loadImageBitmap] Failed to fetch ${i}: ${e.status} ${e.statusText}`);
  const s = await e.blob();
  return ((r = t == null ? void 0 : t.data) == null ? void 0 : r.alphaMode) === "premultiplied-alpha" ? createImageBitmap(s, { premultiplyAlpha: "none" }) : createImageBitmap(s);
}
const $0 = {
  name: "loadTextures",
  extension: {
    type: B.LoadParser,
    priority: pn.High,
    name: "loadTextures"
  },
  config: {
    preferWorkers: !0,
    preferCreateImageBitmap: !0,
    crossOrigin: "anonymous"
  },
  test(i) {
    return Zo(i, QU) || Qo(i, ZU);
  },
  async load(i, t, e) {
    var n;
    let s = null;
    globalThis.createImageBitmap && this.config.preferCreateImageBitmap ? this.config.preferWorkers && await XS.isImageBitmapSupported() ? s = await XS.loadImageBitmap(i, t) : s = await JU(i, t) : s = await new Promise((a) => {
      s = new Image(), s.crossOrigin = this.config.crossOrigin, s.src = i, s.complete ? a(s) : s.onload = () => {
        a(s);
      };
    });
    const r = new Ra({
      resource: s,
      alphaMode: "premultiply-alpha-on-upload",
      resolution: ((n = t.data) == null ? void 0 : n.resolution) || NT(i),
      ...t.data
    });
    return UT(r, e, i);
  },
  unload(i) {
    i.destroy(!0);
  }
}, Z0 = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"], tD = Z0.map((i) => `video/${i.substring(1)}`);
function eD(i, t, e) {
  e === void 0 && !t.startsWith("data:") ? i.crossOrigin = iD(t) : e !== !1 && (i.crossOrigin = typeof e == "string" ? e : "anonymous");
}
function sD(i) {
  return new Promise((t, e) => {
    i.addEventListener("canplaythrough", s), i.addEventListener("error", r), i.load();
    function s() {
      n(), t();
    }
    function r(a) {
      n(), e(a);
    }
    function n() {
      i.removeEventListener("canplaythrough", s), i.removeEventListener("error", r);
    }
  });
}
function iD(i, t = globalThis.location) {
  if (i.startsWith("data:"))
    return "";
  t = t || globalThis.location;
  const e = new URL(i, document.baseURI);
  return e.hostname !== t.hostname || e.port !== t.port || e.protocol !== t.protocol ? "anonymous" : "";
}
const rD = {
  name: "loadVideo",
  extension: {
    type: B.LoadParser,
    name: "loadVideo"
  },
  test(i) {
    const t = Zo(i, tD), e = Qo(i, Z0);
    return t || e;
  },
  async load(i, t, e) {
    var h, u;
    const s = {
      ...Tl.defaultOptions,
      resolution: ((h = t.data) == null ? void 0 : h.resolution) || NT(i),
      alphaMode: ((u = t.data) == null ? void 0 : u.alphaMode) || await JR(),
      ...t.data
    }, r = document.createElement("video"), n = {
      preload: s.autoLoad !== !1 ? "auto" : void 0,
      "webkit-playsinline": s.playsinline !== !1 ? "" : void 0,
      playsinline: s.playsinline !== !1 ? "" : void 0,
      muted: s.muted === !0 ? "" : void 0,
      loop: s.loop === !0 ? "" : void 0,
      autoplay: s.autoPlay !== !1 ? "" : void 0
    };
    Object.keys(n).forEach((c) => {
      const l = n[c];
      l !== void 0 && r.setAttribute(c, l);
    }), s.muted === !0 && (r.muted = !0), eD(r, i, s.crossorigin);
    const a = document.createElement("source");
    let o;
    if (i.startsWith("data:"))
      o = i.slice(5, i.indexOf(";"));
    else if (!i.startsWith("blob:")) {
      const c = i.split("?")[0].slice(i.lastIndexOf(".") + 1).toLowerCase();
      o = Tl.MIME_TYPES[c] || `video/${c}`;
    }
    return a.src = i, o && (a.type = o), new Promise((c) => {
      const l = async () => {
        const _ = new Tl({ ...s, resource: r });
        r.removeEventListener("canplay", l), t.data.preload && await sD(r), c(UT(_, e, i));
      };
      r.addEventListener("canplay", l), r.appendChild(a);
    });
  },
  unload(i) {
    i.destroy(!0);
  }
}, Q0 = {
  extension: {
    type: B.ResolveParser,
    name: "resolveTexture"
  },
  test: $0.test,
  parse: (i) => {
    var t;
    return {
      resolution: parseFloat(((t = qo.RETINA_PREFIX.exec(i)) == null ? void 0 : t[1]) ?? "1"),
      format: i.split(".").pop(),
      src: i
    };
  }
}, nD = {
  extension: {
    type: B.ResolveParser,
    priority: -2,
    name: "resolveJson"
  },
  test: (i) => qo.RETINA_PREFIX.test(i) && i.endsWith(".json"),
  parse: Q0.parse
};
class aD {
  constructor() {
    this._detections = [], this._initialized = !1, this.resolver = new qo(), this.loader = new xU(), this.cache = ge, this._backgroundLoader = new TU(this.loader), this._backgroundLoader.active = !0, this.reset();
  }
  /**
   * Best practice is to call this function before any loading commences
   * Initiating is the best time to add any customization to the way things are loaded.
   *
   * you do not need to call this for the Assets class to work, only if you want to set any initial properties
   * @param options - options to initialize the Assets manager with
   */
  async init(t = {}) {
    var n, a;
    if (this._initialized) {
      ce("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
      return;
    }
    if (this._initialized = !0, t.defaultSearchParams && this.resolver.setDefaultSearchParams(t.defaultSearchParams), t.basePath && (this.resolver.basePath = t.basePath), t.bundleIdentifier && this.resolver.setBundleIdentifier(t.bundleIdentifier), t.manifest) {
      let o = t.manifest;
      typeof o == "string" && (o = await this.load(o)), this.resolver.addManifest(o);
    }
    const e = ((n = t.texturePreference) == null ? void 0 : n.resolution) ?? 1, s = typeof e == "number" ? [e] : e, r = await this._detectFormats({
      preferredFormats: (a = t.texturePreference) == null ? void 0 : a.format,
      skipDetections: t.skipDetections,
      detections: this._detections
    });
    this.resolver.prefer({
      params: {
        format: r,
        resolution: s
      }
    }), t.preferences && this.setPreferences(t.preferences);
  }
  /**
   * Allows you to specify how to resolve any assets load requests.
   * There are a few ways to add things here as shown below:
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Simple
   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});
   * const bunny = await Assets.load('bunnyBooBoo');
   *
   * // Multiple keys:
   * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});
   *
   * const bunny = await Assets.load('burger');
   * const bunny2 = await Assets.load('chicken');
   *
   * // passing options to to the object
   * Assets.add({
   *     alias: 'bunnyBooBooSmooth',
   *     src: 'bunny{png,webp}',
   *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options
   * });
   *
   * // Multiple assets
   *
   * // The following all do the same thing:
   *
   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny{png,webp}'});
   *
   * Assets.add({
   *     alias: 'bunnyBooBoo',
   *     src: [
   *         'bunny.png',
   *         'bunny.webp',
   *    ],
   * });
   *
   * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available
   * @param assets - the unresolved assets to add to the resolver
   */
  add(t) {
    this.resolver.add(t);
  }
  async load(t, e) {
    this._initialized || await this.init();
    const s = kl(t), r = li(t).map((o) => {
      if (typeof o != "string") {
        const h = this.resolver.getAlias(o);
        return h.some((u) => !this.resolver.hasKey(u)) && this.add(o), Array.isArray(h) ? h[0] : h;
      }
      return this.resolver.hasKey(o) || this.add({ alias: o, src: o }), o;
    }), n = this.resolver.resolve(r), a = await this._mapLoadToResolve(n, e);
    return s ? a[r[0]] : a;
  }
  /**
   * This adds a bundle of assets in one go so that you can load them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.addBundle('animals', [
   *  { alias: 'bunny', src: 'bunny.png' },
   *  { alias: 'chicken', src: 'chicken.png' },
   *  { alias: 'thumper', src: 'thumper.png' },
   * ]);
   * // or
   * Assets.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const assets = await Assets.loadBundle('animals');
   * @param bundleId - the id of the bundle to add
   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key
   */
  addBundle(t, e) {
    this.resolver.addBundle(t, e);
  }
  /**
   * Bundles are a way to load multiple assets at once.
   * If a manifest has been provided to the init function then you can load a bundle, or bundles.
   * you can also add bundles via `addBundle`
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * await Assets.init({ manifest });
   *
   * // Load a bundle...
   * loadScreenAssets = await Assets.loadBundle('load-screen');
   * // Load another bundle...
   * gameScreenAssets = await Assets.loadBundle('game-screen');
   * @param bundleIds - the bundle id or ids to load
   * @param onProgress - Optional function that is called when progress on asset loading is made.
   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)
   * of the assets loaded. Do not use this function to detect when assets are complete and available,
   * instead use the Promise returned by this function.
   * @returns all the bundles assets or a hash of assets for each bundle specified
   */
  async loadBundle(t, e) {
    this._initialized || await this.init();
    let s = !1;
    typeof t == "string" && (s = !0, t = [t]);
    const r = this.resolver.resolveBundle(t), n = {}, a = Object.keys(r);
    let o = 0, h = 0;
    const u = () => {
      e == null || e(++o / h);
    }, c = a.map((l) => {
      const _ = r[l];
      return h += Object.keys(_).length, this._mapLoadToResolve(_, u).then((d) => {
        n[l] = d;
      });
    });
    return await Promise.all(c), s ? n[t[0]] : n;
  }
  /**
   * Initiate a background load of some assets. It will passively begin to load these assets in the background.
   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately
   *
   * An example of this might be that you would background load game assets after your initial load.
   * then when you got to actually load your game screen assets when a player goes to the game - the loading
   * would already have stared or may even be complete, saving you having to show an interim load bar.
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.backgroundLoad('bunny.png');
   *
   * // later on in your app...
   * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!
   * @param urls - the url / urls you want to background load
   */
  async backgroundLoad(t) {
    this._initialized || await this.init(), typeof t == "string" && (t = [t]);
    const e = this.resolver.resolve(t);
    this._backgroundLoader.add(Object.values(e));
  }
  /**
   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.
   * this can only be used if the loader has been initiated with a manifest
   * @example
   * import { Assets } from 'pixi.js';
   *
   * await Assets.init({
   *     manifest: {
   *         bundles: [
   *             {
   *                 name: 'load-screen',
   *                 assets: [...],
   *             },
   *             ...
   *         ],
   *     },
   * });
   *
   * Assets.backgroundLoadBundle('load-screen');
   *
   * // Later on in your app...
   * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!
   * @param bundleIds - the bundleId / bundleIds you want to background load
   */
  async backgroundLoadBundle(t) {
    this._initialized || await this.init(), typeof t == "string" && (t = [t]);
    const e = this.resolver.resolveBundle(t);
    Object.values(e).forEach((s) => {
      this._backgroundLoader.add(Object.values(s));
    });
  }
  /**
   * Only intended for development purposes.
   * This will wipe the resolver and caches.
   * You will need to reinitialize the Asset
   */
  reset() {
    this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = !1;
  }
  get(t) {
    if (typeof t == "string")
      return ge.get(t);
    const e = {};
    for (let s = 0; s < t.length; s++)
      e[s] = ge.get(t[s]);
    return e;
  }
  /**
   * helper function to map resolved assets back to loaded assets
   * @param resolveResults - the resolve results from the resolver
   * @param onProgress - the progress callback
   */
  async _mapLoadToResolve(t, e) {
    const s = [...new Set(Object.values(t))];
    this._backgroundLoader.active = !1;
    const r = await this.loader.load(s, e);
    this._backgroundLoader.active = !0;
    const n = {};
    return s.forEach((a) => {
      const o = r[a.src], h = [a.src];
      a.alias && h.push(...a.alias), h.forEach((u) => {
        n[u] = o;
      }), ge.set(h, o);
    }), n;
  }
  /**
   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function
   * this will make sure to destroy any assets and release them from memory.
   * Once unloaded, you will need to load the asset again.
   *
   * Use this to help manage assets if you find that you have a large app and you want to free up memory.
   *
   * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,
   * Pixi won't break but you will end up with missing assets. Not a good look for the user!
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Load a URL:
   * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture
   *
   * await Assets.unload('http://some.url.com/image.png')
   *
   * // myImageTexture will be destroyed now.
   *
   * // Unload multiple assets:
   * const textures = await Assets.unload(['thumper', 'chicko']);
   * @param urls - the urls to unload
   */
  async unload(t) {
    this._initialized || await this.init();
    const e = li(t).map((r) => typeof r != "string" ? r.src : r), s = this.resolver.resolve(e);
    await this._unloadFromResolved(s);
  }
  /**
   * Bundles are a way to manage multiple assets at once.
   * this will unload all files in a bundle.
   *
   * once a bundle has been unloaded, you need to load it again to have access to the assets.
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.addBundle({
   *     'thumper': 'http://some.url.com/thumper.png',
   * })
   *
   * const assets = await Assets.loadBundle('thumper');
   *
   * // Now to unload...
   *
   * await Assets.unloadBundle('thumper');
   *
   * // All assets in the assets object will now have been destroyed and purged from the cache
   * @param bundleIds - the bundle id or ids to unload
   */
  async unloadBundle(t) {
    this._initialized || await this.init(), t = li(t);
    const e = this.resolver.resolveBundle(t), s = Object.keys(e).map((r) => this._unloadFromResolved(e[r]));
    await Promise.all(s);
  }
  async _unloadFromResolved(t) {
    const e = Object.values(t);
    e.forEach((s) => {
      ge.remove(s.src);
    }), await this.loader.unload(e);
  }
  /**
   * Detects the supported formats for the browser, and returns an array of supported formats, respecting
   * the users preferred formats order.
   * @param options - the options to use when detecting formats
   * @param options.preferredFormats - the preferred formats to use
   * @param options.skipDetections - if we should skip the detections altogether
   * @param options.detections - the detections to use
   * @returns - the detected formats
   */
  async _detectFormats(t) {
    let e = [];
    t.preferredFormats && (e = Array.isArray(t.preferredFormats) ? t.preferredFormats : [t.preferredFormats]);
    for (const s of t.detections)
      t.skipDetections || await s.test() ? e = await s.add(e) : t.skipDetections || (e = await s.remove(e));
    return e = e.filter((s, r) => e.indexOf(s) === r), e;
  }
  /** All the detection parsers currently added to the Assets class. */
  get detections() {
    return this._detections;
  }
  /**
   * General setter for preferences. This is a helper function to set preferences on all parsers.
   * @param preferences - the preferences to set
   */
  setPreferences(t) {
    this.loader.parsers.forEach((e) => {
      e.config && Object.keys(e.config).filter((s) => s in t).forEach((s) => {
        e.config[s] = t[s];
      });
    });
  }
}
const ra = new aD();
Ee.handleByList(B.LoadParser, ra.loader.parsers).handleByList(B.ResolveParser, ra.resolver.parsers).handleByList(B.CacheParser, ra.cache.parsers).handleByList(B.DetectionParser, ra.detections);
Ee.add(
  IU,
  AU,
  SU,
  CU,
  OU,
  yU,
  vU,
  PU,
  DU,
  VU,
  WU,
  $0,
  rD,
  EU,
  mU,
  Q0,
  nD
);
const KS = {
  loader: B.LoadParser,
  resolver: B.ResolveParser,
  cache: B.CacheParser,
  detection: B.DetectionParser
};
Ee.handle(B.Asset, (i) => {
  const t = i.ref;
  Object.entries(KS).filter(([e]) => !!t[e]).forEach(([e, s]) => Ee.add(Object.assign(
    t[e],
    // Allow the function to optionally define it's own
    // ExtensionMetadata, the use cases here is priority for LoaderParsers
    { extension: t[e].extension ?? s }
  )));
}, (i) => {
  const t = i.ref;
  Object.keys(KS).filter((e) => !!t[e]).forEach((e) => Ee.remove(t[e]));
});
var J0 = `in vec2 aPosition;
out vec2 vTextureCoord;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, oD = `
in vec2 vTextureCoord;

out vec4 finalColor;

uniform float uAlpha;
uniform sampler2D uTexture;

void main()
{
    finalColor =  texture(uTexture, vTextureCoord) * uAlpha;
}
`, qS = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct AlphaUniforms {
  uAlpha:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
 
    var sample = textureSample(uTexture, uSampler, uv);
    
    return sample * alphaUniforms.uAlpha;
}`;
const tO = class eO extends xt {
  constructor(t) {
    t = { ...eO.defaultOptions, ...t };
    const e = Ot.from({
      vertex: {
        source: qS,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: qS,
        entryPoint: "mainFragment"
      }
    }), s = It.from({
      vertex: J0,
      fragment: oD,
      name: "alpha-filter"
    }), { alpha: r, ...n } = t, a = new mn({
      uAlpha: { value: r, type: "f32" }
    });
    super({
      ...n,
      gpuProgram: e,
      glProgram: s,
      resources: {
        alphaUniforms: a
      }
    });
  }
  /**
   * Coefficient for alpha multiplication
   * @default 1
   */
  get alpha() {
    return this.resources.alphaUniforms.uniforms.uAlpha;
  }
  set alpha(t) {
    this.resources.alphaUniforms.uniforms.uAlpha = t;
  }
};
tO.defaultOptions = {
  /** Amount of alpha from 0 to 1, where 0 is transparent */
  alpha: 1
};
let Yl = tO, hD = 0;
class uD {
  /**
   * @param textureOptions - options that will be passed to BaseRenderTexture constructor
   * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.
   */
  constructor(t) {
    this._poolKeyHash = /* @__PURE__ */ Object.create(null), this._texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1;
  }
  /**
   * Creates texture with params that were specified in pool constructor.
   * @param pixelWidth - Width of texture in pixels.
   * @param pixelHeight - Height of texture in pixels.
   * @param antialias
   */
  createTexture(t, e, s) {
    const r = new ke({
      ...this.textureOptions,
      width: t,
      height: e,
      resolution: 1,
      antialias: s,
      autoGarbageCollect: !0
    });
    return new W({
      source: r,
      label: `texturePool_${hD++}`
    });
  }
  /**
   * Gets a Power-of-Two render texture or fullScreen texture
   * @param frameWidth - The minimum width of the render texture.
   * @param frameHeight - The minimum height of the render texture.
   * @param resolution - The resolution of the render texture.
   * @param antialias
   * @returns The new render texture.
   */
  getOptimalTexture(t, e, s = 1, r) {
    let n = Math.ceil(t * s - 1e-6), a = Math.ceil(e * s - 1e-6);
    n = Ll(n), a = Ll(a);
    const o = (n << 17) + (a << 1) + (r ? 1 : 0);
    this._texturePool[o] || (this._texturePool[o] = []);
    let h = this._texturePool[o].pop();
    return h || (h = this.createTexture(n, a, r)), h.source._resolution = s, h.source.width = n / s, h.source.height = a / s, h.source.pixelWidth = n, h.source.pixelHeight = a, h.frame.x = 0, h.frame.y = 0, h.frame.width = t, h.frame.height = e, h.updateUvs(), this._poolKeyHash[h.uid] = o, h;
  }
  /**
   * Gets extra texture of the same size as input renderTexture
   * @param texture - The texture to check what size it is.
   * @param antialias - Whether to use antialias.
   * @returns A texture that is a power of two
   */
  getSameSizeTexture(t, e = !1) {
    const s = t.source;
    return this.getOptimalTexture(t.width, t.height, s._resolution, e);
  }
  /**
   * Place a render texture back into the pool.
   * @param renderTexture - The renderTexture to free
   */
  returnTexture(t) {
    const e = this._poolKeyHash[t.uid];
    this._texturePool[e].push(t);
  }
  /**
   * Clears the pool.
   * @param destroyTextures - Destroy all stored textures.
   */
  clear(t) {
    if (t = t !== !1, t)
      for (const e in this._texturePool) {
        const s = this._texturePool[e];
        if (s)
          for (let r = 0; r < s.length; r++)
            s[r].destroy(!0);
      }
    this._texturePool = {};
  }
}
const ps = new uD(), sO = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
}, lD = [
  "in vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uTexture;",
  "out vec4 finalColor;",
  "void main(void)",
  "{",
  "    finalColor = vec4(0.0);",
  "    %blur%",
  "}"
].join(`
`);
function cD(i) {
  const t = sO[i], e = t.length;
  let s = lD, r = "";
  const n = "finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;";
  let a;
  for (let o = 0; o < i; o++) {
    let h = n.replace("%index%", o.toString());
    a = o, o >= e && (a = i - o - 1), h = h.replace("%value%", t[a].toString()), r += h, r += `
`;
  }
  return s = s.replace("%blur%", r), s = s.replace("%size%", i.toString()), s;
}
const _D = `
    in vec2 aPosition;

    uniform float uStrength;

    out vec2 vBlurTexCoords[%size%];

    uniform vec4 uInputSize;
    uniform vec4 uOutputFrame;
    uniform vec4 uOutputTexture;

    vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

    vec2 filterTextureCoord( void )
    {
        return aPosition * (uOutputFrame.zw * uInputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        float pixelStrength = uInputSize.%dimension% * uStrength;

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function dD(i, t) {
  const e = Math.ceil(i / 2);
  let s = _D, r = "", n;
  t ? n = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);" : n = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);";
  for (let a = 0; a < i; a++) {
    let o = n.replace("%index%", a.toString());
    o = o.replace("%sampleIndex%", `${a - (e - 1)}.0`), r += o, r += `
`;
  }
  return s = s.replace("%blur%", r), s = s.replace("%size%", i.toString()), s = s.replace("%dimension%", t ? "z" : "w"), s;
}
function fD(i, t) {
  const e = dD(t, i), s = cD(t);
  return It.from({
    vertex: e,
    fragment: s,
    name: `blur-${i ? "horizontal" : "vertical"}-pass-filter`
  });
}
var gD = `

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct BlurUniforms {
  uStrength:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    %blur-struct%
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}


@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {

  let filteredCord = filterTextureCoord(aPosition);

  let pixelStrength = gfu.uInputSize.%dimension% * blurUniforms.uStrength;

  return VSOutput(
   filterVertexPosition(aPosition),
    %blur-vertex-out%
  );
}

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  %blur-fragment-in%
) -> @location(0) vec4<f32> {

    var   finalColor = vec4(0.0);

    %blur-sampling%

    return finalColor;
}`;
function pD(i, t) {
  const e = sO[t], s = e.length, r = [], n = [], a = [];
  for (let l = 0; l < t; l++) {
    r[l] = `@location(${l}) offset${l}: vec2<f32>,`, i ? n[l] = `filteredCord + vec2(${l - s + 1} * pixelStrength, 0.0),` : n[l] = `filteredCord + vec2(0.0, ${l - s + 1} * pixelStrength),`;
    const _ = l < s ? l : t - l - 1, d = e[_].toString();
    a[l] = `finalColor += textureSample(uTexture, uSampler, offset${l}) * ${d};`;
  }
  const o = r.join(`
`), h = n.join(`
`), u = a.join(`
`), c = gD.replace("%blur-struct%", o).replace("%blur-vertex-out%", h).replace("%blur-fragment-in%", o).replace("%blur-sampling%", u).replace("%dimension%", i ? "z" : "w");
  return Ot.from({
    vertex: {
      source: c,
      entryPoint: "mainVertex"
    },
    fragment: {
      source: c,
      entryPoint: "mainFragment"
    }
  });
}
const iO = class rO extends xt {
  /**
   * @param options
   * @param options.horizontal - Do pass along the x-axis (`true`) or y-axis (`false`).
   * @param options.strength - The strength of the blur filter.
   * @param options.quality - The quality of the blur filter.
   * @param options.kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
   */
  constructor(t) {
    t = { ...rO.defaultOptions, ...t };
    const e = fD(t.horizontal, t.kernelSize), s = pD(t.horizontal, t.kernelSize);
    super({
      glProgram: e,
      gpuProgram: s,
      resources: {
        blurUniforms: {
          uStrength: { value: 0, type: "f32" }
        }
      },
      ...t
    }), this.horizontal = t.horizontal, this._quality = 0, this.quality = t.quality, this.blur = t.strength, this._uniforms = this.resources.blurUniforms.uniforms;
  }
  /**
   * Applies the filter.
   * @param filterManager - The manager.
   * @param input - The input target.
   * @param output - The output target.
   * @param clearMode - How to clear
   */
  apply(t, e, s, r) {
    if (this._uniforms.uStrength = this.strength / this.passes, this.passes === 1)
      t.applyFilter(this, e, s, r);
    else {
      const n = ps.getSameSizeTexture(e);
      let a = e, o = n;
      this._state.blend = !1;
      const h = t.renderer.type === Or.WEBGPU;
      for (let u = 0; u < this.passes - 1; u++) {
        t.applyFilter(this, a, o, u === 0 ? !0 : h);
        const c = o;
        o = a, a = c;
      }
      this._state.blend = !0, t.applyFilter(this, a, s, r), ps.returnTexture(n);
    }
  }
  /**
   * Sets the strength of both the blur.
   * @default 16
   */
  get blur() {
    return this.strength;
  }
  set blur(t) {
    this.padding = 1 + Math.abs(t) * 2, this.strength = t;
  }
  /**
   * Sets the quality of the blur by modifying the number of passes. More passes means higher
   * quality blurring but the lower the performance.
   * @default 4
   */
  get quality() {
    return this._quality;
  }
  set quality(t) {
    this._quality = t, this.passes = t;
  }
};
iO.defaultOptions = {
  /** The strength of the blur filter. */
  strength: 8,
  /** The quality of the blur filter. */
  quality: 4,
  /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */
  kernelSize: 5
};
let $S = iO;
var mD = `
in vec2 vTextureCoord;
in vec4 vColor;

out vec4 finalColor;

uniform float uColorMatrix[20];
uniform float uAlpha;

uniform sampler2D uTexture;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture(uTexture, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * 0.2);
    float diff = (randomValue - 0.5) *  0.5;

    if (uAlpha == 0.0) {
        finalColor = color;
        return;
    }

    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    vec4 result;

    result.r = (uColorMatrix[0] * color.r);
        result.r += (uColorMatrix[1] * color.g);
        result.r += (uColorMatrix[2] * color.b);
        result.r += (uColorMatrix[3] * color.a);
        result.r += uColorMatrix[4];

    result.g = (uColorMatrix[5] * color.r);
        result.g += (uColorMatrix[6] * color.g);
        result.g += (uColorMatrix[7] * color.b);
        result.g += (uColorMatrix[8] * color.a);
        result.g += uColorMatrix[9];

    result.b = (uColorMatrix[10] * color.r);
       result.b += (uColorMatrix[11] * color.g);
       result.b += (uColorMatrix[12] * color.b);
       result.b += (uColorMatrix[13] * color.a);
       result.b += uColorMatrix[14];

    result.a = (uColorMatrix[15] * color.r);
       result.a += (uColorMatrix[16] * color.g);
       result.a += (uColorMatrix[17] * color.b);
       result.a += (uColorMatrix[18] * color.a);
       result.a += uColorMatrix[19];

    vec3 rgb = mix(color.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    finalColor = vec4(rgb, result.a);
}
`, ZS = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct ColorMatrixUniforms {
  uColorMatrix:array<vec4<f32>, 5>,
  uAlpha:f32,
};


@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;
@group(1) @binding(0) var<uniform> colorMatrixUniforms : ColorMatrixUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
  };
  
fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
  );
}


@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
) -> @location(0) vec4<f32> {


  var c = textureSample(uTexture, uSampler, uv);
  
  if (colorMatrixUniforms.uAlpha == 0.0) {
    return c;
  }

 
    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.r /= c.a;
      c.g /= c.a;
      c.b /= c.a;
    }

    var cm = colorMatrixUniforms.uColorMatrix;


    var result = vec4<f32>(0.);

    result.r = (cm[0][0] * c.r);
    result.r += (cm[0][1] * c.g);
    result.r += (cm[0][2] * c.b);
    result.r += (cm[0][3] * c.a);
    result.r += cm[1][0];

    result.g = (cm[1][1] * c.r);
    result.g += (cm[1][2] * c.g);
    result.g += (cm[1][3] * c.b);
    result.g += (cm[2][0] * c.a);
    result.g += cm[2][1];

    result.b = (cm[2][2] * c.r);
    result.b += (cm[2][3] * c.g);
    result.b += (cm[3][0] * c.b);
    result.b += (cm[3][1] * c.a);
    result.b += cm[3][2];

    result.a = (cm[3][3] * c.r);
    result.a += (cm[4][0] * c.g);
    result.a += (cm[4][1] * c.b);
    result.a += (cm[4][2] * c.a);
    result.a += cm[4][3];

    var rgb = mix(c.rgb, result.rgb, colorMatrixUniforms.uAlpha);

    rgb.r *= result.a;
    rgb.g *= result.a;
    rgb.b *= result.a;

    return vec4(rgb, result.a);
}`;
class Sh extends xt {
  constructor(t = {}) {
    const e = new mn({
      uColorMatrix: {
        value: [
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        type: "f32",
        size: 20
      },
      uAlpha: {
        value: 1,
        type: "f32"
      }
    }), s = Ot.from({
      vertex: {
        source: ZS,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: ZS,
        entryPoint: "mainFragment"
      }
    }), r = It.from({
      vertex: J0,
      fragment: mD,
      name: "color-matrix-filter"
    });
    super({
      ...t,
      gpuProgram: s,
      glProgram: r,
      resources: {
        colorMatrixUniforms: e
      }
    }), this.alpha = 1;
  }
  /**
   * Transforms current matrix and set the new one
   * @param {number[]} matrix - 5x4 matrix
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  _loadMatrix(t, e = !1) {
    let s = t;
    e && (this._multiply(s, this.matrix, t), s = this._colorMatrix(s)), this.resources.colorMatrixUniforms.uniforms.uColorMatrix = s, this.resources.colorMatrixUniforms.update();
  }
  /**
   * Multiplies two mat5's
   * @private
   * @param out - 5x4 matrix the receiving matrix
   * @param a - 5x4 matrix the first operand
   * @param b - 5x4 matrix the second operand
   * @returns {number[]} 5x4 matrix
   */
  _multiply(t, e, s) {
    return t[0] = e[0] * s[0] + e[1] * s[5] + e[2] * s[10] + e[3] * s[15], t[1] = e[0] * s[1] + e[1] * s[6] + e[2] * s[11] + e[3] * s[16], t[2] = e[0] * s[2] + e[1] * s[7] + e[2] * s[12] + e[3] * s[17], t[3] = e[0] * s[3] + e[1] * s[8] + e[2] * s[13] + e[3] * s[18], t[4] = e[0] * s[4] + e[1] * s[9] + e[2] * s[14] + e[3] * s[19] + e[4], t[5] = e[5] * s[0] + e[6] * s[5] + e[7] * s[10] + e[8] * s[15], t[6] = e[5] * s[1] + e[6] * s[6] + e[7] * s[11] + e[8] * s[16], t[7] = e[5] * s[2] + e[6] * s[7] + e[7] * s[12] + e[8] * s[17], t[8] = e[5] * s[3] + e[6] * s[8] + e[7] * s[13] + e[8] * s[18], t[9] = e[5] * s[4] + e[6] * s[9] + e[7] * s[14] + e[8] * s[19] + e[9], t[10] = e[10] * s[0] + e[11] * s[5] + e[12] * s[10] + e[13] * s[15], t[11] = e[10] * s[1] + e[11] * s[6] + e[12] * s[11] + e[13] * s[16], t[12] = e[10] * s[2] + e[11] * s[7] + e[12] * s[12] + e[13] * s[17], t[13] = e[10] * s[3] + e[11] * s[8] + e[12] * s[13] + e[13] * s[18], t[14] = e[10] * s[4] + e[11] * s[9] + e[12] * s[14] + e[13] * s[19] + e[14], t[15] = e[15] * s[0] + e[16] * s[5] + e[17] * s[10] + e[18] * s[15], t[16] = e[15] * s[1] + e[16] * s[6] + e[17] * s[11] + e[18] * s[16], t[17] = e[15] * s[2] + e[16] * s[7] + e[17] * s[12] + e[18] * s[17], t[18] = e[15] * s[3] + e[16] * s[8] + e[17] * s[13] + e[18] * s[18], t[19] = e[15] * s[4] + e[16] * s[9] + e[17] * s[14] + e[18] * s[19] + e[19], t;
  }
  /**
   * Create a Float32 Array and normalize the offset component to 0-1
   * @param {number[]} matrix - 5x4 matrix
   * @returns {number[]} 5x4 matrix with all values between 0-1
   */
  _colorMatrix(t) {
    const e = new Float32Array(t);
    return e[4] /= 255, e[9] /= 255, e[14] /= 255, e[19] /= 255, e;
  }
  /**
   * Adjusts brightness
   * @param b - value of the brightness (0-1, where 0 is black)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  brightness(t, e) {
    const s = [
      t,
      0,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(s, e);
  }
  /**
   * Sets each channel on the diagonal of the color matrix.
   * This can be used to achieve a tinting effect on Containers similar to the tint field of some
   * display objects like Sprite, Text, Graphics, and Mesh.
   * @param color - Color of the tint. This is a hex value.
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  tint(t, e) {
    const [s, r, n] = Pt.shared.setValue(t).toArray(), a = [
      s,
      0,
      0,
      0,
      0,
      0,
      r,
      0,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(a, e);
  }
  /**
   * Set the matrices in grey scales
   * @param scale - value of the grey (0-1, where 0 is black)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  greyscale(t, e) {
    const s = [
      t,
      t,
      t,
      0,
      0,
      t,
      t,
      t,
      0,
      0,
      t,
      t,
      t,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(s, e);
  }
  /**
   * for our american friends!
   * @param scale
   * @param multiply
   */
  grayscale(t, e) {
    this.greyscale(t, e);
  }
  /**
   * Set the black and white matrice.
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  blackAndWhite(t) {
    const e = [
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(e, t);
  }
  /**
   * Set the hue property of the color
   * @param rotation - in degrees
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  hue(t, e) {
    t = (t || 0) / 180 * Math.PI;
    const s = Math.cos(t), r = Math.sin(t), n = Math.sqrt, a = 1 / 3, o = n(a), h = s + (1 - s) * a, u = a * (1 - s) - o * r, c = a * (1 - s) + o * r, l = a * (1 - s) + o * r, _ = s + a * (1 - s), d = a * (1 - s) - o * r, f = a * (1 - s) - o * r, p = a * (1 - s) + o * r, g = s + a * (1 - s), m = [
      h,
      u,
      c,
      0,
      0,
      l,
      _,
      d,
      0,
      0,
      f,
      p,
      g,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(m, e);
  }
  /**
   * Set the contrast matrix, increase the separation between dark and bright
   * Increase contrast : shadows darker and highlights brighter
   * Decrease contrast : bring the shadows up and the highlights down
   * @param amount - value of the contrast (0-1)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  contrast(t, e) {
    const s = (t || 0) + 1, r = -0.5 * (s - 1), n = [
      s,
      0,
      0,
      0,
      r,
      0,
      s,
      0,
      0,
      r,
      0,
      0,
      s,
      0,
      r,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(n, e);
  }
  /**
   * Set the saturation matrix, increase the separation between colors
   * Increase saturation : increase contrast, brightness, and sharpness
   * @param amount - The saturation amount (0-1)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  saturate(t = 0, e) {
    const s = t * 2 / 3 + 1, r = (s - 1) * -0.5, n = [
      s,
      r,
      r,
      0,
      0,
      r,
      s,
      r,
      0,
      0,
      r,
      r,
      s,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(n, e);
  }
  /** Desaturate image (remove color) Call the saturate function */
  desaturate() {
    this.saturate(-1);
  }
  /**
   * Negative image (inverse of classic rgb matrix)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  negative(t) {
    const e = [
      -1,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      -1,
      1,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(e, t);
  }
  /**
   * Sepia image
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  sepia(t) {
    const e = [
      0.393,
      0.7689999,
      0.18899999,
      0,
      0,
      0.349,
      0.6859999,
      0.16799999,
      0,
      0,
      0.272,
      0.5339999,
      0.13099999,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(e, t);
  }
  /**
   * Color motion picture process invented in 1916 (thanks Dominic Szablewski)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  technicolor(t) {
    const e = [
      1.9125277891456083,
      -0.8545344976951645,
      -0.09155508482755585,
      0,
      11.793603434377337,
      -0.3087833385928097,
      1.7658908555458428,
      -0.10601743074722245,
      0,
      -70.35205161461398,
      -0.231103377548616,
      -0.7501899197440212,
      1.847597816108189,
      0,
      30.950940869491138,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(e, t);
  }
  /**
   * Polaroid filter
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  polaroid(t) {
    const e = [
      1.438,
      -0.062,
      -0.062,
      0,
      0,
      -0.122,
      1.378,
      -0.122,
      0,
      0,
      -0.016,
      -0.016,
      1.483,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(e, t);
  }
  /**
   * Filter who transforms : Red -> Blue and Blue -> Red
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  toBGR(t) {
    const e = [
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(e, t);
  }
  /**
   * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  kodachrome(t) {
    const e = [
      1.1285582396593525,
      -0.3967382283601348,
      -0.03992559172921793,
      0,
      63.72958762196502,
      -0.16404339962244616,
      1.0835251566291304,
      -0.05498805115633132,
      0,
      24.732407896706203,
      -0.16786010706155763,
      -0.5603416277695248,
      1.6014850761964943,
      0,
      35.62982807460946,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(e, t);
  }
  /**
   * Brown delicious browni filter (thanks Dominic Szablewski)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  browni(t) {
    const e = [
      0.5997023498159715,
      0.34553243048391263,
      -0.2708298674538042,
      0,
      47.43192855600873,
      -0.037703249837783157,
      0.8609577587992641,
      0.15059552388459913,
      0,
      -36.96841498319127,
      0.24113635128153335,
      -0.07441037908422492,
      0.44972182064877153,
      0,
      -7.562075277591283,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(e, t);
  }
  /**
   * Vintage filter (thanks Dominic Szablewski)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  vintage(t) {
    const e = [
      0.6279345635605994,
      0.3202183420819367,
      -0.03965408211312453,
      0,
      9.651285835294123,
      0.02578397704808868,
      0.6441188644374771,
      0.03259127616149294,
      0,
      7.462829176470591,
      0.0466055556782719,
      -0.0851232987247891,
      0.5241648018700465,
      0,
      5.159190588235296,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(e, t);
  }
  /**
   * We don't know exactly what it does, kind of gradient map, but funny to play with!
   * @param desaturation - Tone values.
   * @param toned - Tone values.
   * @param lightColor - Tone values, example: `0xFFE580`
   * @param darkColor - Tone values, example: `0xFFE580`
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  colorTone(t, e, s, r, n) {
    t = t || 0.2, e = e || 0.15, s = s || 16770432, r = r || 3375104;
    const a = Pt.shared, [o, h, u] = a.setValue(s).toArray(), [c, l, _] = a.setValue(r).toArray(), d = [
      0.3,
      0.59,
      0.11,
      0,
      0,
      o,
      h,
      u,
      t,
      0,
      c,
      l,
      _,
      e,
      0,
      o - c,
      h - l,
      u - _,
      0,
      0
    ];
    this._loadMatrix(d, n);
  }
  /**
   * Night effect
   * @param intensity - The intensity of the night effect.
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  night(t, e) {
    t = t || 0.1;
    const s = [
      t * -2,
      -t,
      0,
      0,
      0,
      -t,
      0,
      t,
      0,
      0,
      0,
      t,
      t * 2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(s, e);
  }
  /**
   * Predator effect
   *
   * Erase the current matrix by setting a new independent one
   * @param amount - how much the predator feels his future victim
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  predator(t, e) {
    const s = [
      // row 1
      11.224130630493164 * t,
      -4.794486999511719 * t,
      -2.8746118545532227 * t,
      0 * t,
      0.40342438220977783 * t,
      // row 2
      -3.6330697536468506 * t,
      9.193157196044922 * t,
      -2.951810836791992 * t,
      0 * t,
      -1.316135048866272 * t,
      // row 3
      -3.2184197902679443 * t,
      -4.2375030517578125 * t,
      7.476448059082031 * t,
      0 * t,
      0.8044459223747253 * t,
      // row 4
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(s, e);
  }
  /**
   * LSD effect
   *
   * Multiply the current matrix
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  lsd(t) {
    const e = [
      2,
      -0.4,
      0.5,
      0,
      0,
      -0.5,
      2,
      -0.4,
      0,
      0,
      -0.4,
      -0.5,
      3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(e, t);
  }
  /** Erase the current matrix by setting the default one. */
  reset() {
    const t = [
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(t, !1);
  }
  /**
   * The matrix of the color matrix filter
   * @member {number[]}
   * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
   */
  get matrix() {
    return this.resources.colorMatrixUniforms.uniforms.uColorMatrix;
  }
  set matrix(t) {
    this.resources.colorMatrixUniforms.uniforms.uColorMatrix = t;
  }
  /**
   * The opacity value to use when mixing the original and resultant colors.
   *
   * When the value is 0, the original color is used without modification.
   * When the value is 1, the result color is used.
   * When in the range (0, 1) the color is interpolated between the original and result by this amount.
   * @default 1
   */
  get alpha() {
    return this.resources.colorMatrixUniforms.uniforms.uAlpha;
  }
  set alpha(t) {
    this.resources.colorMatrixUniforms.uniforms.uAlpha = t;
  }
}
var ED = `in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;
uniform float uInverse;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha;
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    float a = alphaMul * masky.r * npmAlpha * clip;

    if (uInverse == 1.0) {
        a = 1.0 - a;
    }

    finalColor = original * a;
}
`, TD = `in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`, QS = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
  uInverse:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;
    var uAlpha = filterUniforms.uAlpha;

    var clip = step(3.5,
      step(maskClamp.x, filterUv.x) +
      step(maskClamp.y, filterUv.y) +
      step(filterUv.x, maskClamp.z) +
      step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);

    var a: f32 = alphaMul * mask.r * uAlpha * clip;

    if (filterUniforms.uInverse == 1.0) {
        a = 1.0 - a;
    }

    return source * a;
}
`;
class ID extends xt {
  constructor(t) {
    const { sprite: e, ...s } = t, r = new wR(e.texture), n = new mn({
      uFilterMatrix: { value: new ot(), type: "mat3x3<f32>" },
      uMaskClamp: { value: r.uClampFrame, type: "vec4<f32>" },
      uAlpha: { value: 1, type: "f32" },
      uInverse: { value: t.inverse ? 1 : 0, type: "f32" }
    }), a = Ot.from({
      vertex: {
        source: QS,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: QS,
        entryPoint: "mainFragment"
      }
    }), o = It.from({
      vertex: TD,
      fragment: ED,
      name: "mask-filter"
    });
    super({
      ...s,
      gpuProgram: a,
      glProgram: o,
      resources: {
        filterUniforms: n,
        uMaskTexture: e.texture.source
      }
    }), this.sprite = e, this._textureMatrix = r;
  }
  set inverse(t) {
    this.resources.filterUniforms.uniforms.uInverse = t ? 1 : 0;
  }
  get inverse() {
    return this.resources.filterUniforms.uniforms.uInverse === 1;
  }
  apply(t, e, s, r) {
    this._textureMatrix.texture = this.sprite.texture, t.calculateSpriteMatrix(
      this.resources.filterUniforms.uniforms.uFilterMatrix,
      this.sprite
    ).prepend(this._textureMatrix.mapCoord), this.resources.uMaskTexture = this.sprite.texture.source, t.applyFilter(this, e, s, r);
  }
}
class SD {
  /**
   * @param options - Options for the transform.
   * @param options.matrix - The matrix to use.
   * @param options.observer - The observer to use.
   */
  constructor({ matrix: t, observer: e } = {}) {
    this.dirty = !0, this._matrix = t ?? new ot(), this.observer = e, this.position = new Me(this, 0, 0), this.scale = new Me(this, 1, 1), this.pivot = new Me(this, 0, 0), this.skew = new Me(this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1;
  }
  /**
   * This matrix is computed by combining this Transforms position, scale, rotation, skew, and pivot
   * properties into a single matrix.
   * @readonly
   */
  get matrix() {
    const t = this._matrix;
    return this.dirty && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this.dirty = !1), t;
  }
  /**
   * Called when a value changes.
   * @param point
   * @internal
   * @private
   */
  _onUpdate(t) {
    var e;
    this.dirty = !0, t === this.skew && this.updateSkew(), (e = this.observer) == null || e._onUpdate(this);
  }
  /** Called when the skew or the rotation changes. */
  updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this.dirty = !0;
  }
  toString() {
    return `[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
  }
  /**
   * Decomposes a matrix and sets the transforms properties based on it.
   * @param matrix - The matrix to decompose
   */
  setFromMatrix(t) {
    t.decompose(this), this.dirty = !0;
  }
  /** The rotation of the object in radians. */
  get rotation() {
    return this._rotation;
  }
  set rotation(t) {
    this._rotation !== t && (this._rotation = t, this._onUpdate(this.skew));
  }
}
const nO = class Sl extends mT {
  constructor(...t) {
    let e = t[0] || {};
    e instanceof W && (e = { texture: e }), t.length > 1 && (dt(Se, "use new TilingSprite({ texture, width:100, height:100 }) instead"), e.width = t[1], e.height = t[2]), e = { ...Sl.defaultOptions, ...e };
    const {
      texture: s,
      anchor: r,
      tilePosition: n,
      tileScale: a,
      tileRotation: o,
      width: h,
      height: u,
      applyAnchorToTexture: c,
      roundPixels: l,
      ..._
    } = e ?? {};
    super({
      label: "TilingSprite",
      ..._
    }), this.renderPipeId = "tilingSprite", this.batched = !0, this.allowChildren = !1, this._anchor = new Me(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    ), this._applyAnchorToTexture = c, this.texture = s, this._width = h ?? s.width, this._height = u ?? s.height, this._tileTransform = new SD({
      observer: {
        _onUpdate: () => this.onViewUpdate()
      }
    }), r && (this.anchor = r), this.tilePosition = n, this.tileScale = a, this.tileRotation = o, this.roundPixels = l ?? !1;
  }
  /**
   * Creates a new tiling sprite.
   * @param source - The source to create the texture from.
   * @param options - The options for creating the tiling sprite.
   * @returns A new tiling sprite.
   */
  static from(t, e = {}) {
    return typeof t == "string" ? new Sl({
      texture: ge.get(t),
      ...e
    }) : new Sl({
      texture: t,
      ...e
    });
  }
  /**
   * Changes frame clamping in corresponding textureMatrix
   * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
   * @default 0.5
   * @member {number}
   */
  get clampMargin() {
    return this._texture.textureMatrix.clampMargin;
  }
  set clampMargin(t) {
    this._texture.textureMatrix.clampMargin = t;
  }
  /**
   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
   * and passed to the constructor.
   *
   * The default is `(0,0)`, this means the sprite's origin is the top left.
   *
   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
   *
   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * import { TilingSprite } from 'pixi.js';
   *
   * const sprite = new TilingSprite({texture: Texture.WHITE});
   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(t) {
    typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
  }
  /** The offset of the image that is being tiled. */
  get tilePosition() {
    return this._tileTransform.position;
  }
  set tilePosition(t) {
    this._tileTransform.position.copyFrom(t);
  }
  /** The scaling of the image that is being tiled. */
  get tileScale() {
    return this._tileTransform.scale;
  }
  set tileScale(t) {
    typeof t == "number" ? this._tileTransform.scale.set(t) : this._tileTransform.scale.copyFrom(t);
  }
  set tileRotation(t) {
    this._tileTransform.rotation = t;
  }
  /** The rotation of the image that is being tiled. */
  get tileRotation() {
    return this._tileTransform.rotation;
  }
  /** The transform of the image that is being tiled. */
  get tileTransform() {
    return this._tileTransform;
  }
  /**
   * The local bounds of the sprite.
   * @type {rendering.Bounds}
   */
  get bounds() {
    return this._boundsDirty && (this._updateBounds(), this._boundsDirty = !1), this._bounds;
  }
  set texture(t) {
    t || (t = W.EMPTY);
    const e = this._texture;
    e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this._texture = t, this.onViewUpdate());
  }
  /** The texture that the sprite is using. */
  get texture() {
    return this._texture;
  }
  /** The width of the tiling area. */
  set width(t) {
    this._width = t, this.onViewUpdate();
  }
  get width() {
    return this._width;
  }
  set height(t) {
    this._height = t, this.onViewUpdate();
  }
  /** The height of the tiling area. */
  get height() {
    return this._height;
  }
  /**
   * Sets the size of the TilingSprite to the specified width and height.
   * This is faster than setting the width and height separately.
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   */
  setSize(t, e) {
    typeof t == "object" && (e = t.height ?? t.width, t = t.width), this._width = t, this._height = e ?? t, this.onViewUpdate();
  }
  /**
   * Retrieves the size of the TilingSprite as a [Size]{@link Size} object.
   * This is faster than get the width and height separately.
   * @param out - Optional object to store the size in.
   * @returns - The size of the TilingSprite.
   */
  getSize(t) {
    return t || (t = {}), t.width = this._width, t.height = this._height, t;
  }
  _updateBounds() {
    const t = this._bounds, e = this._anchor, s = this._width, r = this._height;
    t.maxX = -e._x * s, t.minX = t.maxX + s, t.maxY = -e._y * r, t.minY = t.maxY + r;
  }
  /**
   * Adds the bounds of this object to the bounds object.
   * @param bounds - The output bounds object.
   */
  addBounds(t) {
    const e = this.bounds;
    t.addFrame(
      e.minX,
      e.minY,
      e.maxX,
      e.maxY
    );
  }
  /**
   * Checks if the object contains the given point.
   * @param point - The point to check
   */
  containsPoint(t) {
    const e = this._width, s = this._height, r = -e * this._anchor._x;
    let n = 0;
    return t.x >= r && t.x <= r + e && (n = -s * this._anchor._y, t.y >= n && t.y <= n + s);
  }
  onViewUpdate() {
    this._boundsDirty = !0, super.onViewUpdate();
  }
  /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
   */
  destroy(t = !1) {
    if (super.destroy(t), this._anchor = null, this._tileTransform = null, this._bounds = null, typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
      const s = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
      this._texture.destroy(s);
    }
    this._texture = null;
  }
};
nO.defaultOptions = {
  /** The texture to use for the sprite. */
  texture: W.EMPTY,
  /** The anchor point of the sprite */
  anchor: { x: 0, y: 0 },
  /** The offset of the image that is being tiled. */
  tilePosition: { x: 0, y: 0 },
  /** Scaling of the image that is being tiled. */
  tileScale: { x: 1, y: 1 },
  /** The rotation of the image that is being tiled. */
  tileRotation: 0,
  /** TODO */
  applyAnchorToTexture: !1
};
let hl = nO;
class AD extends mT {
  constructor(t, e) {
    const { text: s, resolution: r, style: n, anchor: a, width: o, height: h, roundPixels: u, ...c } = t;
    super({
      ...c
    }), this.batched = !0, this._resolution = null, this._autoResolution = !0, this._didTextUpdate = !0, this._styleClass = e, this.text = s ?? "", this.style = n, this.resolution = r ?? null, this.allowChildren = !1, this._anchor = new Me(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    ), a && (this.anchor = a), this.roundPixels = u ?? !1, o !== void 0 && (this.width = o), h !== void 0 && (this.height = h);
  }
  /**
   * The anchor sets the origin point of the text.
   * The default is `(0,0)`, this means the text's origin is the top left.
   *
   * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
   *
   * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * import { Text } from 'pixi.js';
   *
   * const text = new Text('hello world');
   * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(t) {
    typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
  }
  /** Set the copy for the text object. To split a line you can use '\n'. */
  set text(t) {
    t = t.toString(), this._text !== t && (this._text = t, this.onViewUpdate());
  }
  get text() {
    return this._text;
  }
  /**
   * The resolution / device pixel ratio of the canvas.
   * @default 1
   */
  set resolution(t) {
    this._autoResolution = t === null, this._resolution = t, this.onViewUpdate();
  }
  get resolution() {
    return this._resolution;
  }
  get style() {
    return this._style;
  }
  /**
   * Set the style of the text.
   *
   * Set up an event listener to listen for changes on the style object and mark the text as dirty.
   *
   * If setting the `style` can also be partial {@link AnyTextStyleOptions}.
   * @type {
   * text.TextStyle |
   * Partial<text.TextStyle> |
   * text.TextStyleOptions |
   * text.HTMLTextStyle |
   * Partial<text.HTMLTextStyle> |
   * text.HTMLTextStyleOptions
   * }
   */
  set style(t) {
    var e;
    t = t || {}, (e = this._style) == null || e.off("update", this.onViewUpdate, this), t instanceof this._styleClass ? this._style = t : this._style = new this._styleClass(t), this._style.on("update", this.onViewUpdate, this), this.onViewUpdate();
  }
  /**
   * The local bounds of the Text.
   * @type {rendering.Bounds}
   */
  get bounds() {
    return this._boundsDirty && (this._updateBounds(), this._boundsDirty = !1), this._bounds;
  }
  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
  get width() {
    return Math.abs(this.scale.x) * this.bounds.width;
  }
  set width(t) {
    this._setWidth(t, this.bounds.width);
  }
  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
  get height() {
    return Math.abs(this.scale.y) * this.bounds.height;
  }
  set height(t) {
    this._setHeight(t, this.bounds.height);
  }
  /**
   * Retrieves the size of the Text as a [Size]{@link Size} object.
   * This is faster than get the width and height separately.
   * @param out - Optional object to store the size in.
   * @returns - The size of the Text.
   */
  getSize(t) {
    return t || (t = {}), t.width = Math.abs(this.scale.x) * this.bounds.width, t.height = Math.abs(this.scale.y) * this.bounds.height, t;
  }
  /**
   * Sets the size of the Text to the specified width and height.
   * This is faster than setting the width and height separately.
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   */
  setSize(t, e) {
    typeof t == "object" ? (e = t.height ?? t.width, t = t.width) : e ?? (e = t), t !== void 0 && this._setWidth(t, this.bounds.width), e !== void 0 && this._setHeight(e, this.bounds.height);
  }
  /**
   * Adds the bounds of this text to the bounds object.
   * @param bounds - The output bounds object.
   */
  addBounds(t) {
    const e = this.bounds;
    t.addFrame(
      e.minX,
      e.minY,
      e.maxX,
      e.maxY
    );
  }
  /**
   * Checks if the text contains the given point.
   * @param point - The point to check
   */
  containsPoint(t) {
    const e = this.bounds.width, s = this.bounds.height, r = -e * this.anchor.x;
    let n = 0;
    return t.x >= r && t.x <= r + e && (n = -s * this.anchor.y, t.y >= n && t.y <= n + s);
  }
  onViewUpdate() {
    this._boundsDirty = !0, this.didViewUpdate || (this._didTextUpdate = !0), super.onViewUpdate();
  }
  _getKey() {
    return `${this.text}:${this._style.styleKey}:${this._resolution}`;
  }
  /**
   * Destroys this text renderable and optionally its style texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style
   * @param {boolean} [options.style=false] - Should it destroy the style of the text
   */
  destroy(t = !1) {
    super.destroy(t), this.owner = null, this._bounds = null, this._anchor = null, (typeof t == "boolean" ? t : t != null && t.style) && this._style.destroy(t), this._style = null, this._text = null;
  }
}
function RD(i, t) {
  let e = i[0] ?? {};
  return (typeof e == "string" || i[1]) && (dt(Se, `use new ${t}({ text: "hi!", style }) instead`), e = {
    text: e,
    style: i[1]
  }), e;
}
class OD extends AD {
  constructor(...t) {
    const e = RD(t, "Text");
    super(e, ga), this.renderPipeId = "text";
  }
  _updateBounds() {
    const t = this._bounds, e = this._anchor, s = yg.measureText(
      this._text,
      this._style
    ), { width: r, height: n } = s;
    t.minX = -e._x * r, t.maxX = t.minX + r, t.minY = -e._y * n, t.maxY = t.minY + n;
  }
}
const ul = Pd.for2d();
class aO {
  start(t, e, s) {
    const r = t.renderer, n = r.encoder, a = s.gpuProgram;
    this._shader = s, this._geometry = e, n.setGeometry(e, a), ul.blendMode = "normal", r.pipeline.getPipeline(
      e,
      a,
      ul
    );
    const o = r.globalUniforms.bindGroup;
    n.resetBindGroup(1), n.setBindGroup(0, o, a);
  }
  execute(t, e) {
    const s = this._shader.gpuProgram, r = t.renderer, n = r.encoder;
    if (!e.bindGroup) {
      const h = e.textures;
      e.bindGroup = OT(h.textures, h.count);
    }
    ul.blendMode = e.blendMode;
    const a = r.bindGroup.getBindGroup(
      e.bindGroup,
      s,
      1
    ), o = r.pipeline.getPipeline(
      this._geometry,
      s,
      ul
    );
    e.bindGroup._touch(r.textureGC.count), n.setPipeline(o), n.renderPassEncoder.setBindGroup(1, a), n.renderPassEncoder.drawIndexed(e.size, 1, e.start);
  }
}
aO.extension = {
  type: [
    B.WebGPUPipesAdaptor
  ],
  name: "batch"
};
const DT = class oO {
  constructor(t, e) {
    var s, r;
    this.state = Pd.for2d(), this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null), this._activeBatches = /* @__PURE__ */ Object.create(null), this.renderer = t, this._adaptor = e, (r = (s = this._adaptor).init) == null || r.call(s, this);
  }
  static getBatcher(t) {
    return new this._availableBatchers[t]();
  }
  buildStart(t) {
    let e = this._batchersByInstructionSet[t.uid];
    e || (e = this._batchersByInstructionSet[t.uid] = /* @__PURE__ */ Object.create(null), e.default || (e.default = new CT())), this._activeBatches = e, this._activeBatch = this._activeBatches.default;
    for (const s in this._activeBatches)
      this._activeBatches[s].begin();
  }
  addToBatch(t, e) {
    if (this._activeBatch.name !== t.batcherName) {
      this._activeBatch.break(e);
      let s = this._activeBatches[t.batcherName];
      s || (s = this._activeBatches[t.batcherName] = oO.getBatcher(t.batcherName), s.begin()), this._activeBatch = s;
    }
    this._activeBatch.add(t);
  }
  break(t) {
    this._activeBatch.break(t);
  }
  buildEnd(t) {
    this._activeBatch.break(t);
    const e = this._activeBatches;
    for (const s in e) {
      const r = e[s], n = r.geometry;
      n.indexBuffer.setDataWithSize(r.indexBuffer, r.indexSize, !0), n.buffers[0].setDataWithSize(r.attributeBuffer.float32View, r.attributeSize, !1);
    }
  }
  upload(t) {
    const e = this._batchersByInstructionSet[t.uid];
    for (const s in e) {
      const r = e[s], n = r.geometry;
      r.dirty && (r.dirty = !1, n.buffers[0].update(r.attributeSize * 4));
    }
  }
  execute(t) {
    if (t.action === "startBatch") {
      const e = t.batcher, s = e.geometry, r = e.shader;
      this._adaptor.start(this, s, r);
    }
    this._adaptor.execute(this, t);
  }
  destroy() {
    this.state = null, this.renderer = null, this._adaptor = null;
    for (const t in this._activeBatches)
      this._activeBatches[t].destroy();
    this._activeBatches = null;
  }
};
DT.extension = {
  type: [
    B.WebGLPipes,
    B.WebGPUPipes,
    B.CanvasPipes
  ],
  name: "batch"
};
DT._availableBatchers = /* @__PURE__ */ Object.create(null);
let hO = DT;
Ee.handleByMap(B.Batcher, hO._availableBatchers);
Ee.add(CT);
const Al = {
  name: "local-uniform-bit",
  vertex: {
    header: (
      /* wgsl */
      `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
    ),
    main: (
      /* wgsl */
      `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
    ),
    end: (
      /* wgsl */
      `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
    )
  }
}, yD = {
  ...Al,
  vertex: {
    ...Al.vertex,
    // replace the group!
    header: Al.vertex.header.replace("group(1)", "group(2)")
  }
}, Prt = {
  name: "local-uniform-bit",
  vertex: {
    header: (
      /* glsl */
      `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
    ),
    main: (
      /* glsl */
      `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `
    ),
    end: (
      /* glsl */
      `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
    )
  }
}, vD = {
  name: "texture-bit",
  vertex: {
    header: (
      /* wgsl */
      `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `
    ),
    main: (
      /* wgsl */
      `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `
    )
  },
  fragment: {
    header: (
      /* wgsl */
      `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `
    ),
    main: (
      /* wgsl */
      `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
    )
  }
}, Nrt = {
  name: "texture-bit",
  vertex: {
    header: (
      /* glsl */
      `
            uniform mat3 uTextureMatrix;
        `
    ),
    main: (
      /* glsl */
      `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
    )
  },
  fragment: {
    header: (
      /* glsl */
      `
        uniform sampler2D uTexture;

         
        `
    ),
    main: (
      /* glsl */
      `
            outColor = texture(uTexture, vUV);
        `
    )
  }
};
function CD(i, t) {
  const e = i.root, s = i.instructionSet;
  s.reset();
  const r = t.renderPipes ? t : t.batch.renderer, n = r.renderPipes;
  n.batch.buildStart(s), n.blendMode.buildStart(), n.colorMask.buildStart(), e.sortableChildren && e.sortChildren(), uO(e, s, r, !0), n.batch.buildEnd(s), n.blendMode.buildEnd(s);
}
function Fd(i, t, e) {
  const s = e.renderPipes ? e : e.batch.renderer;
  i.globalDisplayStatus < 7 || !i.includeInBuild || (i.sortableChildren && i.sortChildren(), i.isSimple ? xD(i, t, s) : uO(i, t, s, !1));
}
function xD(i, t, e) {
  if (i.renderPipeId) {
    const s = i, { renderPipes: r, renderableGC: n } = e;
    r.blendMode.setBlendMode(s, i.groupBlendMode, t), r[s.renderPipeId].addRenderable(s, t), n.addRenderable(s, t), s.didViewUpdate = !1;
  }
  if (!i.renderGroup) {
    const s = i.children, r = s.length;
    for (let n = 0; n < r; n++)
      Fd(s[n], t, e);
  }
}
function uO(i, t, e, s) {
  const { renderPipes: r, renderableGC: n } = e;
  if (!s && i.renderGroup)
    r.renderGroup.addRenderGroup(i.renderGroup, t);
  else {
    for (let u = 0; u < i.effects.length; u++) {
      const c = i.effects[u];
      r[c.pipe].push(c, i, t);
    }
    const a = i, o = a.renderPipeId;
    o && (r.blendMode.setBlendMode(a, a.groupBlendMode, t), r[o].addRenderable(a, t), n.addRenderable(a, t), a.didViewUpdate = !1);
    const h = i.children;
    if (h.length)
      for (let u = 0; u < h.length; u++)
        Fd(h[u], t, e);
    for (let u = i.effects.length - 1; u >= 0; u--) {
      const c = i.effects[u];
      r[c.pipe].pop(c, i, t);
    }
  }
}
const MD = new Zs();
class bD extends Fl {
  constructor() {
    super(), this.filters = [new ID({
      sprite: new Ft(W.EMPTY),
      inverse: !1,
      resolution: "inherit",
      antialias: "inherit"
    })];
  }
  get sprite() {
    return this.filters[0].sprite;
  }
  set sprite(t) {
    this.filters[0].sprite = t;
  }
  get inverse() {
    return this.filters[0].inverse;
  }
  set inverse(t) {
    this.filters[0].inverse = t;
  }
}
class lO {
  constructor(t) {
    this._activeMaskStage = [], this._renderer = t;
  }
  push(t, e, s) {
    const r = this._renderer;
    if (r.renderPipes.batch.break(s), s.add({
      renderPipeId: "alphaMask",
      action: "pushMaskBegin",
      mask: t,
      inverse: e._maskOptions.inverse,
      canBundle: !1,
      maskedContainer: e
    }), t.inverse = e._maskOptions.inverse, t.renderMaskToTexture) {
      const n = t.mask;
      n.includeInBuild = !0, Fd(
        n,
        s,
        r
      ), n.includeInBuild = !1;
    }
    r.renderPipes.batch.break(s), s.add({
      renderPipeId: "alphaMask",
      action: "pushMaskEnd",
      mask: t,
      maskedContainer: e,
      inverse: e._maskOptions.inverse,
      canBundle: !1
    });
  }
  pop(t, e, s) {
    this._renderer.renderPipes.batch.break(s), s.add({
      renderPipeId: "alphaMask",
      action: "popMaskEnd",
      mask: t,
      inverse: e._maskOptions.inverse,
      canBundle: !1
    });
  }
  execute(t) {
    const e = this._renderer, s = t.mask.renderMaskToTexture;
    if (t.action === "pushMaskBegin") {
      const r = Es.get(bD);
      if (r.inverse = t.inverse, s) {
        t.mask.mask.measurable = !0;
        const n = fT(t.mask.mask, !0, MD);
        t.mask.mask.measurable = !1, n.ceil();
        const a = e.renderTarget.renderTarget.colorTexture.source, o = ps.getOptimalTexture(
          n.width,
          n.height,
          a._resolution,
          a.antialias
        );
        e.renderTarget.push(o, !0), e.globalUniforms.push({
          offset: n,
          worldColor: 4294967295
        });
        const h = r.sprite;
        h.texture = o, h.worldTransform.tx = n.minX, h.worldTransform.ty = n.minY, this._activeMaskStage.push({
          filterEffect: r,
          maskedContainer: t.maskedContainer,
          filterTexture: o
        });
      } else
        r.sprite = t.mask.mask, this._activeMaskStage.push({
          filterEffect: r,
          maskedContainer: t.maskedContainer
        });
    } else if (t.action === "pushMaskEnd") {
      const r = this._activeMaskStage[this._activeMaskStage.length - 1];
      s && (e.type === Or.WEBGL && e.renderTarget.finishRenderPass(), e.renderTarget.pop(), e.globalUniforms.pop()), e.filter.push({
        renderPipeId: "filter",
        action: "pushFilter",
        container: r.maskedContainer,
        filterEffect: r.filterEffect,
        canBundle: !1
      });
    } else if (t.action === "popMaskEnd") {
      e.filter.pop();
      const r = this._activeMaskStage.pop();
      s && ps.returnTexture(r.filterTexture), Es.return(r.filterEffect);
    }
  }
  destroy() {
    this._renderer = null, this._activeMaskStage = null;
  }
}
lO.extension = {
  type: [
    B.WebGLPipes,
    B.WebGPUPipes,
    B.CanvasPipes
  ],
  name: "alphaMask"
};
class cO {
  constructor(t) {
    this._colorStack = [], this._colorStackIndex = 0, this._currentColor = 0, this._renderer = t;
  }
  buildStart() {
    this._colorStack[0] = 15, this._colorStackIndex = 1, this._currentColor = 15;
  }
  push(t, e, s) {
    this._renderer.renderPipes.batch.break(s);
    const n = this._colorStack;
    n[this._colorStackIndex] = n[this._colorStackIndex - 1] & t.mask;
    const a = this._colorStack[this._colorStackIndex];
    a !== this._currentColor && (this._currentColor = a, s.add({
      renderPipeId: "colorMask",
      colorMask: a,
      canBundle: !1
    })), this._colorStackIndex++;
  }
  pop(t, e, s) {
    this._renderer.renderPipes.batch.break(s);
    const n = this._colorStack;
    this._colorStackIndex--;
    const a = n[this._colorStackIndex - 1];
    a !== this._currentColor && (this._currentColor = a, s.add({
      renderPipeId: "colorMask",
      colorMask: a,
      canBundle: !1
    }));
  }
  execute(t) {
    this._renderer.colorMask.setMask(t.colorMask);
  }
  destroy() {
    this._colorStack = null;
  }
}
cO.extension = {
  type: [
    B.WebGLPipes,
    B.WebGPUPipes,
    B.CanvasPipes
  ],
  name: "colorMask"
};
class _O {
  constructor(t) {
    this._maskStackHash = {}, this._maskHash = /* @__PURE__ */ new WeakMap(), this._renderer = t;
  }
  push(t, e, s) {
    var r;
    const n = t, a = this._renderer;
    a.renderPipes.batch.break(s), a.renderPipes.blendMode.setBlendMode(n.mask, "none", s), s.add({
      renderPipeId: "stencilMask",
      action: "pushMaskBegin",
      mask: t,
      inverse: e._maskOptions.inverse,
      canBundle: !1
    });
    const o = n.mask;
    o.includeInBuild = !0, this._maskHash.has(n) || this._maskHash.set(n, {
      instructionsStart: 0,
      instructionsLength: 0
    });
    const h = this._maskHash.get(n);
    h.instructionsStart = s.instructionSize, Fd(
      o,
      s,
      a
    ), o.includeInBuild = !1, a.renderPipes.batch.break(s), s.add({
      renderPipeId: "stencilMask",
      action: "pushMaskEnd",
      mask: t,
      inverse: e._maskOptions.inverse,
      canBundle: !1
    });
    const u = s.instructionSize - h.instructionsStart - 1;
    h.instructionsLength = u;
    const c = a.renderTarget.renderTarget.uid;
    (r = this._maskStackHash)[c] ?? (r[c] = 0);
  }
  pop(t, e, s) {
    const r = t, n = this._renderer;
    n.renderPipes.batch.break(s), n.renderPipes.blendMode.setBlendMode(r.mask, "none", s), s.add({
      renderPipeId: "stencilMask",
      action: "popMaskBegin",
      inverse: e._maskOptions.inverse,
      canBundle: !1
    });
    const a = this._maskHash.get(t);
    for (let o = 0; o < a.instructionsLength; o++)
      s.instructions[s.instructionSize++] = s.instructions[a.instructionsStart++];
    s.add({
      renderPipeId: "stencilMask",
      action: "popMaskEnd",
      canBundle: !1
    });
  }
  execute(t) {
    var e;
    const s = this._renderer, r = s.renderTarget.renderTarget.uid;
    let n = (e = this._maskStackHash)[r] ?? (e[r] = 0);
    t.action === "pushMaskBegin" ? (s.renderTarget.ensureDepthStencil(), s.stencil.setStencilMode(Xe.RENDERING_MASK_ADD, n), n++, s.colorMask.setMask(0)) : t.action === "pushMaskEnd" ? (t.inverse ? s.stencil.setStencilMode(Xe.INVERSE_MASK_ACTIVE, n) : s.stencil.setStencilMode(Xe.MASK_ACTIVE, n), s.colorMask.setMask(15)) : t.action === "popMaskBegin" ? (s.colorMask.setMask(0), n !== 0 ? s.stencil.setStencilMode(Xe.RENDERING_MASK_REMOVE, n) : (s.renderTarget.clear(null, Bi.STENCIL), s.stencil.setStencilMode(Xe.DISABLED, n)), n--) : t.action === "popMaskEnd" && (t.inverse ? s.stencil.setStencilMode(Xe.INVERSE_MASK_ACTIVE, n) : s.stencil.setStencilMode(Xe.MASK_ACTIVE, n), s.colorMask.setMask(15)), this._maskStackHash[r] = n;
  }
  destroy() {
    this._renderer = null, this._maskStackHash = null, this._maskHash = null;
  }
}
_O.extension = {
  type: [
    B.WebGLPipes,
    B.WebGPUPipes,
    B.CanvasPipes
  ],
  name: "stencilMask"
};
function PD(i, t) {
  for (const e in i.attributes) {
    const s = i.attributes[e], r = t[e];
    r ? (s.format ?? (s.format = r.format), s.offset ?? (s.offset = r.offset), s.instance ?? (s.instance = r.instance)) : ce(`Attribute ${e} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);
  }
  ND(i);
}
function ND(i) {
  const { buffers: t, attributes: e } = i, s = {}, r = {};
  for (const n in t) {
    const a = t[n];
    s[a.uid] = 0, r[a.uid] = 0;
  }
  for (const n in e) {
    const a = e[n];
    s[a.buffer.uid] += lg(a.format).stride;
  }
  for (const n in e) {
    const a = e[n];
    a.stride ?? (a.stride = s[a.buffer.uid]), a.start ?? (a.start = r[a.buffer.uid]), r[a.buffer.uid] += lg(a.format).stride;
  }
}
const Oa = [];
Oa[Xe.NONE] = void 0;
Oa[Xe.DISABLED] = {
  stencilWriteMask: 0,
  stencilReadMask: 0
};
Oa[Xe.RENDERING_MASK_ADD] = {
  stencilFront: {
    compare: "equal",
    passOp: "increment-clamp"
  },
  stencilBack: {
    compare: "equal",
    passOp: "increment-clamp"
  }
};
Oa[Xe.RENDERING_MASK_REMOVE] = {
  stencilFront: {
    compare: "equal",
    passOp: "decrement-clamp"
  },
  stencilBack: {
    compare: "equal",
    passOp: "decrement-clamp"
  }
};
Oa[Xe.MASK_ACTIVE] = {
  stencilWriteMask: 0,
  stencilFront: {
    compare: "equal",
    passOp: "keep"
  },
  stencilBack: {
    compare: "equal",
    passOp: "keep"
  }
};
Oa[Xe.INVERSE_MASK_ACTIVE] = {
  stencilWriteMask: 0,
  stencilFront: {
    compare: "not-equal",
    passOp: "replace"
  },
  stencilBack: {
    compare: "not-equal",
    passOp: "replace"
  }
};
class UD {
  constructor(t) {
    this._syncFunctionHash = /* @__PURE__ */ Object.create(null), this._adaptor = t, this._systemCheck();
  }
  /**
   * Overridable function by `pixi.js/unsafe-eval` to silence
   * throwing an error if platform doesn't support unsafe-evals.
   * @private
   */
  _systemCheck() {
    if (!_0())
      throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
  }
  ensureUniformGroup(t) {
    const e = this.getUniformGroupData(t);
    t.buffer || (t.buffer = new gn({
      data: new Float32Array(e.layout.size / 4),
      usage: ve.UNIFORM | ve.COPY_DST
    }));
  }
  getUniformGroupData(t) {
    return this._syncFunctionHash[t._signature] || this._initUniformGroup(t);
  }
  _initUniformGroup(t) {
    const e = t._signature;
    let s = this._syncFunctionHash[e];
    if (!s) {
      const r = Object.keys(t.uniformStructures).map((o) => t.uniformStructures[o]), n = this._adaptor.createUboElements(r), a = this._generateUboSync(n.uboElements);
      s = this._syncFunctionHash[e] = {
        layout: n,
        syncFunction: a
      };
    }
    return this._syncFunctionHash[e];
  }
  _generateUboSync(t) {
    return this._adaptor.generateUboSync(t);
  }
  syncUniformGroup(t, e, s) {
    const r = this.getUniformGroupData(t);
    return t.buffer || (t.buffer = new gn({
      data: new Float32Array(r.layout.size / 4),
      usage: ve.UNIFORM | ve.COPY_DST
    })), e || (e = t.buffer.data), s || (s = 0), r.syncFunction(t.uniforms, e, s), !0;
  }
  updateUniformGroup(t) {
    if (t.isStatic && !t._dirtyId)
      return !1;
    t._dirtyId = 0;
    const e = this.syncUniformGroup(t);
    return t.buffer.update(), e;
  }
  destroy() {
    this._syncFunctionHash = null;
  }
}
const ll = [
  // uploading pixi matrix object to mat3
  {
    type: "mat3x3<f32>",
    test: (i) => i.value.a !== void 0,
    ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
    uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
  },
  // uploading a pixi rectangle as a vec4
  {
    type: "vec4<f32>",
    test: (i) => i.type === "vec4<f32>" && i.size === 1 && i.value.width !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
  },
  // uploading a pixi point as a vec2
  {
    type: "vec2<f32>",
    test: (i) => i.type === "vec2<f32>" && i.size === 1 && i.value.x !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
  },
  // uploading a pixi color as a vec4
  {
    type: "vec4<f32>",
    test: (i) => i.type === "vec4<f32>" && i.size === 1 && i.value.red !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
  },
  // uploading a pixi color as a vec3
  {
    type: "vec3<f32>",
    test: (i) => i.type === "vec3<f32>" && i.size === 1 && i.value.red !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
  }
];
function DD(i, t, e, s) {
  const r = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `];
  let n = 0;
  for (let o = 0; o < i.length; o++) {
    const h = i[o], u = h.data.name;
    let c = !1, l = 0;
    for (let _ = 0; _ < ll.length; _++)
      if (ll[_].test(h.data)) {
        l = h.offset / 4, r.push(
          `name = "${u}";`,
          `offset += ${l - n};`,
          ll[_][t] || ll[_].ubo
        ), c = !0;
        break;
      }
    if (!c)
      if (h.data.size > 1)
        l = h.offset / 4, r.push(e(h, l - n));
      else {
        const _ = s[h.data.type];
        l = h.offset / 4, r.push(
          /* wgsl */
          `
                    v = uv.${u};
                    offset += ${l - n};
                    ${_};
                `
        );
      }
    n = l;
  }
  const a = r.join(`
`);
  return new Function(
    "uv",
    "data",
    "offset",
    a
  );
}
function Pa(i, t) {
  return `
        for (let i = 0; i < ${i * t}; i++) {
            data[offset + (((i / ${i})|0) * 4) + (i % ${i})] = v[i];
        }
    `;
}
const LD = {
  f32: `
        data[offset] = v;`,
  i32: `
        data[offset] = v;`,
  "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
  "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
  "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
  "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
  "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
  "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
  "mat3x2<f32>": Pa(3, 2),
  "mat4x2<f32>": Pa(4, 2),
  "mat2x3<f32>": Pa(2, 3),
  "mat4x3<f32>": Pa(4, 3),
  "mat2x4<f32>": Pa(2, 4),
  "mat3x4<f32>": Pa(3, 4)
}, FD = {
  ...LD,
  "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `
};
function wD(i, t, e, s, r, n) {
  const a = n ? 1 : -1;
  return i.identity(), i.a = 1 / s * 2, i.d = a * (1 / r * 2), i.tx = -1 - t * i.a, i.ty = -a - e * i.d, i;
}
const uh = /* @__PURE__ */ new Map();
function dO(i, t) {
  if (!uh.has(i)) {
    const e = new W({
      source: new Do({
        resource: i,
        ...t
      })
    }), s = () => {
      uh.get(i) === e && uh.delete(i);
    };
    e.once("destroy", s), e.source.once("destroy", s), uh.set(i, e);
  }
  return uh.get(i);
}
function GD(i) {
  const t = i.colorTexture.source.resource;
  return globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement && document.body.contains(t);
}
const fO = class gO {
  /**
   * @param [descriptor] - Options for creating a render target.
   */
  constructor(t = {}) {
    if (this.uid = me("renderTarget"), this.colorTextures = [], this.dirtyId = 0, this.isRoot = !1, this._size = new Float32Array(2), this._managedColorTextures = !1, t = { ...gO.defaultOptions, ...t }, this.stencil = t.stencil, this.depth = t.depth, this.isRoot = t.isRoot, typeof t.colorTextures == "number") {
      this._managedColorTextures = !0;
      for (let e = 0; e < t.colorTextures; e++)
        this.colorTextures.push(
          new ke({
            width: t.width,
            height: t.height,
            resolution: t.resolution,
            antialias: t.antialias
          })
        );
    } else {
      this.colorTextures = [...t.colorTextures.map((s) => s.source)];
      const e = this.colorTexture.source;
      this.resize(e.width, e.height, e._resolution);
    }
    this.colorTexture.source.on("resize", this.onSourceResize, this), (t.depthStencilTexture || this.stencil) && (t.depthStencilTexture instanceof W || t.depthStencilTexture instanceof ke ? this.depthStencilTexture = t.depthStencilTexture.source : this.ensureDepthStencilTexture());
  }
  get size() {
    const t = this._size;
    return t[0] = this.pixelWidth, t[1] = this.pixelHeight, t;
  }
  get width() {
    return this.colorTexture.source.width;
  }
  get height() {
    return this.colorTexture.source.height;
  }
  get pixelWidth() {
    return this.colorTexture.source.pixelWidth;
  }
  get pixelHeight() {
    return this.colorTexture.source.pixelHeight;
  }
  get resolution() {
    return this.colorTexture.source._resolution;
  }
  get colorTexture() {
    return this.colorTextures[0];
  }
  onSourceResize(t) {
    this.resize(t.width, t.height, t._resolution, !0);
  }
  /**
   * This will ensure a depthStencil texture is created for this render target.
   * Most likely called by the mask system to make sure we have stencil buffer added.
   * @internal
   * @ignore
   */
  ensureDepthStencilTexture() {
    this.depthStencilTexture || (this.depthStencilTexture = new ke({
      width: this.width,
      height: this.height,
      resolution: this.resolution,
      format: "depth24plus-stencil8",
      autoGenerateMipmaps: !1,
      antialias: !1,
      mipLevelCount: 1
      // sampleCount: handled by the render target system..
    }));
  }
  resize(t, e, s = this.resolution, r = !1) {
    this.dirtyId++, this.colorTextures.forEach((n, a) => {
      r && a === 0 || n.source.resize(t, e, s);
    }), this.depthStencilTexture && this.depthStencilTexture.source.resize(t, e, s);
  }
  destroy() {
    this.colorTexture.source.off("resize", this.onSourceResize, this), this._managedColorTextures && this.colorTextures.forEach((t) => {
      t.destroy();
    }), this.depthStencilTexture && (this.depthStencilTexture.destroy(), delete this.depthStencilTexture);
  }
};
fO.defaultOptions = {
  /** the width of the RenderTarget */
  width: 0,
  /** the height of the RenderTarget */
  height: 0,
  /** the resolution of the RenderTarget */
  resolution: 1,
  /** an array of textures, or a number indicating how many color textures there should be */
  colorTextures: 1,
  /** should this render target have a stencil buffer? */
  stencil: !1,
  /** should this render target have a depth buffer? */
  depth: !1,
  /** should this render target be antialiased? */
  antialias: !1,
  // save on perf by default!
  /** is this a root element, true if this is gl context owners render target */
  isRoot: !1
};
let Cg = fO;
class BD {
  constructor(t) {
    this.rootViewPort = new Kt(), this.viewport = new Kt(), this.onRenderTargetChange = new p0("onRenderTargetChange"), this.projectionMatrix = new ot(), this.defaultClearColor = [0, 0, 0, 0], this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map(), this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null), this._renderTargetStack = [], this._renderer = t, t.renderableGC.addManagedHash(this, "_gpuRenderTargetHash");
  }
  /** called when dev wants to finish a render pass */
  finishRenderPass() {
    this.adaptor.finishRenderPass(this.renderTarget);
  }
  /**
   * called when the renderer starts to render a scene.
   * @param options
   * @param options.target - the render target to render to
   * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
   * @param options.clearColor - the color to clear to
   * @param options.frame - the frame to render to
   */
  renderStart({
    target: t,
    clear: e,
    clearColor: s,
    frame: r
  }) {
    this._renderTargetStack.length = 0, this.push(
      t,
      e,
      s,
      r
    ), this.rootViewPort.copyFrom(this.viewport), this.rootRenderTarget = this.renderTarget, this.renderingToScreen = GD(this.rootRenderTarget);
  }
  postrender() {
    var t, e;
    (e = (t = this.adaptor).postrender) == null || e.call(t, this.rootRenderTarget);
  }
  /**
   * Binding a render surface! This is the main function of the render target system.
   * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.
   * Once bound all draw calls will be rendered to the render surface.
   *
   * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.
   * @param renderSurface - the render surface to bind
   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
   * @param clearColor - the color to clear to
   * @param frame - the frame to render to
   * @returns the render target that was bound
   */
  bind(t, e = !0, s, r) {
    const n = this.getRenderTarget(t), a = this.renderTarget !== n;
    this.renderTarget = n, this.renderSurface = t;
    const o = this.getGpuRenderTarget(n);
    (n.pixelWidth !== o.width || n.pixelHeight !== o.height) && (this.adaptor.resizeGpuRenderTarget(n), o.width = n.pixelWidth, o.height = n.pixelHeight);
    const h = n.colorTexture, u = this.viewport, c = h.pixelWidth, l = h.pixelHeight;
    if (!r && t instanceof W && (r = t.frame), r) {
      const _ = h._resolution;
      u.x = r.x * _ + 0.5 | 0, u.y = r.y * _ + 0.5 | 0, u.width = r.width * _ + 0.5 | 0, u.height = r.height * _ + 0.5 | 0;
    } else
      u.x = 0, u.y = 0, u.width = c, u.height = l;
    return wD(
      this.projectionMatrix,
      0,
      0,
      u.width / h.resolution,
      u.height / h.resolution,
      !n.isRoot
    ), this.adaptor.startRenderPass(n, e, s, u), a && this.onRenderTargetChange.emit(n), n;
  }
  clear(t, e = Bi.ALL, s) {
    e && (t && (t = this.getRenderTarget(t)), this.adaptor.clear(
      t || this.renderTarget,
      e,
      s,
      this.viewport
    ));
  }
  contextChange() {
    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
  }
  /**
   * Push a render surface to the renderer. This will bind the render surface to the renderer,
   * @param renderSurface - the render surface to push
   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
   * @param clearColor - the color to clear to
   * @param frame - the frame to use when rendering to the render surface
   */
  push(t, e = Bi.ALL, s, r) {
    const n = this.bind(t, e, s, r);
    return this._renderTargetStack.push({
      renderTarget: n,
      frame: r
    }), n;
  }
  /** Pops the current render target from the renderer and restores the previous render target. */
  pop() {
    this._renderTargetStack.pop();
    const t = this._renderTargetStack[this._renderTargetStack.length - 1];
    this.bind(t.renderTarget, !1, null, t.frame);
  }
  /**
   * Gets the render target from the provide render surface. Eg if its a texture,
   * it will return the render target for the texture.
   * If its a render target, it will return the same render target.
   * @param renderSurface - the render surface to get the render target for
   * @returns the render target for the render surface
   */
  getRenderTarget(t) {
    return t.isTexture && (t = t.source), this._renderSurfaceToRenderTargetHash.get(t) ?? this._initRenderTarget(t);
  }
  /**
   * Copies a render surface to another texture
   * @param sourceRenderSurfaceTexture - the render surface to copy from
   * @param destinationTexture - the texture to copy to
   * @param originSrc - the origin of the copy
   * @param originSrc.x - the x origin of the copy
   * @param originSrc.y - the y origin of the copy
   * @param size - the size of the copy
   * @param size.width - the width of the copy
   * @param size.height - the height of the copy
   * @param originDest - the destination origin (top left to paste from!)
   * @param originDest.x - the x origin of the paste
   * @param originDest.y - the y origin of the paste
   */
  copyToTexture(t, e, s, r, n) {
    s.x < 0 && (r.width += s.x, n.x -= s.x, s.x = 0), s.y < 0 && (r.height += s.y, n.y -= s.y, s.y = 0);
    const { pixelWidth: a, pixelHeight: o } = t;
    return r.width = Math.min(r.width, a - s.x), r.height = Math.min(r.height, o - s.y), this.adaptor.copyToTexture(
      t,
      e,
      s,
      r,
      n
    );
  }
  /**
   * ensures that we have a depth stencil buffer available to render to
   * This is used by the mask system to make sure we have a stencil buffer.
   */
  ensureDepthStencil() {
    this.renderTarget.stencil || (this.renderTarget.stencil = !0, this.adaptor.startRenderPass(this.renderTarget, !1, null, this.viewport));
  }
  /** nukes the render target system */
  destroy() {
    this._renderer = null, this._renderSurfaceToRenderTargetHash.forEach((t, e) => {
      t !== e && t.destroy();
    }), this._renderSurfaceToRenderTargetHash.clear(), this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
  }
  _initRenderTarget(t) {
    let e = null;
    return Do.test(t) && (t = dO(t).source), t instanceof Cg ? e = t : t instanceof ke && (e = new Cg({
      colorTextures: [t]
    }), Do.test(t.source.resource) && (e.isRoot = !0), t.once("destroy", () => {
      e.destroy(), this._renderSurfaceToRenderTargetHash.delete(t);
      const s = this._gpuRenderTargetHash[e.uid];
      s && (this._gpuRenderTargetHash[e.uid] = null, this.adaptor.destroyGpuRenderTarget(s));
    })), this._renderSurfaceToRenderTargetHash.set(t, e), e;
  }
  getGpuRenderTarget(t) {
    return this._gpuRenderTargetHash[t.uid] || (this._gpuRenderTargetHash[t.uid] = this.adaptor.initGpuRenderTarget(t));
  }
}
class kD extends Js {
  /**
   * Create a new Buffer Resource.
   * @param options - The options for the buffer resource
   * @param options.buffer - The underlying buffer that this resource is using
   * @param options.offset - The offset of the buffer this resource is using.
   * If not provided, then it will use the offset of the buffer.
   * @param options.size - The size of the buffer this resource is using.
   * If not provided, then it will use the size of the buffer.
   */
  constructor({ buffer: t, offset: e, size: s }) {
    super(), this.uid = me("buffer"), this._resourceType = "bufferResource", this._touched = 0, this._resourceId = me("resource"), this._bufferResource = !0, this.destroyed = !1, this.buffer = t, this.offset = e | 0, this.size = s, this.buffer.on("change", this.onBufferChange, this);
  }
  onBufferChange() {
    this._resourceId = me("resource"), this.emit("change", this);
  }
  /**
   * Destroys this resource. Make sure the underlying buffer is not used anywhere else
   * if you want to destroy it as well, or code will explode
   * @param destroyBuffer - Should the underlying buffer be destroyed as well?
   */
  destroy(t = !1) {
    this.destroyed = !0, t && this.buffer.destroy(), this.emit("change", this), this.buffer = null;
  }
}
class pO {
  constructor(t) {
    this._renderer = t;
  }
  updateRenderable() {
  }
  destroyRenderable() {
  }
  validateRenderable() {
    return !1;
  }
  addRenderable(t, e) {
    this._renderer.renderPipes.batch.break(e), e.add(t);
  }
  execute(t) {
    t.isRenderable && t.render(this._renderer);
  }
  destroy() {
    this._renderer = null;
  }
}
pO.extension = {
  type: [
    B.WebGLPipes,
    B.WebGPUPipes,
    B.CanvasPipes
  ],
  name: "customRender"
};
function mO(i, t) {
  const e = i.instructionSet, s = e.instructions;
  for (let r = 0; r < e.instructionSize; r++) {
    const n = s[r];
    t[n.renderPipeId].execute(n);
  }
}
class EO {
  constructor(t) {
    this._renderer = t;
  }
  addRenderGroup(t, e) {
    this._renderer.renderPipes.batch.break(e), e.add(t);
  }
  execute(t) {
    t.isRenderable && (this._renderer.globalUniforms.push({
      worldTransformMatrix: t.worldTransform,
      worldColor: t.worldColorAlpha
    }), mO(t, this._renderer.renderPipes), this._renderer.globalUniforms.pop());
  }
  destroy() {
    this._renderer = null;
  }
}
EO.extension = {
  type: [
    B.WebGLPipes,
    B.WebGPUPipes,
    B.CanvasPipes
  ],
  name: "renderGroup"
};
function LT(i, t) {
  t || (t = 0);
  for (let e = t; e < i.length && i[e]; e++)
    i[e] = null;
}
function TO(i, t = []) {
  t.push(i);
  for (let e = 0; e < i.renderGroupChildren.length; e++)
    TO(i.renderGroupChildren[e], t);
  return t;
}
function zD(i, t, e) {
  const s = i >> 16 & 255, r = i >> 8 & 255, n = i & 255, a = t >> 16 & 255, o = t >> 8 & 255, h = t & 255, u = s + (a - s) * e, c = r + (o - r) * e, l = n + (h - n) * e;
  return (u << 16) + (c << 8) + l;
}
const Pf = 16777215;
function IO(i, t) {
  return i === Pf || t === Pf ? i + t - Pf : zD(i, t, 0.5);
}
const VD = new Qt(), JS = Eh | Gl | pT;
function SO(i, t = !1) {
  HD(i);
  const e = i.childrenToUpdate, s = i.updateTick++;
  for (const r in e) {
    const n = Number(r), a = e[r], o = a.list, h = a.index;
    for (let u = 0; u < h; u++) {
      const c = o[u];
      c.parentRenderGroup === i && c.relativeRenderGroupDepth === n && AO(c, s, 0);
    }
    LT(o, h), a.index = 0;
  }
  if (t)
    for (let r = 0; r < i.renderGroupChildren.length; r++)
      SO(i.renderGroupChildren[r], t);
}
function HD(i) {
  const t = i.root;
  let e;
  if (i.renderGroupParent) {
    const s = i.renderGroupParent;
    i.worldTransform.appendFrom(
      t.relativeGroupTransform,
      s.worldTransform
    ), i.worldColor = IO(
      t.groupColor,
      s.worldColor
    ), e = t.groupAlpha * s.worldAlpha;
  } else
    i.worldTransform.copyFrom(t.localTransform), i.worldColor = t.localColor, e = t.localAlpha;
  e = e < 0 ? 0 : e > 1 ? 1 : e, i.worldAlpha = e, i.worldColorAlpha = i.worldColor + ((e * 255 | 0) << 24);
}
function AO(i, t, e) {
  if (t === i.updateTick)
    return;
  i.updateTick = t, i.didChange = !1;
  const s = i.localTransform;
  i.updateLocalTransform();
  const r = i.parent;
  if (r && !r.renderGroup ? (e = e | i._updateFlags, i.relativeGroupTransform.appendFrom(
    s,
    r.relativeGroupTransform
  ), e & JS && tA(i, r, e)) : (e = i._updateFlags, i.relativeGroupTransform.copyFrom(s), e & JS && tA(i, VD, e)), !i.renderGroup) {
    const n = i.children, a = n.length;
    for (let u = 0; u < a; u++)
      AO(n[u], t, e);
    const o = i.parentRenderGroup, h = i;
    h.renderPipeId && !o.structureDidChange && o.updateRenderable(h);
  }
}
function tA(i, t, e) {
  if (e & Gl) {
    i.groupColor = IO(
      i.localColor,
      t.groupColor
    );
    let s = i.localAlpha * t.groupAlpha;
    s = s < 0 ? 0 : s > 1 ? 1 : s, i.groupAlpha = s, i.groupColorAlpha = i.groupColor + ((s * 255 | 0) << 24);
  }
  e & pT && (i.groupBlendMode = i.localBlendMode === "inherit" ? t.groupBlendMode : i.localBlendMode), e & Eh && (i.globalDisplayStatus = i.localDisplayStatus & t.globalDisplayStatus), i._updateFlags = 0;
}
function YD(i, t) {
  const { list: e, index: s } = i.childrenRenderablesToUpdate;
  let r = !1;
  for (let n = 0; n < s; n++) {
    const a = e[n];
    if (r = t[a.renderPipeId].validateRenderable(a), r)
      break;
  }
  return i.structureDidChange = r, r;
}
const WD = new ot();
class RO {
  constructor(t) {
    this._renderer = t;
  }
  render({ container: t, transform: e }) {
    t.isRenderGroup = !0;
    const s = t.parent, r = t.renderGroup.renderGroupParent;
    t.parent = null, t.renderGroup.renderGroupParent = null;
    const n = this._renderer, a = TO(t.renderGroup, []);
    let o = WD;
    e && (o = o.copyFrom(t.renderGroup.localTransform), t.renderGroup.localTransform.copyFrom(e));
    const h = n.renderPipes;
    for (let u = 0; u < a.length; u++) {
      const c = a[u];
      c.runOnRender(), c.instructionSet.renderPipes = h, c.structureDidChange ? LT(c.childrenRenderablesToUpdate.list, 0) : YD(c, h), SO(c), c.structureDidChange ? (c.structureDidChange = !1, CD(c, n)) : jD(c), c.childrenRenderablesToUpdate.index = 0, n.renderPipes.batch.upload(c.instructionSet);
    }
    n.globalUniforms.start({
      worldTransformMatrix: e ? t.renderGroup.localTransform : t.renderGroup.worldTransform,
      worldColor: t.renderGroup.worldColorAlpha
    }), mO(t.renderGroup, h), h.uniformBatch && h.uniformBatch.renderEnd(), e && t.renderGroup.localTransform.copyFrom(o), t.parent = s, t.renderGroup.renderGroupParent = r;
  }
  destroy() {
    this._renderer = null;
  }
}
RO.extension = {
  type: [
    B.WebGLSystem,
    B.WebGPUSystem,
    B.CanvasSystem
  ],
  name: "renderGroup"
};
function jD(i) {
  const { list: t, index: e } = i.childrenRenderablesToUpdate;
  for (let s = 0; s < e; s++) {
    const r = t[s];
    r.didViewUpdate && i.updateRenderable(r);
  }
  LT(t, e);
}
class XD {
  constructor() {
    this.batcherName = "default", this.attributeSize = 4, this.indexSize = 6, this.packAsQuad = !0, this.roundPixels = 0, this._attributeStart = 0, this._batcher = null, this._batch = null;
  }
  get blendMode() {
    return this.renderable.groupBlendMode;
  }
  get color() {
    return this.renderable.groupColorAlpha;
  }
  reset() {
    this.renderable = null, this.texture = null, this._batcher = null, this._batch = null, this.bounds = null;
  }
}
class OO {
  constructor(t) {
    this._gpuSpriteHash = /* @__PURE__ */ Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = t, this._renderer.renderableGC.addManagedHash(this, "_gpuSpriteHash");
  }
  addRenderable(t, e) {
    const s = this._getGpuSprite(t);
    t.didViewUpdate && this._updateBatchableSprite(t, s), this._renderer.renderPipes.batch.addToBatch(s, e);
  }
  updateRenderable(t) {
    const e = this._gpuSpriteHash[t.uid];
    t.didViewUpdate && this._updateBatchableSprite(t, e), e._batcher.updateElement(e);
  }
  validateRenderable(t) {
    const e = t._texture, s = this._getGpuSprite(t);
    return s.texture._source !== e._source ? !s._batcher.checkAndUpdateTexture(s, e) : !1;
  }
  destroyRenderable(t) {
    const e = this._gpuSpriteHash[t.uid];
    Es.return(e), this._gpuSpriteHash[t.uid] = null, t.off("destroyed", this._destroyRenderableBound);
  }
  _updateBatchableSprite(t, e) {
    e.bounds = t.bounds, e.texture = t._texture;
  }
  _getGpuSprite(t) {
    return this._gpuSpriteHash[t.uid] || this._initGPUSprite(t);
  }
  _initGPUSprite(t) {
    const e = Es.get(XD);
    return e.renderable = t, e.transform = t.groupTransform, e.texture = t._texture, e.bounds = t.bounds, e.roundPixels = this._renderer._roundPixels | t._roundPixels, this._gpuSpriteHash[t.uid] = e, t.on("destroyed", this._destroyRenderableBound), e;
  }
  destroy() {
    for (const t in this._gpuSpriteHash)
      Es.return(this._gpuSpriteHash[t]);
    this._gpuSpriteHash = null, this._renderer = null;
  }
}
OO.extension = {
  type: [
    B.WebGLPipes,
    B.WebGPUPipes,
    B.CanvasPipes
  ],
  name: "sprite"
};
const FT = class yO {
  constructor() {
    this.clearBeforeRender = !0, this._backgroundColor = new Pt(0), this.color = this._backgroundColor, this.alpha = 1;
  }
  /**
   * initiates the background system
   * @param options - the options for the background colors
   */
  init(t) {
    t = { ...yO.defaultOptions, ...t }, this.clearBeforeRender = t.clearBeforeRender, this.color = t.background || t.backgroundColor || this._backgroundColor, this.alpha = t.backgroundAlpha, this._backgroundColor.setAlpha(t.backgroundAlpha);
  }
  /** The background color to fill if not transparent */
  get color() {
    return this._backgroundColor;
  }
  set color(t) {
    this._backgroundColor.setValue(t);
  }
  /** The background color alpha. Setting this to 0 will make the canvas transparent. */
  get alpha() {
    return this._backgroundColor.alpha;
  }
  set alpha(t) {
    this._backgroundColor.setAlpha(t);
  }
  /** The background color as an [R, G, B, A] array. */
  get colorRgba() {
    return this._backgroundColor.toArray();
  }
  /**
   * destroys the background system
   * @internal
   * @ignore
   */
  destroy() {
  }
};
FT.extension = {
  type: [
    B.WebGLSystem,
    B.WebGPUSystem,
    B.CanvasSystem
  ],
  name: "background",
  priority: 0
};
FT.defaultOptions = {
  /**
   * {@link WebGLOptions.backgroundAlpha}
   * @default 1
   */
  backgroundAlpha: 1,
  /**
   * {@link WebGLOptions.backgroundColor}
   * @default 0x000000
   */
  backgroundColor: 0,
  /**
   * {@link WebGLOptions.clearBeforeRender}
   * @default true
   */
  clearBeforeRender: !0
};
let KD = FT;
const Ah = {};
Ee.handle(B.BlendMode, (i) => {
  if (!i.name)
    throw new Error("BlendMode extension must have a name property");
  Ah[i.name] = i.ref;
}, (i) => {
  delete Ah[i.name];
});
class vO {
  constructor(t) {
    this._isAdvanced = !1, this._filterHash = /* @__PURE__ */ Object.create(null), this._renderer = t;
  }
  /**
   * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.
   * @param renderable - The renderable we are adding to the instruction set
   * @param blendMode - The blend mode of the renderable
   * @param instructionSet - The instruction set we are adding to
   */
  setBlendMode(t, e, s) {
    if (this._activeBlendMode === e) {
      this._isAdvanced && this._renderableList.push(t);
      return;
    }
    this._activeBlendMode = e, this._isAdvanced && this._endAdvancedBlendMode(s), this._isAdvanced = !!Ah[e], this._isAdvanced && (this._beginAdvancedBlendMode(s), this._renderableList.push(t));
  }
  _beginAdvancedBlendMode(t) {
    this._renderer.renderPipes.batch.break(t);
    const e = this._activeBlendMode;
    if (!Ah[e]) {
      ce(`Unable to assign BlendMode: '${e}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
      return;
    }
    let s = this._filterHash[e];
    s || (s = this._filterHash[e] = new Fl(), s.filters = [new Ah[e]()]);
    const r = {
      renderPipeId: "filter",
      action: "pushFilter",
      renderables: [],
      filterEffect: s,
      canBundle: !1
    };
    this._renderableList = r.renderables, t.add(r);
  }
  _endAdvancedBlendMode(t) {
    this._renderableList = null, this._renderer.renderPipes.batch.break(t), t.add({
      renderPipeId: "filter",
      action: "popFilter",
      canBundle: !1
    });
  }
  /**
   * called when the instruction build process is starting this will reset internally to the default blend mode
   * @internal
   * @ignore
   */
  buildStart() {
    this._isAdvanced = !1;
  }
  /**
   * called when the instruction build process is finished, ensuring that if there is an advanced blend mode
   * active, we add the final render instructions added to the instruction set
   * @param instructionSet - The instruction set we are adding to
   * @internal
   * @ignore
   */
  buildEnd(t) {
    this._isAdvanced && this._endAdvancedBlendMode(t);
  }
  /**
   * @internal
   * @ignore
   */
  destroy() {
    this._renderer = null, this._renderableList = null;
    for (const t in this._filterHash)
      this._filterHash[t].destroy();
    this._filterHash = null;
  }
}
vO.extension = {
  type: [
    B.WebGLPipes,
    B.WebGPUPipes,
    B.CanvasPipes
  ],
  name: "blendMode"
};
const Nf = {
  png: "image/png",
  jpg: "image/jpeg",
  webp: "image/webp"
}, wT = class CO {
  /** @param renderer - The renderer this System works for. */
  constructor(t) {
    this._renderer = t;
  }
  _normalizeOptions(t, e = {}) {
    return t instanceof Qt || t instanceof W ? {
      target: t,
      ...e
    } : {
      ...e,
      ...t
    };
  }
  /**
   * Will return a HTML Image of the target
   * @param options - The options for creating the image, or the target to extract
   * @returns - HTML Image of the target
   */
  async image(t) {
    const e = new Image();
    return e.src = await this.base64(t), e;
  }
  /**
   * Will return a base64 encoded string of this target. It works by calling
   * `Extract.canvas` and then running toDataURL on that.
   * @param options - The options for creating the image, or the target to extract
   */
  async base64(t) {
    t = this._normalizeOptions(
      t,
      CO.defaultImageOptions
    );
    const { format: e, quality: s } = t, r = this.canvas(t);
    if (r.toBlob !== void 0)
      return new Promise((n, a) => {
        r.toBlob((o) => {
          if (!o) {
            a(new Error("ICanvas.toBlob failed!"));
            return;
          }
          const h = new FileReader();
          h.onload = () => n(h.result), h.onerror = a, h.readAsDataURL(o);
        }, Nf[e], s);
      });
    if (r.toDataURL !== void 0)
      return r.toDataURL(Nf[e], s);
    if (r.convertToBlob !== void 0) {
      const n = await r.convertToBlob({ type: Nf[e], quality: s });
      return new Promise((a, o) => {
        const h = new FileReader();
        h.onload = () => a(h.result), h.onerror = o, h.readAsDataURL(n);
      });
    }
    throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
  }
  /**
   * Creates a Canvas element, renders this target to it and then returns it.
   * @param options - The options for creating the canvas, or the target to extract
   * @returns - A Canvas element with the texture rendered on.
   */
  canvas(t) {
    t = this._normalizeOptions(t);
    const e = t.target, s = this._renderer;
    if (e instanceof W)
      return s.texture.generateCanvas(e);
    const r = s.textureGenerator.generateTexture(t), n = s.texture.generateCanvas(r);
    return r.destroy(), n;
  }
  /**
   * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
   * order, with integer values between 0 and 255 (included).
   * @param options - The options for extracting the image, or the target to extract
   * @returns - One-dimensional array containing the pixel data of the entire texture
   */
  pixels(t) {
    t = this._normalizeOptions(t);
    const e = t.target, s = this._renderer, r = e instanceof W ? e : s.textureGenerator.generateTexture(t), n = s.texture.getPixels(r);
    return e instanceof Qt && r.destroy(), n;
  }
  /**
   * Will return a texture of the target
   * @param options - The options for creating the texture, or the target to extract
   * @returns - A texture of the target
   */
  texture(t) {
    return t = this._normalizeOptions(t), t.target instanceof W ? t.target : this._renderer.textureGenerator.generateTexture(t);
  }
  /**
   * Will extract a HTMLImage of the target and download it
   * @param options - The options for downloading and extracting the image, or the target to extract
   */
  download(t) {
    t = this._normalizeOptions(t);
    const e = this.canvas(t), s = document.createElement("a");
    s.download = t.filename ?? "image.png", s.href = e.toDataURL("image/png"), document.body.appendChild(s), s.click(), document.body.removeChild(s);
  }
  /**
   * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.
   * @param options - The options for logging the image, or the target to log
   */
  log(t) {
    const e = t.width ?? 200;
    t = this._normalizeOptions(t);
    const s = this.canvas(t), r = s.toDataURL();
    console.log(`[Pixi Texture] ${s.width}px ${s.height}px`);
    const n = [
      "font-size: 1px;",
      `padding: ${e}px 300px;`,
      `background: url(${r}) no-repeat;`,
      "background-size: contain;"
    ].join(" ");
    console.log("%c ", n);
  }
  destroy() {
    this._renderer = null;
  }
};
wT.extension = {
  type: [
    B.WebGLSystem,
    B.WebGPUSystem
  ],
  name: "extract"
};
wT.defaultImageOptions = {
  /** The format of the image. */
  format: "png",
  /** The quality of the image. */
  quality: 1
};
let qD = wT;
class ku extends W {
  static create(t) {
    return new ku({
      source: new ke(t)
    });
  }
  /**
   * Resizes the render texture.
   * @param width - The new width of the render texture.
   * @param height - The new height of the render texture.
   * @param resolution - The new resolution of the render texture.
   * @returns This texture.
   */
  resize(t, e, s) {
    return this.source.resize(t, e, s), this;
  }
}
const $D = new Kt(), ZD = new Zs(), QD = [0, 0, 0, 0];
class xO {
  constructor(t) {
    this._renderer = t;
  }
  /**
   * A Useful function that returns a texture of the display object that can then be used to create sprites
   * This can be quite useful if your container is complicated and needs to be reused multiple times.
   * @param {GenerateTextureOptions | Container} options - Generate texture options.
   * @param {Container} [options.container] - If not given, the renderer's resolution is used.
   * @param {Rectangle} options.region - The region of the container, that shall be rendered,
   * @param {number} [options.resolution] - The resolution of the texture being generated.
   *        if no region is specified, defaults to the local bounds of the container.
   * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.
   * @returns a shiny new texture of the container passed in
   */
  generateTexture(t) {
    var u;
    t instanceof Qt && (t = {
      target: t,
      frame: void 0,
      textureSourceOptions: {},
      resolution: void 0
    });
    const e = t.resolution || this._renderer.resolution, s = t.antialias || this._renderer.view.antialias, r = t.target;
    let n = t.clearColor;
    n ? n = Array.isArray(n) && n.length === 4 ? n : Pt.shared.setValue(n).toArray() : n = QD;
    const a = ((u = t.frame) == null ? void 0 : u.copyTo($D)) || gT(r, ZD).rectangle;
    a.width = Math.max(a.width, 1 / e) | 0, a.height = Math.max(a.height, 1 / e) | 0;
    const o = ku.create({
      ...t.textureSourceOptions,
      width: a.width,
      height: a.height,
      resolution: e,
      antialias: s
    }), h = ot.shared.translate(-a.x, -a.y);
    return this._renderer.render({
      container: r,
      transform: h,
      target: o,
      clearColor: n
    }), o.source.updateMipmaps(), o;
  }
  destroy() {
    this._renderer = null;
  }
}
xO.extension = {
  type: [
    B.WebGLSystem,
    B.WebGPUSystem
  ],
  name: "textureGenerator"
};
function JD(i, t, e) {
  const s = (i >> 24 & 255) / 255;
  t[e++] = (i & 255) / 255 * s, t[e++] = (i >> 8 & 255) / 255 * s, t[e++] = (i >> 16 & 255) / 255 * s, t[e++] = s;
}
class MO {
  constructor(t) {
    this._stackIndex = 0, this._globalUniformDataStack = [], this._uniformsPool = [], this._activeUniforms = [], this._bindGroupPool = [], this._activeBindGroups = [], this._renderer = t;
  }
  reset() {
    this._stackIndex = 0;
    for (let t = 0; t < this._activeUniforms.length; t++)
      this._uniformsPool.push(this._activeUniforms[t]);
    for (let t = 0; t < this._activeBindGroups.length; t++)
      this._bindGroupPool.push(this._activeBindGroups[t]);
    this._activeUniforms.length = 0, this._activeBindGroups.length = 0;
  }
  start(t) {
    this.reset(), this.push(t);
  }
  bind({
    size: t,
    projectionMatrix: e,
    worldTransformMatrix: s,
    worldColor: r,
    offset: n
  }) {
    const a = this._renderer.renderTarget.renderTarget, o = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
      projectionData: a,
      worldTransformMatrix: new ot(),
      worldColor: 4294967295,
      offset: new st()
    }, h = {
      projectionMatrix: e || this._renderer.renderTarget.projectionMatrix,
      resolution: t || a.size,
      worldTransformMatrix: s || o.worldTransformMatrix,
      worldColor: r || o.worldColor,
      offset: n || o.offset,
      bindGroup: null
    }, u = this._uniformsPool.pop() || this._createUniforms();
    this._activeUniforms.push(u);
    const c = u.uniforms;
    c.uProjectionMatrix = h.projectionMatrix, c.uResolution = h.resolution, c.uWorldTransformMatrix.copyFrom(h.worldTransformMatrix), c.uWorldTransformMatrix.tx -= h.offset.x, c.uWorldTransformMatrix.ty -= h.offset.y, JD(
      h.worldColor,
      c.uWorldColorAlpha,
      0
    ), u.update();
    let l;
    this._renderer.renderPipes.uniformBatch ? l = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(u, !1) : (l = this._bindGroupPool.pop() || new la(), this._activeBindGroups.push(l), l.setResource(u, 0)), h.bindGroup = l, this._currentGlobalUniformData = h;
  }
  push(t) {
    this.bind(t), this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
  }
  pop() {
    this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1], this._renderer.type === Or.WEBGL && this._currentGlobalUniformData.bindGroup.resources[0].update();
  }
  get bindGroup() {
    return this._currentGlobalUniformData.bindGroup;
  }
  get globalUniformData() {
    return this._currentGlobalUniformData;
  }
  get uniformGroup() {
    return this._currentGlobalUniformData.bindGroup.resources[0];
  }
  _createUniforms() {
    return new mn({
      uProjectionMatrix: { value: new ot(), type: "mat3x3<f32>" },
      uWorldTransformMatrix: { value: new ot(), type: "mat3x3<f32>" },
      // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>
      uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" },
      uResolution: { value: [0, 0], type: "vec2<f32>" }
    }, {
      isStatic: !0
    });
  }
  destroy() {
    this._renderer = null;
  }
}
MO.extension = {
  type: [
    B.WebGLSystem,
    B.WebGPUSystem,
    B.CanvasSystem
  ],
  name: "globalUniforms"
};
let t1 = 1;
class bO {
  constructor() {
    this._tasks = [], this._offset = 0;
  }
  /** Initializes the scheduler system and starts the ticker. */
  init() {
    js.system.add(this._update, this);
  }
  /**
   * Schedules a repeating task.
   * @param func - The function to execute.
   * @param duration - The interval duration in milliseconds.
   * @param useOffset - this will spread out tasks so that they do not all run at the same time
   * @returns The unique identifier for the scheduled task.
   */
  repeat(t, e, s = !0) {
    const r = t1++;
    let n = 0;
    return s && (this._offset += 1e3, n = this._offset), this._tasks.push({
      func: t,
      duration: e,
      start: performance.now(),
      offset: n,
      last: performance.now(),
      repeat: !0,
      id: r
    }), r;
  }
  /**
   * Cancels a scheduled task.
   * @param id - The unique identifier of the task to cancel.
   */
  cancel(t) {
    for (let e = 0; e < this._tasks.length; e++)
      if (this._tasks[e].id === t) {
        this._tasks.splice(e, 1);
        return;
      }
  }
  /**
   * Updates and executes the scheduled tasks.
   * @private
   */
  _update() {
    const t = performance.now();
    for (let e = 0; e < this._tasks.length; e++) {
      const s = this._tasks[e];
      if (t - s.offset - s.last >= s.duration) {
        const r = t - s.start;
        s.func(r), s.last = t;
      }
    }
  }
  /**
   * Destroys the scheduler system and removes all tasks.
   * @internal
   * @ignore
   */
  destroy() {
    js.system.remove(this._update, this), this._tasks.length = 0;
  }
}
bO.extension = {
  type: [
    B.WebGLSystem,
    B.WebGPUSystem,
    B.CanvasSystem
  ],
  name: "scheduler",
  priority: 0
};
let eA = !1;
function e1(i) {
  if (!eA) {
    if (Wt.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
      const t = [
        `%c  %c  %c  %c  %c PixiJS %c v${zl} (${i}) http://www.pixijs.com/

`,
        "background: #E72264; padding:5px 0;",
        "background: #6CA2EA; padding:5px 0;",
        "background: #B5D33D; padding:5px 0;",
        "background: #FED23F; padding:5px 0;",
        "color: #FFFFFF; background: #E72264; padding:5px 0;",
        "color: #E72264; background: #FFFFFF; padding:5px 0;"
      ];
      globalThis.console.log(...t);
    } else globalThis.console && globalThis.console.log(`PixiJS ${zl} - ${i} - http://www.pixijs.com/`);
    eA = !0;
  }
}
class wd {
  constructor(t) {
    this._renderer = t;
  }
  /**
   * It all starts here! This initiates every system, passing in the options for any system by name.
   * @param options - the config for the renderer and all its systems
   */
  init(t) {
    if (t.hello) {
      let e = this._renderer.name;
      this._renderer.type === Or.WEBGL && (e += ` ${this._renderer.context.webGLVersion}`), e1(e);
    }
  }
}
wd.extension = {
  type: [
    B.WebGLSystem,
    B.WebGPUSystem,
    B.CanvasSystem
  ],
  name: "hello",
  priority: -2
};
wd.defaultOptions = {
  /** {@link WebGLOptions.hello} */
  hello: !1
};
function s1(i) {
  let t = !1;
  for (const s in i)
    if (i[s] == null) {
      t = !0;
      break;
    }
  if (!t)
    return i;
  const e = /* @__PURE__ */ Object.create(null);
  for (const s in i) {
    const r = i[s];
    r && (e[s] = r);
  }
  return e;
}
function i1(i) {
  let t = 0;
  for (let e = 0; e < i.length; e++)
    i[e] == null ? t++ : i[e - t] = i[e];
  return i.length = i.length - t, i;
}
const GT = class PO {
  /** @param renderer - The renderer this System works for. */
  constructor(t) {
    this._managedRenderables = [], this._managedHashes = [], this._managedArrays = [], this._renderer = t;
  }
  init(t) {
    t = { ...PO.defaultOptions, ...t }, this.maxUnusedTime = t.renderableGCMaxUnusedTime, this._frequency = t.renderableGCFrequency, this.enabled = t.renderableGCActive;
  }
  get enabled() {
    return !!this._handler;
  }
  set enabled(t) {
    this.enabled !== t && (t ? (this._handler = this._renderer.scheduler.repeat(
      () => this.run(),
      this._frequency,
      !1
    ), this._hashHandler = this._renderer.scheduler.repeat(
      () => {
        for (const e of this._managedHashes)
          e.context[e.hash] = s1(e.context[e.hash]);
      },
      this._frequency
    ), this._arrayHandler = this._renderer.scheduler.repeat(
      () => {
        for (const e of this._managedArrays)
          i1(e.context[e.hash]);
      },
      this._frequency
    )) : (this._renderer.scheduler.cancel(this._handler), this._renderer.scheduler.cancel(this._hashHandler), this._renderer.scheduler.cancel(this._arrayHandler)));
  }
  addManagedHash(t, e) {
    this._managedHashes.push({ context: t, hash: e });
  }
  addManagedArray(t, e) {
    this._managedArrays.push({ context: t, hash: e });
  }
  prerender() {
    this._now = performance.now();
  }
  addRenderable(t, e) {
    this.enabled && (t._lastUsed = this._now, t._lastInstructionTick === -1 && (this._managedRenderables.push(t), t.once("destroyed", this._removeRenderable, this)), t._lastInstructionTick = e.tick);
  }
  /** Runs the scheduled garbage collection */
  run() {
    var n;
    const t = performance.now(), e = this._managedRenderables, s = this._renderer.renderPipes;
    let r = 0;
    for (let a = 0; a < e.length; a++) {
      const o = e[a];
      if (o === null) {
        r++;
        continue;
      }
      const h = o.renderGroup ?? o.parentRenderGroup, u = ((n = h == null ? void 0 : h.instructionSet) == null ? void 0 : n.tick) ?? -1;
      o._lastInstructionTick !== u && t - o._lastUsed > this.maxUnusedTime ? (o.destroyed || s[o.renderPipeId].destroyRenderable(o), o._lastInstructionTick = -1, r++, o.off("destroyed", this._removeRenderable, this)) : e[a - r] = o;
    }
    e.length = e.length - r;
  }
  destroy() {
    this.enabled = !1, this._renderer = null, this._managedRenderables.length = 0, this._managedHashes.length = 0, this._managedArrays.length = 0;
  }
  _removeRenderable(t) {
    const e = this._managedRenderables.indexOf(t);
    e >= 0 && (t.off("destroyed", this._removeRenderable, this), this._managedRenderables[e] = null);
  }
};
GT.extension = {
  type: [
    B.WebGLSystem,
    B.WebGPUSystem
  ],
  name: "renderableGC",
  priority: 0
};
GT.defaultOptions = {
  /**
   * If set to true, this will enable the garbage collector on the GPU.
   * @default true
   */
  renderableGCActive: !0,
  /**
   * The maximum idle frames before a texture is destroyed by garbage collection.
   * @default 60 * 60
   */
  renderableGCMaxUnusedTime: 6e4,
  /**
   * Frames between two garbage collections.
   * @default 600
   */
  renderableGCFrequency: 3e4
};
let r1 = GT;
const BT = class NO {
  /** @param renderer - The renderer this System works for. */
  constructor(t) {
    this._renderer = t, this.count = 0, this.checkCount = 0;
  }
  init(t) {
    t = { ...NO.defaultOptions, ...t }, this.checkCountMax = t.textureGCCheckCountMax, this.maxIdle = t.textureGCAMaxIdle ?? t.textureGCMaxIdle, this.active = t.textureGCActive;
  }
  /**
   * Checks to see when the last time a texture was used.
   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
   */
  postrender() {
    this._renderer.renderingToScreen && (this.count++, this.active && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
  }
  /**
   * Checks to see when the last time a texture was used.
   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
   */
  run() {
    const t = this._renderer.texture.managedTextures;
    for (let e = 0; e < t.length; e++) {
      const s = t[e];
      s.autoGarbageCollect && s.resource && s._touched > -1 && this.count - s._touched > this.maxIdle && (s._touched = -1, s.unload());
    }
  }
  destroy() {
    this._renderer = null;
  }
};
BT.extension = {
  type: [
    B.WebGLSystem,
    B.WebGPUSystem
  ],
  name: "textureGC"
};
BT.defaultOptions = {
  /**
   * If set to true, this will enable the garbage collector on the GPU.
   * @default true
   */
  textureGCActive: !0,
  /**
   * @deprecated since 8.3.0
   * @see {@link TextureGCSystem.textureGCMaxIdle}
   */
  textureGCAMaxIdle: null,
  /**
   * The maximum idle frames before a texture is destroyed by garbage collection.
   * @default 60 * 60
   */
  textureGCMaxIdle: 60 * 60,
  /**
   * Frames between two garbage collections.
   * @default 600
   */
  textureGCCheckCountMax: 600
};
let n1 = BT;
const kT = class UO {
  /**
   * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.
   * @member {boolean}
   */
  get autoDensity() {
    return this.texture.source.autoDensity;
  }
  set autoDensity(t) {
    this.texture.source.autoDensity = t;
  }
  /** The resolution / device pixel ratio of the renderer. */
  get resolution() {
    return this.texture.source._resolution;
  }
  set resolution(t) {
    this.texture.source.resize(
      this.texture.source.width,
      this.texture.source.height,
      t
    );
  }
  /**
   * initiates the view system
   * @param options - the options for the view
   */
  init(t) {
    t = {
      ...UO.defaultOptions,
      ...t
    }, t.view && (dt(Se, "ViewSystem.view has been renamed to ViewSystem.canvas"), t.canvas = t.view), this.screen = new Kt(0, 0, t.width, t.height), this.canvas = t.canvas || Wt.get().createCanvas(), this.antialias = !!t.antialias, this.texture = dO(this.canvas, t), this.renderTarget = new Cg({
      colorTextures: [this.texture],
      depth: !!t.depth,
      isRoot: !0
    }), this.texture.source.transparent = t.backgroundAlpha < 1, this.resolution = t.resolution;
  }
  /**
   * Resizes the screen and canvas to the specified dimensions.
   * @param desiredScreenWidth - The new width of the screen.
   * @param desiredScreenHeight - The new height of the screen.
   * @param resolution
   */
  resize(t, e, s) {
    this.texture.source.resize(t, e, s), this.screen.width = this.texture.frame.width, this.screen.height = this.texture.frame.height;
  }
  /**
   * Destroys this System and optionally removes the canvas from the dom.
   * @param {options | false} options - The options for destroying the view, or "false".
   * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.
   */
  destroy(t = !1) {
    (typeof t == "boolean" ? t : !!(t != null && t.removeView)) && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
  }
};
kT.extension = {
  type: [
    B.WebGLSystem,
    B.WebGPUSystem,
    B.CanvasSystem
  ],
  name: "view",
  priority: 0
};
kT.defaultOptions = {
  /**
   * {@link WebGLOptions.width}
   * @default 800
   */
  width: 800,
  /**
   * {@link WebGLOptions.height}
   * @default 600
   */
  height: 600,
  /**
   * {@link WebGLOptions.autoDensity}
   * @default false
   */
  autoDensity: !1,
  /**
   * {@link WebGLOptions.antialias}
   * @default false
   */
  antialias: !1
};
let DO = kT;
const a1 = [
  KD,
  MO,
  wd,
  DO,
  RO,
  n1,
  xO,
  qD,
  S0,
  r1,
  bO
], o1 = [
  vO,
  hO,
  OO,
  EO,
  lO,
  _O,
  cO,
  pO
];
class LO {
  constructor(t) {
    this._hash = /* @__PURE__ */ Object.create(null), this._renderer = t, this._renderer.renderableGC.addManagedHash(this, "_hash");
  }
  contextChange(t) {
    this._gpu = t;
  }
  getBindGroup(t, e, s) {
    return t._updateKey(), this._hash[t._key] || this._createBindGroup(t, e, s);
  }
  _createBindGroup(t, e, s) {
    const r = this._gpu.device, n = e.layout[s], a = [], o = this._renderer;
    for (const c in n) {
      const l = t.resources[c] ?? t.resources[n[c]];
      let _;
      if (l._resourceType === "uniformGroup") {
        const d = l;
        o.ubo.updateUniformGroup(d);
        const f = d.buffer;
        _ = {
          buffer: o.buffer.getGPUBuffer(f),
          offset: 0,
          size: f.descriptor.size
        };
      } else if (l._resourceType === "buffer") {
        const d = l;
        _ = {
          buffer: o.buffer.getGPUBuffer(d),
          offset: 0,
          size: d.descriptor.size
        };
      } else if (l._resourceType === "bufferResource") {
        const d = l;
        _ = {
          buffer: o.buffer.getGPUBuffer(d.buffer),
          offset: d.offset,
          size: d.size
        };
      } else if (l._resourceType === "textureSampler") {
        const d = l;
        _ = o.texture.getGpuSampler(d);
      } else if (l._resourceType === "textureSource") {
        const d = l;
        _ = o.texture.getGpuSource(d).createView({});
      }
      a.push({
        binding: n[c],
        resource: _
      });
    }
    const h = o.shader.getProgramData(e).bindGroups[s], u = r.createBindGroup({
      layout: h,
      entries: a
    });
    return this._hash[t._key] = u, u;
  }
  destroy() {
    for (const t of Object.keys(this._hash))
      this._hash[t] = null;
    this._hash = null, this._renderer = null;
  }
}
LO.extension = {
  type: [
    B.WebGPUSystem
  ],
  name: "bindGroup"
};
class FO {
  constructor(t) {
    this._gpuBuffers = /* @__PURE__ */ Object.create(null), this._managedBuffers = [], t.renderableGC.addManagedHash(this, "_gpuBuffers");
  }
  contextChange(t) {
    this._gpu = t;
  }
  getGPUBuffer(t) {
    return this._gpuBuffers[t.uid] || this.createGPUBuffer(t);
  }
  updateBuffer(t) {
    const e = this._gpuBuffers[t.uid] || this.createGPUBuffer(t), s = t.data;
    return t._updateID && s && (t._updateID = 0, this._gpu.device.queue.writeBuffer(
      e,
      0,
      s.buffer,
      0,
      // round to the nearest 4 bytes
      (t._updateSize || s.byteLength) + 3 & -4
    )), e;
  }
  /** dispose all WebGL resources of all managed buffers */
  destroyAll() {
    for (const t in this._gpuBuffers)
      this._gpuBuffers[t].destroy();
    this._gpuBuffers = {};
  }
  createGPUBuffer(t) {
    this._gpuBuffers[t.uid] || (t.on("update", this.updateBuffer, this), t.on("change", this.onBufferChange, this), t.on("destroy", this.onBufferDestroy, this), this._managedBuffers.push(t));
    const e = this._gpu.device.createBuffer(t.descriptor);
    return t._updateID = 0, t.data && (Tg(t.data.buffer, e.getMappedRange()), e.unmap()), this._gpuBuffers[t.uid] = e, e;
  }
  onBufferChange(t) {
    this._gpuBuffers[t.uid].destroy(), t._updateID = 0, this._gpuBuffers[t.uid] = this.createGPUBuffer(t);
  }
  /**
   * Disposes buffer
   * @param buffer - buffer with data
   */
  onBufferDestroy(t) {
    this._managedBuffers.splice(this._managedBuffers.indexOf(t), 1), this._destroyBuffer(t);
  }
  destroy() {
    this._managedBuffers.forEach((t) => this._destroyBuffer(t)), this._managedBuffers = null, this._gpuBuffers = null;
  }
  _destroyBuffer(t) {
    this._gpuBuffers[t.uid].destroy(), t.off("update", this.updateBuffer, this), t.off("change", this.onBufferChange, this), t.off("destroy", this.onBufferDestroy, this), this._gpuBuffers[t.uid] = null;
  }
}
FO.extension = {
  type: [
    B.WebGPUSystem
  ],
  name: "buffer"
};
class h1 {
  constructor({ minUniformOffsetAlignment: t }) {
    this._minUniformOffsetAlignment = 256, this.byteIndex = 0, this._minUniformOffsetAlignment = t, this.data = new Float32Array(65535);
  }
  clear() {
    this.byteIndex = 0;
  }
  addEmptyGroup(t) {
    if (t > this._minUniformOffsetAlignment / 4)
      throw new Error(`UniformBufferBatch: array is too large: ${t * 4}`);
    const e = this.byteIndex;
    let s = e + t * 4;
    if (s = Math.ceil(s / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment, s > this.data.length * 4)
      throw new Error("UniformBufferBatch: ubo batch got too big");
    return this.byteIndex = s, e;
  }
  addGroup(t) {
    const e = this.addEmptyGroup(t.length);
    for (let s = 0; s < t.length; s++)
      this.data[e / 4 + s] = t[s];
    return e;
  }
  destroy() {
    this._buffer.destroy(), this._buffer = null, this.data = null;
  }
}
class wO {
  constructor(t) {
    this._colorMaskCache = 15, this._renderer = t;
  }
  setMask(t) {
    this._colorMaskCache !== t && (this._colorMaskCache = t, this._renderer.pipeline.setColorMask(t));
  }
  destroy() {
    this._renderer = null, this._colorMaskCache = null;
  }
}
wO.extension = {
  type: [
    B.WebGPUSystem
  ],
  name: "colorMask"
};
class zT {
  /**
   * @param {WebGPURenderer} renderer - The renderer this System works for.
   */
  constructor(t) {
    this._renderer = t;
  }
  async init(t) {
    return this._initPromise ? this._initPromise : (this._initPromise = this._createDeviceAndAdaptor(t).then((e) => {
      this.gpu = e, this._renderer.runners.contextChange.emit(this.gpu);
    }), this._initPromise);
  }
  /**
   * Handle the context change event
   * @param gpu
   */
  contextChange(t) {
    this._renderer.gpu = t;
  }
  /**
   * Helper class to create a WebGL Context
   * @param {object} options - An options object that gets passed in to the canvas element containing the
   *    context attributes
   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
   * @returns {WebGLRenderingContext} the WebGL context
   */
  async _createDeviceAndAdaptor(t) {
    const e = await Wt.get().getNavigator().gpu.requestAdapter({
      powerPreference: t.powerPreference,
      forceFallbackAdapter: t.forceFallbackAdapter
    }), s = [
      "texture-compression-bc",
      "texture-compression-astc",
      "texture-compression-etc2"
    ].filter((n) => e.features.has(n)), r = await e.requestDevice({
      requiredFeatures: s
    });
    return { adapter: e, device: r };
  }
  destroy() {
    this.gpu = null, this._renderer = null;
  }
}
zT.extension = {
  type: [
    B.WebGPUSystem
  ],
  name: "device"
};
zT.defaultOptions = {
  /**
   * {@link WebGPUOptions.powerPreference}
   * @default default
   */
  powerPreference: void 0,
  /**
   * Force the use of the fallback adapter
   * @default false
   */
  forceFallbackAdapter: !1
};
class GO {
  constructor(t) {
    this._boundBindGroup = /* @__PURE__ */ Object.create(null), this._boundVertexBuffer = /* @__PURE__ */ Object.create(null), this._renderer = t;
  }
  renderStart() {
    this.commandFinished = new Promise((t) => {
      this._resolveCommandFinished = t;
    }), this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
  }
  beginRenderPass(t) {
    this.endRenderPass(), this._clearCache(), this.renderPassEncoder = this.commandEncoder.beginRenderPass(t.descriptor);
  }
  endRenderPass() {
    this.renderPassEncoder && this.renderPassEncoder.end(), this.renderPassEncoder = null;
  }
  setViewport(t) {
    this.renderPassEncoder.setViewport(t.x, t.y, t.width, t.height, 0, 1);
  }
  setPipelineFromGeometryProgramAndState(t, e, s, r) {
    const n = this._renderer.pipeline.getPipeline(t, e, s, r);
    this.setPipeline(n);
  }
  setPipeline(t) {
    this._boundPipeline !== t && (this._boundPipeline = t, this.renderPassEncoder.setPipeline(t));
  }
  _setVertexBuffer(t, e) {
    this._boundVertexBuffer[t] !== e && (this._boundVertexBuffer[t] = e, this.renderPassEncoder.setVertexBuffer(t, this._renderer.buffer.updateBuffer(e)));
  }
  _setIndexBuffer(t) {
    if (this._boundIndexBuffer === t)
      return;
    this._boundIndexBuffer = t;
    const e = t.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
    this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(t), e);
  }
  resetBindGroup(t) {
    this._boundBindGroup[t] = null;
  }
  setBindGroup(t, e, s) {
    if (this._boundBindGroup[t] === e)
      return;
    this._boundBindGroup[t] = e, e._touch(this._renderer.textureGC.count);
    const r = this._renderer.bindGroup.getBindGroup(e, s, t);
    this.renderPassEncoder.setBindGroup(t, r);
  }
  setGeometry(t, e) {
    const s = this._renderer.pipeline.getBufferNamesToBind(t, e);
    for (const r in s)
      this._setVertexBuffer(r, t.attributes[s[r]].buffer);
    t.indexBuffer && this._setIndexBuffer(t.indexBuffer);
  }
  _setShaderBindGroups(t, e) {
    for (const s in t.groups) {
      const r = t.groups[s];
      e || this._syncBindGroup(r), this.setBindGroup(s, r, t.gpuProgram);
    }
  }
  _syncBindGroup(t) {
    for (const e in t.resources) {
      const s = t.resources[e];
      s.isUniformGroup && this._renderer.ubo.updateUniformGroup(s);
    }
  }
  draw(t) {
    const { geometry: e, shader: s, state: r, topology: n, size: a, start: o, instanceCount: h, skipSync: u } = t;
    this.setPipelineFromGeometryProgramAndState(e, s.gpuProgram, r, n), this.setGeometry(e, s.gpuProgram), this._setShaderBindGroups(s, u), e.indexBuffer ? this.renderPassEncoder.drawIndexed(
      a || e.indexBuffer.data.length,
      h || e.instanceCount,
      o || 0
    ) : this.renderPassEncoder.draw(a || e.getSize(), h || e.instanceCount, o || 0);
  }
  finishRenderPass() {
    this.renderPassEncoder && (this.renderPassEncoder.end(), this.renderPassEncoder = null);
  }
  postrender() {
    this.finishRenderPass(), this._gpu.device.queue.submit([this.commandEncoder.finish()]), this._resolveCommandFinished(), this.commandEncoder = null;
  }
  // restores a render pass if finishRenderPass was called
  // not optimised as really used for debugging!
  // used when we want to stop drawing and log a texture..
  restoreRenderPass() {
    const t = this._renderer.renderTarget.adaptor.getDescriptor(
      this._renderer.renderTarget.renderTarget,
      !1,
      [0, 0, 0, 1]
    );
    this.renderPassEncoder = this.commandEncoder.beginRenderPass(t);
    const e = this._boundPipeline, s = { ...this._boundVertexBuffer }, r = this._boundIndexBuffer, n = { ...this._boundBindGroup };
    this._clearCache();
    const a = this._renderer.renderTarget.viewport;
    this.renderPassEncoder.setViewport(a.x, a.y, a.width, a.height, 0, 1), this.setPipeline(e);
    for (const o in s)
      this._setVertexBuffer(o, s[o]);
    for (const o in n)
      this.setBindGroup(o, n[o], null);
    this._setIndexBuffer(r);
  }
  _clearCache() {
    for (let t = 0; t < 16; t++)
      this._boundBindGroup[t] = null, this._boundVertexBuffer[t] = null;
    this._boundIndexBuffer = null, this._boundPipeline = null;
  }
  destroy() {
    this._renderer = null, this._gpu = null, this._boundBindGroup = null, this._boundVertexBuffer = null, this._boundIndexBuffer = null, this._boundPipeline = null;
  }
  contextChange(t) {
    this._gpu = t;
  }
}
GO.extension = {
  type: [B.WebGPUSystem],
  name: "encoder",
  priority: 1
};
class BO {
  constructor(t) {
    this._renderTargetStencilState = /* @__PURE__ */ Object.create(null), this._renderer = t, t.renderTarget.onRenderTargetChange.add(this);
  }
  onRenderTargetChange(t) {
    let e = this._renderTargetStencilState[t.uid];
    e || (e = this._renderTargetStencilState[t.uid] = {
      stencilMode: Xe.DISABLED,
      stencilReference: 0
    }), this._activeRenderTarget = t, this.setStencilMode(e.stencilMode, e.stencilReference);
  }
  setStencilMode(t, e) {
    const s = this._renderTargetStencilState[this._activeRenderTarget.uid];
    s.stencilMode = t, s.stencilReference = e;
    const r = this._renderer;
    r.pipeline.setStencilMode(t), r.encoder.renderPassEncoder.setStencilReference(e);
  }
  destroy() {
    this._renderer.renderTarget.onRenderTargetChange.remove(this), this._renderer = null, this._activeRenderTarget = null, this._renderTargetStencilState = null;
  }
}
BO.extension = {
  type: [
    B.WebGPUSystem
  ],
  name: "stencil"
};
const Rl = {
  i32: { align: 4, size: 4 },
  u32: { align: 4, size: 4 },
  f32: { align: 4, size: 4 },
  f16: { align: 2, size: 2 },
  "vec2<i32>": { align: 8, size: 8 },
  "vec2<u32>": { align: 8, size: 8 },
  "vec2<f32>": { align: 8, size: 8 },
  "vec2<f16>": { align: 4, size: 4 },
  "vec3<i32>": { align: 16, size: 12 },
  "vec3<u32>": { align: 16, size: 12 },
  "vec3<f32>": { align: 16, size: 12 },
  "vec3<f16>": { align: 8, size: 6 },
  "vec4<i32>": { align: 16, size: 16 },
  "vec4<u32>": { align: 16, size: 16 },
  "vec4<f32>": { align: 16, size: 16 },
  "vec4<f16>": { align: 8, size: 8 },
  "mat2x2<f32>": { align: 8, size: 16 },
  "mat2x2<f16>": { align: 4, size: 8 },
  "mat3x2<f32>": { align: 8, size: 24 },
  "mat3x2<f16>": { align: 4, size: 12 },
  "mat4x2<f32>": { align: 8, size: 32 },
  "mat4x2<f16>": { align: 4, size: 16 },
  "mat2x3<f32>": { align: 16, size: 32 },
  "mat2x3<f16>": { align: 8, size: 16 },
  "mat3x3<f32>": { align: 16, size: 48 },
  "mat3x3<f16>": { align: 8, size: 24 },
  "mat4x3<f32>": { align: 16, size: 64 },
  "mat4x3<f16>": { align: 8, size: 32 },
  "mat2x4<f32>": { align: 16, size: 32 },
  "mat2x4<f16>": { align: 8, size: 16 },
  "mat3x4<f32>": { align: 16, size: 48 },
  "mat3x4<f16>": { align: 8, size: 24 },
  "mat4x4<f32>": { align: 16, size: 64 },
  "mat4x4<f16>": { align: 8, size: 32 }
};
function u1(i) {
  const t = i.map((s) => ({
    data: s,
    offset: 0,
    size: 0
  }));
  let e = 0;
  for (let s = 0; s < t.length; s++) {
    const r = t[s];
    let n = Rl[r.data.type].size;
    const a = Rl[r.data.type].align;
    if (!Rl[r.data.type])
      throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${r.data.type}`);
    r.data.size > 1 && (n = Math.max(n, a) * r.data.size), e = Math.ceil(e / a) * a, r.size = n, r.offset = e, e += n;
  }
  return e = Math.ceil(e / 16) * 16, { uboElements: t, size: e };
}
function l1(i, t) {
  const { size: e, align: s } = Rl[i.data.type], r = (s - e) / 4;
  return `
         v = uv.${i.data.name};
         ${t !== 0 ? `offset += ${t};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${i.data.size * (e / 4)}; i++)
         {
             for(var j = 0; j < ${e / 4}; j++)
             {
                 data[arrayOffset++] = v[t++];
             }
             ${r !== 0 ? `arrayOffset += ${r};` : ""}
         }
     `;
}
function c1(i) {
  return DD(
    i,
    "uboWgsl",
    l1,
    FD
  );
}
class kO extends UD {
  constructor() {
    super({
      createUboElements: u1,
      generateUboSync: c1
    });
  }
}
kO.extension = {
  type: [B.WebGPUSystem],
  name: "ubo"
};
const Cr = 128;
class zO {
  constructor(t) {
    this._bindGroupHash = /* @__PURE__ */ Object.create(null), this._buffers = [], this._bindGroups = [], this._bufferResources = [], this._renderer = t, this._renderer.renderableGC.addManagedHash(this, "_bindGroupHash"), this._batchBuffer = new h1({ minUniformOffsetAlignment: Cr });
    const e = 256 / Cr;
    for (let s = 0; s < e; s++) {
      let r = ve.UNIFORM | ve.COPY_DST;
      s === 0 && (r |= ve.COPY_SRC), this._buffers.push(new gn({
        data: this._batchBuffer.data,
        usage: r
      }));
    }
  }
  renderEnd() {
    this._uploadBindGroups(), this._resetBindGroups();
  }
  _resetBindGroups() {
    for (const t in this._bindGroupHash)
      this._bindGroupHash[t] = null;
    this._batchBuffer.clear();
  }
  // just works for single bind groups for now
  getUniformBindGroup(t, e) {
    if (!e && this._bindGroupHash[t.uid])
      return this._bindGroupHash[t.uid];
    this._renderer.ubo.ensureUniformGroup(t);
    const s = t.buffer.data, r = this._batchBuffer.addEmptyGroup(s.length);
    return this._renderer.ubo.syncUniformGroup(t, this._batchBuffer.data, r / 4), this._bindGroupHash[t.uid] = this._getBindGroup(r / Cr), this._bindGroupHash[t.uid];
  }
  getUboResource(t) {
    this._renderer.ubo.updateUniformGroup(t);
    const e = t.buffer.data, s = this._batchBuffer.addGroup(e);
    return this._getBufferResource(s / Cr);
  }
  getArrayBindGroup(t) {
    const e = this._batchBuffer.addGroup(t);
    return this._getBindGroup(e / Cr);
  }
  getArrayBufferResource(t) {
    const s = this._batchBuffer.addGroup(t) / Cr;
    return this._getBufferResource(s);
  }
  _getBufferResource(t) {
    if (!this._bufferResources[t]) {
      const e = this._buffers[t % 2];
      this._bufferResources[t] = new kD({
        buffer: e,
        offset: (t / 2 | 0) * 256,
        size: Cr
      });
    }
    return this._bufferResources[t];
  }
  _getBindGroup(t) {
    if (!this._bindGroups[t]) {
      const e = new la({
        0: this._getBufferResource(t)
      });
      this._bindGroups[t] = e;
    }
    return this._bindGroups[t];
  }
  _uploadBindGroups() {
    const t = this._renderer.buffer, e = this._buffers[0];
    e.update(this._batchBuffer.byteIndex), t.updateBuffer(e);
    const s = this._renderer.gpu.device.createCommandEncoder();
    for (let r = 1; r < this._buffers.length; r++) {
      const n = this._buffers[r];
      s.copyBufferToBuffer(
        t.getGPUBuffer(e),
        Cr,
        t.getGPUBuffer(n),
        0,
        this._batchBuffer.byteIndex
      );
    }
    this._renderer.gpu.device.queue.submit([s.finish()]);
  }
  destroy() {
    for (let t = 0; t < this._bindGroups.length; t++)
      this._bindGroups[t].destroy();
    this._bindGroups = null, this._bindGroupHash = null;
    for (let t = 0; t < this._buffers.length; t++)
      this._buffers[t].destroy();
    this._buffers = null;
    for (let t = 0; t < this._bufferResources.length; t++)
      this._bufferResources[t].destroy();
    this._bufferResources = null, this._batchBuffer.destroy(), this._bindGroupHash = null, this._renderer = null;
  }
}
zO.extension = {
  type: [
    B.WebGPUPipes
  ],
  name: "uniformBatch"
};
const _1 = {
  "point-list": 0,
  "line-list": 1,
  "line-strip": 2,
  "triangle-list": 3,
  "triangle-strip": 4
};
function d1(i, t, e, s, r) {
  return i << 24 | t << 16 | e << 10 | s << 5 | r;
}
function f1(i, t, e, s) {
  return e << 6 | i << 3 | s << 1 | t;
}
class VO {
  constructor(t) {
    this._moduleCache = /* @__PURE__ */ Object.create(null), this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null), this._bindingNamesCache = /* @__PURE__ */ Object.create(null), this._pipeCache = /* @__PURE__ */ Object.create(null), this._pipeStateCaches = /* @__PURE__ */ Object.create(null), this._colorMask = 15, this._multisampleCount = 1, this._renderer = t;
  }
  contextChange(t) {
    this._gpu = t, this.setStencilMode(Xe.DISABLED), this._updatePipeHash();
  }
  setMultisampleCount(t) {
    this._multisampleCount !== t && (this._multisampleCount = t, this._updatePipeHash());
  }
  setRenderTarget(t) {
    this._multisampleCount = t.msaaSamples, this._depthStencilAttachment = t.descriptor.depthStencilAttachment ? 1 : 0, this._updatePipeHash();
  }
  setColorMask(t) {
    this._colorMask !== t && (this._colorMask = t, this._updatePipeHash());
  }
  setStencilMode(t) {
    this._stencilMode !== t && (this._stencilMode = t, this._stencilState = Oa[t], this._updatePipeHash());
  }
  setPipeline(t, e, s, r) {
    const n = this.getPipeline(t, e, s);
    r.setPipeline(n);
  }
  getPipeline(t, e, s, r) {
    t._layoutKey || (PD(t, e.attributeData), this._generateBufferKey(t)), r = r || t.topology;
    const n = d1(
      t._layoutKey,
      e._layoutKey,
      s.data,
      s._blendModeId,
      _1[r]
    );
    return this._pipeCache[n] ? this._pipeCache[n] : (this._pipeCache[n] = this._createPipeline(t, e, s, r), this._pipeCache[n]);
  }
  _createPipeline(t, e, s, r) {
    const n = this._gpu.device, a = this._createVertexBufferLayouts(t, e), o = this._renderer.state.getColorTargets(s);
    o[0].writeMask = this._stencilMode === Xe.RENDERING_MASK_ADD ? 0 : this._colorMask;
    const h = this._renderer.shader.getProgramData(e).pipeline, u = {
      // TODO later check if its helpful to create..
      // layout,
      vertex: {
        module: this._getModule(e.vertex.source),
        entryPoint: e.vertex.entryPoint,
        // geometry..
        buffers: a
      },
      fragment: {
        module: this._getModule(e.fragment.source),
        entryPoint: e.fragment.entryPoint,
        targets: o
      },
      primitive: {
        topology: r,
        cullMode: s.cullMode
      },
      layout: h,
      multisample: {
        count: this._multisampleCount
      },
      // depthStencil,
      label: "PIXI Pipeline"
    };
    return this._depthStencilAttachment && (u.depthStencil = {
      ...this._stencilState,
      format: "depth24plus-stencil8",
      depthWriteEnabled: s.depthTest,
      depthCompare: s.depthTest ? "less" : "always"
    }), n.createRenderPipeline(u);
  }
  _getModule(t) {
    return this._moduleCache[t] || this._createModule(t);
  }
  _createModule(t) {
    const e = this._gpu.device;
    return this._moduleCache[t] = e.createShaderModule({
      code: t
    }), this._moduleCache[t];
  }
  _generateBufferKey(t) {
    const e = [];
    let s = 0;
    const r = Object.keys(t.attributes).sort();
    for (let a = 0; a < r.length; a++) {
      const o = t.attributes[r[a]];
      e[s++] = o.offset, e[s++] = o.format, e[s++] = o.stride, e[s++] = o.instance;
    }
    const n = e.join("|");
    return t._layoutKey = cu(n, "geometry"), t._layoutKey;
  }
  _generateAttributeLocationsKey(t) {
    const e = [];
    let s = 0;
    const r = Object.keys(t.attributeData).sort();
    for (let a = 0; a < r.length; a++) {
      const o = t.attributeData[r[a]];
      e[s++] = o.location;
    }
    const n = e.join("|");
    return t._attributeLocationsKey = cu(n, "programAttributes"), t._attributeLocationsKey;
  }
  /**
   * Returns a hash of buffer names mapped to bind locations.
   * This is used to bind the correct buffer to the correct location in the shader.
   * @param geometry - The geometry where to get the buffer names
   * @param program - The program where to get the buffer names
   * @returns An object of buffer names mapped to the bind location.
   */
  getBufferNamesToBind(t, e) {
    const s = t._layoutKey << 16 | e._attributeLocationsKey;
    if (this._bindingNamesCache[s])
      return this._bindingNamesCache[s];
    const r = this._createVertexBufferLayouts(t, e), n = /* @__PURE__ */ Object.create(null), a = e.attributeData;
    for (let o = 0; o < r.length; o++)
      for (const h in a)
        if (a[h].location === o) {
          n[o] = h;
          break;
        }
    return this._bindingNamesCache[s] = n, n;
  }
  _createVertexBufferLayouts(t, e) {
    e._attributeLocationsKey || this._generateAttributeLocationsKey(e);
    const s = t._layoutKey << 16 | e._attributeLocationsKey;
    if (this._bufferLayoutsCache[s])
      return this._bufferLayoutsCache[s];
    const r = [];
    return t.buffers.forEach((n) => {
      const a = {
        arrayStride: 0,
        stepMode: "vertex",
        attributes: []
      }, o = a.attributes;
      for (const h in e.attributeData) {
        const u = t.attributes[h];
        (u.divisor ?? 1) !== 1 && ce(`Attribute ${h} has an invalid divisor value of '${u.divisor}'. WebGPU only supports a divisor value of 1`), u.buffer === n && (a.arrayStride = u.stride, a.stepMode = u.instance ? "instance" : "vertex", o.push({
          shaderLocation: e.attributeData[h].location,
          offset: u.offset,
          format: u.format
        }));
      }
      o.length && r.push(a);
    }), this._bufferLayoutsCache[s] = r, r;
  }
  _updatePipeHash() {
    const t = f1(
      this._stencilMode,
      this._multisampleCount,
      this._colorMask,
      this._depthStencilAttachment
    );
    this._pipeStateCaches[t] || (this._pipeStateCaches[t] = /* @__PURE__ */ Object.create(null)), this._pipeCache = this._pipeStateCaches[t];
  }
  destroy() {
    this._renderer = null, this._bufferLayoutsCache = null;
  }
}
VO.extension = {
  type: [B.WebGPUSystem],
  name: "pipeline"
};
class g1 {
  constructor() {
    this.contexts = [], this.msaaTextures = [], this.msaaSamples = 1;
  }
}
class p1 {
  init(t, e) {
    this._renderer = t, this._renderTargetSystem = e;
  }
  copyToTexture(t, e, s, r, n) {
    const a = this._renderer, o = this._getGpuColorTexture(
      t
    ), h = a.texture.getGpuSource(
      e.source
    );
    return a.encoder.commandEncoder.copyTextureToTexture(
      {
        texture: o,
        origin: s
      },
      {
        texture: h,
        origin: n
      },
      r
    ), e;
  }
  startRenderPass(t, e = !0, s, r) {
    const a = this._renderTargetSystem.getGpuRenderTarget(t), o = this.getDescriptor(t, e, s);
    a.descriptor = o, this._renderer.pipeline.setRenderTarget(a), this._renderer.encoder.beginRenderPass(a), this._renderer.encoder.setViewport(r);
  }
  finishRenderPass() {
    this._renderer.encoder.endRenderPass();
  }
  /**
   * returns the gpu texture for the first color texture in the render target
   * mainly used by the filter manager to get copy the texture for blending
   * @param renderTarget
   * @returns a gpu texture
   */
  _getGpuColorTexture(t) {
    const e = this._renderTargetSystem.getGpuRenderTarget(t);
    return e.contexts[0] ? e.contexts[0].getCurrentTexture() : this._renderer.texture.getGpuSource(
      t.colorTextures[0].source
    );
  }
  getDescriptor(t, e, s) {
    typeof e == "boolean" && (e = e ? Bi.ALL : Bi.NONE);
    const r = this._renderTargetSystem, n = r.getGpuRenderTarget(t), a = t.colorTextures.map(
      (u, c) => {
        const l = n.contexts[c];
        let _, d;
        l ? _ = l.getCurrentTexture().createView() : _ = this._renderer.texture.getGpuSource(u).createView({
          mipLevelCount: 1
        }), n.msaaTextures[c] && (d = _, _ = this._renderer.texture.getTextureView(
          n.msaaTextures[c]
        ));
        const f = e & Bi.COLOR ? "clear" : "load";
        return s ?? (s = r.defaultClearColor), {
          view: _,
          resolveTarget: d,
          clearValue: s,
          storeOp: "store",
          loadOp: f
        };
      }
    );
    let o;
    if ((t.stencil || t.depth) && !t.depthStencilTexture && (t.ensureDepthStencilTexture(), t.depthStencilTexture.source.sampleCount = n.msaa ? 4 : 1), t.depthStencilTexture) {
      const u = e & Bi.STENCIL ? "clear" : "load", c = e & Bi.DEPTH ? "clear" : "load";
      o = {
        view: this._renderer.texture.getGpuSource(t.depthStencilTexture.source).createView(),
        stencilStoreOp: "store",
        stencilLoadOp: u,
        depthClearValue: 1,
        depthLoadOp: c,
        depthStoreOp: "store"
      };
    }
    return {
      colorAttachments: a,
      depthStencilAttachment: o
    };
  }
  clear(t, e = !0, s, r) {
    if (!e)
      return;
    const { gpu: n, encoder: a } = this._renderer, o = n.device;
    if (a.commandEncoder === null) {
      const u = o.createCommandEncoder(), c = this.getDescriptor(t, e, s), l = u.beginRenderPass(c);
      l.setViewport(r.x, r.y, r.width, r.height, 0, 1), l.end();
      const _ = u.finish();
      o.queue.submit([_]);
    } else
      this.startRenderPass(t, e, s, r);
  }
  initGpuRenderTarget(t) {
    t.isRoot = !0;
    const e = new g1();
    return t.colorTextures.forEach((s, r) => {
      if (Do.test(s.resource)) {
        const n = s.resource.getContext(
          "webgpu"
        ), a = s.transparent ? "premultiplied" : "opaque";
        try {
          n.configure({
            device: this._renderer.gpu.device,
            // eslint-disable-next-line max-len
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
            format: "bgra8unorm",
            alphaMode: a
          });
        } catch (o) {
          console.error(o);
        }
        e.contexts[r] = n;
      }
      if (e.msaa = s.source.antialias, s.source.antialias) {
        const n = new ke({
          width: 0,
          height: 0,
          sampleCount: 4
        });
        e.msaaTextures[r] = n;
      }
    }), e.msaa && (e.msaaSamples = 4, t.depthStencilTexture && (t.depthStencilTexture.source.sampleCount = 4)), e;
  }
  destroyGpuRenderTarget(t) {
    t.contexts.forEach((e) => {
      e.unconfigure();
    }), t.msaaTextures.forEach((e) => {
      e.destroy();
    }), t.msaaTextures.length = 0, t.contexts.length = 0;
  }
  ensureDepthStencilTexture(t) {
    const e = this._renderTargetSystem.getGpuRenderTarget(t);
    t.depthStencilTexture && e.msaa && (t.depthStencilTexture.source.sampleCount = 4);
  }
  resizeGpuRenderTarget(t) {
    const e = this._renderTargetSystem.getGpuRenderTarget(t);
    e.width = t.width, e.height = t.height, e.msaa && t.colorTextures.forEach((s, r) => {
      const n = e.msaaTextures[r];
      n == null || n.resize(
        s.source.width,
        s.source.height,
        s.source._resolution
      );
    });
  }
}
class HO extends BD {
  constructor(t) {
    super(t), this.adaptor = new p1(), this.adaptor.init(t, this);
  }
}
HO.extension = {
  type: [B.WebGPUSystem],
  name: "renderTarget"
};
class YO {
  constructor() {
    this._gpuProgramData = /* @__PURE__ */ Object.create(null);
  }
  contextChange(t) {
    this._gpu = t, this.maxTextures = t.device.limits.maxSampledTexturesPerShaderStage;
  }
  getProgramData(t) {
    return this._gpuProgramData[t._layoutKey] || this._createGPUProgramData(t);
  }
  _createGPUProgramData(t) {
    const e = this._gpu.device, s = t.gpuLayout.map((n) => e.createBindGroupLayout({ entries: n })), r = { bindGroupLayouts: s };
    return this._gpuProgramData[t._layoutKey] = {
      bindGroups: s,
      pipeline: e.createPipelineLayout(r)
    }, this._gpuProgramData[t._layoutKey];
  }
  destroy() {
    this._gpu = null, this._gpuProgramData = null;
  }
}
YO.extension = {
  type: [
    B.WebGPUSystem
  ],
  name: "shader"
};
const Is = {};
Is.normal = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  }
};
Is.add = {
  alpha: {
    srcFactor: "src-alpha",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "add"
  }
};
Is.multiply = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "dst",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  }
};
Is.screen = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one-minus-src",
    operation: "add"
  }
};
Is.overlay = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one-minus-src",
    operation: "add"
  }
};
Is.none = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "zero",
    dstFactor: "zero",
    operation: "add"
  }
};
Is["normal-npm"] = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "src-alpha",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  }
};
Is["add-npm"] = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "add"
  },
  color: {
    srcFactor: "src-alpha",
    dstFactor: "one",
    operation: "add"
  }
};
Is["screen-npm"] = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "src-alpha",
    dstFactor: "one-minus-src",
    operation: "add"
  }
};
Is.erase = {
  alpha: {
    srcFactor: "zero",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "zero",
    dstFactor: "one-minus-src",
    operation: "add"
  }
};
Is.min = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "min"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "min"
  }
};
Is.max = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "max"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "max"
  }
};
class WO {
  constructor() {
    this.defaultState = new Pd(), this.defaultState.blend = !0;
  }
  contextChange(t) {
    this.gpu = t;
  }
  /**
   * Gets the blend mode data for the current state
   * @param state - The state to get the blend mode from
   */
  getColorTargets(t) {
    return [
      {
        format: "bgra8unorm",
        writeMask: 0,
        blend: Is[t.blendMode] || Is.normal
      }
    ];
  }
  destroy() {
    this.gpu = null;
  }
}
WO.extension = {
  type: [
    B.WebGPUSystem
  ],
  name: "state"
};
const m1 = {
  type: "image",
  upload(i, t, e) {
    const s = i.resource, r = (i.pixelWidth | 0) * (i.pixelHeight | 0), n = s.byteLength / r;
    e.device.queue.writeTexture(
      { texture: t },
      s,
      {
        offset: 0,
        rowsPerImage: i.pixelHeight,
        bytesPerRow: i.pixelHeight * n
      },
      {
        width: i.pixelWidth,
        height: i.pixelHeight,
        depthOrArrayLayers: 1
      }
    );
  }
}, jO = {
  "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
  "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
  "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
  "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
  "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
  "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
  "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }
}, E1 = { blockBytes: 4, blockWidth: 1, blockHeight: 1 }, T1 = {
  type: "compressed",
  upload(i, t, e) {
    let s = i.pixelWidth, r = i.pixelHeight;
    const n = jO[i.format] || E1;
    for (let a = 0; a < i.resource.length; a++) {
      const o = i.resource[a], h = Math.ceil(s / n.blockWidth) * n.blockBytes;
      e.device.queue.writeTexture(
        {
          texture: t,
          mipLevel: a
        },
        o,
        {
          offset: 0,
          bytesPerRow: h
        },
        {
          width: Math.ceil(s / n.blockWidth) * n.blockWidth,
          height: Math.ceil(r / n.blockHeight) * n.blockHeight,
          depthOrArrayLayers: 1
        }
      ), s = Math.max(s >> 1, 1), r = Math.max(r >> 1, 1);
    }
  }
}, XO = {
  type: "image",
  upload(i, t, e) {
    const s = i.resource;
    if (!s)
      return;
    const r = Math.min(t.width, i.resourceWidth || i.pixelWidth), n = Math.min(t.height, i.resourceHeight || i.pixelHeight), a = i.alphaMode === "premultiply-alpha-on-upload";
    e.device.queue.copyExternalImageToTexture(
      { source: s },
      { texture: t, premultipliedAlpha: a },
      {
        width: r,
        height: n
      }
    );
  }
}, I1 = {
  type: "video",
  upload(i, t, e) {
    XO.upload(i, t, e);
  }
};
class S1 {
  constructor(t) {
    this.device = t, this.sampler = t.createSampler({ minFilter: "linear" }), this.pipelines = {};
  }
  _getMipmapPipeline(t) {
    let e = this.pipelines[t];
    return e || (this.mipmapShaderModule || (this.mipmapShaderModule = this.device.createShaderModule({
      code: (
        /* wgsl */
        `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
      )
    })), e = this.device.createRenderPipeline({
      layout: "auto",
      vertex: {
        module: this.mipmapShaderModule,
        entryPoint: "vertexMain"
      },
      fragment: {
        module: this.mipmapShaderModule,
        entryPoint: "fragmentMain",
        targets: [{ format: t }]
      }
    }), this.pipelines[t] = e), e;
  }
  /**
   * Generates mipmaps for the given GPUTexture from the data in level 0.
   * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.
   * @returns {module:External.GPUTexture} - The originally passed texture
   */
  generateMipmap(t) {
    const e = this._getMipmapPipeline(t.format);
    if (t.dimension === "3d" || t.dimension === "1d")
      throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
    let s = t;
    const r = t.depthOrArrayLayers || 1, n = t.usage & GPUTextureUsage.RENDER_ATTACHMENT;
    if (!n) {
      const h = {
        size: {
          width: Math.ceil(t.width / 2),
          height: Math.ceil(t.height / 2),
          depthOrArrayLayers: r
        },
        format: t.format,
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
        mipLevelCount: t.mipLevelCount - 1
      };
      s = this.device.createTexture(h);
    }
    const a = this.device.createCommandEncoder({}), o = e.getBindGroupLayout(0);
    for (let h = 0; h < r; ++h) {
      let u = t.createView({
        baseMipLevel: 0,
        mipLevelCount: 1,
        dimension: "2d",
        baseArrayLayer: h,
        arrayLayerCount: 1
      }), c = n ? 1 : 0;
      for (let l = 1; l < t.mipLevelCount; ++l) {
        const _ = s.createView({
          baseMipLevel: c++,
          mipLevelCount: 1,
          dimension: "2d",
          baseArrayLayer: h,
          arrayLayerCount: 1
        }), d = a.beginRenderPass({
          colorAttachments: [{
            view: _,
            storeOp: "store",
            loadOp: "clear",
            clearValue: { r: 0, g: 0, b: 0, a: 0 }
          }]
        }), f = this.device.createBindGroup({
          layout: o,
          entries: [{
            binding: 0,
            resource: this.sampler
          }, {
            binding: 1,
            resource: u
          }]
        });
        d.setPipeline(e), d.setBindGroup(0, f), d.draw(3, 1, 0, 0), d.end(), u = _;
      }
    }
    if (!n) {
      const h = {
        width: Math.ceil(t.width / 2),
        height: Math.ceil(t.height / 2),
        depthOrArrayLayers: r
      };
      for (let u = 1; u < t.mipLevelCount; ++u)
        a.copyTextureToTexture({
          texture: s,
          mipLevel: u - 1
        }, {
          texture: t,
          mipLevel: u
        }, h), h.width = Math.ceil(h.width / 2), h.height = Math.ceil(h.height / 2);
    }
    return this.device.queue.submit([a.finish()]), n || s.destroy(), t;
  }
}
class KO {
  constructor(t) {
    this.managedTextures = [], this._gpuSources = /* @__PURE__ */ Object.create(null), this._gpuSamplers = /* @__PURE__ */ Object.create(null), this._bindGroupHash = /* @__PURE__ */ Object.create(null), this._textureViewHash = /* @__PURE__ */ Object.create(null), this._uploads = {
      image: XO,
      buffer: m1,
      video: I1,
      compressed: T1
    }, this._renderer = t, t.renderableGC.addManagedHash(this, "_gpuSources"), t.renderableGC.addManagedHash(this, "_gpuSamplers"), t.renderableGC.addManagedHash(this, "_bindGroupHash"), t.renderableGC.addManagedHash(this, "_textureViewHash");
  }
  contextChange(t) {
    this._gpu = t;
  }
  initSource(t) {
    if (t.autoGenerateMipmaps) {
      const h = Math.max(t.pixelWidth, t.pixelHeight);
      t.mipLevelCount = Math.floor(Math.log2(h)) + 1;
    }
    let e = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
    t.uploadMethodId !== "compressed" && (e |= GPUTextureUsage.RENDER_ATTACHMENT, e |= GPUTextureUsage.COPY_SRC);
    const s = jO[t.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 }, r = Math.ceil(t.pixelWidth / s.blockWidth) * s.blockWidth, n = Math.ceil(t.pixelHeight / s.blockHeight) * s.blockHeight, a = {
      label: t.label,
      size: { width: r, height: n },
      format: t.format,
      sampleCount: t.sampleCount,
      mipLevelCount: t.mipLevelCount,
      dimension: t.dimension,
      usage: e
    }, o = this._gpu.device.createTexture(a);
    return this._gpuSources[t.uid] = o, this.managedTextures.includes(t) || (t.on("update", this.onSourceUpdate, this), t.on("resize", this.onSourceResize, this), t.on("destroy", this.onSourceDestroy, this), t.on("unload", this.onSourceUnload, this), t.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(t)), this.onSourceUpdate(t), o;
  }
  onSourceUpdate(t) {
    const e = this.getGpuSource(t);
    e && (this._uploads[t.uploadMethodId] && this._uploads[t.uploadMethodId].upload(t, e, this._gpu), t.autoGenerateMipmaps && t.mipLevelCount > 1 && this.onUpdateMipmaps(t));
  }
  onSourceUnload(t) {
    const e = this._gpuSources[t.uid];
    e && (this._gpuSources[t.uid] = null, e.destroy());
  }
  onUpdateMipmaps(t) {
    this._mipmapGenerator || (this._mipmapGenerator = new S1(this._gpu.device));
    const e = this.getGpuSource(t);
    this._mipmapGenerator.generateMipmap(e);
  }
  onSourceDestroy(t) {
    t.off("update", this.onSourceUpdate, this), t.off("unload", this.onSourceUnload, this), t.off("destroy", this.onSourceDestroy, this), t.off("resize", this.onSourceResize, this), t.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(t), 1), this.onSourceUnload(t);
  }
  onSourceResize(t) {
    const e = this._gpuSources[t.uid];
    e ? (e.width !== t.pixelWidth || e.height !== t.pixelHeight) && (this._textureViewHash[t.uid] = null, this._bindGroupHash[t.uid] = null, this.onSourceUnload(t), this.initSource(t)) : this.initSource(t);
  }
  _initSampler(t) {
    return this._gpuSamplers[t._resourceId] = this._gpu.device.createSampler(t), this._gpuSamplers[t._resourceId];
  }
  getGpuSampler(t) {
    return this._gpuSamplers[t._resourceId] || this._initSampler(t);
  }
  getGpuSource(t) {
    return this._gpuSources[t.uid] || this.initSource(t);
  }
  /**
   * this returns s bind group for a specific texture, the bind group contains
   * - the texture source
   * - the texture style
   * - the texture matrix
   * This is cached so the bind group should only be created once per texture
   * @param texture - the texture you want the bindgroup for
   * @returns the bind group for the texture
   */
  getTextureBindGroup(t) {
    return this._bindGroupHash[t.uid] ?? this._createTextureBindGroup(t);
  }
  _createTextureBindGroup(t) {
    const e = t.source;
    return this._bindGroupHash[t.uid] = new la({
      0: e,
      1: e.style,
      2: new mn({
        uTextureMatrix: { type: "mat3x3<f32>", value: t.textureMatrix.mapCoord }
      })
    }), this._bindGroupHash[t.uid];
  }
  getTextureView(t) {
    const e = t.source;
    return this._textureViewHash[e.uid] ?? this._createTextureView(e);
  }
  _createTextureView(t) {
    return this._textureViewHash[t.uid] = this.getGpuSource(t).createView(), this._textureViewHash[t.uid];
  }
  generateCanvas(t) {
    const e = this._renderer, s = e.gpu.device.createCommandEncoder(), r = Wt.get().createCanvas();
    r.width = t.source.pixelWidth, r.height = t.source.pixelHeight;
    const n = r.getContext("webgpu");
    return n.configure({
      device: e.gpu.device,
      // eslint-disable-next-line max-len
      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
      format: Wt.get().getNavigator().gpu.getPreferredCanvasFormat(),
      alphaMode: "premultiplied"
    }), s.copyTextureToTexture({
      texture: e.texture.getGpuSource(t.source),
      origin: {
        x: 0,
        y: 0
      }
    }, {
      texture: n.getCurrentTexture()
    }, {
      width: r.width,
      height: r.height
    }), e.gpu.device.queue.submit([s.finish()]), r;
  }
  getPixels(t) {
    const e = this.generateCanvas(t), s = Hl.getOptimalCanvasAndContext(e.width, e.height), r = s.context;
    r.drawImage(e, 0, 0);
    const { width: n, height: a } = e, o = r.getImageData(0, 0, n, a), h = new Uint8ClampedArray(o.data.buffer);
    return Hl.returnCanvasAndContext(s), { pixels: h, width: n, height: a };
  }
  destroy() {
    this.managedTextures.slice().forEach((t) => this.onSourceDestroy(t)), this.managedTextures = null;
    for (const t of Object.keys(this._bindGroupHash)) {
      const e = Number(t), s = this._bindGroupHash[e];
      s == null || s.destroy(), this._bindGroupHash[e] = null;
    }
    this._gpu = null, this._mipmapGenerator = null, this._gpuSources = null, this._bindGroupHash = null, this._textureViewHash = null, this._gpuSamplers = null;
  }
}
KO.extension = {
  type: [
    B.WebGPUSystem
  ],
  name: "texture"
};
class qO {
  init() {
    const t = new mn({
      uTransformMatrix: { value: new ot(), type: "mat3x3<f32>" },
      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
      uRound: { value: 0, type: "f32" }
    }), e = yT({
      name: "graphics",
      bits: [
        N0,
        U0(RT()),
        yD,
        vT
      ]
    });
    this.shader = new $o({
      gpuProgram: e,
      resources: {
        // added on the fly!
        localUniforms: t
      }
    });
  }
  execute(t, e) {
    const s = e.context, r = s.customShader || this.shader, n = t.renderer, a = n.graphicsContext, {
      batcher: o,
      instructions: h
    } = a.getContextRenderData(s), u = n.encoder;
    u.setPipelineFromGeometryProgramAndState(
      o.geometry,
      r.gpuProgram,
      t.state
    ), u.setGeometry(o.geometry, r.gpuProgram);
    const c = n.globalUniforms.bindGroup;
    u.setBindGroup(0, c, r.gpuProgram);
    const l = n.renderPipes.uniformBatch.getUniformBindGroup(r.resources.localUniforms, !0);
    u.setBindGroup(2, l, r.gpuProgram);
    const _ = h.instructions;
    for (let d = 0; d < h.instructionSize; d++) {
      const f = _[d];
      if (r.groups[1] = f.bindGroup, !f.gpuBindGroup) {
        const p = f.textures;
        f.bindGroup = OT(p.textures, p.count), f.gpuBindGroup = n.bindGroup.getBindGroup(
          f.bindGroup,
          r.gpuProgram,
          1
        );
      }
      u.setBindGroup(1, f.bindGroup, r.gpuProgram), u.renderPassEncoder.drawIndexed(f.size, 1, f.start);
    }
  }
  destroy() {
    this.shader.destroy(!0), this.shader = null;
  }
}
qO.extension = {
  type: [
    B.WebGPUPipesAdaptor
  ],
  name: "graphics"
};
class $O {
  init() {
    const t = yT({
      name: "mesh",
      bits: [
        Al,
        vD,
        vT
      ]
    });
    this._shader = new $o({
      gpuProgram: t,
      resources: {
        uTexture: W.EMPTY._source,
        uSampler: W.EMPTY._source.style,
        textureUniforms: {
          uTextureMatrix: { type: "mat3x3<f32>", value: new ot() }
        }
      }
    });
  }
  execute(t, e) {
    const s = t.renderer;
    let r = e._shader;
    if (!r)
      r = this._shader, r.groups[2] = s.texture.getTextureBindGroup(e.texture);
    else if (!r.gpuProgram) {
      ce("Mesh shader has no gpuProgram", e.shader);
      return;
    }
    const n = r.gpuProgram;
    if (n.autoAssignGlobalUniforms && (r.groups[0] = s.globalUniforms.bindGroup), n.autoAssignLocalUniforms) {
      const a = t.localUniforms;
      r.groups[1] = s.renderPipes.uniformBatch.getUniformBindGroup(a, !0);
    }
    s.encoder.draw({
      geometry: e._geometry,
      shader: r,
      state: e.state
    });
  }
  destroy() {
    this._shader.destroy(!0), this._shader = null;
  }
}
$O.extension = {
  type: [
    B.WebGPUPipesAdaptor
  ],
  name: "mesh"
};
const A1 = [
  ...a1,
  kO,
  GO,
  zT,
  FO,
  KO,
  HO,
  YO,
  WO,
  VO,
  wO,
  BO,
  LO
], R1 = [...o1, zO], O1 = [aO, $O, qO], ZO = [], QO = [], JO = [];
Ee.handleByNamedList(B.WebGPUSystem, ZO);
Ee.handleByNamedList(B.WebGPUPipes, QO);
Ee.handleByNamedList(B.WebGPUPipesAdaptor, JO);
Ee.add(...A1, ...R1, ...O1);
class ty extends TT {
  constructor() {
    const t = {
      name: "webgpu",
      type: Or.WEBGPU,
      systems: ZO,
      renderPipes: QO,
      renderPipeAdaptors: JO
    };
    super(t);
  }
}
const y1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  WebGPURenderer: ty
}, Symbol.toStringTag, { value: "Module" }));
Ee.add(qM, $M);
const jc = class jc {
};
jc.UNKNOWN = 0, jc.BROWSER = 1;
let xg = jc;
const Ph = class Ph {
};
Ph.UNKNOWN = 0, Ph.FLASH = 1, Ph.HTML5 = 2;
let Mg = Ph;
const Qa = class Qa {
};
Qa.CONNECTION_OPENED = "open", Qa.CONNECTION_CLOSED = "close", Qa.CONNECTION_ERROR = "error", Qa.CONNECTION_MESSAGE = "message";
let Va = Qa;
const q = class q {
  static getExpressionTimeout(t) {
    switch (t = parseInt(t), t) {
      case 1:
        return 5e3;
      case 2:
        return 1400;
      case 3:
        return 2e3;
      case 4:
        return 2e3;
      case 5:
        return 0;
      case 6:
        return 700;
      case 7:
        return 2e3;
      case 8:
        return 1500;
      case 9:
        return 1500;
      case 10:
        return 1500;
      default:
        return 0;
    }
  }
  static getExpressionId(t) {
    return q.EXPRESSION_MAP.indexOf(t);
  }
  static getExpression(t) {
    return t > q.EXPRESSION_MAP.length ? null : q.EXPRESSION_MAP[t];
  }
  static getGestureId(t) {
    return q.GESTURE_MAP.indexOf(t);
  }
  static getGesture(t) {
    return t > q.GESTURE_MAP.length ? null : q.GESTURE_MAP[t];
  }
  static idToAvatarActionState(t) {
    return t === "Lay" ? "lay" : t === "Float" ? "float" : t === "Swim" ? "swim" : t === "Sit" ? "sit" : t === "Respect" ? "respect" : t === "Wave" ? "wave" : t === "Idle" ? "idle" : t === "Dance" ? "dance" : t === "UseItem" ? "usei" : t === "CarryItem" ? "cri" : t === "Talk" ? "talk" : t === "Sleep" ? "Sleep" : t === "Move" ? "mv" : "std";
  }
};
q.CARRY_OBJECT = "cri", q.DANCE = "dance", q.EFFECT = "fx", q.EXPRESSION = "expression", q.EXPRESSION_BLOW_A_KISS = "blow", q.EXPRESSION_CRY = "cry", q.EXPRESSION_IDLE = "idle", q.EXPRESSION_LAUGH = "laugh", q.EXPRESSION_RESPECT = "respect", q.EXPRESSION_RIDE_JUMP = "ridejump", q.EXPRESSION_SNOWBOARD_OLLIE = "sbollie", q.EXPRESSION_SNOWBORD_360 = "sb360", q.EXPRESSION_WAVE = "wave", q.GESTURE = "gest", q.GESTURE_AGGRAVATED = "agr", q.GESTURE_SAD = "sad", q.GESTURE_SMILE = "sml", q.GESTURE_SURPRISED = "srp", q.GUIDE_STATUS = "guide", q.MUTED = "muted", q.PET_GESTURE_BLINK = "eyb", q.PET_GESTURE_CRAZY = "crz", q.PET_GESTURE_JOY = "joy", q.PET_GESTURE_MISERABLE = "mis", q.PET_GESTURE_PUZZLED = "puz", q.PET_GESTURE_TONGUE = "tng", q.PLAYING_GAME = "playing_game", q.POSTURE = "posture", q.POSTURE_FLOAT = "float", q.POSTURE_LAY = "lay", q.POSTURE_SIT = "sit", q.POSTURE_STAND = "std", q.POSTURE_SWIM = "swim", q.POSTURE_WALK = "mv", q.SIGN = "sign", q.SLEEP = "sleep", q.SNOWWAR_DIE_BACK = "swdieback", q.SNOWWAR_DIE_FRONT = "swdiefront", q.SNOWWAR_PICK = "swpick", q.SNOWWAR_RUN = "swrun", q.SNOWWAR_THROW = "swthrow", q.TALK = "talk", q.BLINK = "blink", q.TYPING = "typing", q.USE_OBJECT = "usei", q.VOTE = "vote", q.GESTURE_MAP = ["", q.GESTURE_SMILE, q.GESTURE_AGGRAVATED, q.GESTURE_SURPRISED, q.GESTURE_SAD, q.PET_GESTURE_JOY, q.PET_GESTURE_CRAZY, q.PET_GESTURE_TONGUE, q.PET_GESTURE_BLINK, q.PET_GESTURE_MISERABLE, q.PET_GESTURE_PUZZLED], q.EXPRESSION_MAP = ["", q.EXPRESSION_WAVE, q.EXPRESSION_BLOW_A_KISS, q.EXPRESSION_LAUGH, q.EXPRESSION_CRY, q.EXPRESSION_IDLE, q.DANCE, q.EXPRESSION_RESPECT, q.EXPRESSION_SNOWBOARD_OLLIE, q.EXPRESSION_SNOWBORD_360, q.EXPRESSION_RIDE_JUMP];
let et = q;
const Ja = class Ja {
};
Ja.DIRECTION_TO_ANGLE = [45, 90, 135, 180, 225, 270, 315, 0], Ja.DIRECTION_IS_FLIPPED = [!1, !1, !1, !1, !0, !0, !0, !1], Ja.MIN_DIRECTION = 0, Ja.MAX_DIRECTION = 7;
let Jr = Ja;
const tr = class tr {
};
tr.GENERIC = "hd", tr.HEAD = "head", tr.TORSO = "torso", tr.LEGS = "legs", tr.HOTLOOKS = "hotlooks", tr.WARDROBE = "wardrobe", tr.EFFECTS = "effects";
let sA = tr;
const to = class to {
};
to.OWN_AVATAR_EDITOR = 0, to.FURNITURE_AVATAR_EDITOR = 1, to.BOT_EDITOR = 2, to.DEV_TOOL_EDITOR = 3;
let iA = to;
const Xc = class Xc {
};
Xc.NOTHING = "nothing", Xc.WARDROBE = "wardrobe";
let rA = Xc;
const gt = class gt {
};
gt.MALE = "M", gt.FEMALE = "F", gt.UNISEX = "U", gt.SCALE = "h", gt.STD = "std", gt.DEFAULT_FRAME = 0, gt.BODY = "bd", gt.SHOES = "sh", gt.LEGS = "lg", gt.CHEST = "ch", gt.WAIST_ACCESSORY = "wa", gt.CHEST_ACCESSORY = "ca", gt.HEAD = "hd", gt.HAIR = "hr", gt.FACE_ACCESSORY = "fa", gt.EYE_ACCESSORY = "ea", gt.HEAD_ACCESSORY = "ha", gt.HEAD_ACCESSORY_EXTRA = "he", gt.COAT_CHEST = "cc", gt.CHEST_PRINT = "cp", gt.LEFT_HAND_ITEM = "li", gt.LEFT_HAND = "lh", gt.LEFT_SLEEVE = "ls", gt.RIGHT_HAND = "rh", gt.RIGHT_SLEEVE = "rs", gt.FACE = "fc", gt.EYES = "ey", gt.HAIR_BIG = "hrb", gt.RIGHT_HAND_ITEM = "ri", gt.LEFT_COAT_SLEEVE = "lc", gt.RIGHT_COAT_SLEEVE = "rc", gt.FIGURE_SETS = [gt.SHOES, gt.LEGS, gt.CHEST, gt.WAIST_ACCESSORY, gt.CHEST_ACCESSORY, gt.HEAD, gt.HAIR, gt.FACE_ACCESSORY, gt.EYE_ACCESSORY, gt.HEAD_ACCESSORY, gt.HEAD_ACCESSORY_EXTRA, gt.COAT_CHEST, gt.CHEST_PRINT];
let as = gt;
const Nh = class Nh {
};
Nh.NONE = 0, Nh.GUIDE = 1, Nh.REQUESTER = 2;
let Gi = Nh;
const Kc = class Kc {
};
Kc.LARGE = "h", Kc.SMALL = "sh";
let ci = Kc;
const Uh = class Uh {
};
Uh.FULL = "full", Uh.HEAD = "head", Uh.BODY = "body";
let gs = Uh;
const wn = class wn {
};
wn.VERTICAL = "vertical", wn.SITTING = "sitting", wn.HORIZONTAL = "horizontal", wn.SWIM = "swim", wn.SNOWWARS_HORIZONTAL = "swhorizontal";
let xr = wn;
const eo = class eo {
};
eo.TOOL = "tool", eo.COMPONENT = "component", eo.ONLINE_TOOL = "online_tool", eo.LOCAL_ONLY = "local_only";
let nA = eo;
const Ur = class Ur {
};
Ur.NONE = 0, Ur.HEART = 1, Ur.SMILE = 2, Ur.BOBBA = 3, Ur.RELATIONSHIP_TYPES = [0, 1, 2, 3], Ur.RELATIONSHIP_NAMES = ["None", "Heart", "Smile", "Bobba"];
let bg = Ur;
const er = class er {
};
er.HOTEL_VIEW = "hotel_view", er.HOME_ROOM = "home_room", er.NAVIGATOR = "navigator", er.CATALOG = "catalog", er.INVENTORY = "inventory", er.ME_MENU = "me_menu", er.FRIEND_LIST = "friendlist";
let Wl = er;
const Gn = class Gn {
};
Gn.LOVE_LOCK = 0, Gn.CARVE_A_TREE = 1, Gn.FRIENDS_PORTRAIT = 2, Gn.WILD_WEST_WANTED = 3, Gn.HABBOWEEN = 4;
let jl = Gn;
const qc = class qc {
};
qc.CATALOG = "catalog", qc.INVENTORY = "inventory";
let Pg = qc;
const w = class w {
};
w.OBJECT_ROOM_ID = "object_room_id", w.OBJECT_ACCURATE_Z_VALUE = "object_accurate_z_value", w.TILE_CURSOR_HEIGHT = "tile_cursor_height", w.FIGURE = "figure", w.GENDER = "gender", w.OWN_USER = "own_user", w.FIGURE_CAN_STAND_UP = "figure_can_stand_up", w.FIGURE_VERTICAL_OFFSET = "figure_vertical_offset", w.FIGURE_TALK = "figure_talk", w.FIGURE_DANCE = "figure_dance", w.FIGURE_SLEEP = "figure_sleep", w.FIGURE_BLINK = "figure_blink", w.FIGURE_EFFECT = "figure_effect", w.FIGURE_CARRY_OBJECT = "figure_carry_object", w.FIGURE_USE_OBJECT = "figure_use_object", w.FIGURE_GESTURE = "figure_gesture", w.FIGURE_POSTURE = "figure_posture", w.FIGURE_POSTURE_PARAMETER = "figure_posture_parameter", w.FIGURE_HIGHLIGHT_ENABLE = "figure_highlight_enable", w.FIGURE_HIGHLIGHT = "figure_highlight", w.FURNITURE_PURCHASER_NAME = "furniture_purchaser_name", w.FURNITURE_PURCHASER_FIGURE = "furniture_purchaser_figure", w.STD = "std", w.SWIM = "swm", w.FIGURE_SIGN = "figure_sign", w.FIGURE_FLAT_CONTROL = "figure_flat_control", w.FIGURE_IS_TYPING = "figure_is_typing", w.FIGURE_IS_MUTED = "figure_is_muted", w.FIGURE_GAINED_EXPERIENCE = "figure_gained_experience", w.FIGURE_EXPERIENCE_TIMESTAMP = "figure_experience_timestamp", w.FIGURE_NUMBER_VALUE = "figure_number_value", w.FIGURE_IS_PLAYING_GAME = "figure_is_playing_game", w.FIGURE_GUIDE_STATUS = "figure_guide_status", w.FIGURE_EXPRESSION = "figure_expression", w.HEAD_DIRECTION = "head_direction", w.FURNITURE_CUSTOM_VARIABLES = "furniture_custom_variables", w.FURNITURE_AUTOMATIC_STATE_INDEX = "furniture_automatic_state_index", w.FURNITURE_ALWAYS_STACKABLE = "furniture_always_stackable", w.FURNITURE_DISABLE_PICKING_ANIMATION = "furniture_disable_picking_animation", w.FURNITURE_DATA_FORMAT = "furniture_data_format", w.FURNITURE_UNIQUE_SERIAL_NUMBER = "furniture_unique_serial_number", w.FURNITURE_UNIQUE_EDITION_SIZE = "furniture_unique_edition_size", w.FURNITURE_CRACKABLE_STATE = "furniture_crackable_state", w.FURNITURE_CRACKABLE_HITS = "furniture_crackable_hits", w.FURNITURE_CRACKABLE_TARGET = "furniture_crackable_target", w.FURNITURE_CREDIT_VALUE = "furniture_credit_value", w.FURNITURE_DATA = "furniture_data", w.FURNITURE_ITEMDATA = "furniture_itemdata", w.FURNITURE_COLOR = "furniture_color", w.FURNITURE_LIFT_AMOUNT = "furniure_lift_amount", w.FURNITURE_GUILD_CUSTOMIZED_GUILD_ID = "furniture_guild_customized_guild_id", w.FURNITURE_GUILD_CUSTOMIZED_ASSET_NAME = "furniture_guild_customized_asset_name", w.FURNITURE_GUILD_CUSTOMIZED_COLOR_1 = "furniture_guild_customized_color_1", w.FURNITURE_GUILD_CUSTOMIZED_COLOR_2 = "furniture_guild_customized_color_2", w.FURNITURE_STATE_UPDATE_TIME = "furniture_state_update_time", w.FURNITURE_SELECTION_DISABLED = "furniture_selection_disabled", w.FURNITURE_SIZE_X = "furniture_size_x", w.FURNITURE_SIZE_Y = "furniture_size_y", w.FURNITURE_SIZE_Z = "furniture_size_z", w.FURNITURE_CENTER_X = "furniture_center_x", w.FURNITURE_CENTER_Y = "furniture_center_y", w.FURNITURE_CENTER_Z = "furniture_center_z", w.FURNITURE_ALLOWED_DIRECTIONS = "furniture_allowed_directions", w.FURNITURE_AD_URL = "furniture_ad_url", w.FURNITURE_TYPE_ID = "furniture_type_id", w.FURNITURE_EXTRAS = "furniture_extras", w.FURNITURE_EXPIRY_TIME = "furniture_expiry_time", w.FURNITURE_EXPIRTY_TIMESTAMP = "furniture_expiry_timestamp", w.FURNITURE_REAL_ROOM_OBJECT = "furniture_real_room_object", w.FURNITURE_IS_STICKIE = "furniture_is_stickie", w.FURNITURE_BRANDING_IMAGE_STATUS = "furniture_branding_image_status", w.FURNITURE_BRANDING_IMAGE_URL = "furniture_branding_image_url", w.FURNITURE_BRANDING_URL = "furniture_branding_url", w.FURNITURE_BRANDING_OFFSET_X = "furniture_branding_offset_x", w.FURNITURE_BRANDING_OFFSET_Y = "furniture_branding_offset_y", w.FURNITURE_BRANDING_OFFSET_Z = "furniture_branding_offset_z", w.FURNITURE_BADGE_IMAGE_STATUS = "furniture_badge_image_status", w.FURNITURE_BADGE_ASSET_NAME = "furniture_badge_asset_name", w.FURNITURE_BADGE_VISIBLE_IN_STATE = "furniture_badge_visible_in_state", w.FURNITURE_ALPHA_MULTIPLIER = "furniture_alpha_multiplier", w.FURNITURE_USAGE_POLICY = "furniture_usage_policy", w.FURNITURE_OWNER_ID = "furniture_owner_id", w.FURNITURE_OWNER_NAME = "furniture_owner_name", w.FURNITURE_ROOM_BACKGROUND_COLOR_HUE = "furniture_room_background_color_hue", w.FURNITURE_ROOM_BACKGROUND_COLOR_SATURATION = "furniture_room_background_color_saturation", w.FURNITURE_ROOM_BACKGROUND_COLOR_LIGHTNESS = "furniture_room_background_color_lightness", w.FURNITURE_AREA_HIDE_ROOT_X = "furniture_area_hide_root_x", w.FURNITURE_AREA_HIDE_ROOT_Y = "furniture_area_hide_root_y", w.FURNITURE_AREA_HIDE_WIDTH = "furniture_area_hide_width", w.FURNITURE_AREA_HIDE_LENGTH = "furniture_area_hide_length", w.FURNITURE_AREA_HIDE_INVISIBILITY = "furniture_area_hide_invisibility", w.FURNITURE_AREA_HIDE_WALL_ITEMS = "furniture_area_hide_wall_items", w.FURNITURE_AREA_HIDE_INVERT = "furniture_area_hide_invert", w.FURNITURE_USES_PLANE_MASK = "furniture_uses_plane_mask", w.FURNITURE_PLANE_MASK_TYPE = "furniture_plane_mask_type", w.FURNITURE_IS_VARIABLE_HEIGHT = "furniture_is_variable_height", w.FURNITURE_VOTE_MAJORITY_RESULT = "furniture_vote_majority_result", w.FURNITURE_VOTE_COUNTER_COUNT = "furniture_vote_counter_count", w.FURNITURE_SOUNDBLOCK_RELATIVE_ANIMATION_SPEED = "furniture_soundblock_relative_animation_speed", w.FURNITURE_MANNEQUIN_NAME = "furniture_mannequin_name", w.FURNITURE_MANNEQUIN_GENDER = "furniture_mannequin_gender", w.FURNITURE_MANNEQUIN_FIGURE = "furniture_mannequin_figure", w.FURNITURE_HIGHSCORE_SCORE_TYPE = "furniture_highscore_score_type", w.FURNITURE_HIGHSCORE_CLEAR_TYPE = "furniture_highscore_clear_type", w.FURNITURE_HIGHSCORE_DATA_ENTRY_COUNT = "furniture_highscore_data_entry_count", w.FURNITURE_HIGHSCORE_DATA_ENTRY_BASE_USERS_ = "furniture_highscore_data_entry_base_users_", w.FURNITURE_HIGHSCORE_DATA_ENTRY_BASE_SCORE_ = "furniture_highscore_data_entry_base_score_", w.FURNITURE_INTERNAL_LINK = "furniture_internal_link", w.FURNITURE_CLOTHING_BOY = "furniture_clothing_boy", w.FURNITURE_CLOTHING_GIRL = "furniture_clothing_girl", w.FURNITURE_PLANETSYSTEM_DATA = "furniture_planetsystem_data", w.FURNITURE_FIREWORKS_DATA = "furniture_fireworks_data", w.PET_PALETTE_INDEX = "pet_palette_index", w.PET_COLOR = "pet_color", w.PET_HEAD_ONLY = "pet_head_only", w.PET_CUSTOM_LAYER_IDS = "pet_custom_layer_ids", w.PET_CUSTOM_PARTS_IDS = "pet_custom_part_ids", w.PET_CUSTOM_PALETTE_IDS = "pet_custom_palette_ids", w.PET_IS_RIDING = "pet_is_riding", w.PET_TYPE = "pet_type", w.PET_ALLOWED_DIRECTIONS = "pet_allowed_directions", w.RACE = "race", w.ROOM_MAP_DATA = "room_map_data", w.ROOM_PLANE_MASK_XML = "room_plane_mask_xml", w.ROOM_FLOOR_TYPE = "room_floor_type", w.ROOM_WALL_TYPE = "room_wall_type", w.ROOM_LANDSCAPE_TYPE = "room_landscape_type", w.ROOM_WALL_THICKNESS = "room_wall_thickness", w.ROOM_FLOOR_THICKNESS = "room_floor_thickness", w.ROOM_FLOOR_HOLE_UPDATE_TIME = "room_floor_hole_update_time", w.ROOM_FLOOR_VISIBILITY = "room_floor_visibility", w.ROOM_WALL_VISIBILITY = "room_wall_visibility", w.ROOM_LANDSCAPE_VISIBILITY = "room_landscape_visibility", w.ROOM_DOOR_X = "room_door_x", w.ROOM_DOOR_Y = "room_door_y", w.ROOM_DOOR_Z = "room_door_z", w.ROOM_DOOR_DIR = "room_door_dir", w.ROOM_BACKGROUND_COLOR = "room_background_color", w.ROOM_COLORIZE_BG_ONLY = "room_colorize_bg_only", w.ROOM_RANDOM_SEED = "room_random_seed", w.ROOM_WORLD_TYPE = "room_world_type", w.ROOM_SELECTED_X = "room_selected_x", w.ROOM_SELECTED_Y = "room_selected_y", w.ROOM_SELECTED_Z = "room_selected_z", w.ROOM_SELECTED_PLANE = "room_selected_plane", w.IMAGE_QUERY_SCALE = "image_query_scale", w.FURNITURE_FRIENDFURNI_ENGRAVING = "furniture_friendfurni_engraving_type", w.SESSION_URL_PREFIX = "session_url_prefix", w.SESSION_CURRENT_USER_ID = "session_current_user_id";
let I = w;
const AI = class AI {
};
AI.UNIQUE_SET = 256;
let Ng = AI;
class En {
  constructor() {
    this._flags = 0, this._uniqueNumber = 0, this._uniqueSeries = 0;
  }
  parseWrapper(t) {
    (this._flags & Ng.UNIQUE_SET) > 0 && (this._uniqueNumber = t.readInt(), this._uniqueSeries = t.readInt());
  }
  initializeFromRoomObjectModel(t) {
    this._uniqueNumber = t.getValue(I.FURNITURE_UNIQUE_SERIAL_NUMBER), this._uniqueSeries = t.getValue(I.FURNITURE_UNIQUE_EDITION_SIZE);
  }
  writeRoomObjectModel(t) {
    t && (t.setValue(I.FURNITURE_UNIQUE_SERIAL_NUMBER, this._uniqueNumber), t.setValue(I.FURNITURE_UNIQUE_EDITION_SIZE, this._uniqueSeries));
  }
  getLegacyString() {
    return "";
  }
  compare(t) {
    return !1;
  }
  get state() {
    const t = parseInt(this.getLegacyString());
    return isNaN(t) ? 0 : t;
  }
  get isUnique() {
    return this._uniqueSeries > 0;
  }
  get uniqueNumber() {
    return this._uniqueNumber;
  }
  set uniqueNumber(t) {
    this._uniqueNumber = t;
  }
  get uniqueSeries() {
    return this._uniqueSeries;
  }
  set uniqueSeries(t) {
    this._uniqueSeries = t;
  }
  get rarityLevel() {
    return -1;
  }
  get flags() {
    return this._flags;
  }
  set flags(t) {
    this._flags = t;
  }
}
const Ri = class Ri {
};
Ri.LEGACY_KEY = 0, Ri.MAP_KEY = 1, Ri.STRING_KEY = 2, Ri.VOTE_KEY = 3, Ri.EMPTY_KEY = 4, Ri.NUMBER_KEY = 5, Ri.HIGHSCORE_KEY = 6, Ri.CRACKABLE_KEY = 7;
let Wi = Ri;
const $c = class $c extends En {
  constructor() {
    super(), this._state = "", this._hits = 0, this._target = 0;
  }
  parseWrapper(t) {
    t && (this._state = t.readString(), this._hits = t.readInt(), this._target = t.readInt(), super.parseWrapper(t));
  }
  initializeFromRoomObjectModel(t) {
    super.initializeFromRoomObjectModel(t), this._state = t.getValue(I.FURNITURE_CRACKABLE_STATE), this._hits = t.getValue(I.FURNITURE_CRACKABLE_HITS), this._target = t.getValue(I.FURNITURE_CRACKABLE_TARGET);
  }
  writeRoomObjectModel(t) {
    super.writeRoomObjectModel(t), t.setValue(I.FURNITURE_DATA_FORMAT, $c.FORMAT_KEY), t.setValue(I.FURNITURE_CRACKABLE_STATE, this._state), t.setValue(I.FURNITURE_CRACKABLE_HITS, this._hits), t.setValue(I.FURNITURE_CRACKABLE_TARGET, this._target);
  }
  getLegacyString() {
    return this._state;
  }
  compare(t) {
    return !0;
  }
  get hits() {
    return this._hits;
  }
  get target() {
    return this._target;
  }
};
$c.FORMAT_KEY = Wi.CRACKABLE_KEY;
let Xl = $c;
const Zc = class Zc extends En {
  parseWrapper(t) {
    t && (this._state = "", super.parseWrapper(t));
  }
  writeRoomObjectModel(t) {
    super.writeRoomObjectModel(t), t.setValue(I.FURNITURE_DATA_FORMAT, Zc.FORMAT_KEY);
  }
  getLegacyString() {
    return this._state;
  }
  compare(t) {
    return super.compare(t);
  }
};
Zc.FORMAT_KEY = Wi.EMPTY_KEY;
let Kl = Zc;
class aA {
  constructor() {
    this._score = -1, this._users = [];
  }
  get score() {
    return this._score;
  }
  set score(t) {
    this._score = t;
  }
  get users() {
    return this._users;
  }
  set users(t) {
    this._users = t;
  }
  addUsername(t) {
    this._users.push(t);
  }
}
const Qc = class Qc extends En {
  constructor() {
    super(), this._state = "", this._scoreType = -1, this._clearType = -1, this._entries = [];
  }
  parseWrapper(t) {
    if (!t) return;
    this._state = t.readString(), this._scoreType = t.readInt(), this._clearType = t.readInt();
    let e = t.readInt();
    for (; e > 0; ) {
      const s = new aA();
      s.score = t.readInt();
      let r = t.readInt();
      for (; r > 0; )
        s.addUsername(t.readString()), r--;
      this._entries.push(s), e--;
    }
    super.parseWrapper(t);
  }
  initializeFromRoomObjectModel(t) {
    this._scoreType = t.getValue(I.FURNITURE_HIGHSCORE_SCORE_TYPE), this._clearType = t.getValue(I.FURNITURE_HIGHSCORE_CLEAR_TYPE), this._entries = [];
    const e = t.getValue(I.FURNITURE_HIGHSCORE_DATA_ENTRY_COUNT);
    let s = 0;
    for (; s < e; ) {
      const r = new aA();
      r.score = t.getValue(I.FURNITURE_HIGHSCORE_DATA_ENTRY_BASE_SCORE_ + s), r.users = t.getValue(I.FURNITURE_HIGHSCORE_DATA_ENTRY_BASE_USERS_ + s), this._entries.push(r), s++;
    }
    super.initializeFromRoomObjectModel(t);
  }
  writeRoomObjectModel(t) {
    if (super.writeRoomObjectModel(t), t.setValue(I.FURNITURE_DATA_FORMAT, Qc.FORMAT_KEY), t.setValue(I.FURNITURE_HIGHSCORE_SCORE_TYPE, this._scoreType), t.setValue(I.FURNITURE_HIGHSCORE_CLEAR_TYPE, this._clearType), this._entries) {
      t.setValue(I.FURNITURE_HIGHSCORE_DATA_ENTRY_COUNT, this._entries.length);
      let e = 0;
      for (; e < this._entries.length; ) {
        const s = this._entries[e];
        t.setValue(I.FURNITURE_HIGHSCORE_DATA_ENTRY_BASE_SCORE_ + e, s.score), t.setValue(I.FURNITURE_HIGHSCORE_DATA_ENTRY_BASE_USERS_ + e, s.users), e++;
      }
    }
  }
  getLegacyString() {
    return this._state;
  }
  get entries() {
    return this._entries;
  }
  get clearType() {
    return this._clearType;
  }
  get scoreType() {
    return this._scoreType;
  }
};
Qc.FORMAT_KEY = Wi.HIGHSCORE_KEY;
let ql = Qc;
const Jc = class Jc extends En {
  constructor() {
    super(), this._data = "";
  }
  parseWrapper(t) {
    t && (this._data = t.readString(), super.parseWrapper(t));
  }
  initializeFromRoomObjectModel(t) {
    super.initializeFromRoomObjectModel(t), this._data = t.getValue(I.FURNITURE_DATA);
  }
  writeRoomObjectModel(t) {
    super.writeRoomObjectModel(t), t.setValue(I.FURNITURE_DATA_FORMAT, Jc.FORMAT_KEY), t.setValue(I.FURNITURE_DATA, this._data);
  }
  getLegacyString() {
    return this._data;
  }
  compare(t) {
    return this._data === t.getLegacyString();
  }
  setString(t) {
    this._data = t;
  }
};
Jc.FORMAT_KEY = Wi.LEGACY_KEY;
let ns = Jc;
const Dr = class Dr extends En {
  constructor() {
    super(), this._data = {};
  }
  parseWrapper(t) {
    if (!t) return;
    this._data = {};
    const e = t.readInt();
    if (e) for (let s = 0; s < e; s++) this._data[t.readString()] = t.readString();
    super.parseWrapper(t);
  }
  initializeFromRoomObjectModel(t) {
    super.initializeFromRoomObjectModel(t), this._data = t.getValue(I.FURNITURE_DATA) || {};
  }
  writeRoomObjectModel(t) {
    super.writeRoomObjectModel(t), t.setValue(I.FURNITURE_DATA_FORMAT, Dr.FORMAT_KEY), t.setValue(I.FURNITURE_DATA, this._data);
  }
  getLegacyString() {
    if (!this._data) return "";
    const t = this._data[Dr.STATE];
    return t ?? "";
  }
  compare(t) {
    return !1;
  }
  getValue(t) {
    return this._data[t];
  }
  get rarityLevel() {
    if (!this._data) return -1;
    const t = this._data[Dr.RARITY];
    return t == null ? -1 : parseInt(t);
  }
  // TODO: How to get the keys?
  get data() {
    return this._data;
  }
};
Dr.FORMAT_KEY = Wi.MAP_KEY, Dr.STATE = "state", Dr.RARITY = "rarity";
let pa = Dr;
const Bn = class Bn extends En {
  constructor() {
    super(), this._data = [];
  }
  parseWrapper(t) {
    if (!t) return;
    this._data = [];
    const e = t.readInt();
    if (e) for (let s = 0; s < e; s++) this._data.push(t.readInt());
    super.parseWrapper(t);
  }
  initializeFromRoomObjectModel(t) {
    super.initializeFromRoomObjectModel(t), this._data = t.getValue(I.FURNITURE_DATA);
  }
  writeRoomObjectModel(t) {
    super.writeRoomObjectModel(t), t.setValue(I.FURNITURE_DATA_FORMAT, Bn.FORMAT_KEY), t.setValue(I.FURNITURE_DATA, this._data);
  }
  getLegacyString() {
    return !this._data || !this._data.length ? "" : this._data[Bn.STATE].toString();
  }
  compare(t) {
    if (!(t instanceof Bn)) return !1;
    let e = 0;
    for (; e < this._data.length; ) {
      if (e !== 0) {
        if (this._data[e] !== t.getValue(e)) return !1;
      }
      e++;
    }
    return !0;
  }
  getValue(t) {
    if (!this._data || !this._data.length) return -1;
    const e = this._data[t];
    return e ?? -1;
  }
};
Bn.FORMAT_KEY = Wi.NUMBER_KEY, Bn.STATE = 0;
let Fo = Bn;
const kn = class kn extends En {
  constructor() {
    super(), this._data = [];
  }
  parseWrapper(t) {
    if (!t) return;
    this._data = [];
    const e = t.readInt();
    if (e) for (let s = 0; s < e; s++) this._data.push(t.readString());
    super.parseWrapper(t);
  }
  initializeFromRoomObjectModel(t) {
    super.initializeFromRoomObjectModel(t), this._data = t.getValue(I.FURNITURE_DATA);
  }
  writeRoomObjectModel(t) {
    super.writeRoomObjectModel(t), t.setValue(I.FURNITURE_DATA_FORMAT, kn.FORMAT_KEY), t.setValue(I.FURNITURE_DATA, this._data);
  }
  getLegacyString() {
    return !this._data || !this._data.length ? "" : this._data[kn.STATE];
  }
  compare(t) {
    if (!(t instanceof kn)) return !1;
    let e = 0;
    for (; e < this._data.length; ) {
      if (e !== 0) {
        if (this._data[e] !== t.getValue(e)) return !1;
      }
      e++;
    }
    return !0;
  }
  getValue(t) {
    return this._data[t] || "";
  }
  setValue(t) {
    this._data = t;
  }
};
kn.FORMAT_KEY = Wi.STRING_KEY, kn.STATE = 0;
let wo = kn;
const t_ = class t_ extends En {
  constructor() {
    super(), this._state = "", this._result = 0;
  }
  parseWrapper(t) {
    t && (this._state = t.readString(), this._result = t.readInt(), super.parseWrapper(t));
  }
  writeRoomObjectModel(t) {
    super.writeRoomObjectModel(t), t.setValue(I.FURNITURE_DATA_FORMAT, t_.FORMAT_KEY);
    const e = {};
    e.S = this._state, e.R = this._result.toString(), t.setValue(I.FURNITURE_DATA, e);
  }
  getLegacyString() {
    return this._state;
  }
  compare(t) {
    return !0;
  }
  setString(t) {
    this._state = t;
  }
  get result() {
    return this._result;
  }
};
t_.FORMAT_KEY = Wi.VOTE_KEY;
let mu = t_;
class tn {
  static getData(t) {
    let e = null;
    switch (t & 255) {
      case Xl.FORMAT_KEY:
        e = new Xl();
        break;
      case Kl.FORMAT_KEY:
        e = new Kl();
        break;
      case ql.FORMAT_KEY:
        e = new ql();
        break;
      case ns.FORMAT_KEY:
        e = new ns();
        break;
      case pa.FORMAT_KEY:
        e = new pa();
        break;
      case Fo.FORMAT_KEY:
        e = new Fo();
        break;
      case wo.FORMAT_KEY:
        e = new wo();
        break;
      case mu.FORMAT_KEY:
        e = new mu();
        break;
    }
    return e ? (e.flags = t & 65280, e) : null;
  }
}
const Lr = class Lr {
};
Lr.MINIMUM = -2, Lr.ROOM = 0, Lr.FLOOR = 10, Lr.WALL = 20, Lr.UNIT = 100, Lr.CURSOR = 200;
let L = Lr;
const Z = class Z {
};
Z.FURNITURE_BASIC = "furniture_basic", Z.FURNITURE_MULTISTATE = "furniture_multistate", Z.FURNITURE_MULTIHEIGHT = "furniture_multiheight", Z.FURNITURE_RANDOMSTATE = "furniture_randomstate", Z.FURNITURE_PLACEHOLDER = "furniture_placeholder", Z.FURNITURE_CREDIT = "furniture_credit", Z.FURNITURE_STICKIE = "furniture_stickie", Z.FURNITURE_PRESENT = "furniture_present", Z.FURNITURE_TROPHY = "furniture_trophy", Z.FURNITURE_ECOTRON_BOX = "furniture_ecotron_box", Z.FURNITURE_DICE = "furniture_dice", Z.FURNITURE_HOCKEY_SCORE = "furniture_hockey_score", Z.FURNITURE_HABBOWHEEL = "furniture_habbowheel", Z.FURNITURE_ONE_WAY_DOOR = "furniture_one_way_door", Z.FURNITURE_PLANET_SYSTEM = "furniture_planet_system", Z.FURNITURE_WINDOW = "furniture_window", Z.FURNITURE_EXTERNAL_IMAGE_WALLITEM = "furniture_external_image_wallitem", Z.FURNITURE_ROOMDIMMER = "furniture_roomdimmer", Z.FURNITURE_SOUND_MACHINE = "furniture_sound_machine", Z.FURNITURE_JUKEBOX = "furniture_jukebox", Z.FURNITURE_CRACKABLE = "furniture_crackable", Z.FURNITURE_PUSHABLE = "furniture_pushable", Z.FURNITURE_CLOTHING_CHANGE = "furniture_clothing_change", Z.FURNITURE_COUNTER_CLOCK = "furniture_counter_clock", Z.FURNITURE_SCORE = "furniture_score", Z.FURNITURE_ES = "furniture_es", Z.FURNITURE_FIREWORKS = "furniture_fireworks", Z.FURNITURE_SONG_DISK = "furniture_song_disk", Z.FURNITURE_BB = "furniture_bb", Z.FURNITURE_BG = "furniture_bg", Z.FURNITURE_WELCOME_GIFT = "furniture_welcome_gift", Z.FURNITURE_FLOOR_HOLE = "furniture_floor_hole", Z.FURNITURE_MANNEQUIN = "furniture_mannequin", Z.FURNITURE_GUILD_CUSTOMIZED = "furniture_guild_customized", Z.FURNITURE_GROUP_FORUM_TERMINAL = "furniture_group_forum_terminal", Z.FURNITURE_PET_CUSTOMIZATION = "furniture_pet_customization", Z.FURNITURE_CUCKOO_CLOCK = "furniture_cuckoo_clock", Z.FURNITURE_VOTE_COUNTER = "furniture_vote_counter", Z.FURNITURE_VOTE_MAJORITY = "furniture_vote_majority", Z.FURNITURE_SOUNDBLOCK = "furniture_soundblock", Z.FURNITURE_RANDOM_TELEPORT = "furniture_random_teleport", Z.FURNITURE_MONSTERPLANT_SEED = "furniture_monsterplant_seed", Z.FURNITURE_PURCHASABLE_CLOTHING = "furniture_purchasable_clothing", Z.FURNITURE_BACKGROUND_COLOR = "furniture_background_color", Z.FURNITURE_MYSTERYBOX = "furniture_mysterybox", Z.FURNITURE_EFFECTBOX = "furniture_effectbox", Z.FURNITURE_MYSTERYTROPHY = "furniture_mysterytrophy", Z.FURNITURE_ACHIEVEMENT_RESOLUTION = "furniture_achievement_resolution", Z.FURNITURE_LOVELOCK = "furniture_lovelock", Z.FURNITURE_WILDWEST_WANTED = "furniture_wildwest_wanted", Z.FURNITURE_HWEEN_LOVELOCK = "furniture_hween_lovelock", Z.FURNITURE_BADGE_DISPLAY = "furniture_badge_display", Z.FURNITURE_HIGH_SCORE = "furniture_high_score", Z.FURNITURE_INTERNAL_LINK = "furniture_internal_link", Z.FURNITURE_CUSTOM_STACK_HEIGHT = "furniture_custom_stack_height", Z.FURNITURE_YOUTUBE = "furniture_youtube", Z.FURNITURE_RENTABLE_SPACE = "furniture_rentable_space", Z.FURNITURE_CHANGE_STATE_WHEN_STEP_ON = "furniture_change_state_when_step_on", Z.FURNITURE_VIMEO = "furniture_vimeo", Z.FURNITURE_EDITABLE_INTERNAL_LINK = "furniture_editable_internal_link", Z.FURNITURE_EDITABLE_ROOM_LINK = "furniture_editable_room_link", Z.FURNITURE_CRAFTING_GIZMO = "furniture_crafting_gizmo", Z.FURNITURE_AREA_HIDE = "furniture_area_hide", Z.ROOM = "room", Z.USER = "user", Z.BOT = "bot", Z.RENTABLE_BOT = "rentable_bot", Z.PET = "pet", Z.TILE_CURSOR = "tile_cursor", Z.SELECTION_ARROW = "selection_arrow", Z.GAME_SNOWBALL = "game_snowball", Z.GAME_SNOWSPLASH = "game_snowsplash";
let tt = Z;
const os = class os {
};
os.OBJECT_UNDEFINED = "OBJECT_UNDEFINED", os.OBJECT_MOVE = "OBJECT_MOVE", os.OBJECT_PLACE = "OBJECT_PLACE", os.OBJECT_ROTATE_POSITIVE = "OBJECT_ROTATE_POSITIVE", os.OBJECT_ROTATE_NEGATIVE = "OBJECT_ROTATE_NEGATIVE", os.OBJECT_MOVE_TO = "OBJECT_MOVE_TO", os.OBJECT_PLACE_TO = "OBJECT_PLACE_TO", os.OBJECT_PICKUP = "OBJECT_PICKUP", os.OBJECT_PICKUP_BOT = "OBJECT_PICKUP_BOT", os.OBJECT_PICKUP_PET = "OBJECT_PICKUP_PET", os.OBJECT_EJECT = "OBJECT_EJECT", os.OBJECT_SAVE_STUFF_DATA = "OBJECT_SAVE_STUFF_DATA";
let yt = os;
const so = class so {
};
so.USER = 1, so.PET = 2, so.BOT = 3, so.RENTABLE_BOT = 4;
let pr = so;
const hs = class hs {
  static getTypeNumber(t) {
    return hs.AVATAR_TYPES[t];
  }
  static getTypeString(t) {
    for (const e in hs.AVATAR_TYPES)
      if (e && hs.AVATAR_TYPES[e] === t)
        return e;
    return null;
  }
  static getRealType(t) {
    switch (t) {
      case hs.BOT:
      case hs.RENTABLE_BOT:
        return hs.USER;
      default:
        return t;
    }
  }
};
hs.USER = "user", hs.PET = "pet", hs.BOT = "bot", hs.RENTABLE_BOT = "rentable_bot", hs.MONSTER_PLANT = "monsterplant", hs.AVATAR_TYPES = { user: 1, pet: 2, bot: 3, rentable_bot: 4 };
let Xt = hs;
const bt = class bt {
};
bt.FURNITURE_STATIC = "furniture_static", bt.FURNITURE_ANIMATED = "furniture_animated", bt.FURNITURE_RESETTING_ANIMATED = "furniture_resetting_animated", bt.FURNITURE_POSTER = "furniture_poster", bt.FURNITURE_EXTERNAL_IMAGE = "furniture_external_image", bt.FURNITURE_HABBOWHEEL = "furniture_habbowheel", bt.FURNITURE_VAL_RANDOMIZER = "furniture_val_randomizer", bt.FURNITURE_BOTTLE = "furniture_bottle", bt.FURNITURE_PLANET_SYSTEM = "furniture_planet_system", bt.FURNITURE_QUEUE_TILE = "furniture_queue_tile", bt.FURNITURE_PARTY_BEAMER = "furniture_party_beamer", bt.FURNITURE_CUBOID = "furniture_cuboid", bt.FURNITURE_GIFT_WRAPPED = "furniture_gift_wrapped", bt.FURNITURE_GIFT_WRAPPED_FIREWORKS = "furniture_gift_wrapped_fireworks", bt.FURNITURE_COUNTER_CLOCK = "furniture_counter_clock", bt.FURNITURE_WATER_AREA = "furniture_water_area", bt.FURNITURE_SCORE_BOARD = "furniture_score_board", bt.FURNITURE_FIREWORKS = "furniture_fireworks", bt.FURNITURE_BB = "furniture_bb", bt.FURNITURE_ISOMETRIC_BB = "furniture_isometric_bb", bt.FURNITURE_BG = "furniture_bg", bt.FURNITURE_STICKIE = "furniture_stickie", bt.FURNITURE_MANNEQUIN = "furniture_mannequin", bt.FURNITURE_GUILD_CUSTOMIZED = "furniture_guild_customized", bt.FURNITURE_GUILD_ISOMETRIC_BADGE = "furniture_guild_isometric_badge", bt.FURNITURE_VOTE_COUNTER = "furniture_vote_counter", bt.FURNITURE_VOTE_MAJORITY = "furniture_vote_majority", bt.FURNITURE_SOUNDBLOCK = "furniture_soundblock", bt.FURNITURE_BADGE_DISPLAY = "furniture_badge_display", bt.FURNITURE_YOUTUBE = "furniture_youtube", bt.FURNITURE_BUILDER_PLACEHOLDER = "furniture_builder_placeholder", bt.ROOM = "room", bt.USER = "user", bt.PET_ANIMATED = "pet_animated", bt.BOT = "bot", bt.RENTABLE_BOT = "rentable_bot", bt.TILE_CURSOR = "tile_cursor";
let j = bt;
const e_ = class e_ {
  constructor(t, e, s, r = null) {
    this._id = t, this._location = e, this._targetLocation = s, this._movementType = r;
  }
  get id() {
    return this._id;
  }
  get location() {
    return this._location;
  }
  get targetLocation() {
    return this._targetLocation;
  }
  get movementType() {
    return this._movementType;
  }
};
e_.MOVE = "mv", e_.SLIDE = "sld";
let fr = e_;
class oA {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this._webId = t.readInt(), this._name = t.readString(), this._level = t.readInt(), this._figure = t.readString(), this._owner = t.readString();
  }
  dispose() {
    this._webId = 0, this._name = "", this._level = 0, this._figure = "", this._owner = "";
  }
  get webId() {
    return this._webId;
  }
  get name() {
    return this._name;
  }
  get level() {
    return this._level;
  }
  get figure() {
    return this._figure;
  }
  get owner() {
    return this._owner;
  }
}
var en = /* @__PURE__ */ ((i) => (i.FLOOR = "S", i.WALL = "I", i.EFFECT = "E", i.BADGE = "B", i.ROBOT = "R", i.HABBO_CLUB = "H", i.PET = "P", i))(en || {});
class hA {
  constructor(t) {
    this._stuffId = t.readInt(), this._classId = t.readInt(), this._productCode = t.readString(), this._userId = t.readInt(), this._userName = t.readString(), this._rarityLevel = t.readInt(), this._hasMutation = t.readBoolean();
  }
  get stuffId() {
    return this._stuffId;
  }
  get classId() {
    return this._classId;
  }
  get productCode() {
    return this._productCode;
  }
  get userId() {
    return this._userId;
  }
  get userName() {
    return this._userName;
  }
  get rarityLevel() {
    return this._rarityLevel;
  }
  get hasMutation() {
    return this._hasMutation;
  }
}
class ey {
  constructor(t, e, s) {
    this._layerId = t, this._partId = e, this._paletteId = s;
  }
  get layerId() {
    return this._layerId;
  }
  set layerId(t) {
    this._layerId = t;
  }
  get partId() {
    return this._partId;
  }
  set partId(t) {
    this._partId = t;
  }
  get paletteId() {
    return this._paletteId;
  }
  set paletteId(t) {
    this._paletteId = t;
  }
}
class $l {
  constructor(t) {
    this._typeId = this.getTypeId(t), this._paletteId = this.getPaletteId(t), this._color = this.getColor(t), this._headOnly = this.getHeadOnly(t);
    const e = this.getCustomData(t);
    this._customLayerIds = this.getCustomLayerIds(e), this._customPartIds = this.getCustomPartIds(e), this._customPaletteIds = this.getCustomPaletteIds(e), this._customParts = [];
    let s = 0;
    for (; s < this._customLayerIds.length; )
      this._customParts.push(new ey(this._customLayerIds[s], this._customPartIds[s], this._customPaletteIds[s])), s++;
  }
  get typeId() {
    return this._typeId;
  }
  get paletteId() {
    return this._paletteId;
  }
  get color() {
    return this._color;
  }
  get customLayerIds() {
    return this._customLayerIds;
  }
  get customPartIds() {
    return this._customPartIds;
  }
  get customPaletteIds() {
    return this._customPaletteIds;
  }
  get customParts() {
    return this._customParts;
  }
  getCustomPart(t) {
    if (this._customParts) {
      for (const e of this._customParts)
        if (e.layerId === t) return e;
    }
    return null;
  }
  get hasCustomParts() {
    return this._customLayerIds != null && this._customLayerIds.length > 0;
  }
  get headOnly() {
    return this._headOnly;
  }
  get figureString() {
    let t = this.typeId + " " + this.paletteId + " " + this.color.toString(16);
    t = t + (" " + this.customParts.length);
    for (const e of this.customParts)
      t = t + (" " + e.layerId + " " + e.partId + " " + e.paletteId);
    return t;
  }
  getCustomData(t) {
    let e = [];
    if (t) {
      const s = t.split(" "), r = this._headOnly ? 1 : 0, n = 4 + r;
      if (s.length > n) {
        const a = 3 + r, o = parseInt(s[a]);
        e = s.slice(n, n + o * 3);
      }
    }
    return e;
  }
  getCustomLayerIds(t) {
    const e = [];
    let s = 0;
    for (; s < t.length; )
      e.push(parseInt(t[s + 0])), s = s + 3;
    return e;
  }
  getCustomPartIds(t) {
    const e = [];
    let s = 0;
    for (; s < t.length; )
      e.push(parseInt(t[s + 1])), s = s + 3;
    return e;
  }
  getCustomPaletteIds(t) {
    const e = [];
    let s = 0;
    for (; s < t.length; )
      e.push(parseInt(t[s + 2])), s = s + 3;
    return e;
  }
  getTypeId(t) {
    if (t) {
      const e = t.split(" ");
      if (e.length >= 1) return parseInt(e[0]);
    }
    return 0;
  }
  getPaletteId(t) {
    if (t) {
      const e = t.split(" ");
      if (e.length >= 2) return parseInt(e[1]);
    }
    return 0;
  }
  getColor(t) {
    if (t) {
      const e = t.split(" ");
      if (e.length >= 3) return parseInt(e[2], 16);
    }
    return 16777215;
  }
  getHeadOnly(t) {
    if (t) {
      const e = t.split(" ");
      if (e.length >= 4) return e[3] === "head";
    }
    return !1;
  }
}
class v1 {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this._chance = t.readInt(), this._breeds = [];
    let e = t.readInt();
    for (; e > 0; )
      this._breeds.push(t.readInt()), e--;
  }
  dispose() {
    this._chance = -1, this._breeds = [];
  }
  get chance() {
    return this._chance;
  }
  get breeds() {
    return this._breeds;
  }
}
const s_ = class s_ {
};
s_.KICKED_OUT_OF_ROOM = 4008, s_.STRIP_LOCKED_FOR_TRADING = -13001;
let Ug = s_;
const Dh = class Dh {
};
Dh.OLD_IDENTITY = 0, Dh.NEW_IDENTITY = 1, Dh.REAL_NOOB = 2;
let Rh = Dh;
const Dt = class Dt {
};
Dt.DOG = 0, Dt.CAT = 1, Dt.CROCODILE = 2, Dt.TERRIER = 3, Dt.BEAR = 4, Dt.PIG = 5, Dt.LION = 6, Dt.RHINO = 7, Dt.SPIDER = 8, Dt.TURTLE = 9, Dt.CHICKEN = 10, Dt.FROG = 11, Dt.DRAGON = 12, Dt.MONSTER = 13, Dt.MONKEY = 14, Dt.HORSE = 15, Dt.MONSTERPLANT = 16, Dt.BUNNY = 17, Dt.BUNNYEVIL = 18, Dt.BUNNYDEPRESSED = 19, Dt.BUNNYLOVE = 20, Dt.PIGEONGOOD = 21, Dt.PIGEONEVIL = 22, Dt.DEMONMONKEY = 23, Dt.BABYBEAR = 24, Dt.BABYTERRIER = 25, Dt.GNOME = 26, Dt.LEPRECHAUN = 27, Dt.KITTENBABY = 28, Dt.PUPPYBABY = 29, Dt.PIGLETNBABY = 30, Dt.HALOOMPA = 31, Dt.FOOLS = 32, Dt.PTEROSAUR = 33, Dt.VELOCIRAPTOR = 34;
let Eu = Dt;
const Fr = class Fr {
};
Fr.NONE = 0, Fr.GUEST = 1, Fr.GUILD_MEMBER = 2, Fr.GUILD_ADMIN = 3, Fr.ROOM_OWNER = 4, Fr.MODERATOR = 5;
let mr = Fr;
const wr = class wr {
  static getLocalizationKey(t) {
    switch (t) {
      case wr.FREE_TRADING:
        return "${trading.mode.free}";
      case wr.ROOM_CONTROLLER_REQUIRED:
        return "${trading.mode.controller}";
      case wr.NO_TRADING:
        return "${trading.mode.not.allowed}";
    }
    return "";
  }
};
wr.NO_TRADING = 0, wr.ROOM_CONTROLLER_REQUIRED = 1, wr.FREE_TRADING = 2;
let Dg = wr;
const Fs = class Fs {
};
Fs.SUPER_USER = 9, Fs.ADMINISTRATOR = 8, Fs.COMMUNITY = 7, Fs.PLAYER_SUPPORT = 6, Fs.MODERATOR = 5, Fs.EMPLOYEE = 4, Fs.BUS_PARTNER = 3, Fs.PARTNER = 2, Fs.CELEBRITY = 1, Fs.NONE = 0;
let Lg = Fs;
class C1 {
}
const Lh = class Lh {
};
Lh.MATCH_ALL_PIXELS = -1, Lh.MATCH_OPAQUE_PIXELS = 128, Lh.MATCH_NOTHING = 256;
let _i = Lh;
const io = class io {
};
io.DEFAULT = 1, io.ROOM_PLANE = 2, io.AVATAR = 3, io.AVATAR_OWN = 4;
let Us = io;
const ii = class ii {
};
ii.MOUSE_CLICK = "click", ii.DOUBLE_CLICK = "double_click", ii.MOUSE_MOVE = "mousemove", ii.MOUSE_DOWN = "mousedown", ii.MOUSE_DOWN_LONG = "mousedown_long", ii.MOUSE_UP = "mouseup", ii.ROLL_OVER = "mouseover", ii.ROLL_OUT = "mouseout", ii.RIGHT_CLICK = "contextmenu";
let J = ii;
const zn = class zn {
};
zn.TOUCH_START = "touchstart", zn.TOUCH_MOVE = "touchmove", zn.TOUCH_CANCEL = "touchcancel", zn.TOUCH_END = "touchend", zn.TOUCH_LONG = "touchlong";
let uA = zn;
const De = class De {
  constructor(t) {
    this._ordinal = t;
  }
  get ordinal() {
    return this._ordinal;
  }
  equals(t) {
    return t && t._ordinal == this._ordinal;
  }
};
De.NONE = new De(0), De.WAVE = new De(1), De.BLOW = new De(2), De.LAUGH = new De(3), De.CRY = new De(4), De.IDLE = new De(5), De.JUMP = new De(6), De.RESPECT = new De(7);
let lA = De;
const ri = class ri {
};
ri.DUMMY = "DUMMY", ri.FRIEND_FURNITURE = "FRIEND_FURNITURE", ri.MONSTERPLANT_SEED = "MONSTERPLANT_SEED", ri.MYSTERY_BOX = "MYSTERY_BOX", ri.EFFECT_BOX = "EFFECT_BOX", ri.MYSTERY_TROPHY = "MYSTERY_TROPHY", ri.RANDOM_TELEPORT = "RANDOM_TELEPORT", ri.PURCHASABLE_CLOTHING = "PURCHASABLE_CLOTHING", ri.GENERIC_USABLE = "GENERIC_USABLE";
let ji = ri;
const Vn = class Vn {
};
Vn.LOVE_LOCK = 0, Vn.CARVE_A_TREE = 1, Vn.FRIENDS_PORTRAIT = 2, Vn.WILD_WEST_WANTED = 3, Vn.HABBOWEEN = 4;
let cA = Vn;
const nt = class nt {
};
nt.CHAT_WIDGET = "RWE_CHAT_WIDGET", nt.INFOSTAND = "RWE_INFOSTAND", nt.ME_MENU = "RWE_ME_MENU", nt.CHAT_INPUT_WIDGET = "RWE_CHAT_INPUT_WIDGET", nt.FURNI_PLACEHOLDER = "RWE_FURNI_PLACEHOLDER", nt.FURNI_CREDIT_WIDGET = "RWE_FURNI_CREDIT_WIDGET", nt.FURNI_STICKIE_WIDGET = "RWE_FURNI_STICKIE_WIDGET", nt.FURNI_TROPHY_WIDGET = "RWE_FURNI_TROPHY_WIDGET", nt.FURNI_LOVELOCK_WIDGET = "RWE_FURNI_LOVELOCK_WIDGET", nt.FURNI_PRESENT_WIDGET = "RWE_FURNI_PRESENT_WIDGET", nt.FURNI_ECOTRONBOX_WIDGET = "RWE_FURNI_ECOTRONBOX_WIDGET", nt.FURNI_PET_PACKAGE_WIDGET = "RWE_FURNI_PET_PACKAGE_WIDGET", nt.PLAYLIST_EDITOR_WIDGET = "RWE_PLAYLIST_EDITOR_WIDGET", nt.DOORBELL = "RWE_DOORBELL", nt.LOADINGBAR = "RWE_LOADINGBAR", nt.ROOM_QUEUE = "RWE_ROOM_QUEUE", nt.ROOM_POLL = "RWE_ROOM_POLL", nt.ROOM_VOTE = "RWE_ROOM_VOTE", nt.USER_CHOOSER = "RWE_USER_CHOOSER", nt.FURNI_CHOOSER = "RWE_FURNI_CHOOSER", nt.ROOM_DIMMER = "RWE_ROOM_DIMMER", nt.FRIEND_REQUEST = "RWE_FRIEND_REQUEST", nt.CLOTHING_CHANGE = "RWE_CLOTHING_CHANGE", nt.CONVERSION_TRACKING = "RWE_CONVERSION_TRACKING", nt.USER_NOTIFICATION = "RWE_USER_NOTIFICATION", nt.FRIENDS_BAR = "RWE_FRIENDS_BAR", nt.PURSE_WIDGET = "RWE_PURSE_WIDGET", nt.AVATAR_INFO = "RWE_AVATAR_INFO", nt.WELCOME_GIFT = "RWE_WELCOME_GIFT", nt.SPAMWALL_POSTIT_WIDGET = "RWE_SPAMWALL_POSTIT_WIDGET", nt.EFFECTS = "RWE_EFFECTS", nt.MANNEQUIN = "RWE_MANNEQUIN", nt.FURNITURE_CONTEXT_MENU = "RWE_FURNITURE_CONTEXT_MENU", nt.LOCATION_WIDGET = "RWE_LOCATION_WIDGET", nt.CAMERA = "RWE_CAMERA", nt.ROOM_THUMBNAIL_CAMERA = "RWE_ROOM_THUMBNAIL_CAMERA", nt.ROOM_BACKGROUND_COLOR = "RWE_ROOM_BACKGROUND_COLOR", nt.CUSTOM_USER_NOTIFICATION = "RWE_CUSTOM_USER_NOTIFICATION", nt.FURNI_ACHIEVEMENT_RESOLUTION_ENGRAVING = "RWE_FURNI_ACHIEVEMENT_RESOLUTION_ENGRAVING", nt.FRIEND_FURNI_CONFIRM = "RWE_FRIEND_FURNI_CONFIRM", nt.FRIEND_FURNI_ENGRAVING = "RWE_FRIEND_FURNI_ENGRAVING", nt.HIGH_SCORE_DISPLAY = "RWE_HIGH_SCORE_DISPLAY", nt.INTERNAL_LINK = "RWE_INTERNAL_LINK", nt.CUSTOM_STACK_HEIGHT = "RWE_CUSTOM_STACK_HEIGHT", nt.YOUTUBE = "RWE_YOUTUBE", nt.RENTABLESPACE = "RWE_RENTABLESPACE", nt.VIMEO = "RWE_VIMEO", nt.ROOM_TOOLS = "RWE_ROOM_TOOLS", nt.EXTERNAL_IMAGE = "RWE_EXTERNAL_IMAGE", nt.WORD_QUIZZ = "RWE_WORD_QUIZZ", nt.UI_HELP_BUBBLE = "RWE_UI_HELP_BUBBLE", nt.ROOM_LINK = "RWE_ROOM_LINK", nt.CRAFTING = "RWE_CRAFTING", nt.ROOMGAME_CHECKERS = "RWE_GAME_CHECKERS";
let Zl = nt;
const sr = class sr {
};
sr.INFOSTAND_EXTRA_PARAM = "RWEIEP_INFOSTAND_EXTRA_PARAM", sr.JUKEBOX = "RWEIEP_JUKEBOX", sr.USABLE_PRODUCT = "RWEIEP_USABLE_PRODUCT", sr.SONGDISK = "RWEIEP_SONGDISK", sr.CRACKABLE_FURNI = "RWEIEP_CRACKABLE_FURNI", sr.BRANDING_OPTIONS = "RWEIEP_BRANDING_OPTIONS", sr.USABLE = "RWEIEP_USABLE";
let Ss = sr;
const Fh = class Fh {
};
Fh.NOBODY = 0, Fh.CONTROLLER = 1, Fh.EVERYBODY = 2;
let _A = Fh;
const wh = class wh {
};
wh.NORMAL = 0, wh.GENERIC = 1, wh.BOT = 2;
let Ln = wh;
const Gr = class Gr {
};
Gr.CHANNELS_EQUAL = "CHANNELS_EQUAL", Gr.CHANNELS_UNIQUE = "CHANNELS_UNIQUE", Gr.CHANNELS_RED = "CHANNELS_RED", Gr.CHANNELS_GREEN = "CHANNELS_GREEN", Gr.CHANNELS_BLUE = "CHANNELS_BLUE", Gr.CHANNELS_DESATURATED = "CHANNELS_DESATURATED";
let Mr = Gr;
class be {
  constructor(t = null) {
    if (this._length = 0, this._dictionary = /* @__PURE__ */ new Map(), this._array = [], this._keys = [], t) for (const [e, s] of t.entries()) this.add(e, s);
  }
  get length() {
    return this._length;
  }
  get disposed() {
    return !this._dictionary;
  }
  dispose() {
    if (!this._dictionary) {
      for (const t of this._dictionary.keys()) this._dictionary.delete(t);
      this._dictionary = null;
    }
    this._length = 0, this._array = null, this._keys = null;
  }
  reset() {
    for (const t of this._dictionary.keys()) this._dictionary.delete(t);
    this._length = 0, this._array = [], this._keys = [];
  }
  unshift(t, e) {
    return this._dictionary.get(t) !== null ? !1 : (this._dictionary.set(t, e), this._array.unshift(e), this._keys.unshift(t), this._length++, !0);
  }
  add(t, e) {
    return this._dictionary.get(t) !== void 0 ? !1 : (this._dictionary.set(t, e), this._array[this._length] = e, this._keys[this._length] = t, this._length++, !0);
  }
  remove(t) {
    const e = this._dictionary.get(t);
    if (!e) return null;
    const s = this._array.indexOf(e);
    return s >= 0 && (this._array.splice(s, 1), this._keys.splice(s, 1), this._length--), this._dictionary.delete(t), e;
  }
  getWithIndex(t) {
    return t < 0 || t >= this._length ? null : this._array[t];
  }
  getKey(t) {
    return t < 0 || t >= this._length ? null : this._keys[t];
  }
  getKeys() {
    return this._keys.slice();
  }
  hasKey(t) {
    return this._keys.indexOf(t) > -1;
  }
  getValue(t) {
    return this._dictionary.get(t);
  }
  getValues() {
    return this._array.slice();
  }
  hasValue(t) {
    return this._array.indexOf(t) > -1;
  }
  indexOf(t) {
    return this._array.indexOf(t);
  }
  concatenate(t) {
    for (const e of t._keys) this.add(e, t.getValue(e));
  }
  clone() {
    const t = new be();
    return t.concatenate(this), t;
  }
}
const x1 = (i) => {
  let t = "";
  const e = new Uint8Array(i), s = e.byteLength;
  for (let r = 0; r < s; r++) t += String.fromCharCode(e[r]);
  return window.btoa(t);
};
class Gd {
  constructor(t) {
    this._position = 0, this._dataView = new DataView(t);
  }
  readBytes(t) {
    const e = new Gd(this._dataView.buffer.slice(this._position, this._position + t));
    return this._position += t, e;
  }
  readByte() {
    const t = this._dataView.getInt8(this._position);
    return this._position++, t;
  }
  readShort() {
    const t = this._dataView.getInt16(this._position);
    return this._position += 2, t;
  }
  readInt() {
    const t = this._dataView.getInt32(this._position);
    return this._position += 4, t;
  }
  readFloat() {
    const t = this._dataView.getFloat32(this._position);
    return this._position += 4, t;
  }
  readDouble() {
    const t = this._dataView.getFloat64(this._position);
    return this._position += 8, t;
  }
  remaining() {
    return this._dataView.byteLength - this._position;
  }
  toString(t) {
    return new TextDecoder().decode(this._dataView.buffer);
  }
  toArrayBuffer() {
    return this._dataView.buffer;
  }
}
class dA {
  constructor() {
    this._buffer = new Uint8Array(), this._position = 0;
  }
  writeByte(t) {
    const e = new Uint8Array(1);
    return e[0] = t, this.appendArray(e), this;
  }
  writeBytes(t) {
    const e = new Uint8Array(t);
    return this.appendArray(e), this;
  }
  writeShort(t) {
    const e = new Uint8Array(2);
    return e[0] = t >> 8, e[1] = t & 255, this.appendArray(e), this;
  }
  writeInt(t) {
    const e = new Uint8Array(4);
    return e[0] = t >> 24, e[1] = t >> 16, e[2] = t >> 8, e[3] = t & 255, this.appendArray(e), this;
  }
  writeString(t, e = !0) {
    const s = new TextEncoder().encode(t);
    return e ? (this.writeShort(s.length), this.appendArray(s)) : this.appendArray(s), this;
  }
  appendArray(t) {
    if (!t) return;
    const e = new Uint8Array(this.position + t.length > this._buffer.length ? this.position + t.length : this._buffer.length);
    e.set(this._buffer), e.set(t, this.position), this._buffer = e, this.position += t.length;
  }
  getBuffer() {
    return this._buffer.buffer;
  }
  get position() {
    return this._position;
  }
  set position(t) {
    this._position = t;
  }
  toString(t) {
    return new TextDecoder(t).decode(this._buffer);
  }
}
class v {
  constructor(t = 0, e = 0, s = 0) {
    this._x = t, this._y = e, this._z = s, this._length = NaN;
  }
  static sum(t, e) {
    return !t || !e ? null : new v(t.x + e.x, t.y + e.y, t.z + e.z);
  }
  static dif(t, e) {
    return !t || !e ? null : new v(t.x - e.x, t.y - e.y, t.z - e.z);
  }
  static product(t, e) {
    return t ? new v(t.x * e, t.y * e, t.z * e) : null;
  }
  static dotProduct(t, e) {
    return !t || !e ? 0 : t.x * e.x + t.y * e.y + t.z * e.z;
  }
  static crossProduct(t, e) {
    if (!t || !e) return null;
    const s = new v();
    return s.x = t.y * e.z - t.z * e.y, s.y = t.z * e.x - t.x * e.z, s.z = t.x * e.y - t.y * e.x, s;
  }
  static scalarProjection(t, e) {
    if (!t || !e) return -1;
    const s = e.length;
    return s > 0 ? (t.x * e.x + t.y * e.y + t.z * e.z) / s : -1;
  }
  static cosAngle(t, e) {
    if (!t || !e) return 0;
    const s = t.length * e.length;
    return s ? v.dotProduct(t, e) / s : 0;
  }
  static isEqual(t, e) {
    return !(!t || !e || t.x !== e.x || t.y !== e.y || t.z !== e.z);
  }
  assign(t) {
    t && (this._x = t.x, this._y = t.y, this._z = t.z, this._length = NaN);
  }
  add(t) {
    t && (this._x += t.x, this._y += t.y, this._z += t.z, this._length = NaN);
  }
  subtract(t) {
    t && (this._x -= t.x, this._y -= t.y, this._z -= t.z, this._length = NaN);
  }
  multiply(t) {
    this._x *= t, this._y *= t, this._z *= t, this._length = NaN;
  }
  divide(t) {
    t && (this._x /= t, this._y /= t, this._z /= t, this._length = NaN);
  }
  negate() {
    this._x = -this._x, this._y = -this._y, this._z = -this._z;
  }
  dotProduct(t) {
    return this._x * t.x + this._y * t.y + this._z * t.z;
  }
  crossProduct(t) {
    const e = new v();
    return e.x = this._y * t.z - this._z * t.y, e.y = this._z * t.x - this._x * t.z, e.z = this._x * t.y - this._y * t.x, e;
  }
  normalize() {
    const t = 1 / this.length;
    this._x = this._x * t, this._y = this._y * t, this._z = this._z * t;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t, this._length = NaN;
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t, this._length = NaN;
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t, this._length = NaN;
  }
  get length() {
    return isNaN(this._length) && (this._length = Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z)), this._length;
  }
  toString() {
    return `[Vector3d: ${this._x}, ${this._y}, ${this._z}]`;
  }
}
const Oi = class Oi {
  static hex2rgb(t, e = []) {
    return e[0] = (t >> 16 & 255) / 255, e[1] = (t >> 8 & 255) / 255, e[2] = (t & 255) / 255, e;
  }
  static hex2rgba(t, e = []) {
    return e[0] = (t >> 16 & 255) / 255, e[1] = (t >> 8 & 255) / 255, e[2] = (t & 255) / 255, e[3] = t & 255, e;
  }
  static rgb2hex(t) {
    return (t[0] * 255 << 16) + (t[1] * 255 << 8) + (t[2] * 255 | 0);
  }
  static rgba2hex(t) {
    return (t[0] * 255 << 16) + (t[1] * 255 << 8) + (t[2] * 255 | 0) + (t[3] | 0);
  }
  static rgbStringToHex(t) {
    const e = t.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
    return "#" + Oi.getHex(e[1]) + Oi.getHex(e[2]) + Oi.getHex(e[3]);
  }
  static getHex(t) {
    return isNaN(t) ? "00" : Oi.HEX_DIGITS[(t - t % 16) / 16] + Oi.HEX_DIGITS[t % 16];
  }
  static int2rgb(t) {
    t >>>= 0;
    const e = t & 255, s = (t & 65280) >>> 8;
    return "rgba(" + [(t & 16711680) >>> 16, s, e, 1].join(",") + ")";
  }
  static rgbToHSL(t) {
    const e = (t >> 16 & 255) / 255, s = (t >> 8 & 255) / 255, r = (t & 255) / 255, n = Math.max(e, s, r), a = Math.min(e, s, r), o = n - a;
    let h = 0, u = 0;
    const c = (n + a) / 2;
    if (o !== 0) {
      switch (u = c > 0.5 ? o / (2 - n - a) : o / (n + a), n) {
        case e:
          h = (s - r) / o + (s < r ? 6 : 0);
          break;
        case s:
          h = (r - e) / o + 2;
          break;
        case r:
          h = (e - s) / o + 4;
          break;
      }
      h *= 60;
    }
    const l = Math.round(h / 360 * 255), _ = Math.round(u * 255), d = Math.round(c * 255);
    return (l << 16) + (_ << 8) + d;
  }
  static hslToRGB(t) {
    const e = (t >> 16 & 255) / 255, s = (t >> 8 & 255) / 255, r = (t & 255) / 255;
    let n = 0, a = 0, o = 0;
    if (s > 0) {
      const l = r < 0.5 ? r * (1 + s) : r + s - r * s, _ = 2 * r - l;
      [n, a, o] = [e + 1 / 3, e, e - 1 / 3].map((f) => (f < 0 && (f += 1), f > 1 && (f -= 1), f * 6 < 1 ? _ + (l - _) * 6 * f : f * 2 < 1 ? l : f * 3 < 2 ? _ + (l - _) * (2 / 3 - f) * 6 : _));
    } else
      n = a = o = r;
    const h = Math.round(n * 255), u = Math.round(a * 255), c = Math.round(o * 255);
    return (h << 16) + (u << 8) + c;
  }
  static rgb2xyz(t) {
    let e = (t >> 16 & 255) / 255, s = (t >> 8 & 255) / 255, r = (t >> 0 & 255) / 255;
    return e > 0.04045 ? e = Math.pow((e + 0.055) / 1.055, 2.4) : e = e / 12.92, s > 0.04045 ? s = Math.pow((s + 0.055) / 1.055, 2.4) : s = s / 12.92, r > 0.04045 ? r = Math.pow((r + 0.055) / 1.055, 2.4) : r = r / 12.92, e = e * 100, s = s * 100, r = r * 100, new v(e * 0.4124 + s * 0.3576 + r * 0.1805, e * 0.2126 + s * 0.7152 + r * 0.0722, e * 0.0193 + s * 0.1192 + r * 0.9505);
  }
  static xyz2CieLab(t) {
    let e = t.x / 95.047, s = t.y / 100, r = t.z / 108.883;
    return e > 8856e-6 ? e = Math.pow(e, 1 / 3) : e = 7.787 * e + 16 / 116, s > 8856e-6 ? s = Math.pow(s, 1 / 3) : s = 7.787 * s + 16 / 116, r > 8856e-6 ? r = Math.pow(r, 1 / 3) : r = 7.787 * r + 16 / 116, new v(116 * s - 16, 500 * (e - s), 200 * (s - r));
  }
  static rgb2CieLab(t) {
    return Oi.xyz2CieLab(Oi.rgb2xyz(t));
  }
  static colorize(t, e) {
    if (e === 4294967295) return t;
    let s = e >> 16 & 255, r = e >> 8 & 255, n = e & 255;
    return s = (t >> 16 & 255) * s / 255, r = (t >> 8 & 255) * r / 255, n = (t & 255) * n / 255, (t && 4278190080) | s << 16 | r << 8 | n;
  }
};
Oi.HEX_DIGITS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
let Ql = Oi;
const i_ = class i_ {
  static isBuilderClubId(t) {
    return t >= i_.BUILDER_CLUB_FURNI_ID_BASE;
  }
};
i_.BUILDER_CLUB_FURNI_ID_BASE = 2147418112;
let Jl = i_;
const M1 = new R0(), Urt = () => M1;
let Ol = null;
const Drt = async (i) => {
  var t;
  return Ol = await T0(i), (t = Ol.events) == null || t.destroy(), Ol;
}, ma = () => Ol, Bd = new Qt();
Bd.interactive = !1;
Bd.interactiveChildren = !1;
Bd.eventMode = "none";
const Lrt = () => Bd, r_ = class r_ {
  constructor() {
    this._textures = {}, this._totalTextures = 0, this._runCount = 0;
  }
  getTotalTextures() {
    let t = 0;
    for (const e in this._textures)
      for (const s in this._textures[e])
        t += this._textures[e][s].length;
    return this._totalTextures = t, this._totalTextures;
  }
  getTexture(t, e) {
    if (this._textures[t] || (this._textures[t] = {}), this._textures[t][e] || (this._textures[t][e] = []), this._textures[t][e].length) {
      const s = this._textures[t][e].shift();
      if (s)
        return this._totalTextures--, s;
    }
    return le.createRenderTexture(t, e);
  }
  putTexture(t) {
    t && (this._textures[t.width] || (this._textures[t.width] = {}), this._textures[t.width][t.height] || (this._textures[t.width][t.height] = []), delete t.source.hitMap, this._textures[t.width][t.height].push(t), this._totalTextures++);
  }
  run() {
    if (this._runCount++, !!this._totalTextures)
      for (const t in this._textures)
        for (const e in this._textures[t]) {
          const s = this._textures[t][e];
          for (let r = s.length - 1; r >= 0; r--) {
            const n = s[r], a = n.source;
            a._touched > -1 && this._runCount - a._touched > r_.MAX_IDLE && (delete n.source.hitMap, a.destroyed || n.destroy(!0), this._textures[n.width][n.height].splice(r, 1), this._totalTextures--, rt.log(`[TexturePool] Texture disposed: ${n.width}x${n.height}`));
          }
        }
  }
  get textures() {
    return this._textures;
  }
};
r_.MAX_IDLE = 3600;
let Fg = r_;
const b1 = new Fg(), on = () => b1, VT = () => js.shared, P1 = () => VT().FPS, Nt = () => VT().lastTime, Hn = class Hn {
  static get available() {
    return this._isListeningForPostMessages || (this._isListeningForPostMessages = !0, window.addEventListener("message", (t) => {
      if (typeof t.data == "string" && t.data.startsWith(Hn.MESSAGE_KEY)) {
        const { method: e, params: s } = JSON.parse(
          t.data.substr(Hn.MESSAGE_KEY.length)
        ), r = window[e];
        if (!r) return;
        r(...s);
        return;
      }
    })), !0;
  }
  static call(t, ...e) {
    if (window.top !== window && window.top.postMessage(Hn.MESSAGE_KEY + JSON.stringify({
      method: t,
      params: e
    }), "*"), !("FlashExternalInterface" in window)) return;
    const s = window.FlashExternalInterface[t];
    return typeof s < "u" ? s(...e) : void 0;
  }
  static callGame(t, ...e) {
    if (window.top !== window && window.top.postMessage("Nitro_LegacyExternalGameInterface" + JSON.stringify({
      method: t,
      params: e
    }), "*"), !("FlashExternalGameInterface" in window)) return;
    const s = window.FlashExternalGameInterface[t];
    return typeof s < "u" ? s(...e) : void 0;
  }
  static addCallback(t, e) {
    window[t] = e;
  }
};
Hn.MESSAGE_KEY = "Nitro_LegacyExternalInterface", Hn._isListeningForPostMessages = !1;
let Ut = Hn;
const Yn = class Yn {
  static log(...t) {
    this.LOG_DEBUG && console.log(this.logPrefix(), ...t);
  }
  static warn(...t) {
    this.LOG_WARN && console.warn(this.logPrefix(), ...t);
  }
  static error(...t) {
    this.LOG_ERROR && console.error(this.logPrefix(), ...t);
  }
  static events(...t) {
    this.LOG_EVENTS && console.log(this.logPrefix(), ...t);
  }
  static packets(...t) {
    this.LOG_PACKETS && console.log(this.logPrefix(), ...t);
  }
  static logPrefix() {
    return "[Nitro]";
  }
};
Yn.LOG_DEBUG = !1, Yn.LOG_WARN = !1, Yn.LOG_ERROR = !1, Yn.LOG_EVENTS = !1, Yn.LOG_PACKETS = !1;
let rt = Yn;
const ro = class ro {
  static logEventLog(t) {
    try {
      Ut.available && Ut.call("logEventLog", t);
    } catch {
      rt.log("External interface not working, failed to log event log.");
    }
  }
  static openPage(t) {
    try {
      Ut.available ? Ut.call("openPage", t) : rt.log("External interface not available, openPage failed.");
    } catch {
      rt.log("Failed to open web page", t);
    }
  }
  static openWebPage(t) {
    window.open(t);
  }
  static sendHeartBeat() {
    try {
      Ut.available && Ut.call("heartBeat");
    } catch {
      rt.log("Failed to send heartbeat");
    }
  }
  static openWebPageAndMinimizeClient(t) {
    try {
      Ut.available && ro.openPage(t);
    } catch {
      rt.log("Failed to open web page", t);
    }
  }
  static closeWebPageAndRestoreClient() {
    try {
      Ut.available && Ut.call("closeWebPageAndRestoreClient");
    } catch {
      rt.log("Failed to close web page and restore client!");
    }
  }
  static openHabblet(t, e = null) {
    try {
      Ut.available && Ut.call("openHabblet", t, e);
    } catch {
      rt.log("Failed to open Habblet", t);
    }
  }
  static closeHabblet(t, e = null) {
    try {
      Ut.available && Ut.call("closeHabblet", t, e);
    } catch {
      rt.log("Failed to close Habblet", t);
    }
  }
  static send(t, e) {
    try {
      Ut.available && Ut.call("disconnect", t, e);
    } catch {
      rt.log("Failed to close send ");
    }
  }
  static showGame(t) {
    try {
      Ut.available && Ut.callGame("showGame", t);
    } catch (e) {
      rt.log("Failed to open game", e);
    }
  }
  static hideGame() {
    try {
      Ut.available && Ut.callGame("hideGame");
    } catch {
      rt.log("Failed to hide game");
    }
  }
  static open(t) {
    try {
      Ut.available ? Ut.call("openExternalLink", escape(t)) : rt.log("External interface not available. Could not request to open: " + t);
    } catch {
      rt.log("External interface not working. Could not request to open: " + t);
    }
  }
  static roomVisited(t) {
    try {
      Ut.available ? Ut.call("roomVisited", t) : rt.log("External interface not available. Could not store last room visit.");
    } catch {
      rt.log("External interface not working. Could not store last room visit.");
    }
  }
  static openMinimail(t) {
    try {
      Ut.available ? Ut.call("openMinimail", t) : rt.log("External interface not available. Could not open minimail.");
    } catch {
      rt.log("External interface not working. Could not open minimail.");
    }
  }
  static openNews() {
    try {
      Ut.available ? Ut.call("openNews") : rt.log("External interface not available. Could not open news.");
    } catch {
      rt.log("External interface not working. Could not open news.");
    }
  }
  static closeNews() {
    try {
      Ut.available ? Ut.call("closeNews") : rt.log("External interface not available. Could not close news.");
    } catch {
      rt.log("External interface not working. Could not close news.");
    }
  }
  static openAvatars() {
    try {
      Ut.available ? Ut.call("openAvatars") : rt.log("External interface not available. Could not open avatars.");
    } catch {
      rt.log("External interface not working. Could not open avatars.");
    }
  }
  static openRoomEnterAd() {
    try {
      Ut.available ? Ut.call("openRoomEnterAd") : rt.log("External interface not available. Could not open roomenterad.");
    } catch {
      rt.log("External interface not working. Could not open roomenterad.");
    }
  }
  static updateFigure(t) {
    try {
      Ut.available ? Ut.call("updateFigure", t) : rt.log("External interface not available. Could not update figure.");
    } catch {
      rt.log("External interface not working. Could not update figure.");
    }
  }
};
ro.ADVERTISEMENT = "advertisement", ro.OPENLINK = "openlink", ro.OPENROOM = "openroom";
let Tu = ro;
const N1 = (i) => i >>> 0, sy = (i) => {
  const t = N1(i);
  return t >= Math.pow(2, 31) ? t - Math.pow(2, 32) : t;
}, Iu = [], Frt = (i) => {
  Iu.indexOf(i) >= 0 || Iu.push(i);
}, wrt = (i) => {
  const t = Iu.indexOf(i);
  t !== -1 && Iu.splice(t, 1);
}, wg = (i) => {
  if (!(!i || i === ""))
    for (const t of Iu) {
      if (!t) continue;
      const e = t.eventUrlPrefix;
      e.length > 0 ? i.substr(0, e.length) === e && t.linkReceived(i) : t.linkReceived(i);
    }
}, Os = class Os {
  constructor(t = 0, e = 0, s = 0, r = 0, n = 0, a = 0, o = 0, h = 0, u = 0) {
    this._data = [t, e, s, r, n, a, o, h, u];
  }
  static getXRotationMatrix(t) {
    const e = t * Math.PI / 180, s = Math.cos(e), r = Math.sin(e);
    return new Os(1, 0, 0, 0, s, -r, 0, r, s);
  }
  static getYRotationMatrix(t) {
    const e = t * Math.PI / 180, s = Math.cos(e), r = Math.sin(e);
    return new Os(s, 0, r, 0, 1, 0, -r, 0, s);
  }
  static getZRotationMatrix(t) {
    const e = t * Math.PI / 180, s = Math.cos(e), r = Math.sin(e);
    return new Os(s, -r, 0, r, s, 0, 0, 0, 1);
  }
  identity() {
    return this._data = [1, 0, 0, 0, 1, 0, 0, 0, 1], this;
  }
  vectorMultiplication(t) {
    const e = t.x * this._data[0] + t.y * this._data[3] + t.z * this._data[6], s = t.x * this._data[1] + t.y * this._data[4] + t.z * this._data[7], r = t.x * this._data[2] + t.y * this._data[5] + t.z * this._data[8];
    return new v(e, s, r);
  }
  multiply(t) {
    const e = this._data[0] * t.data[0] + this._data[1] * t.data[3] + this._data[2] * t.data[6], s = this._data[0] * t.data[1] + this._data[1] * t.data[4] + this._data[2] * t.data[7], r = this._data[0] * t.data[2] + this._data[1] * t.data[5] + this._data[2] * t.data[8], n = this._data[3] * t.data[0] + this._data[4] * t.data[3] + this._data[5] * t.data[6], a = this._data[3] * t.data[1] + this._data[4] * t.data[4] + this._data[5] * t.data[7], o = this._data[3] * t.data[2] + this._data[4] * t.data[5] + this._data[5] * t.data[8], h = this._data[6] * t.data[0] + this._data[7] * t.data[3] + this._data[8] * t.data[6], u = this._data[6] * t.data[1] + this._data[7] * t.data[4] + this._data[8] * t.data[7], c = this._data[6] * t.data[2] + this._data[7] * t.data[5] + this._data[8] * t.data[8];
    return new Os(e, s, r, n, a, o, h, u, c);
  }
  scalarMultiply(t) {
    let e = 0;
    for (; e < this._data.length; )
      this._data[e] = this._data[e] * t, e++;
  }
  rotateX(t) {
    const e = t * Math.PI / 180, s = Math.cos(e), r = Math.sin(e);
    return new Os(1, 0, 0, 0, s, -r, 0, r, s).multiply(this);
  }
  rotateY(t) {
    const e = t * Math.PI / 180, s = Math.cos(e), r = Math.sin(e);
    return new Os(s, 0, r, 0, 1, 0, -r, 0, s).multiply(this);
  }
  rotateZ(t) {
    const e = t * Math.PI / 180, s = Math.cos(e), r = Math.sin(e);
    return new Os(s, -r, 0, r, s, 0, 0, 0, 1).multiply(this);
  }
  skew() {
  }
  transpose() {
    return new Os(this._data[0], this._data[3], this._data[6], this._data[1], this._data[4], this._data[7], this._data[2], this._data[5], this._data[8]);
  }
  equals(t) {
    return !1;
  }
  get data() {
    return this._data;
  }
};
Os.IDENTITY = new Os(1, 0, 0, 0, 1, 0, 0, 0, 1), Os.TOLERANS = 1e-18;
let Oh = Os;
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const U1 = 4, fA = 0, gA = 1, D1 = 2;
function Jo(i) {
  let t = i.length;
  for (; --t >= 0; )
    i[t] = 0;
}
const L1 = 0, iy = 1, F1 = 2, w1 = 3, G1 = 258, HT = 29, zu = 256, Su = zu + 1 + HT, bo = 30, YT = 19, ry = 2 * Su + 1, na = 15, Uf = 16, B1 = 7, WT = 256, ny = 16, ay = 17, oy = 18, Gg = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
), yl = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
), k1 = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
), hy = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), z1 = 512, _r = new Array((Su + 2) * 2);
Jo(_r);
const yh = new Array(bo * 2);
Jo(yh);
const Au = new Array(z1);
Jo(Au);
const Ru = new Array(G1 - w1 + 1);
Jo(Ru);
const jT = new Array(HT);
Jo(jT);
const tc = new Array(bo);
Jo(tc);
function Df(i, t, e, s, r) {
  this.static_tree = i, this.extra_bits = t, this.extra_base = e, this.elems = s, this.max_length = r, this.has_stree = i && i.length;
}
let uy, ly, cy;
function Lf(i, t) {
  this.dyn_tree = i, this.max_code = 0, this.stat_desc = t;
}
const _y = (i) => i < 256 ? Au[i] : Au[256 + (i >>> 7)], Ou = (i, t) => {
  i.pending_buf[i.pending++] = t & 255, i.pending_buf[i.pending++] = t >>> 8 & 255;
}, ms = (i, t, e) => {
  i.bi_valid > Uf - e ? (i.bi_buf |= t << i.bi_valid & 65535, Ou(i, i.bi_buf), i.bi_buf = t >> Uf - i.bi_valid, i.bi_valid += e - Uf) : (i.bi_buf |= t << i.bi_valid & 65535, i.bi_valid += e);
}, ki = (i, t, e) => {
  ms(
    i,
    e[t * 2],
    e[t * 2 + 1]
    /*.Len*/
  );
}, dy = (i, t) => {
  let e = 0;
  do
    e |= i & 1, i >>>= 1, e <<= 1;
  while (--t > 0);
  return e >>> 1;
}, V1 = (i) => {
  i.bi_valid === 16 ? (Ou(i, i.bi_buf), i.bi_buf = 0, i.bi_valid = 0) : i.bi_valid >= 8 && (i.pending_buf[i.pending++] = i.bi_buf & 255, i.bi_buf >>= 8, i.bi_valid -= 8);
}, H1 = (i, t) => {
  const e = t.dyn_tree, s = t.max_code, r = t.stat_desc.static_tree, n = t.stat_desc.has_stree, a = t.stat_desc.extra_bits, o = t.stat_desc.extra_base, h = t.stat_desc.max_length;
  let u, c, l, _, d, f, p = 0;
  for (_ = 0; _ <= na; _++)
    i.bl_count[_] = 0;
  for (e[i.heap[i.heap_max] * 2 + 1] = 0, u = i.heap_max + 1; u < ry; u++)
    c = i.heap[u], _ = e[e[c * 2 + 1] * 2 + 1] + 1, _ > h && (_ = h, p++), e[c * 2 + 1] = _, !(c > s) && (i.bl_count[_]++, d = 0, c >= o && (d = a[c - o]), f = e[c * 2], i.opt_len += f * (_ + d), n && (i.static_len += f * (r[c * 2 + 1] + d)));
  if (p !== 0) {
    do {
      for (_ = h - 1; i.bl_count[_] === 0; )
        _--;
      i.bl_count[_]--, i.bl_count[_ + 1] += 2, i.bl_count[h]--, p -= 2;
    } while (p > 0);
    for (_ = h; _ !== 0; _--)
      for (c = i.bl_count[_]; c !== 0; )
        l = i.heap[--u], !(l > s) && (e[l * 2 + 1] !== _ && (i.opt_len += (_ - e[l * 2 + 1]) * e[l * 2], e[l * 2 + 1] = _), c--);
  }
}, fy = (i, t, e) => {
  const s = new Array(na + 1);
  let r = 0, n, a;
  for (n = 1; n <= na; n++)
    r = r + e[n - 1] << 1, s[n] = r;
  for (a = 0; a <= t; a++) {
    let o = i[a * 2 + 1];
    o !== 0 && (i[a * 2] = dy(s[o]++, o));
  }
}, Y1 = () => {
  let i, t, e, s, r;
  const n = new Array(na + 1);
  for (e = 0, s = 0; s < HT - 1; s++)
    for (jT[s] = e, i = 0; i < 1 << Gg[s]; i++)
      Ru[e++] = s;
  for (Ru[e - 1] = s, r = 0, s = 0; s < 16; s++)
    for (tc[s] = r, i = 0; i < 1 << yl[s]; i++)
      Au[r++] = s;
  for (r >>= 7; s < bo; s++)
    for (tc[s] = r << 7, i = 0; i < 1 << yl[s] - 7; i++)
      Au[256 + r++] = s;
  for (t = 0; t <= na; t++)
    n[t] = 0;
  for (i = 0; i <= 143; )
    _r[i * 2 + 1] = 8, i++, n[8]++;
  for (; i <= 255; )
    _r[i * 2 + 1] = 9, i++, n[9]++;
  for (; i <= 279; )
    _r[i * 2 + 1] = 7, i++, n[7]++;
  for (; i <= 287; )
    _r[i * 2 + 1] = 8, i++, n[8]++;
  for (fy(_r, Su + 1, n), i = 0; i < bo; i++)
    yh[i * 2 + 1] = 5, yh[i * 2] = dy(i, 5);
  uy = new Df(_r, Gg, zu + 1, Su, na), ly = new Df(yh, yl, 0, bo, na), cy = new Df(new Array(0), k1, 0, YT, B1);
}, gy = (i) => {
  let t;
  for (t = 0; t < Su; t++)
    i.dyn_ltree[t * 2] = 0;
  for (t = 0; t < bo; t++)
    i.dyn_dtree[t * 2] = 0;
  for (t = 0; t < YT; t++)
    i.bl_tree[t * 2] = 0;
  i.dyn_ltree[WT * 2] = 1, i.opt_len = i.static_len = 0, i.sym_next = i.matches = 0;
}, py = (i) => {
  i.bi_valid > 8 ? Ou(i, i.bi_buf) : i.bi_valid > 0 && (i.pending_buf[i.pending++] = i.bi_buf), i.bi_buf = 0, i.bi_valid = 0;
}, pA = (i, t, e, s) => {
  const r = t * 2, n = e * 2;
  return i[r] < i[n] || i[r] === i[n] && s[t] <= s[e];
}, Ff = (i, t, e) => {
  const s = i.heap[e];
  let r = e << 1;
  for (; r <= i.heap_len && (r < i.heap_len && pA(t, i.heap[r + 1], i.heap[r], i.depth) && r++, !pA(t, s, i.heap[r], i.depth)); )
    i.heap[e] = i.heap[r], e = r, r <<= 1;
  i.heap[e] = s;
}, mA = (i, t, e) => {
  let s, r, n = 0, a, o;
  if (i.sym_next !== 0)
    do
      s = i.pending_buf[i.sym_buf + n++] & 255, s += (i.pending_buf[i.sym_buf + n++] & 255) << 8, r = i.pending_buf[i.sym_buf + n++], s === 0 ? ki(i, r, t) : (a = Ru[r], ki(i, a + zu + 1, t), o = Gg[a], o !== 0 && (r -= jT[a], ms(i, r, o)), s--, a = _y(s), ki(i, a, e), o = yl[a], o !== 0 && (s -= tc[a], ms(i, s, o)));
    while (n < i.sym_next);
  ki(i, WT, t);
}, Bg = (i, t) => {
  const e = t.dyn_tree, s = t.stat_desc.static_tree, r = t.stat_desc.has_stree, n = t.stat_desc.elems;
  let a, o, h = -1, u;
  for (i.heap_len = 0, i.heap_max = ry, a = 0; a < n; a++)
    e[a * 2] !== 0 ? (i.heap[++i.heap_len] = h = a, i.depth[a] = 0) : e[a * 2 + 1] = 0;
  for (; i.heap_len < 2; )
    u = i.heap[++i.heap_len] = h < 2 ? ++h : 0, e[u * 2] = 1, i.depth[u] = 0, i.opt_len--, r && (i.static_len -= s[u * 2 + 1]);
  for (t.max_code = h, a = i.heap_len >> 1; a >= 1; a--)
    Ff(i, e, a);
  u = n;
  do
    a = i.heap[
      1
      /*SMALLEST*/
    ], i.heap[
      1
      /*SMALLEST*/
    ] = i.heap[i.heap_len--], Ff(
      i,
      e,
      1
      /*SMALLEST*/
    ), o = i.heap[
      1
      /*SMALLEST*/
    ], i.heap[--i.heap_max] = a, i.heap[--i.heap_max] = o, e[u * 2] = e[a * 2] + e[o * 2], i.depth[u] = (i.depth[a] >= i.depth[o] ? i.depth[a] : i.depth[o]) + 1, e[a * 2 + 1] = e[o * 2 + 1] = u, i.heap[
      1
      /*SMALLEST*/
    ] = u++, Ff(
      i,
      e,
      1
      /*SMALLEST*/
    );
  while (i.heap_len >= 2);
  i.heap[--i.heap_max] = i.heap[
    1
    /*SMALLEST*/
  ], H1(i, t), fy(e, h, i.bl_count);
}, EA = (i, t, e) => {
  let s, r = -1, n, a = t[0 * 2 + 1], o = 0, h = 7, u = 4;
  for (a === 0 && (h = 138, u = 3), t[(e + 1) * 2 + 1] = 65535, s = 0; s <= e; s++)
    n = a, a = t[(s + 1) * 2 + 1], !(++o < h && n === a) && (o < u ? i.bl_tree[n * 2] += o : n !== 0 ? (n !== r && i.bl_tree[n * 2]++, i.bl_tree[ny * 2]++) : o <= 10 ? i.bl_tree[ay * 2]++ : i.bl_tree[oy * 2]++, o = 0, r = n, a === 0 ? (h = 138, u = 3) : n === a ? (h = 6, u = 3) : (h = 7, u = 4));
}, TA = (i, t, e) => {
  let s, r = -1, n, a = t[0 * 2 + 1], o = 0, h = 7, u = 4;
  for (a === 0 && (h = 138, u = 3), s = 0; s <= e; s++)
    if (n = a, a = t[(s + 1) * 2 + 1], !(++o < h && n === a)) {
      if (o < u)
        do
          ki(i, n, i.bl_tree);
        while (--o !== 0);
      else n !== 0 ? (n !== r && (ki(i, n, i.bl_tree), o--), ki(i, ny, i.bl_tree), ms(i, o - 3, 2)) : o <= 10 ? (ki(i, ay, i.bl_tree), ms(i, o - 3, 3)) : (ki(i, oy, i.bl_tree), ms(i, o - 11, 7));
      o = 0, r = n, a === 0 ? (h = 138, u = 3) : n === a ? (h = 6, u = 3) : (h = 7, u = 4);
    }
}, W1 = (i) => {
  let t;
  for (EA(i, i.dyn_ltree, i.l_desc.max_code), EA(i, i.dyn_dtree, i.d_desc.max_code), Bg(i, i.bl_desc), t = YT - 1; t >= 3 && i.bl_tree[hy[t] * 2 + 1] === 0; t--)
    ;
  return i.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;
}, j1 = (i, t, e, s) => {
  let r;
  for (ms(i, t - 257, 5), ms(i, e - 1, 5), ms(i, s - 4, 4), r = 0; r < s; r++)
    ms(i, i.bl_tree[hy[r] * 2 + 1], 3);
  TA(i, i.dyn_ltree, t - 1), TA(i, i.dyn_dtree, e - 1);
}, X1 = (i) => {
  let t = 4093624447, e;
  for (e = 0; e <= 31; e++, t >>>= 1)
    if (t & 1 && i.dyn_ltree[e * 2] !== 0)
      return fA;
  if (i.dyn_ltree[9 * 2] !== 0 || i.dyn_ltree[10 * 2] !== 0 || i.dyn_ltree[13 * 2] !== 0)
    return gA;
  for (e = 32; e < zu; e++)
    if (i.dyn_ltree[e * 2] !== 0)
      return gA;
  return fA;
};
let IA = !1;
const K1 = (i) => {
  IA || (Y1(), IA = !0), i.l_desc = new Lf(i.dyn_ltree, uy), i.d_desc = new Lf(i.dyn_dtree, ly), i.bl_desc = new Lf(i.bl_tree, cy), i.bi_buf = 0, i.bi_valid = 0, gy(i);
}, my = (i, t, e, s) => {
  ms(i, (L1 << 1) + (s ? 1 : 0), 3), py(i), Ou(i, e), Ou(i, ~e), e && i.pending_buf.set(i.window.subarray(t, t + e), i.pending), i.pending += e;
}, q1 = (i) => {
  ms(i, iy << 1, 3), ki(i, WT, _r), V1(i);
}, $1 = (i, t, e, s) => {
  let r, n, a = 0;
  i.level > 0 ? (i.strm.data_type === D1 && (i.strm.data_type = X1(i)), Bg(i, i.l_desc), Bg(i, i.d_desc), a = W1(i), r = i.opt_len + 3 + 7 >>> 3, n = i.static_len + 3 + 7 >>> 3, n <= r && (r = n)) : r = n = e + 5, e + 4 <= r && t !== -1 ? my(i, t, e, s) : i.strategy === U1 || n === r ? (ms(i, (iy << 1) + (s ? 1 : 0), 3), mA(i, _r, yh)) : (ms(i, (F1 << 1) + (s ? 1 : 0), 3), j1(i, i.l_desc.max_code + 1, i.d_desc.max_code + 1, a + 1), mA(i, i.dyn_ltree, i.dyn_dtree)), gy(i), s && py(i);
}, Z1 = (i, t, e) => (i.pending_buf[i.sym_buf + i.sym_next++] = t, i.pending_buf[i.sym_buf + i.sym_next++] = t >> 8, i.pending_buf[i.sym_buf + i.sym_next++] = e, t === 0 ? i.dyn_ltree[e * 2]++ : (i.matches++, t--, i.dyn_ltree[(Ru[e] + zu + 1) * 2]++, i.dyn_dtree[_y(t) * 2]++), i.sym_next === i.sym_end);
var Q1 = K1, J1 = my, tL = $1, eL = Z1, sL = q1, iL = {
  _tr_init: Q1,
  _tr_stored_block: J1,
  _tr_flush_block: tL,
  _tr_tally: eL,
  _tr_align: sL
};
const rL = (i, t, e, s) => {
  let r = i & 65535 | 0, n = i >>> 16 & 65535 | 0, a = 0;
  for (; e !== 0; ) {
    a = e > 2e3 ? 2e3 : e, e -= a;
    do
      r = r + t[s++] | 0, n = n + r | 0;
    while (--a);
    r %= 65521, n %= 65521;
  }
  return r | n << 16 | 0;
};
var yu = rL;
const nL = () => {
  let i, t = [];
  for (var e = 0; e < 256; e++) {
    i = e;
    for (var s = 0; s < 8; s++)
      i = i & 1 ? 3988292384 ^ i >>> 1 : i >>> 1;
    t[e] = i;
  }
  return t;
}, aL = new Uint32Array(nL()), oL = (i, t, e, s) => {
  const r = aL, n = s + e;
  i ^= -1;
  for (let a = s; a < n; a++)
    i = i >>> 8 ^ r[(i ^ t[a]) & 255];
  return i ^ -1;
};
var Ge = oL, Go = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
}, Vu = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init: hL, _tr_stored_block: kg, _tr_flush_block: uL, _tr_tally: hn, _tr_align: lL } = iL, {
  Z_NO_FLUSH: un,
  Z_PARTIAL_FLUSH: cL,
  Z_FULL_FLUSH: _L,
  Z_FINISH: Xs,
  Z_BLOCK: SA,
  Z_OK: je,
  Z_STREAM_END: AA,
  Z_STREAM_ERROR: Vi,
  Z_DATA_ERROR: dL,
  Z_BUF_ERROR: wf,
  Z_DEFAULT_COMPRESSION: fL,
  Z_FILTERED: gL,
  Z_HUFFMAN_ONLY: cl,
  Z_RLE: pL,
  Z_FIXED: mL,
  Z_DEFAULT_STRATEGY: EL,
  Z_UNKNOWN: TL,
  Z_DEFLATED: kd
} = Vu, IL = 9, SL = 15, AL = 8, RL = 29, OL = 256, zg = OL + 1 + RL, yL = 30, vL = 19, CL = 2 * zg + 1, xL = 15, zt = 3, sn = 258, Hi = sn + zt + 1, ML = 32, Bo = 42, XT = 57, Vg = 69, Hg = 73, Yg = 91, Wg = 103, aa = 113, fh = 666, rs = 1, th = 2, Ea = 3, eh = 4, bL = 3, oa = (i, t) => (i.msg = Go[t], t), RA = (i) => i * 2 - (i > 4 ? 9 : 0), $r = (i) => {
  let t = i.length;
  for (; --t >= 0; )
    i[t] = 0;
}, PL = (i) => {
  let t, e, s, r = i.w_size;
  t = i.hash_size, s = t;
  do
    e = i.head[--s], i.head[s] = e >= r ? e - r : 0;
  while (--t);
  t = r, s = t;
  do
    e = i.prev[--s], i.prev[s] = e >= r ? e - r : 0;
  while (--t);
};
let NL = (i, t, e) => (t << i.hash_shift ^ e) & i.hash_mask, ln = NL;
const Ms = (i) => {
  const t = i.state;
  let e = t.pending;
  e > i.avail_out && (e = i.avail_out), e !== 0 && (i.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + e), i.next_out), i.next_out += e, t.pending_out += e, i.total_out += e, i.avail_out -= e, t.pending -= e, t.pending === 0 && (t.pending_out = 0));
}, Ds = (i, t) => {
  uL(i, i.block_start >= 0 ? i.block_start : -1, i.strstart - i.block_start, t), i.block_start = i.strstart, Ms(i.strm);
}, jt = (i, t) => {
  i.pending_buf[i.pending++] = t;
}, lh = (i, t) => {
  i.pending_buf[i.pending++] = t >>> 8 & 255, i.pending_buf[i.pending++] = t & 255;
}, jg = (i, t, e, s) => {
  let r = i.avail_in;
  return r > s && (r = s), r === 0 ? 0 : (i.avail_in -= r, t.set(i.input.subarray(i.next_in, i.next_in + r), e), i.state.wrap === 1 ? i.adler = yu(i.adler, t, r, e) : i.state.wrap === 2 && (i.adler = Ge(i.adler, t, r, e)), i.next_in += r, i.total_in += r, r);
}, Ey = (i, t) => {
  let e = i.max_chain_length, s = i.strstart, r, n, a = i.prev_length, o = i.nice_match;
  const h = i.strstart > i.w_size - Hi ? i.strstart - (i.w_size - Hi) : 0, u = i.window, c = i.w_mask, l = i.prev, _ = i.strstart + sn;
  let d = u[s + a - 1], f = u[s + a];
  i.prev_length >= i.good_match && (e >>= 2), o > i.lookahead && (o = i.lookahead);
  do
    if (r = t, !(u[r + a] !== f || u[r + a - 1] !== d || u[r] !== u[s] || u[++r] !== u[s + 1])) {
      s += 2, r++;
      do
        ;
      while (u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && s < _);
      if (n = sn - (_ - s), s = _ - sn, n > a) {
        if (i.match_start = t, a = n, n >= o)
          break;
        d = u[s + a - 1], f = u[s + a];
      }
    }
  while ((t = l[t & c]) > h && --e !== 0);
  return a <= i.lookahead ? a : i.lookahead;
}, ko = (i) => {
  const t = i.w_size;
  let e, s, r;
  do {
    if (s = i.window_size - i.lookahead - i.strstart, i.strstart >= t + (t - Hi) && (i.window.set(i.window.subarray(t, t + t - s), 0), i.match_start -= t, i.strstart -= t, i.block_start -= t, i.insert > i.strstart && (i.insert = i.strstart), PL(i), s += t), i.strm.avail_in === 0)
      break;
    if (e = jg(i.strm, i.window, i.strstart + i.lookahead, s), i.lookahead += e, i.lookahead + i.insert >= zt)
      for (r = i.strstart - i.insert, i.ins_h = i.window[r], i.ins_h = ln(i, i.ins_h, i.window[r + 1]); i.insert && (i.ins_h = ln(i, i.ins_h, i.window[r + zt - 1]), i.prev[r & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = r, r++, i.insert--, !(i.lookahead + i.insert < zt)); )
        ;
  } while (i.lookahead < Hi && i.strm.avail_in !== 0);
}, Ty = (i, t) => {
  let e = i.pending_buf_size - 5 > i.w_size ? i.w_size : i.pending_buf_size - 5, s, r, n, a = 0, o = i.strm.avail_in;
  do {
    if (s = 65535, n = i.bi_valid + 42 >> 3, i.strm.avail_out < n || (n = i.strm.avail_out - n, r = i.strstart - i.block_start, s > r + i.strm.avail_in && (s = r + i.strm.avail_in), s > n && (s = n), s < e && (s === 0 && t !== Xs || t === un || s !== r + i.strm.avail_in)))
      break;
    a = t === Xs && s === r + i.strm.avail_in ? 1 : 0, kg(i, 0, 0, a), i.pending_buf[i.pending - 4] = s, i.pending_buf[i.pending - 3] = s >> 8, i.pending_buf[i.pending - 2] = ~s, i.pending_buf[i.pending - 1] = ~s >> 8, Ms(i.strm), r && (r > s && (r = s), i.strm.output.set(i.window.subarray(i.block_start, i.block_start + r), i.strm.next_out), i.strm.next_out += r, i.strm.avail_out -= r, i.strm.total_out += r, i.block_start += r, s -= r), s && (jg(i.strm, i.strm.output, i.strm.next_out, s), i.strm.next_out += s, i.strm.avail_out -= s, i.strm.total_out += s);
  } while (a === 0);
  return o -= i.strm.avail_in, o && (o >= i.w_size ? (i.matches = 2, i.window.set(i.strm.input.subarray(i.strm.next_in - i.w_size, i.strm.next_in), 0), i.strstart = i.w_size, i.insert = i.strstart) : (i.window_size - i.strstart <= o && (i.strstart -= i.w_size, i.window.set(i.window.subarray(i.w_size, i.w_size + i.strstart), 0), i.matches < 2 && i.matches++, i.insert > i.strstart && (i.insert = i.strstart)), i.window.set(i.strm.input.subarray(i.strm.next_in - o, i.strm.next_in), i.strstart), i.strstart += o, i.insert += o > i.w_size - i.insert ? i.w_size - i.insert : o), i.block_start = i.strstart), i.high_water < i.strstart && (i.high_water = i.strstart), a ? eh : t !== un && t !== Xs && i.strm.avail_in === 0 && i.strstart === i.block_start ? th : (n = i.window_size - i.strstart, i.strm.avail_in > n && i.block_start >= i.w_size && (i.block_start -= i.w_size, i.strstart -= i.w_size, i.window.set(i.window.subarray(i.w_size, i.w_size + i.strstart), 0), i.matches < 2 && i.matches++, n += i.w_size, i.insert > i.strstart && (i.insert = i.strstart)), n > i.strm.avail_in && (n = i.strm.avail_in), n && (jg(i.strm, i.window, i.strstart, n), i.strstart += n, i.insert += n > i.w_size - i.insert ? i.w_size - i.insert : n), i.high_water < i.strstart && (i.high_water = i.strstart), n = i.bi_valid + 42 >> 3, n = i.pending_buf_size - n > 65535 ? 65535 : i.pending_buf_size - n, e = n > i.w_size ? i.w_size : n, r = i.strstart - i.block_start, (r >= e || (r || t === Xs) && t !== un && i.strm.avail_in === 0 && r <= n) && (s = r > n ? n : r, a = t === Xs && i.strm.avail_in === 0 && s === r ? 1 : 0, kg(i, i.block_start, s, a), i.block_start += s, Ms(i.strm)), a ? Ea : rs);
}, Gf = (i, t) => {
  let e, s;
  for (; ; ) {
    if (i.lookahead < Hi) {
      if (ko(i), i.lookahead < Hi && t === un)
        return rs;
      if (i.lookahead === 0)
        break;
    }
    if (e = 0, i.lookahead >= zt && (i.ins_h = ln(i, i.ins_h, i.window[i.strstart + zt - 1]), e = i.prev[i.strstart & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = i.strstart), e !== 0 && i.strstart - e <= i.w_size - Hi && (i.match_length = Ey(i, e)), i.match_length >= zt)
      if (s = hn(i, i.strstart - i.match_start, i.match_length - zt), i.lookahead -= i.match_length, i.match_length <= i.max_lazy_match && i.lookahead >= zt) {
        i.match_length--;
        do
          i.strstart++, i.ins_h = ln(i, i.ins_h, i.window[i.strstart + zt - 1]), e = i.prev[i.strstart & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = i.strstart;
        while (--i.match_length !== 0);
        i.strstart++;
      } else
        i.strstart += i.match_length, i.match_length = 0, i.ins_h = i.window[i.strstart], i.ins_h = ln(i, i.ins_h, i.window[i.strstart + 1]);
    else
      s = hn(i, 0, i.window[i.strstart]), i.lookahead--, i.strstart++;
    if (s && (Ds(i, !1), i.strm.avail_out === 0))
      return rs;
  }
  return i.insert = i.strstart < zt - 1 ? i.strstart : zt - 1, t === Xs ? (Ds(i, !0), i.strm.avail_out === 0 ? Ea : eh) : i.sym_next && (Ds(i, !1), i.strm.avail_out === 0) ? rs : th;
}, Na = (i, t) => {
  let e, s, r;
  for (; ; ) {
    if (i.lookahead < Hi) {
      if (ko(i), i.lookahead < Hi && t === un)
        return rs;
      if (i.lookahead === 0)
        break;
    }
    if (e = 0, i.lookahead >= zt && (i.ins_h = ln(i, i.ins_h, i.window[i.strstart + zt - 1]), e = i.prev[i.strstart & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = i.strstart), i.prev_length = i.match_length, i.prev_match = i.match_start, i.match_length = zt - 1, e !== 0 && i.prev_length < i.max_lazy_match && i.strstart - e <= i.w_size - Hi && (i.match_length = Ey(i, e), i.match_length <= 5 && (i.strategy === gL || i.match_length === zt && i.strstart - i.match_start > 4096) && (i.match_length = zt - 1)), i.prev_length >= zt && i.match_length <= i.prev_length) {
      r = i.strstart + i.lookahead - zt, s = hn(i, i.strstart - 1 - i.prev_match, i.prev_length - zt), i.lookahead -= i.prev_length - 1, i.prev_length -= 2;
      do
        ++i.strstart <= r && (i.ins_h = ln(i, i.ins_h, i.window[i.strstart + zt - 1]), e = i.prev[i.strstart & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = i.strstart);
      while (--i.prev_length !== 0);
      if (i.match_available = 0, i.match_length = zt - 1, i.strstart++, s && (Ds(i, !1), i.strm.avail_out === 0))
        return rs;
    } else if (i.match_available) {
      if (s = hn(i, 0, i.window[i.strstart - 1]), s && Ds(i, !1), i.strstart++, i.lookahead--, i.strm.avail_out === 0)
        return rs;
    } else
      i.match_available = 1, i.strstart++, i.lookahead--;
  }
  return i.match_available && (s = hn(i, 0, i.window[i.strstart - 1]), i.match_available = 0), i.insert = i.strstart < zt - 1 ? i.strstart : zt - 1, t === Xs ? (Ds(i, !0), i.strm.avail_out === 0 ? Ea : eh) : i.sym_next && (Ds(i, !1), i.strm.avail_out === 0) ? rs : th;
}, UL = (i, t) => {
  let e, s, r, n;
  const a = i.window;
  for (; ; ) {
    if (i.lookahead <= sn) {
      if (ko(i), i.lookahead <= sn && t === un)
        return rs;
      if (i.lookahead === 0)
        break;
    }
    if (i.match_length = 0, i.lookahead >= zt && i.strstart > 0 && (r = i.strstart - 1, s = a[r], s === a[++r] && s === a[++r] && s === a[++r])) {
      n = i.strstart + sn;
      do
        ;
      while (s === a[++r] && s === a[++r] && s === a[++r] && s === a[++r] && s === a[++r] && s === a[++r] && s === a[++r] && s === a[++r] && r < n);
      i.match_length = sn - (n - r), i.match_length > i.lookahead && (i.match_length = i.lookahead);
    }
    if (i.match_length >= zt ? (e = hn(i, 1, i.match_length - zt), i.lookahead -= i.match_length, i.strstart += i.match_length, i.match_length = 0) : (e = hn(i, 0, i.window[i.strstart]), i.lookahead--, i.strstart++), e && (Ds(i, !1), i.strm.avail_out === 0))
      return rs;
  }
  return i.insert = 0, t === Xs ? (Ds(i, !0), i.strm.avail_out === 0 ? Ea : eh) : i.sym_next && (Ds(i, !1), i.strm.avail_out === 0) ? rs : th;
}, DL = (i, t) => {
  let e;
  for (; ; ) {
    if (i.lookahead === 0 && (ko(i), i.lookahead === 0)) {
      if (t === un)
        return rs;
      break;
    }
    if (i.match_length = 0, e = hn(i, 0, i.window[i.strstart]), i.lookahead--, i.strstart++, e && (Ds(i, !1), i.strm.avail_out === 0))
      return rs;
  }
  return i.insert = 0, t === Xs ? (Ds(i, !0), i.strm.avail_out === 0 ? Ea : eh) : i.sym_next && (Ds(i, !1), i.strm.avail_out === 0) ? rs : th;
};
function mi(i, t, e, s, r) {
  this.good_length = i, this.max_lazy = t, this.nice_length = e, this.max_chain = s, this.func = r;
}
const gh = [
  /*      good lazy nice chain */
  new mi(0, 0, 0, 0, Ty),
  /* 0 store only */
  new mi(4, 4, 8, 4, Gf),
  /* 1 max speed, no lazy matches */
  new mi(4, 5, 16, 8, Gf),
  /* 2 */
  new mi(4, 6, 32, 32, Gf),
  /* 3 */
  new mi(4, 4, 16, 16, Na),
  /* 4 lazy matches */
  new mi(8, 16, 32, 32, Na),
  /* 5 */
  new mi(8, 16, 128, 128, Na),
  /* 6 */
  new mi(8, 32, 128, 256, Na),
  /* 7 */
  new mi(32, 128, 258, 1024, Na),
  /* 8 */
  new mi(32, 258, 258, 4096, Na)
  /* 9 max compression */
], LL = (i) => {
  i.window_size = 2 * i.w_size, $r(i.head), i.max_lazy_match = gh[i.level].max_lazy, i.good_match = gh[i.level].good_length, i.nice_match = gh[i.level].nice_length, i.max_chain_length = gh[i.level].max_chain, i.strstart = 0, i.block_start = 0, i.lookahead = 0, i.insert = 0, i.match_length = i.prev_length = zt - 1, i.match_available = 0, i.ins_h = 0;
};
function FL() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = kd, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(CL * 2), this.dyn_dtree = new Uint16Array((2 * yL + 1) * 2), this.bl_tree = new Uint16Array((2 * vL + 1) * 2), $r(this.dyn_ltree), $r(this.dyn_dtree), $r(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(xL + 1), this.heap = new Uint16Array(2 * zg + 1), $r(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * zg + 1), $r(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
const Hu = (i) => {
  if (!i)
    return 1;
  const t = i.state;
  return !t || t.strm !== i || t.status !== Bo && //#ifdef GZIP
  t.status !== XT && //#endif
  t.status !== Vg && t.status !== Hg && t.status !== Yg && t.status !== Wg && t.status !== aa && t.status !== fh ? 1 : 0;
}, Iy = (i) => {
  if (Hu(i))
    return oa(i, Vi);
  i.total_in = i.total_out = 0, i.data_type = TL;
  const t = i.state;
  return t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = //#ifdef GZIP
  t.wrap === 2 ? XT : (
    //#endif
    t.wrap ? Bo : aa
  ), i.adler = t.wrap === 2 ? 0 : 1, t.last_flush = -2, hL(t), je;
}, Sy = (i) => {
  const t = Iy(i);
  return t === je && LL(i.state), t;
}, wL = (i, t) => Hu(i) || i.state.wrap !== 2 ? Vi : (i.state.gzhead = t, je), Ay = (i, t, e, s, r, n) => {
  if (!i)
    return Vi;
  let a = 1;
  if (t === fL && (t = 6), s < 0 ? (a = 0, s = -s) : s > 15 && (a = 2, s -= 16), r < 1 || r > IL || e !== kd || s < 8 || s > 15 || t < 0 || t > 9 || n < 0 || n > mL || s === 8 && a !== 1)
    return oa(i, Vi);
  s === 8 && (s = 9);
  const o = new FL();
  return i.state = o, o.strm = i, o.status = Bo, o.wrap = a, o.gzhead = null, o.w_bits = s, o.w_size = 1 << o.w_bits, o.w_mask = o.w_size - 1, o.hash_bits = r + 7, o.hash_size = 1 << o.hash_bits, o.hash_mask = o.hash_size - 1, o.hash_shift = ~~((o.hash_bits + zt - 1) / zt), o.window = new Uint8Array(o.w_size * 2), o.head = new Uint16Array(o.hash_size), o.prev = new Uint16Array(o.w_size), o.lit_bufsize = 1 << r + 6, o.pending_buf_size = o.lit_bufsize * 4, o.pending_buf = new Uint8Array(o.pending_buf_size), o.sym_buf = o.lit_bufsize, o.sym_end = (o.lit_bufsize - 1) * 3, o.level = t, o.strategy = n, o.method = e, Sy(i);
}, GL = (i, t) => Ay(i, t, kd, SL, AL, EL), BL = (i, t) => {
  if (Hu(i) || t > SA || t < 0)
    return i ? oa(i, Vi) : Vi;
  const e = i.state;
  if (!i.output || i.avail_in !== 0 && !i.input || e.status === fh && t !== Xs)
    return oa(i, i.avail_out === 0 ? wf : Vi);
  const s = e.last_flush;
  if (e.last_flush = t, e.pending !== 0) {
    if (Ms(i), i.avail_out === 0)
      return e.last_flush = -1, je;
  } else if (i.avail_in === 0 && RA(t) <= RA(s) && t !== Xs)
    return oa(i, wf);
  if (e.status === fh && i.avail_in !== 0)
    return oa(i, wf);
  if (e.status === Bo && e.wrap === 0 && (e.status = aa), e.status === Bo) {
    let r = kd + (e.w_bits - 8 << 4) << 8, n = -1;
    if (e.strategy >= cl || e.level < 2 ? n = 0 : e.level < 6 ? n = 1 : e.level === 6 ? n = 2 : n = 3, r |= n << 6, e.strstart !== 0 && (r |= ML), r += 31 - r % 31, lh(e, r), e.strstart !== 0 && (lh(e, i.adler >>> 16), lh(e, i.adler & 65535)), i.adler = 1, e.status = aa, Ms(i), e.pending !== 0)
      return e.last_flush = -1, je;
  }
  if (e.status === XT) {
    if (i.adler = 0, jt(e, 31), jt(e, 139), jt(e, 8), e.gzhead)
      jt(
        e,
        (e.gzhead.text ? 1 : 0) + (e.gzhead.hcrc ? 2 : 0) + (e.gzhead.extra ? 4 : 0) + (e.gzhead.name ? 8 : 0) + (e.gzhead.comment ? 16 : 0)
      ), jt(e, e.gzhead.time & 255), jt(e, e.gzhead.time >> 8 & 255), jt(e, e.gzhead.time >> 16 & 255), jt(e, e.gzhead.time >> 24 & 255), jt(e, e.level === 9 ? 2 : e.strategy >= cl || e.level < 2 ? 4 : 0), jt(e, e.gzhead.os & 255), e.gzhead.extra && e.gzhead.extra.length && (jt(e, e.gzhead.extra.length & 255), jt(e, e.gzhead.extra.length >> 8 & 255)), e.gzhead.hcrc && (i.adler = Ge(i.adler, e.pending_buf, e.pending, 0)), e.gzindex = 0, e.status = Vg;
    else if (jt(e, 0), jt(e, 0), jt(e, 0), jt(e, 0), jt(e, 0), jt(e, e.level === 9 ? 2 : e.strategy >= cl || e.level < 2 ? 4 : 0), jt(e, bL), e.status = aa, Ms(i), e.pending !== 0)
      return e.last_flush = -1, je;
  }
  if (e.status === Vg) {
    if (e.gzhead.extra) {
      let r = e.pending, n = (e.gzhead.extra.length & 65535) - e.gzindex;
      for (; e.pending + n > e.pending_buf_size; ) {
        let o = e.pending_buf_size - e.pending;
        if (e.pending_buf.set(e.gzhead.extra.subarray(e.gzindex, e.gzindex + o), e.pending), e.pending = e.pending_buf_size, e.gzhead.hcrc && e.pending > r && (i.adler = Ge(i.adler, e.pending_buf, e.pending - r, r)), e.gzindex += o, Ms(i), e.pending !== 0)
          return e.last_flush = -1, je;
        r = 0, n -= o;
      }
      let a = new Uint8Array(e.gzhead.extra);
      e.pending_buf.set(a.subarray(e.gzindex, e.gzindex + n), e.pending), e.pending += n, e.gzhead.hcrc && e.pending > r && (i.adler = Ge(i.adler, e.pending_buf, e.pending - r, r)), e.gzindex = 0;
    }
    e.status = Hg;
  }
  if (e.status === Hg) {
    if (e.gzhead.name) {
      let r = e.pending, n;
      do {
        if (e.pending === e.pending_buf_size) {
          if (e.gzhead.hcrc && e.pending > r && (i.adler = Ge(i.adler, e.pending_buf, e.pending - r, r)), Ms(i), e.pending !== 0)
            return e.last_flush = -1, je;
          r = 0;
        }
        e.gzindex < e.gzhead.name.length ? n = e.gzhead.name.charCodeAt(e.gzindex++) & 255 : n = 0, jt(e, n);
      } while (n !== 0);
      e.gzhead.hcrc && e.pending > r && (i.adler = Ge(i.adler, e.pending_buf, e.pending - r, r)), e.gzindex = 0;
    }
    e.status = Yg;
  }
  if (e.status === Yg) {
    if (e.gzhead.comment) {
      let r = e.pending, n;
      do {
        if (e.pending === e.pending_buf_size) {
          if (e.gzhead.hcrc && e.pending > r && (i.adler = Ge(i.adler, e.pending_buf, e.pending - r, r)), Ms(i), e.pending !== 0)
            return e.last_flush = -1, je;
          r = 0;
        }
        e.gzindex < e.gzhead.comment.length ? n = e.gzhead.comment.charCodeAt(e.gzindex++) & 255 : n = 0, jt(e, n);
      } while (n !== 0);
      e.gzhead.hcrc && e.pending > r && (i.adler = Ge(i.adler, e.pending_buf, e.pending - r, r));
    }
    e.status = Wg;
  }
  if (e.status === Wg) {
    if (e.gzhead.hcrc) {
      if (e.pending + 2 > e.pending_buf_size && (Ms(i), e.pending !== 0))
        return e.last_flush = -1, je;
      jt(e, i.adler & 255), jt(e, i.adler >> 8 & 255), i.adler = 0;
    }
    if (e.status = aa, Ms(i), e.pending !== 0)
      return e.last_flush = -1, je;
  }
  if (i.avail_in !== 0 || e.lookahead !== 0 || t !== un && e.status !== fh) {
    let r = e.level === 0 ? Ty(e, t) : e.strategy === cl ? DL(e, t) : e.strategy === pL ? UL(e, t) : gh[e.level].func(e, t);
    if ((r === Ea || r === eh) && (e.status = fh), r === rs || r === Ea)
      return i.avail_out === 0 && (e.last_flush = -1), je;
    if (r === th && (t === cL ? lL(e) : t !== SA && (kg(e, 0, 0, !1), t === _L && ($r(e.head), e.lookahead === 0 && (e.strstart = 0, e.block_start = 0, e.insert = 0))), Ms(i), i.avail_out === 0))
      return e.last_flush = -1, je;
  }
  return t !== Xs ? je : e.wrap <= 0 ? AA : (e.wrap === 2 ? (jt(e, i.adler & 255), jt(e, i.adler >> 8 & 255), jt(e, i.adler >> 16 & 255), jt(e, i.adler >> 24 & 255), jt(e, i.total_in & 255), jt(e, i.total_in >> 8 & 255), jt(e, i.total_in >> 16 & 255), jt(e, i.total_in >> 24 & 255)) : (lh(e, i.adler >>> 16), lh(e, i.adler & 65535)), Ms(i), e.wrap > 0 && (e.wrap = -e.wrap), e.pending !== 0 ? je : AA);
}, kL = (i) => {
  if (Hu(i))
    return Vi;
  const t = i.state.status;
  return i.state = null, t === aa ? oa(i, dL) : je;
}, zL = (i, t) => {
  let e = t.length;
  if (Hu(i))
    return Vi;
  const s = i.state, r = s.wrap;
  if (r === 2 || r === 1 && s.status !== Bo || s.lookahead)
    return Vi;
  if (r === 1 && (i.adler = yu(i.adler, t, e, 0)), s.wrap = 0, e >= s.w_size) {
    r === 0 && ($r(s.head), s.strstart = 0, s.block_start = 0, s.insert = 0);
    let h = new Uint8Array(s.w_size);
    h.set(t.subarray(e - s.w_size, e), 0), t = h, e = s.w_size;
  }
  const n = i.avail_in, a = i.next_in, o = i.input;
  for (i.avail_in = e, i.next_in = 0, i.input = t, ko(s); s.lookahead >= zt; ) {
    let h = s.strstart, u = s.lookahead - (zt - 1);
    do
      s.ins_h = ln(s, s.ins_h, s.window[h + zt - 1]), s.prev[h & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = h, h++;
    while (--u);
    s.strstart = h, s.lookahead = zt - 1, ko(s);
  }
  return s.strstart += s.lookahead, s.block_start = s.strstart, s.insert = s.lookahead, s.lookahead = 0, s.match_length = s.prev_length = zt - 1, s.match_available = 0, i.next_in = a, i.input = o, i.avail_in = n, s.wrap = r, je;
};
var VL = GL, HL = Ay, YL = Sy, WL = Iy, jL = wL, XL = BL, KL = kL, qL = zL, $L = "pako deflate (from Nodeca project)", vh = {
  deflateInit: VL,
  deflateInit2: HL,
  deflateReset: YL,
  deflateResetKeep: WL,
  deflateSetHeader: jL,
  deflate: XL,
  deflateEnd: KL,
  deflateSetDictionary: qL,
  deflateInfo: $L
};
const ZL = (i, t) => Object.prototype.hasOwnProperty.call(i, t);
var QL = function(i) {
  const t = Array.prototype.slice.call(arguments, 1);
  for (; t.length; ) {
    const e = t.shift();
    if (e) {
      if (typeof e != "object")
        throw new TypeError(e + "must be non-object");
      for (const s in e)
        ZL(e, s) && (i[s] = e[s]);
    }
  }
  return i;
}, JL = (i) => {
  let t = 0;
  for (let s = 0, r = i.length; s < r; s++)
    t += i[s].length;
  const e = new Uint8Array(t);
  for (let s = 0, r = 0, n = i.length; s < n; s++) {
    let a = i[s];
    e.set(a, r), r += a.length;
  }
  return e;
}, zd = {
  assign: QL,
  flattenChunks: JL
};
let Ry = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch {
  Ry = !1;
}
const vu = new Uint8Array(256);
for (let i = 0; i < 256; i++)
  vu[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
vu[254] = vu[254] = 1;
var t2 = (i) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
    return new TextEncoder().encode(i);
  let t, e, s, r, n, a = i.length, o = 0;
  for (r = 0; r < a; r++)
    e = i.charCodeAt(r), (e & 64512) === 55296 && r + 1 < a && (s = i.charCodeAt(r + 1), (s & 64512) === 56320 && (e = 65536 + (e - 55296 << 10) + (s - 56320), r++)), o += e < 128 ? 1 : e < 2048 ? 2 : e < 65536 ? 3 : 4;
  for (t = new Uint8Array(o), n = 0, r = 0; n < o; r++)
    e = i.charCodeAt(r), (e & 64512) === 55296 && r + 1 < a && (s = i.charCodeAt(r + 1), (s & 64512) === 56320 && (e = 65536 + (e - 55296 << 10) + (s - 56320), r++)), e < 128 ? t[n++] = e : e < 2048 ? (t[n++] = 192 | e >>> 6, t[n++] = 128 | e & 63) : e < 65536 ? (t[n++] = 224 | e >>> 12, t[n++] = 128 | e >>> 6 & 63, t[n++] = 128 | e & 63) : (t[n++] = 240 | e >>> 18, t[n++] = 128 | e >>> 12 & 63, t[n++] = 128 | e >>> 6 & 63, t[n++] = 128 | e & 63);
  return t;
};
const e2 = (i, t) => {
  if (t < 65534 && i.subarray && Ry)
    return String.fromCharCode.apply(null, i.length === t ? i : i.subarray(0, t));
  let e = "";
  for (let s = 0; s < t; s++)
    e += String.fromCharCode(i[s]);
  return e;
};
var s2 = (i, t) => {
  const e = t || i.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
    return new TextDecoder().decode(i.subarray(0, t));
  let s, r;
  const n = new Array(e * 2);
  for (r = 0, s = 0; s < e; ) {
    let a = i[s++];
    if (a < 128) {
      n[r++] = a;
      continue;
    }
    let o = vu[a];
    if (o > 4) {
      n[r++] = 65533, s += o - 1;
      continue;
    }
    for (a &= o === 2 ? 31 : o === 3 ? 15 : 7; o > 1 && s < e; )
      a = a << 6 | i[s++] & 63, o--;
    if (o > 1) {
      n[r++] = 65533;
      continue;
    }
    a < 65536 ? n[r++] = a : (a -= 65536, n[r++] = 55296 | a >> 10 & 1023, n[r++] = 56320 | a & 1023);
  }
  return e2(n, r);
}, i2 = (i, t) => {
  t = t || i.length, t > i.length && (t = i.length);
  let e = t - 1;
  for (; e >= 0 && (i[e] & 192) === 128; )
    e--;
  return e < 0 || e === 0 ? t : e + vu[i[e]] > t ? e : t;
}, Cu = {
  string2buf: t2,
  buf2string: s2,
  utf8border: i2
};
function r2() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var Oy = r2;
const yy = Object.prototype.toString, {
  Z_NO_FLUSH: n2,
  Z_SYNC_FLUSH: a2,
  Z_FULL_FLUSH: o2,
  Z_FINISH: h2,
  Z_OK: ec,
  Z_STREAM_END: u2,
  Z_DEFAULT_COMPRESSION: l2,
  Z_DEFAULT_STRATEGY: c2,
  Z_DEFLATED: _2
} = Vu;
function KT(i) {
  this.options = zd.assign({
    level: l2,
    method: _2,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: c2
  }, i || {});
  let t = this.options;
  t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Oy(), this.strm.avail_out = 0;
  let e = vh.deflateInit2(
    this.strm,
    t.level,
    t.method,
    t.windowBits,
    t.memLevel,
    t.strategy
  );
  if (e !== ec)
    throw new Error(Go[e]);
  if (t.header && vh.deflateSetHeader(this.strm, t.header), t.dictionary) {
    let s;
    if (typeof t.dictionary == "string" ? s = Cu.string2buf(t.dictionary) : yy.call(t.dictionary) === "[object ArrayBuffer]" ? s = new Uint8Array(t.dictionary) : s = t.dictionary, e = vh.deflateSetDictionary(this.strm, s), e !== ec)
      throw new Error(Go[e]);
    this._dict_set = !0;
  }
}
KT.prototype.push = function(i, t) {
  const e = this.strm, s = this.options.chunkSize;
  let r, n;
  if (this.ended)
    return !1;
  for (t === ~~t ? n = t : n = t === !0 ? h2 : n2, typeof i == "string" ? e.input = Cu.string2buf(i) : yy.call(i) === "[object ArrayBuffer]" ? e.input = new Uint8Array(i) : e.input = i, e.next_in = 0, e.avail_in = e.input.length; ; ) {
    if (e.avail_out === 0 && (e.output = new Uint8Array(s), e.next_out = 0, e.avail_out = s), (n === a2 || n === o2) && e.avail_out <= 6) {
      this.onData(e.output.subarray(0, e.next_out)), e.avail_out = 0;
      continue;
    }
    if (r = vh.deflate(e, n), r === u2)
      return e.next_out > 0 && this.onData(e.output.subarray(0, e.next_out)), r = vh.deflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === ec;
    if (e.avail_out === 0) {
      this.onData(e.output);
      continue;
    }
    if (n > 0 && e.next_out > 0) {
      this.onData(e.output.subarray(0, e.next_out)), e.avail_out = 0;
      continue;
    }
    if (e.avail_in === 0) break;
  }
  return !0;
};
KT.prototype.onData = function(i) {
  this.chunks.push(i);
};
KT.prototype.onEnd = function(i) {
  i === ec && (this.result = zd.flattenChunks(this.chunks)), this.chunks = [], this.err = i, this.msg = this.strm.msg;
};
const _l = 16209, d2 = 16191;
var f2 = function(t, e) {
  let s, r, n, a, o, h, u, c, l, _, d, f, p, g, m, O, y, C, b, D, P, F, M, U;
  const k = t.state;
  s = t.next_in, M = t.input, r = s + (t.avail_in - 5), n = t.next_out, U = t.output, a = n - (e - t.avail_out), o = n + (t.avail_out - 257), h = k.dmax, u = k.wsize, c = k.whave, l = k.wnext, _ = k.window, d = k.hold, f = k.bits, p = k.lencode, g = k.distcode, m = (1 << k.lenbits) - 1, O = (1 << k.distbits) - 1;
  t:
    do {
      f < 15 && (d += M[s++] << f, f += 8, d += M[s++] << f, f += 8), y = p[d & m];
      e:
        for (; ; ) {
          if (C = y >>> 24, d >>>= C, f -= C, C = y >>> 16 & 255, C === 0)
            U[n++] = y & 65535;
          else if (C & 16) {
            b = y & 65535, C &= 15, C && (f < C && (d += M[s++] << f, f += 8), b += d & (1 << C) - 1, d >>>= C, f -= C), f < 15 && (d += M[s++] << f, f += 8, d += M[s++] << f, f += 8), y = g[d & O];
            s:
              for (; ; ) {
                if (C = y >>> 24, d >>>= C, f -= C, C = y >>> 16 & 255, C & 16) {
                  if (D = y & 65535, C &= 15, f < C && (d += M[s++] << f, f += 8, f < C && (d += M[s++] << f, f += 8)), D += d & (1 << C) - 1, D > h) {
                    t.msg = "invalid distance too far back", k.mode = _l;
                    break t;
                  }
                  if (d >>>= C, f -= C, C = n - a, D > C) {
                    if (C = D - C, C > c && k.sane) {
                      t.msg = "invalid distance too far back", k.mode = _l;
                      break t;
                    }
                    if (P = 0, F = _, l === 0) {
                      if (P += u - C, C < b) {
                        b -= C;
                        do
                          U[n++] = _[P++];
                        while (--C);
                        P = n - D, F = U;
                      }
                    } else if (l < C) {
                      if (P += u + l - C, C -= l, C < b) {
                        b -= C;
                        do
                          U[n++] = _[P++];
                        while (--C);
                        if (P = 0, l < b) {
                          C = l, b -= C;
                          do
                            U[n++] = _[P++];
                          while (--C);
                          P = n - D, F = U;
                        }
                      }
                    } else if (P += l - C, C < b) {
                      b -= C;
                      do
                        U[n++] = _[P++];
                      while (--C);
                      P = n - D, F = U;
                    }
                    for (; b > 2; )
                      U[n++] = F[P++], U[n++] = F[P++], U[n++] = F[P++], b -= 3;
                    b && (U[n++] = F[P++], b > 1 && (U[n++] = F[P++]));
                  } else {
                    P = n - D;
                    do
                      U[n++] = U[P++], U[n++] = U[P++], U[n++] = U[P++], b -= 3;
                    while (b > 2);
                    b && (U[n++] = U[P++], b > 1 && (U[n++] = U[P++]));
                  }
                } else if (C & 64) {
                  t.msg = "invalid distance code", k.mode = _l;
                  break t;
                } else {
                  y = g[(y & 65535) + (d & (1 << C) - 1)];
                  continue s;
                }
                break;
              }
          } else if (C & 64)
            if (C & 32) {
              k.mode = d2;
              break t;
            } else {
              t.msg = "invalid literal/length code", k.mode = _l;
              break t;
            }
          else {
            y = p[(y & 65535) + (d & (1 << C) - 1)];
            continue e;
          }
          break;
        }
    } while (s < r && n < o);
  b = f >> 3, s -= b, f -= b << 3, d &= (1 << f) - 1, t.next_in = s, t.next_out = n, t.avail_in = s < r ? 5 + (r - s) : 5 - (s - r), t.avail_out = n < o ? 257 + (o - n) : 257 - (n - o), k.hold = d, k.bits = f;
};
const Ua = 15, OA = 852, yA = 592, vA = 0, Bf = 1, CA = 2, g2 = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]), p2 = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]), m2 = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]), E2 = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]), T2 = (i, t, e, s, r, n, a, o) => {
  const h = o.bits;
  let u = 0, c = 0, l = 0, _ = 0, d = 0, f = 0, p = 0, g = 0, m = 0, O = 0, y, C, b, D, P, F = null, M;
  const U = new Uint16Array(Ua + 1), k = new Uint16Array(Ua + 1);
  let ft = null, K, Y, ut;
  for (u = 0; u <= Ua; u++)
    U[u] = 0;
  for (c = 0; c < s; c++)
    U[t[e + c]]++;
  for (d = h, _ = Ua; _ >= 1 && U[_] === 0; _--)
    ;
  if (d > _ && (d = _), _ === 0)
    return r[n++] = 1 << 24 | 64 << 16 | 0, r[n++] = 1 << 24 | 64 << 16 | 0, o.bits = 1, 0;
  for (l = 1; l < _ && U[l] === 0; l++)
    ;
  for (d < l && (d = l), g = 1, u = 1; u <= Ua; u++)
    if (g <<= 1, g -= U[u], g < 0)
      return -1;
  if (g > 0 && (i === vA || _ !== 1))
    return -1;
  for (k[1] = 0, u = 1; u < Ua; u++)
    k[u + 1] = k[u] + U[u];
  for (c = 0; c < s; c++)
    t[e + c] !== 0 && (a[k[t[e + c]]++] = c);
  if (i === vA ? (F = ft = a, M = 20) : i === Bf ? (F = g2, ft = p2, M = 257) : (F = m2, ft = E2, M = 0), O = 0, c = 0, u = l, P = n, f = d, p = 0, b = -1, m = 1 << d, D = m - 1, i === Bf && m > OA || i === CA && m > yA)
    return 1;
  for (; ; ) {
    K = u - p, a[c] + 1 < M ? (Y = 0, ut = a[c]) : a[c] >= M ? (Y = ft[a[c] - M], ut = F[a[c] - M]) : (Y = 96, ut = 0), y = 1 << u - p, C = 1 << f, l = C;
    do
      C -= y, r[P + (O >> p) + C] = K << 24 | Y << 16 | ut | 0;
    while (C !== 0);
    for (y = 1 << u - 1; O & y; )
      y >>= 1;
    if (y !== 0 ? (O &= y - 1, O += y) : O = 0, c++, --U[u] === 0) {
      if (u === _)
        break;
      u = t[e + a[c]];
    }
    if (u > d && (O & D) !== b) {
      for (p === 0 && (p = d), P += l, f = u - p, g = 1 << f; f + p < _ && (g -= U[f + p], !(g <= 0)); )
        f++, g <<= 1;
      if (m += 1 << f, i === Bf && m > OA || i === CA && m > yA)
        return 1;
      b = O & D, r[b] = d << 24 | f << 16 | P - n | 0;
    }
  }
  return O !== 0 && (r[P + O] = u - p << 24 | 64 << 16 | 0), o.bits = d, 0;
};
var Ch = T2;
const I2 = 0, vy = 1, Cy = 2, {
  Z_FINISH: xA,
  Z_BLOCK: S2,
  Z_TREES: dl,
  Z_OK: Ta,
  Z_STREAM_END: A2,
  Z_NEED_DICT: R2,
  Z_STREAM_ERROR: Qs,
  Z_DATA_ERROR: xy,
  Z_MEM_ERROR: My,
  Z_BUF_ERROR: O2,
  Z_DEFLATED: MA
} = Vu, Vd = 16180, bA = 16181, PA = 16182, NA = 16183, UA = 16184, DA = 16185, LA = 16186, FA = 16187, wA = 16188, GA = 16189, sc = 16190, Zi = 16191, kf = 16192, BA = 16193, zf = 16194, kA = 16195, zA = 16196, VA = 16197, HA = 16198, fl = 16199, gl = 16200, YA = 16201, WA = 16202, jA = 16203, XA = 16204, KA = 16205, Vf = 16206, qA = 16207, $A = 16208, oe = 16209, by = 16210, Py = 16211, y2 = 852, v2 = 592, C2 = 15, x2 = C2, ZA = (i) => (i >>> 24 & 255) + (i >>> 8 & 65280) + ((i & 65280) << 8) + ((i & 255) << 24);
function M2() {
  this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
const ya = (i) => {
  if (!i)
    return 1;
  const t = i.state;
  return !t || t.strm !== i || t.mode < Vd || t.mode > Py ? 1 : 0;
}, Ny = (i) => {
  if (ya(i))
    return Qs;
  const t = i.state;
  return i.total_in = i.total_out = t.total = 0, i.msg = "", t.wrap && (i.adler = t.wrap & 1), t.mode = Vd, t.last = 0, t.havedict = 0, t.flags = -1, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(y2), t.distcode = t.distdyn = new Int32Array(v2), t.sane = 1, t.back = -1, Ta;
}, Uy = (i) => {
  if (ya(i))
    return Qs;
  const t = i.state;
  return t.wsize = 0, t.whave = 0, t.wnext = 0, Ny(i);
}, Dy = (i, t) => {
  let e;
  if (ya(i))
    return Qs;
  const s = i.state;
  return t < 0 ? (e = 0, t = -t) : (e = (t >> 4) + 5, t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? Qs : (s.window !== null && s.wbits !== t && (s.window = null), s.wrap = e, s.wbits = t, Uy(i));
}, Ly = (i, t) => {
  if (!i)
    return Qs;
  const e = new M2();
  i.state = e, e.strm = i, e.window = null, e.mode = Vd;
  const s = Dy(i, t);
  return s !== Ta && (i.state = null), s;
}, b2 = (i) => Ly(i, x2);
let QA = !0, Hf, Yf;
const P2 = (i) => {
  if (QA) {
    Hf = new Int32Array(512), Yf = new Int32Array(32);
    let t = 0;
    for (; t < 144; )
      i.lens[t++] = 8;
    for (; t < 256; )
      i.lens[t++] = 9;
    for (; t < 280; )
      i.lens[t++] = 7;
    for (; t < 288; )
      i.lens[t++] = 8;
    for (Ch(vy, i.lens, 0, 288, Hf, 0, i.work, { bits: 9 }), t = 0; t < 32; )
      i.lens[t++] = 5;
    Ch(Cy, i.lens, 0, 32, Yf, 0, i.work, { bits: 5 }), QA = !1;
  }
  i.lencode = Hf, i.lenbits = 9, i.distcode = Yf, i.distbits = 5;
}, Fy = (i, t, e, s) => {
  let r;
  const n = i.state;
  return n.window === null && (n.wsize = 1 << n.wbits, n.wnext = 0, n.whave = 0, n.window = new Uint8Array(n.wsize)), s >= n.wsize ? (n.window.set(t.subarray(e - n.wsize, e), 0), n.wnext = 0, n.whave = n.wsize) : (r = n.wsize - n.wnext, r > s && (r = s), n.window.set(t.subarray(e - s, e - s + r), n.wnext), s -= r, s ? (n.window.set(t.subarray(e - s, e), 0), n.wnext = s, n.whave = n.wsize) : (n.wnext += r, n.wnext === n.wsize && (n.wnext = 0), n.whave < n.wsize && (n.whave += r))), 0;
}, N2 = (i, t) => {
  let e, s, r, n, a, o, h, u, c, l, _, d, f, p, g = 0, m, O, y, C, b, D, P, F;
  const M = new Uint8Array(4);
  let U, k;
  const ft = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (ya(i) || !i.output || !i.input && i.avail_in !== 0)
    return Qs;
  e = i.state, e.mode === Zi && (e.mode = kf), a = i.next_out, r = i.output, h = i.avail_out, n = i.next_in, s = i.input, o = i.avail_in, u = e.hold, c = e.bits, l = o, _ = h, F = Ta;
  t:
    for (; ; )
      switch (e.mode) {
        case Vd:
          if (e.wrap === 0) {
            e.mode = kf;
            break;
          }
          for (; c < 16; ) {
            if (o === 0)
              break t;
            o--, u += s[n++] << c, c += 8;
          }
          if (e.wrap & 2 && u === 35615) {
            e.wbits === 0 && (e.wbits = 15), e.check = 0, M[0] = u & 255, M[1] = u >>> 8 & 255, e.check = Ge(e.check, M, 2, 0), u = 0, c = 0, e.mode = bA;
            break;
          }
          if (e.head && (e.head.done = !1), !(e.wrap & 1) || /* check if zlib header allowed */
          (((u & 255) << 8) + (u >> 8)) % 31) {
            i.msg = "incorrect header check", e.mode = oe;
            break;
          }
          if ((u & 15) !== MA) {
            i.msg = "unknown compression method", e.mode = oe;
            break;
          }
          if (u >>>= 4, c -= 4, P = (u & 15) + 8, e.wbits === 0 && (e.wbits = P), P > 15 || P > e.wbits) {
            i.msg = "invalid window size", e.mode = oe;
            break;
          }
          e.dmax = 1 << e.wbits, e.flags = 0, i.adler = e.check = 1, e.mode = u & 512 ? GA : Zi, u = 0, c = 0;
          break;
        case bA:
          for (; c < 16; ) {
            if (o === 0)
              break t;
            o--, u += s[n++] << c, c += 8;
          }
          if (e.flags = u, (e.flags & 255) !== MA) {
            i.msg = "unknown compression method", e.mode = oe;
            break;
          }
          if (e.flags & 57344) {
            i.msg = "unknown header flags set", e.mode = oe;
            break;
          }
          e.head && (e.head.text = u >> 8 & 1), e.flags & 512 && e.wrap & 4 && (M[0] = u & 255, M[1] = u >>> 8 & 255, e.check = Ge(e.check, M, 2, 0)), u = 0, c = 0, e.mode = PA;
        case PA:
          for (; c < 32; ) {
            if (o === 0)
              break t;
            o--, u += s[n++] << c, c += 8;
          }
          e.head && (e.head.time = u), e.flags & 512 && e.wrap & 4 && (M[0] = u & 255, M[1] = u >>> 8 & 255, M[2] = u >>> 16 & 255, M[3] = u >>> 24 & 255, e.check = Ge(e.check, M, 4, 0)), u = 0, c = 0, e.mode = NA;
        case NA:
          for (; c < 16; ) {
            if (o === 0)
              break t;
            o--, u += s[n++] << c, c += 8;
          }
          e.head && (e.head.xflags = u & 255, e.head.os = u >> 8), e.flags & 512 && e.wrap & 4 && (M[0] = u & 255, M[1] = u >>> 8 & 255, e.check = Ge(e.check, M, 2, 0)), u = 0, c = 0, e.mode = UA;
        case UA:
          if (e.flags & 1024) {
            for (; c < 16; ) {
              if (o === 0)
                break t;
              o--, u += s[n++] << c, c += 8;
            }
            e.length = u, e.head && (e.head.extra_len = u), e.flags & 512 && e.wrap & 4 && (M[0] = u & 255, M[1] = u >>> 8 & 255, e.check = Ge(e.check, M, 2, 0)), u = 0, c = 0;
          } else e.head && (e.head.extra = null);
          e.mode = DA;
        case DA:
          if (e.flags & 1024 && (d = e.length, d > o && (d = o), d && (e.head && (P = e.head.extra_len - e.length, e.head.extra || (e.head.extra = new Uint8Array(e.head.extra_len)), e.head.extra.set(
            s.subarray(
              n,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              n + d
            ),
            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
            P
          )), e.flags & 512 && e.wrap & 4 && (e.check = Ge(e.check, s, d, n)), o -= d, n += d, e.length -= d), e.length))
            break t;
          e.length = 0, e.mode = LA;
        case LA:
          if (e.flags & 2048) {
            if (o === 0)
              break t;
            d = 0;
            do
              P = s[n + d++], e.head && P && e.length < 65536 && (e.head.name += String.fromCharCode(P));
            while (P && d < o);
            if (e.flags & 512 && e.wrap & 4 && (e.check = Ge(e.check, s, d, n)), o -= d, n += d, P)
              break t;
          } else e.head && (e.head.name = null);
          e.length = 0, e.mode = FA;
        case FA:
          if (e.flags & 4096) {
            if (o === 0)
              break t;
            d = 0;
            do
              P = s[n + d++], e.head && P && e.length < 65536 && (e.head.comment += String.fromCharCode(P));
            while (P && d < o);
            if (e.flags & 512 && e.wrap & 4 && (e.check = Ge(e.check, s, d, n)), o -= d, n += d, P)
              break t;
          } else e.head && (e.head.comment = null);
          e.mode = wA;
        case wA:
          if (e.flags & 512) {
            for (; c < 16; ) {
              if (o === 0)
                break t;
              o--, u += s[n++] << c, c += 8;
            }
            if (e.wrap & 4 && u !== (e.check & 65535)) {
              i.msg = "header crc mismatch", e.mode = oe;
              break;
            }
            u = 0, c = 0;
          }
          e.head && (e.head.hcrc = e.flags >> 9 & 1, e.head.done = !0), i.adler = e.check = 0, e.mode = Zi;
          break;
        case GA:
          for (; c < 32; ) {
            if (o === 0)
              break t;
            o--, u += s[n++] << c, c += 8;
          }
          i.adler = e.check = ZA(u), u = 0, c = 0, e.mode = sc;
        case sc:
          if (e.havedict === 0)
            return i.next_out = a, i.avail_out = h, i.next_in = n, i.avail_in = o, e.hold = u, e.bits = c, R2;
          i.adler = e.check = 1, e.mode = Zi;
        case Zi:
          if (t === S2 || t === dl)
            break t;
        case kf:
          if (e.last) {
            u >>>= c & 7, c -= c & 7, e.mode = Vf;
            break;
          }
          for (; c < 3; ) {
            if (o === 0)
              break t;
            o--, u += s[n++] << c, c += 8;
          }
          switch (e.last = u & 1, u >>>= 1, c -= 1, u & 3) {
            case 0:
              e.mode = BA;
              break;
            case 1:
              if (P2(e), e.mode = fl, t === dl) {
                u >>>= 2, c -= 2;
                break t;
              }
              break;
            case 2:
              e.mode = zA;
              break;
            case 3:
              i.msg = "invalid block type", e.mode = oe;
          }
          u >>>= 2, c -= 2;
          break;
        case BA:
          for (u >>>= c & 7, c -= c & 7; c < 32; ) {
            if (o === 0)
              break t;
            o--, u += s[n++] << c, c += 8;
          }
          if ((u & 65535) !== (u >>> 16 ^ 65535)) {
            i.msg = "invalid stored block lengths", e.mode = oe;
            break;
          }
          if (e.length = u & 65535, u = 0, c = 0, e.mode = zf, t === dl)
            break t;
        case zf:
          e.mode = kA;
        case kA:
          if (d = e.length, d) {
            if (d > o && (d = o), d > h && (d = h), d === 0)
              break t;
            r.set(s.subarray(n, n + d), a), o -= d, n += d, h -= d, a += d, e.length -= d;
            break;
          }
          e.mode = Zi;
          break;
        case zA:
          for (; c < 14; ) {
            if (o === 0)
              break t;
            o--, u += s[n++] << c, c += 8;
          }
          if (e.nlen = (u & 31) + 257, u >>>= 5, c -= 5, e.ndist = (u & 31) + 1, u >>>= 5, c -= 5, e.ncode = (u & 15) + 4, u >>>= 4, c -= 4, e.nlen > 286 || e.ndist > 30) {
            i.msg = "too many length or distance symbols", e.mode = oe;
            break;
          }
          e.have = 0, e.mode = VA;
        case VA:
          for (; e.have < e.ncode; ) {
            for (; c < 3; ) {
              if (o === 0)
                break t;
              o--, u += s[n++] << c, c += 8;
            }
            e.lens[ft[e.have++]] = u & 7, u >>>= 3, c -= 3;
          }
          for (; e.have < 19; )
            e.lens[ft[e.have++]] = 0;
          if (e.lencode = e.lendyn, e.lenbits = 7, U = { bits: e.lenbits }, F = Ch(I2, e.lens, 0, 19, e.lencode, 0, e.work, U), e.lenbits = U.bits, F) {
            i.msg = "invalid code lengths set", e.mode = oe;
            break;
          }
          e.have = 0, e.mode = HA;
        case HA:
          for (; e.have < e.nlen + e.ndist; ) {
            for (; g = e.lencode[u & (1 << e.lenbits) - 1], m = g >>> 24, O = g >>> 16 & 255, y = g & 65535, !(m <= c); ) {
              if (o === 0)
                break t;
              o--, u += s[n++] << c, c += 8;
            }
            if (y < 16)
              u >>>= m, c -= m, e.lens[e.have++] = y;
            else {
              if (y === 16) {
                for (k = m + 2; c < k; ) {
                  if (o === 0)
                    break t;
                  o--, u += s[n++] << c, c += 8;
                }
                if (u >>>= m, c -= m, e.have === 0) {
                  i.msg = "invalid bit length repeat", e.mode = oe;
                  break;
                }
                P = e.lens[e.have - 1], d = 3 + (u & 3), u >>>= 2, c -= 2;
              } else if (y === 17) {
                for (k = m + 3; c < k; ) {
                  if (o === 0)
                    break t;
                  o--, u += s[n++] << c, c += 8;
                }
                u >>>= m, c -= m, P = 0, d = 3 + (u & 7), u >>>= 3, c -= 3;
              } else {
                for (k = m + 7; c < k; ) {
                  if (o === 0)
                    break t;
                  o--, u += s[n++] << c, c += 8;
                }
                u >>>= m, c -= m, P = 0, d = 11 + (u & 127), u >>>= 7, c -= 7;
              }
              if (e.have + d > e.nlen + e.ndist) {
                i.msg = "invalid bit length repeat", e.mode = oe;
                break;
              }
              for (; d--; )
                e.lens[e.have++] = P;
            }
          }
          if (e.mode === oe)
            break;
          if (e.lens[256] === 0) {
            i.msg = "invalid code -- missing end-of-block", e.mode = oe;
            break;
          }
          if (e.lenbits = 9, U = { bits: e.lenbits }, F = Ch(vy, e.lens, 0, e.nlen, e.lencode, 0, e.work, U), e.lenbits = U.bits, F) {
            i.msg = "invalid literal/lengths set", e.mode = oe;
            break;
          }
          if (e.distbits = 6, e.distcode = e.distdyn, U = { bits: e.distbits }, F = Ch(Cy, e.lens, e.nlen, e.ndist, e.distcode, 0, e.work, U), e.distbits = U.bits, F) {
            i.msg = "invalid distances set", e.mode = oe;
            break;
          }
          if (e.mode = fl, t === dl)
            break t;
        case fl:
          e.mode = gl;
        case gl:
          if (o >= 6 && h >= 258) {
            i.next_out = a, i.avail_out = h, i.next_in = n, i.avail_in = o, e.hold = u, e.bits = c, f2(i, _), a = i.next_out, r = i.output, h = i.avail_out, n = i.next_in, s = i.input, o = i.avail_in, u = e.hold, c = e.bits, e.mode === Zi && (e.back = -1);
            break;
          }
          for (e.back = 0; g = e.lencode[u & (1 << e.lenbits) - 1], m = g >>> 24, O = g >>> 16 & 255, y = g & 65535, !(m <= c); ) {
            if (o === 0)
              break t;
            o--, u += s[n++] << c, c += 8;
          }
          if (O && !(O & 240)) {
            for (C = m, b = O, D = y; g = e.lencode[D + ((u & (1 << C + b) - 1) >> C)], m = g >>> 24, O = g >>> 16 & 255, y = g & 65535, !(C + m <= c); ) {
              if (o === 0)
                break t;
              o--, u += s[n++] << c, c += 8;
            }
            u >>>= C, c -= C, e.back += C;
          }
          if (u >>>= m, c -= m, e.back += m, e.length = y, O === 0) {
            e.mode = KA;
            break;
          }
          if (O & 32) {
            e.back = -1, e.mode = Zi;
            break;
          }
          if (O & 64) {
            i.msg = "invalid literal/length code", e.mode = oe;
            break;
          }
          e.extra = O & 15, e.mode = YA;
        case YA:
          if (e.extra) {
            for (k = e.extra; c < k; ) {
              if (o === 0)
                break t;
              o--, u += s[n++] << c, c += 8;
            }
            e.length += u & (1 << e.extra) - 1, u >>>= e.extra, c -= e.extra, e.back += e.extra;
          }
          e.was = e.length, e.mode = WA;
        case WA:
          for (; g = e.distcode[u & (1 << e.distbits) - 1], m = g >>> 24, O = g >>> 16 & 255, y = g & 65535, !(m <= c); ) {
            if (o === 0)
              break t;
            o--, u += s[n++] << c, c += 8;
          }
          if (!(O & 240)) {
            for (C = m, b = O, D = y; g = e.distcode[D + ((u & (1 << C + b) - 1) >> C)], m = g >>> 24, O = g >>> 16 & 255, y = g & 65535, !(C + m <= c); ) {
              if (o === 0)
                break t;
              o--, u += s[n++] << c, c += 8;
            }
            u >>>= C, c -= C, e.back += C;
          }
          if (u >>>= m, c -= m, e.back += m, O & 64) {
            i.msg = "invalid distance code", e.mode = oe;
            break;
          }
          e.offset = y, e.extra = O & 15, e.mode = jA;
        case jA:
          if (e.extra) {
            for (k = e.extra; c < k; ) {
              if (o === 0)
                break t;
              o--, u += s[n++] << c, c += 8;
            }
            e.offset += u & (1 << e.extra) - 1, u >>>= e.extra, c -= e.extra, e.back += e.extra;
          }
          if (e.offset > e.dmax) {
            i.msg = "invalid distance too far back", e.mode = oe;
            break;
          }
          e.mode = XA;
        case XA:
          if (h === 0)
            break t;
          if (d = _ - h, e.offset > d) {
            if (d = e.offset - d, d > e.whave && e.sane) {
              i.msg = "invalid distance too far back", e.mode = oe;
              break;
            }
            d > e.wnext ? (d -= e.wnext, f = e.wsize - d) : f = e.wnext - d, d > e.length && (d = e.length), p = e.window;
          } else
            p = r, f = a - e.offset, d = e.length;
          d > h && (d = h), h -= d, e.length -= d;
          do
            r[a++] = p[f++];
          while (--d);
          e.length === 0 && (e.mode = gl);
          break;
        case KA:
          if (h === 0)
            break t;
          r[a++] = e.length, h--, e.mode = gl;
          break;
        case Vf:
          if (e.wrap) {
            for (; c < 32; ) {
              if (o === 0)
                break t;
              o--, u |= s[n++] << c, c += 8;
            }
            if (_ -= h, i.total_out += _, e.total += _, e.wrap & 4 && _ && (i.adler = e.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
            e.flags ? Ge(e.check, r, _, a - _) : yu(e.check, r, _, a - _)), _ = h, e.wrap & 4 && (e.flags ? u : ZA(u)) !== e.check) {
              i.msg = "incorrect data check", e.mode = oe;
              break;
            }
            u = 0, c = 0;
          }
          e.mode = qA;
        case qA:
          if (e.wrap && e.flags) {
            for (; c < 32; ) {
              if (o === 0)
                break t;
              o--, u += s[n++] << c, c += 8;
            }
            if (e.wrap & 4 && u !== (e.total & 4294967295)) {
              i.msg = "incorrect length check", e.mode = oe;
              break;
            }
            u = 0, c = 0;
          }
          e.mode = $A;
        case $A:
          F = A2;
          break t;
        case oe:
          F = xy;
          break t;
        case by:
          return My;
        case Py:
        default:
          return Qs;
      }
  return i.next_out = a, i.avail_out = h, i.next_in = n, i.avail_in = o, e.hold = u, e.bits = c, (e.wsize || _ !== i.avail_out && e.mode < oe && (e.mode < Vf || t !== xA)) && Fy(i, i.output, i.next_out, _ - i.avail_out), l -= i.avail_in, _ -= i.avail_out, i.total_in += l, i.total_out += _, e.total += _, e.wrap & 4 && _ && (i.adler = e.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
  e.flags ? Ge(e.check, r, _, i.next_out - _) : yu(e.check, r, _, i.next_out - _)), i.data_type = e.bits + (e.last ? 64 : 0) + (e.mode === Zi ? 128 : 0) + (e.mode === fl || e.mode === zf ? 256 : 0), (l === 0 && _ === 0 || t === xA) && F === Ta && (F = O2), F;
}, U2 = (i) => {
  if (ya(i))
    return Qs;
  let t = i.state;
  return t.window && (t.window = null), i.state = null, Ta;
}, D2 = (i, t) => {
  if (ya(i))
    return Qs;
  const e = i.state;
  return e.wrap & 2 ? (e.head = t, t.done = !1, Ta) : Qs;
}, L2 = (i, t) => {
  const e = t.length;
  let s, r, n;
  return ya(i) || (s = i.state, s.wrap !== 0 && s.mode !== sc) ? Qs : s.mode === sc && (r = 1, r = yu(r, t, e, 0), r !== s.check) ? xy : (n = Fy(i, t, e, e), n ? (s.mode = by, My) : (s.havedict = 1, Ta));
};
var F2 = Uy, w2 = Dy, G2 = Ny, B2 = b2, k2 = Ly, z2 = N2, V2 = U2, H2 = D2, Y2 = L2, W2 = "pako inflate (from Nodeca project)", dr = {
  inflateReset: F2,
  inflateReset2: w2,
  inflateResetKeep: G2,
  inflateInit: B2,
  inflateInit2: k2,
  inflate: z2,
  inflateEnd: V2,
  inflateGetHeader: H2,
  inflateSetDictionary: Y2,
  inflateInfo: W2
};
function j2() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}
var X2 = j2;
const wy = Object.prototype.toString, {
  Z_NO_FLUSH: K2,
  Z_FINISH: q2,
  Z_OK: xu,
  Z_STREAM_END: Wf,
  Z_NEED_DICT: jf,
  Z_STREAM_ERROR: $2,
  Z_DATA_ERROR: JA,
  Z_MEM_ERROR: Z2
} = Vu;
function Yu(i) {
  this.options = zd.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, i || {});
  const t = this.options;
  t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, t.windowBits === 0 && (t.windowBits = -15)), t.windowBits >= 0 && t.windowBits < 16 && !(i && i.windowBits) && (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && (t.windowBits & 15 || (t.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Oy(), this.strm.avail_out = 0;
  let e = dr.inflateInit2(
    this.strm,
    t.windowBits
  );
  if (e !== xu)
    throw new Error(Go[e]);
  if (this.header = new X2(), dr.inflateGetHeader(this.strm, this.header), t.dictionary && (typeof t.dictionary == "string" ? t.dictionary = Cu.string2buf(t.dictionary) : wy.call(t.dictionary) === "[object ArrayBuffer]" && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (e = dr.inflateSetDictionary(this.strm, t.dictionary), e !== xu)))
    throw new Error(Go[e]);
}
Yu.prototype.push = function(i, t) {
  const e = this.strm, s = this.options.chunkSize, r = this.options.dictionary;
  let n, a, o;
  if (this.ended) return !1;
  for (t === ~~t ? a = t : a = t === !0 ? q2 : K2, wy.call(i) === "[object ArrayBuffer]" ? e.input = new Uint8Array(i) : e.input = i, e.next_in = 0, e.avail_in = e.input.length; ; ) {
    for (e.avail_out === 0 && (e.output = new Uint8Array(s), e.next_out = 0, e.avail_out = s), n = dr.inflate(e, a), n === jf && r && (n = dr.inflateSetDictionary(e, r), n === xu ? n = dr.inflate(e, a) : n === JA && (n = jf)); e.avail_in > 0 && n === Wf && e.state.wrap > 0 && i[e.next_in] !== 0; )
      dr.inflateReset(e), n = dr.inflate(e, a);
    switch (n) {
      case $2:
      case JA:
      case jf:
      case Z2:
        return this.onEnd(n), this.ended = !0, !1;
    }
    if (o = e.avail_out, e.next_out && (e.avail_out === 0 || n === Wf))
      if (this.options.to === "string") {
        let h = Cu.utf8border(e.output, e.next_out), u = e.next_out - h, c = Cu.buf2string(e.output, h);
        e.next_out = u, e.avail_out = s - u, u && e.output.set(e.output.subarray(h, h + u), 0), this.onData(c);
      } else
        this.onData(e.output.length === e.next_out ? e.output : e.output.subarray(0, e.next_out));
    if (!(n === xu && o === 0)) {
      if (n === Wf)
        return n = dr.inflateEnd(this.strm), this.onEnd(n), this.ended = !0, !0;
      if (e.avail_in === 0) break;
    }
  }
  return !0;
};
Yu.prototype.onData = function(i) {
  this.chunks.push(i);
};
Yu.prototype.onEnd = function(i) {
  i === xu && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = zd.flattenChunks(this.chunks)), this.chunks = [], this.err = i, this.msg = this.strm.msg;
};
function qT(i, t) {
  const e = new Yu(t);
  if (e.push(i), e.err) throw e.msg || Go[e.err];
  return e.result;
}
function Q2(i, t) {
  return t = t || {}, t.raw = !0, qT(i, t);
}
var J2 = Yu, tF = qT, eF = Q2, sF = qT, iF = Vu, rF = {
  Inflate: J2,
  inflate: tF,
  inflateRaw: eF,
  ungzip: sF,
  constants: iF
};
const { Inflate: Grt, inflate: nF, inflateRaw: Brt, ungzip: krt } = rF;
var aF = nF;
const Gh = class Gh {
  constructor() {
    this._jsonFile = null, this._texture = null;
  }
  static async from(t) {
    const e = new Gh();
    return await e.parse(t), e;
  }
  async parse(t) {
    const e = new Gd(t);
    let s = e.readShort();
    for (; s > 0; ) {
      const r = e.readShort(), n = e.readBytes(r).toString(), a = e.readInt(), o = e.readBytes(a), h = aF(o.toArrayBuffer());
      n.endsWith(".json") ? this._jsonFile = JSON.parse(Gh.TEXT_DECODER.decode(h)) : this._texture = await ra.load(`data:image/png;base64,${x1(h)}`), s--;
    }
  }
  get jsonFile() {
    return this._jsonFile;
  }
  get texture() {
    return this._texture;
  }
};
Gh.TEXT_DECODER = new TextDecoder("utf-8");
let Xg = Gh;
const Br = class Br {
  static sayHello() {
    if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
      const t = [
        `
 %c %c %c Nitro ${Br.UI_VERSION} - Renderer ${Br.RENDERER_VERSION} %c %c %c https://discord.nitrodev.co %c %c 

`,
        "background: #ffffff; padding:5px 0;",
        "background: #ffffff; padding:5px 0;",
        "color: #ffffff; background: #000000; padding:5px 0;",
        "background: #ffffff; padding:5px 0;",
        "background: #ffffff; padding:5px 0;",
        "background: #000000; padding:5px 0;",
        "background: #ffffff; padding:5px 0;",
        "background: #ffffff; padding:5px 0;"
      ];
      self.console.log(...t);
    } else self.console && self.console.log(`Nitro ${Br.UI_VERSION} - Renderer ${Br.RENDERER_VERSION} `);
  }
};
Br.RENDERER_VERSION = "2.0.0", Br.UI_VERSION = "";
let ic = Br;
class Gy {
  constructor(t, e, s) {
    this._location = null, this._transformedLocation = new v(), this._needsTransformation = !1, this._location = new v(t, e, s), (t !== 0 || e !== 0 || s !== 0) && (this._needsTransformation = !0);
  }
  get location() {
    return this._location;
  }
  get transformedLocation() {
    return this._transformedLocation;
  }
  applyTransform(t) {
    this._needsTransformation && (this._transformedLocation = t.vectorMultiplication(this._location));
  }
}
class tR {
  constructor(t) {
    t < 0 && (t = 0), this._reservedNumbers = [], this._freeNumbers = [];
    let e = 0;
    for (; e < t; )
      this._freeNumbers.push(e), e++;
  }
  dispose() {
    this._reservedNumbers = null, this._freeNumbers = null;
  }
  reserveNumber() {
    if (this._freeNumbers.length > 0) {
      const t = this._freeNumbers.pop();
      return this._reservedNumbers.push(t), t;
    }
    return -1;
  }
  freeNumber(t) {
    const e = this._reservedNumbers.indexOf(t);
    e >= 0 && (this._reservedNumbers.splice(e, 1), this._freeNumbers.push(t));
  }
}
class zrt {
  static sum(t, e) {
    return new st(t.x + e.x, t.y + e.y);
  }
  static sub(t, e) {
    return new st(t.x - e.x, t.y - e.y);
  }
  static mul(t, e) {
    return new st(t.x * e, t.y * e);
  }
}
const Bh = class Bh {
  static makeRoomPreviewerId(t) {
    return (t & 65535) + Bh.PREVIEW_ROOM_ID_BASE;
  }
  static isRoomPreviewerId(t) {
    return t >= Bh.PREVIEW_ROOM_ID_BASE;
  }
};
Bh.PREVIEW_ROOM_ID_BASE = 2147418112;
let rc = Bh;
class le {
  static generateTexture(t) {
    return this.getRenderer().textureGenerator.generateTexture(t);
  }
  static generateTextureFromImage(t) {
    return W.from(t);
  }
  static async generateImage(t) {
    return this.getExtractor().image(t);
  }
  static async generateImageUrl(t) {
    return this.getExtractor().base64(t);
  }
  static generateCanvas(t) {
    return this.getExtractor().canvas(t);
  }
  static clearRenderTexture(t) {
    return this.writeToTexture(new Ft(W.EMPTY), t);
  }
  static createRenderTexture(t, e) {
    return t < 0 || e < 0 ? null : ku.create({ width: t, height: e });
  }
  static createAndFillRenderTexture(t, e, s = 16777215) {
    return t < 0 || e < 0 ? null : this.clearAndFillRenderTexture(this.createRenderTexture(t, e), s);
  }
  static createAndWriteRenderTexture(t, e, s, r = null) {
    return t < 0 || e < 0 ? null : this.writeToTexture(s, this.createRenderTexture(t, e), !0, r);
  }
  static clearAndFillRenderTexture(t, e = 16777215) {
    if (!t) return null;
    const s = new Ft(W.WHITE);
    return s.tint = e, s.width = t.width, s.height = t.height, this.writeToTexture(s, t);
  }
  static writeToTexture(t, e, s = !0, r = null) {
    return !t || !e ? null : (this.getRenderer().render({
      container: t,
      target: e,
      clear: s,
      transform: r
    }), e);
  }
  static flipTextureHorizontal(t) {
    if (!t) return null;
    const e = new ot();
    return e.scale(-1, 1), e.translate(t.width, 0), this.createAndWriteRenderTexture(t.width, t.height, new Ft(t), e);
  }
  static flipTextureVertical(t) {
    if (!t) return null;
    const e = new ot();
    return e.scale(1, -1), e.translate(0, t.height), this.createAndWriteRenderTexture(t.width, t.height, new Ft(t), e);
  }
  static flipTextureHorizontalAndVertical(t) {
    if (!t) return null;
    const e = new ot();
    return e.scale(-1, -1), e.translate(t.width, t.height), this.createAndWriteRenderTexture(t.width, t.height, new Ft(t), e);
  }
  static getPixels(t) {
    return this.getExtractor().pixels(t);
  }
  static getRenderer() {
    return ma();
  }
  static getExtractor() {
    return this.getRenderer().extract;
  }
}
const oF = (i = Mr.CHANNELS_EQUAL) => {
  let t = 0.33, e = 0.33, s = 0.33;
  switch (i) {
    case Mr.CHANNELS_UNIQUE:
      t = 0.3, e = 0.59, s = 0.11;
      break;
    case Mr.CHANNELS_RED:
      t = 1, e = 0, s = 0;
      break;
    case Mr.CHANNELS_GREEN:
      t = 0, e = 1, s = 0;
      break;
    case Mr.CHANNELS_BLUE:
      t = 0, e = 0, s = 1;
      break;
    case Mr.CHANNELS_DESATURATED:
      t = 0.3086, e = 0.6094, s = 0.082;
      break;
  }
  const r = new Sh();
  return r.matrix = [
    t,
    e,
    s,
    0,
    0,
    // Red channel
    t,
    e,
    s,
    0,
    0,
    // Green channel
    t,
    e,
    s,
    0,
    0,
    // Blue channel
    0,
    0,
    0,
    1,
    0
    // Alpha channel
  ], r;
}, hF = (i) => {
  const t = [];
  for (let e = 0; e < i.length; e++)
    t[e * 4 + 0] = i[e] >> 16 & 255, t[e * 4 + 1] = i[e] >> 8 & 255, t[e * 4 + 2] = i[e] & 255, t[e * 4 + 3] = i[e] >> 24 & 255;
  return t;
}, n_ = class n_ extends xt {
  constructor(t) {
    t = { ...n_.DEFAULT_OPTIONS, ...t };
    const e = hF(t.palette), s = Md.from({
      width: e.length / 4,
      height: 1,
      resource: Uint8Array.from(e),
      scaleMode: "linear",
      autoGenerateMipmaps: !1
    }), r = W.from(s), n = null, a = It.from({
      vertex: `
            in vec2 aPosition;
            out vec2 vTextureCoord;
            
            uniform vec4 uInputSize;
            uniform vec4 uOutputFrame;
            uniform vec4 uOutputTexture;
            
            vec4 filterVertexPosition( void )
            {
                vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
                
                position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
                position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;
            
                return vec4(position, 0.0, 1.0);
            }
            
            vec2 filterTextureCoord( void )
            {
                return aPosition * (uOutputFrame.zw * uInputSize.zw);
            }
            
            void main(void)
            {
                gl_Position = filterVertexPosition();
                vTextureCoord = filterTextureCoord();
            }`,
      fragment: `
            in vec2 vTextureCoord;

            uniform sampler2D uTexture;
            uniform sampler2D uPaletteTexture;
            uniform float uChannel;

            void main() {
                vec4 currentColor = texture2D(uTexture, vTextureCoord);
                vec4 paletteColor = currentColor;

                if(currentColor.a > 0.0) {
                    paletteColor = texture2D(uPaletteTexture, vec2((currentColor.r * 255.0 + 0.5) / 256.0, 0.5));
                }

                gl_FragColor = vec4(paletteColor.r, paletteColor.g, paletteColor.b, currentColor.a);
            }`,
      name: "palette-map-filter"
    });
    console.log(r), super({
      gpuProgram: n,
      glProgram: a,
      resources: {
        paletteMapUniforms: {
          uChannel: { value: t.channel, type: "f32" }
        },
        uPaletteTexture: r.source,
        uPaletteSampler: r.source.style
      }
    }), this.uniforms = this.resources.paletteMapUniforms.uniforms, this.resources.uPaletteTexture = r.source, this.resources.uPaletteSampler = r.source.style, Object.assign(this, t);
  }
};
n_.DEFAULT_OPTIONS = {
  palette: [],
  channel: 0
};
let Kg = n_;
const a_ = class a_ extends xt {
  constructor(t) {
    t = { ...a_.DEFAULT_OPTIONS, ...t };
    const e = It.from({
      vertex: `in vec2 aPosition;
            out vec2 vTextureCoord;
            
            uniform vec4 uInputSize;
            uniform vec4 uOutputFrame;
            uniform vec4 uOutputTexture;
            
            vec4 filterVertexPosition( void )
            {
                vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
                
                position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
                position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;
            
                return vec4(position, 0.0, 1.0);
            }
            
            vec2 filterTextureCoord( void )
            {
                return aPosition * (uOutputFrame.zw * uInputSize.zw);
            }
            
            void main(void)
            {
                gl_Position = filterVertexPosition();
                vTextureCoord = filterTextureCoord();
            }`,
      fragment: `
            in vec2 vTextureCoord;
            out vec4 finalColor;

            uniform sampler2D uTexture;

            void main(void) {
                vec4 c = texture(uTexture, vTextureCoord);
                finalColor = c;

                if(c.r == 0.0 && c.g == 0.0 && c.b == 0.0) {
                    finalColor = vec4(0.0, 0.0, 0.0, 0.0);
                }
            }
            `,
      name: "plane-mask-filter"
    });
    super({
      gpuProgram: null,
      glProgram: e,
      resources: {
        planeMaskUniforms: {}
      }
    }), this.uniforms = this.resources.planeMaskUniforms.uniforms, Object.assign(this, t);
  }
  apply(t, e, s, r) {
    t.applyFilter(this, e, s, r);
  }
};
a_.DEFAULT_OPTIONS = {};
let qg = a_;
const o_ = class o_ extends xt {
  constructor(t) {
    t = { ...o_.DEFAULT_OPTIONS, ...t };
    const e = It.from({
      vertex: `in vec2 aPosition;
            out vec2 vTextureCoord;
            
            uniform vec4 uInputSize;
            uniform vec4 uOutputFrame;
            uniform vec4 uOutputTexture;
            
            vec4 filterVertexPosition( void )
            {
                vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
                
                position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
                position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;
            
                return vec4(position, 0.0, 1.0);
            }
            
            vec2 filterTextureCoord( void )
            {
                return aPosition * (uOutputFrame.zw * uInputSize.zw);
            }
            
            void main(void)
            {
                gl_Position = filterVertexPosition();
                vTextureCoord = filterTextureCoord();
            }`,
      fragment: `
            in vec2 vTextureCoord;
            out vec4 finalColor;

            uniform sampler2D uTexture;
            uniform vec3 uLineColor;
            uniform vec3 uColor;

            void main(void) {
                vec4 currentColor = texture(uTexture, vTextureCoord);
                vec3 colorLine = uLineColor * currentColor.a;
                vec3 colorOverlay = uColor * currentColor.a;

                if(currentColor.r == 0.0 && currentColor.g == 0.0 && currentColor.b == 0.0 && currentColor.a > 0.0) {
                    finalColor = vec4(colorLine.r, colorLine.g, colorLine.b, currentColor.a);
                } else if(currentColor.a > 0.0) {
                    finalColor = vec4(colorOverlay.r, colorOverlay.g, colorOverlay.b, currentColor.a);
                }
            }
            `,
      name: "wired-filter"
    });
    super({
      gpuProgram: null,
      glProgram: e,
      resources: {
        planeMaskUniforms: {
          uLineColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uColor: { value: new Float32Array(3), type: "vec3<f32>" }
        }
      }
    }), this.uniforms = this.resources.planeMaskUniforms.uniforms, this._lineColor = new Pt(), this.lineColor = t.lineColor ?? 0, this._color = new Pt(), this.color = t.color ?? 0, Object.assign(this, t);
  }
  apply(t, e, s, r) {
    t.applyFilter(this, e, s, r);
  }
  get lineColor() {
    return this._lineColor.value;
  }
  set lineColor(t) {
    this._lineColor.setValue(t);
    const [e, s, r] = this._lineColor.toArray();
    this.uniforms.uLineColor[0] = e, this.uniforms.uLineColor[1] = s, this.uniforms.uLineColor[2] = r;
  }
  get color() {
    return this._color.value;
  }
  set color(t) {
    this._color.setValue(t);
    const [e, s, r] = this._color.toArray();
    this.uniforms.uColor[0] = e, this.uniforms.uColor[1] = s, this.uniforms.uColor[2] = r;
  }
};
o_.DEFAULT_OPTIONS = {
  lineColor: 0,
  color: 0
};
let eR = o_;
class sh {
  constructor(t) {
    this._complete = !0, this._target = t;
  }
  get running() {
    return this._running && !!this._target;
  }
  get complete() {
    return this._complete;
  }
  set target(t) {
    this._target = t;
  }
  get target() {
    return this._target;
  }
  set tag(t) {
    this._tag = t;
  }
  get tag() {
    return this._tag;
  }
  start() {
    this._running = !0;
  }
  update(t) {
  }
  stop() {
    this._target = null, this._running = !1;
  }
  tick(t) {
  }
}
class Vrt extends sh {
  constructor(t) {
    super(null), this._callback = t;
  }
  get running() {
    return this._running && !!this._callback;
  }
  tick(t) {
    super.tick(t), this._callback && (this._callback(), this._callback = null);
  }
}
class Hrt extends sh {
  constructor(...t) {
    super(t && t.length ? t[0].target : null), this._runningMotions = [], this._removedMotions = [];
    for (const e of t) this._runningMotions.push(e);
  }
  start() {
    super.start();
    for (const t of this._runningMotions) t.start();
  }
  tick(t) {
    super.tick(t);
    let e = null;
    for (; (e = this._removedMotions.pop()) !== null; )
      this._runningMotions.splice(this._removedMotions.indexOf(e), 1), e.running && e.stop();
    for (const s of this._runningMotions)
      s.running && s.tick(t), s.complete && this._removedMotions.push(s);
    if (this._runningMotions.length > 0) {
      for (const s of this._runningMotions)
        if (this._target = s.target, this._target) break;
      this._complete = !1;
    } else
      this._complete = !0;
  }
}
class Yrt extends sh {
  constructor(t) {
    super(t);
  }
  tick(t) {
    super.tick(t), this.target && (this.target.remove(), this.target = null);
  }
}
class Wu extends sh {
  constructor(t, e) {
    super(t), this._complete = !1, this._duration = e;
  }
  get duration() {
    return this._duration;
  }
  start() {
    super.start(), this._complete = !1, this._startTimeMs = Nt();
  }
  tick(t) {
    super.tick(t);
    const e = (t - this._startTimeMs) / this._duration;
    e < 1 ? this.update(e) : (this.update(1), this._complete = !0);
  }
}
class Wrt extends Wu {
  constructor(t, e, s) {
    super(t, e), this._height = s;
  }
  start() {
    super.start(), this._offset = 0, this.target.style.top = this._offset - this._height + "px";
  }
  update(t) {
    super.update(t), this.target.style.top = this._offset - this._height + this.getBounceOffset(t) * this._height + "px";
  }
  getBounceOffset(t) {
    return t < 0.364 ? 7.5625 * t * t : t < 0.727 ? (t = t - 0.545, 7.5625 * t * t + 0.75) : t < 0.909 ? (t = t - 0.9091, 7.5625 * t * t + 0.9375) : (t = t - 0.955, 7.5625 * t * t + 0.984375);
  }
  stop() {
    this.target.style.top = this._offset + "px", super.stop();
  }
}
class uF extends Wu {
  constructor(t) {
    super(t.target, t.duration), this._interval = t;
  }
  start() {
    super.start(), this._interval.start();
  }
  update(t) {
    super.update(t), this._interval.update(t);
  }
  stop() {
    super.stop(), this._interval.stop();
  }
}
class lF extends uF {
  constructor(t, e) {
    super(t), this._rate = e;
  }
}
class jrt extends lF {
  constructor(t, e) {
    super(t, e);
  }
  update(t) {
    this._interval.update(Math.pow(t, 1 / this._rate));
  }
}
class Xrt extends Wu {
  constructor(t, e, s, r, n, a) {
    super(t, e), this._deltaX = s, this._deltaY = r, this._height = -n, this._numJumps = a;
  }
  start() {
    super.start(), this._startX = this.target.offsetLeft, this._startY = this.target.offsetTop;
  }
  update(t) {
    super.update(t), this.target.style.left = this._startX + this._deltaX * t + "px", this.target.style.top = this._startY + this._height * Math.abs(Math.sin(t * Math.PI * this._numJumps)) + this._deltaY * t + "px";
  }
}
const ct = class ct {
  static get TIMER_TIME() {
    return 1e3 / P1();
  }
  static runMotion(t) {
    return ct._RUNNING_MOTIONS.indexOf(t) === -1 && ct._QUEUED_MOTIONS.indexOf(t) === -1 && (ct._IS_UPDATING ? ct._QUEUED_MOTIONS.push(t) : (ct._RUNNING_MOTIONS.push(t), t.start()), ct.startTimer()), t;
  }
  static removeMotion(t) {
    let e = ct._RUNNING_MOTIONS.indexOf(t);
    e > -1 ? ct._IS_UPDATING ? (e = ct._REMOVED_MOTIONS.indexOf(t), e == -1 && ct._REMOVED_MOTIONS.push(t)) : (ct._RUNNING_MOTIONS.splice(e, 1), t.running && t.stop(), ct._RUNNING_MOTIONS.length || ct.stopTimer()) : (e = ct._QUEUED_MOTIONS.indexOf(t), e > -1 && ct._QUEUED_MOTIONS.splice(e, 1));
  }
  static getMotionByTag(t) {
    for (const e of ct._RUNNING_MOTIONS)
      if (e.tag == t) return e;
    for (const e of ct._QUEUED_MOTIONS)
      if (e.tag == t) return e;
    return null;
  }
  static getMotionByTarget(t) {
    for (const e of ct._RUNNING_MOTIONS)
      if (e.target == t) return e;
    for (const e of ct._QUEUED_MOTIONS)
      if (e.target == t) return e;
    return null;
  }
  static getMotionByTagAndTarget(t, e) {
    for (const s of ct._RUNNING_MOTIONS)
      if (s.tag == t && s.target == e) return s;
    for (const s of ct._QUEUED_MOTIONS)
      if (s.tag == t && s.target == e) return s;
    return null;
  }
  static get isRunning() {
    return !!ct._TIMER;
  }
  static get isUpdating() {
    return ct._IS_UPDATING;
  }
  static onTick() {
    ct._IS_UPDATING = !0;
    const t = Nt();
    let e = null;
    for (; e = ct._QUEUED_MOTIONS.pop(); ) ct._RUNNING_MOTIONS.push(e);
    for (; e = ct._REMOVED_MOTIONS.pop(); )
      ct._RUNNING_MOTIONS.splice(ct._RUNNING_MOTIONS.indexOf(e), 1), e.running && e.stop();
    for (e of ct._RUNNING_MOTIONS)
      e.running ? (e.tick(t), e.complete && ct.removeMotion(e)) : ct.removeMotion(e);
    ct._RUNNING_MOTIONS.length || ct.stopTimer(), ct._IS_UPDATING = !1;
  }
  static startTimer() {
    ct._TIMER || (ct._TIMER = setInterval(() => ct.onTick(), ct.TIMER_TIME));
  }
  static stopTimer() {
    ct._TIMER && (clearInterval(ct._TIMER), ct._TIMER = null);
  }
  getNumRunningMotions(t) {
    let e = 0;
    for (const s of ct._RUNNING_MOTIONS)
      s.target === t && e++;
    return e;
  }
};
ct._QUEUED_MOTIONS = [], ct._RUNNING_MOTIONS = [], ct._REMOVED_MOTIONS = [], ct._TIMER = null, ct._IS_UPDATING = !1;
let sR = ct;
class cF extends Wu {
  constructor(t, e, s, r) {
    super(t, e), this._endX = s, this._endY = r;
  }
  start() {
    super.start(), this._startX = this.target.offsetLeft, this._startY = this.target.offsetTop, this._deltaX = this._endX - this._startX, this._deltaY = this._endY - this._startY;
  }
  update(t) {
    this.target.style.left = this._startX + this._deltaX * t + "px", this.target.style.top = this._startY + this._deltaY * t + "px";
  }
}
class Krt extends cF {
  constructor(t, e, s, r) {
    super(t, e, s, r);
  }
  start() {
    this._endX = this.target.offsetLeft + this._endX, this._endY = this.target.offsetTop + this._endY, super.start();
  }
}
class qrt extends sh {
  constructor(...t) {
    super(t ? t[0].target : null), this._queue = [];
    for (const e of t) this._queue.push(e);
    this._motion = t[0], this._complete = !this._motion;
  }
  get running() {
    return this._running && this._motion ? this._motion.running : !1;
  }
  start() {
    super.start(), this._motion.start();
  }
  update(t) {
    super.update(t), this._motion.running && this._motion.update(t);
  }
  stop() {
    super.stop(), this._motion.stop();
  }
  tick(t) {
    if (super.tick(t), this._motion.tick(t), this._motion.complete) {
      this._motion.stop();
      const e = this._queue.indexOf(this._motion);
      e < this._queue.length - 1 ? (this._motion = this._queue[e + 1], this._target = this._motion.target, this._motion.start()) : this._complete = !0;
    }
  }
}
class $rt extends Wu {
  constructor(t, e, s, r) {
    super(t, e), this._endW = s, this._endH = r;
  }
  start() {
    super.start(), this._startW = this.target.offsetWidth, this._startH = this.target.offsetHeight, this._deltaW = this._endW - this._startW, this._deltaH = this._endH - this._startH;
  }
  update(t) {
    this.target.style.width = this._startW + this._deltaW * t + "px", this.target.style.height = this._startH + this._deltaH * t + "px";
  }
}
class Zrt extends sh {
  constructor(t) {
    super(null), this._waitTimeMs = t;
  }
  get running() {
    return this._running;
  }
  start() {
    super.start(), this._complete = !1, this._startTimeMs = Nt();
  }
  tick(t) {
    super.tick(t), this._complete = t - this._startTimeMs >= this._waitTimeMs, this._complete && this.stop();
  }
}
var ca = {}, By = {}, Rr = {};
Object.defineProperty(Rr, "__esModule", {
  value: !0
});
Rr.loop = Rr.conditional = Rr.parse = void 0;
var _F = function i(t, e) {
  var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : s;
  if (Array.isArray(e))
    e.forEach(function(a) {
      return i(t, a, s, r);
    });
  else if (typeof e == "function")
    e(t, s, r, i);
  else {
    var n = Object.keys(e)[0];
    Array.isArray(e[n]) ? (r[n] = {}, i(t, e[n], s, r[n])) : r[n] = e[n](t, s, r, i);
  }
  return s;
};
Rr.parse = _F;
var dF = function(t, e) {
  return function(s, r, n, a) {
    e(s, r, n) && a(s, t, r, n);
  };
};
Rr.conditional = dF;
var fF = function(t, e) {
  return function(s, r, n, a) {
    for (var o = [], h = s.pos; e(s, r, n); ) {
      var u = {};
      if (a(s, t, r, u), s.pos === h)
        break;
      h = s.pos, o.push(u);
    }
    return o;
  };
};
Rr.loop = fF;
var Oe = {};
Object.defineProperty(Oe, "__esModule", {
  value: !0
});
Oe.readBits = Oe.readArray = Oe.readUnsigned = Oe.readString = Oe.peekBytes = Oe.readBytes = Oe.peekByte = Oe.readByte = Oe.buildStream = void 0;
var gF = function(t) {
  return {
    data: t,
    pos: 0
  };
};
Oe.buildStream = gF;
var ky = function() {
  return function(t) {
    return t.data[t.pos++];
  };
};
Oe.readByte = ky;
var pF = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  return function(e) {
    return e.data[e.pos + t];
  };
};
Oe.peekByte = pF;
var Hd = function(t) {
  return function(e) {
    return e.data.subarray(e.pos, e.pos += t);
  };
};
Oe.readBytes = Hd;
var mF = function(t) {
  return function(e) {
    return e.data.subarray(e.pos, e.pos + t);
  };
};
Oe.peekBytes = mF;
var EF = function(t) {
  return function(e) {
    return Array.from(Hd(t)(e)).map(function(s) {
      return String.fromCharCode(s);
    }).join("");
  };
};
Oe.readString = EF;
var TF = function(t) {
  return function(e) {
    var s = Hd(2)(e);
    return t ? (s[1] << 8) + s[0] : (s[0] << 8) + s[1];
  };
};
Oe.readUnsigned = TF;
var IF = function(t, e) {
  return function(s, r, n) {
    for (var a = typeof e == "function" ? e(s, r, n) : e, o = Hd(t), h = new Array(a), u = 0; u < a; u++)
      h[u] = o(s);
    return h;
  };
};
Oe.readArray = IF;
var SF = function(t, e, s) {
  for (var r = 0, n = 0; n < s; n++)
    r += t[e + n] && Math.pow(2, s - n - 1);
  return r;
}, AF = function(t) {
  return function(e) {
    for (var s = ky()(e), r = new Array(8), n = 0; n < 8; n++)
      r[7 - n] = !!(s & 1 << n);
    return Object.keys(t).reduce(function(a, o) {
      var h = t[o];
      return h.length ? a[o] = SF(r, h.index, h.length) : a[o] = r[h.index], a;
    }, {});
  };
};
Oe.readBits = AF;
(function(i) {
  Object.defineProperty(i, "__esModule", {
    value: !0
  }), i.default = void 0;
  var t = Rr, e = Oe, s = {
    blocks: function(_) {
      for (var d = 0, f = [], p = _.data.length, g = 0, m = (0, e.readByte)()(_); m !== d && m; m = (0, e.readByte)()(_)) {
        if (_.pos + m >= p) {
          var O = p - _.pos;
          f.push((0, e.readBytes)(O)(_)), g += O;
          break;
        }
        f.push((0, e.readBytes)(m)(_)), g += m;
      }
      for (var y = new Uint8Array(g), C = 0, b = 0; b < f.length; b++)
        y.set(f[b], C), C += f[b].length;
      return y;
    }
  }, r = (0, t.conditional)({
    gce: [{
      codes: (0, e.readBytes)(2)
    }, {
      byteSize: (0, e.readByte)()
    }, {
      extras: (0, e.readBits)({
        future: {
          index: 0,
          length: 3
        },
        disposal: {
          index: 3,
          length: 3
        },
        userInput: {
          index: 6
        },
        transparentColorGiven: {
          index: 7
        }
      })
    }, {
      delay: (0, e.readUnsigned)(!0)
    }, {
      transparentColorIndex: (0, e.readByte)()
    }, {
      terminator: (0, e.readByte)()
    }]
  }, function(l) {
    var _ = (0, e.peekBytes)(2)(l);
    return _[0] === 33 && _[1] === 249;
  }), n = (0, t.conditional)({
    image: [{
      code: (0, e.readByte)()
    }, {
      descriptor: [{
        left: (0, e.readUnsigned)(!0)
      }, {
        top: (0, e.readUnsigned)(!0)
      }, {
        width: (0, e.readUnsigned)(!0)
      }, {
        height: (0, e.readUnsigned)(!0)
      }, {
        lct: (0, e.readBits)({
          exists: {
            index: 0
          },
          interlaced: {
            index: 1
          },
          sort: {
            index: 2
          },
          future: {
            index: 3,
            length: 2
          },
          size: {
            index: 5,
            length: 3
          }
        })
      }]
    }, (0, t.conditional)({
      lct: (0, e.readArray)(3, function(l, _, d) {
        return Math.pow(2, d.descriptor.lct.size + 1);
      })
    }, function(l, _, d) {
      return d.descriptor.lct.exists;
    }), {
      data: [{
        minCodeSize: (0, e.readByte)()
      }, s]
    }]
  }, function(l) {
    return (0, e.peekByte)()(l) === 44;
  }), a = (0, t.conditional)({
    text: [{
      codes: (0, e.readBytes)(2)
    }, {
      blockSize: (0, e.readByte)()
    }, {
      preData: function(_, d, f) {
        return (0, e.readBytes)(f.text.blockSize)(_);
      }
    }, s]
  }, function(l) {
    var _ = (0, e.peekBytes)(2)(l);
    return _[0] === 33 && _[1] === 1;
  }), o = (0, t.conditional)({
    application: [{
      codes: (0, e.readBytes)(2)
    }, {
      blockSize: (0, e.readByte)()
    }, {
      id: function(_, d, f) {
        return (0, e.readString)(f.blockSize)(_);
      }
    }, s]
  }, function(l) {
    var _ = (0, e.peekBytes)(2)(l);
    return _[0] === 33 && _[1] === 255;
  }), h = (0, t.conditional)({
    comment: [{
      codes: (0, e.readBytes)(2)
    }, s]
  }, function(l) {
    var _ = (0, e.peekBytes)(2)(l);
    return _[0] === 33 && _[1] === 254;
  }), u = [
    {
      header: [{
        signature: (0, e.readString)(3)
      }, {
        version: (0, e.readString)(3)
      }]
    },
    {
      lsd: [{
        width: (0, e.readUnsigned)(!0)
      }, {
        height: (0, e.readUnsigned)(!0)
      }, {
        gct: (0, e.readBits)({
          exists: {
            index: 0
          },
          resolution: {
            index: 1,
            length: 3
          },
          sort: {
            index: 4
          },
          size: {
            index: 5,
            length: 3
          }
        })
      }, {
        backgroundColorIndex: (0, e.readByte)()
      }, {
        pixelAspectRatio: (0, e.readByte)()
      }]
    },
    (0, t.conditional)({
      gct: (0, e.readArray)(3, function(l, _) {
        return Math.pow(2, _.lsd.gct.size + 1);
      })
    }, function(l, _) {
      return _.lsd.gct.exists;
    }),
    // content frames
    {
      frames: (0, t.loop)([r, o, h, n, a], function(l) {
        var _ = (0, e.peekByte)()(l);
        return _ === 33 || _ === 44;
      })
    }
  ], c = u;
  i.default = c;
})(By);
var Yd = {};
Object.defineProperty(Yd, "__esModule", {
  value: !0
});
Yd.deinterlace = void 0;
var RF = function(t, e) {
  for (var s = new Array(t.length), r = t.length / e, n = function(_, d) {
    var f = t.slice(d * e, (d + 1) * e);
    s.splice.apply(s, [_ * e, e].concat(f));
  }, a = [0, 4, 2, 1], o = [8, 8, 4, 2], h = 0, u = 0; u < 4; u++)
    for (var c = a[u]; c < r; c += o[u])
      n(c, h), h++;
  return s;
};
Yd.deinterlace = RF;
var Wd = {};
Object.defineProperty(Wd, "__esModule", {
  value: !0
});
Wd.lzw = void 0;
var OF = function(t, e, s) {
  var r = 4096, n = -1, a = s, o, h, u, c, l, _, d, D, f, p, b, g, P, F, U, M, m = new Array(s), O = new Array(r), y = new Array(r), C = new Array(r + 1);
  for (g = t, h = 1 << g, l = h + 1, o = h + 2, d = n, c = g + 1, u = (1 << c) - 1, f = 0; f < h; f++)
    O[f] = 0, y[f] = f;
  var b, D, P, F, M, U;
  for (b = D = P = F = M = U = 0, p = 0; p < a; ) {
    if (F === 0) {
      if (D < c) {
        b += e[U] << D, D += 8, U++;
        continue;
      }
      if (f = b & u, b >>= c, D -= c, f > o || f == l)
        break;
      if (f == h) {
        c = g + 1, u = (1 << c) - 1, o = h + 2, d = n;
        continue;
      }
      if (d == n) {
        C[F++] = y[f], d = f, P = f;
        continue;
      }
      for (_ = f, f == o && (C[F++] = P, f = d); f > h; )
        C[F++] = y[f], f = O[f];
      P = y[f] & 255, C[F++] = P, o < r && (O[o] = d, y[o] = P, o++, !(o & u) && o < r && (c++, u += o)), d = _;
    }
    F--, m[M++] = C[F], p++;
  }
  for (p = M; p < a; p++)
    m[p] = 0;
  return m;
};
Wd.lzw = OF;
Object.defineProperty(ca, "__esModule", {
  value: !0
});
var zy = ca.decompressFrames = ca.decompressFrame = Vy = ca.parseGIF = void 0, yF = bF(By), vF = Rr, CF = Oe, xF = Yd, MF = Wd;
function bF(i) {
  return i && i.__esModule ? i : { default: i };
}
var PF = function(t) {
  var e = new Uint8Array(t);
  return (0, vF.parse)((0, CF.buildStream)(e), yF.default);
}, Vy = ca.parseGIF = PF, NF = function(t) {
  for (var e = t.pixels.length, s = new Uint8ClampedArray(e * 4), r = 0; r < e; r++) {
    var n = r * 4, a = t.pixels[r], o = t.colorTable[a] || [0, 0, 0];
    s[n] = o[0], s[n + 1] = o[1], s[n + 2] = o[2], s[n + 3] = a !== t.transparentIndex ? 255 : 0;
  }
  return s;
}, Hy = function(t, e, s) {
  if (!t.image) {
    console.warn("gif frame does not have associated image.");
    return;
  }
  var r = t.image, n = r.descriptor.width * r.descriptor.height, a = (0, MF.lzw)(r.data.minCodeSize, r.data.blocks, n);
  r.descriptor.lct.interlaced && (a = (0, xF.deinterlace)(a, r.descriptor.width));
  var o = {
    pixels: a,
    dims: {
      top: t.image.descriptor.top,
      left: t.image.descriptor.left,
      width: t.image.descriptor.width,
      height: t.image.descriptor.height
    }
  };
  return r.descriptor.lct && r.descriptor.lct.exists ? o.colorTable = r.lct : o.colorTable = e, t.gce && (o.delay = (t.gce.delay || 10) * 10, o.disposalType = t.gce.extras.disposal, t.gce.extras.transparentColorGiven && (o.transparentIndex = t.gce.transparentColorIndex)), s && (o.patch = NF(o)), o;
};
ca.decompressFrame = Hy;
var UF = function(t, e) {
  return t.frames.filter(function(s) {
    return s.image;
  }).map(function(s) {
    return Hy(s, t.gct, e);
  });
};
zy = ca.decompressFrames = UF;
const ph = class extends Ft {
  constructor(i, t) {
    super(W.EMPTY), this.animationSpeed = 1, this.loop = !0, this.duration = 0, this.autoPlay = !0, this.dirty = !1, this._currentFrame = 0, this._autoUpdate = !1, this._isConnectedToTicker = !1, this._playing = !1, this._currentTime = 0, this.onRender = () => this.updateFrame();
    const { scaleMode: e, width: s, height: r, ...n } = Object.assign(
      {},
      ph.defaultOptions,
      t
    ), a = Wt.get().createCanvas(s, r), o = a.getContext("2d");
    this.texture = W.from(a), this.texture.source.scaleMode = e, this.duration = i[i.length - 1].end, this._frames = i, this._context = o, this._playing = !1, this._currentTime = 0, this._isConnectedToTicker = !1, Object.assign(this, n), this.currentFrame = 0, n.autoPlay && this.play();
  }
  static fromBuffer(i, t) {
    if (!i || i.byteLength === 0)
      throw new Error("Invalid buffer");
    const e = (g) => {
      let m = null;
      for (const O of g.frames)
        m = O.gce ?? m, "image" in O && !("gce" in O) && (O.gce = m);
    }, s = Vy(i);
    e(s);
    const r = zy(s, !0), n = [], a = Wt.get().createCanvas(s.lsd.width, s.lsd.height), o = a.getContext("2d", {
      willReadFrequently: !0
    }), h = Wt.get().createCanvas(), u = h.getContext("2d");
    let c = 0, l = null;
    const { fps: _ } = Object.assign({}, ph.defaultOptions, t), d = 1e3 / _;
    for (let g = 0; g < r.length; g++) {
      const {
        disposalType: m = 2,
        delay: O = d,
        patch: y,
        dims: { width: C, height: b, left: D, top: P }
      } = r[g];
      h.width = C, h.height = b, u.clearRect(0, 0, C, b);
      const F = u.createImageData(C, b);
      F.data.set(y), u.putImageData(F, 0, 0), m === 3 && (l = o.getImageData(0, 0, a.width, a.height)), o.drawImage(h, D, P);
      const M = o.getImageData(0, 0, a.width, a.height);
      m === 2 ? o.clearRect(0, 0, a.width, a.height) : m === 3 && o.putImageData(l, 0, 0), n.push({
        start: c,
        end: c + O,
        imageData: M
      }), c += O;
    }
    a.width = a.height = 0, h.width = h.height = 0;
    const { width: f, height: p } = s.lsd;
    return new ph(n, { width: f, height: p, ...t });
  }
  stop() {
    this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (js.shared.remove(this.update, this), this._isConnectedToTicker = !1));
  }
  play() {
    this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (js.shared.add(this.update, this, Bl.HIGH), this._isConnectedToTicker = !0), !this.loop && this.currentFrame === this._frames.length - 1 && (this._currentTime = 0));
  }
  get progress() {
    return this._currentTime / this.duration;
  }
  get playing() {
    return this._playing;
  }
  update(i) {
    var n, a;
    if (!this._playing)
      return;
    const t = this.animationSpeed * i.deltaTime / js.targetFPMS, e = this._currentTime + t, s = e % this.duration, r = this._frames.findIndex((o) => o.start <= s && o.end > s);
    e >= this.duration ? this.loop ? (this._currentTime = s, this.updateFrameIndex(r), (n = this.onLoop) == null || n.call(this)) : (this._currentTime = this.duration, this.updateFrameIndex(this._frames.length - 1), (a = this.onComplete) == null || a.call(this), this.stop()) : (this._currentTime = s, this.updateFrameIndex(r));
  }
  updateFrame() {
    if (!this.dirty)
      return;
    const { imageData: i } = this._frames[this._currentFrame];
    this._context.putImageData(i, 0, 0), this._context.fillStyle = "transparent", this._context.fillRect(0, 0, 0, 1), this.texture.source.update(), this.dirty = !1;
  }
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(i) {
    i !== this._autoUpdate && (this._autoUpdate = i, !this._autoUpdate && this._isConnectedToTicker ? (js.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (js.shared.add(this.update, this), this._isConnectedToTicker = !0));
  }
  get currentFrame() {
    return this._currentFrame;
  }
  set currentFrame(i) {
    this.updateFrameIndex(i), this._currentTime = this._frames[i].start;
  }
  updateFrameIndex(i) {
    var t;
    if (i < 0 || i >= this._frames.length)
      throw new Error(`Frame index out of range, expecting 0 to ${this.totalFrames}, got ${i}`);
    this._currentFrame !== i && (this._currentFrame = i, this.dirty = !0, (t = this.onFrameChange) == null || t.call(this, i));
  }
  get totalFrames() {
    return this._frames.length;
  }
  destroy() {
    this.stop(), super.destroy(!0);
    const i = null;
    this._context = i, this._frames = i, this.onComplete = i, this.onFrameChange = i, this.onLoop = i;
  }
  clone() {
    const i = new ph([...this._frames], {
      autoUpdate: this._autoUpdate,
      loop: this.loop,
      autoPlay: this.autoPlay,
      scaleMode: this.texture.source.scaleMode,
      animationSpeed: this.animationSpeed,
      width: this._context.canvas.width,
      height: this._context.canvas.height,
      onComplete: this.onComplete,
      onFrameChange: this.onFrameChange,
      onLoop: this.onLoop
    });
    return i.dirty = !0, i;
  }
};
let $T = ph;
$T.defaultOptions = {
  scaleMode: "linear",
  fps: 30,
  loop: !0,
  animationSpeed: 1,
  autoPlay: !0,
  autoUpdate: !0,
  onComplete: null,
  onFrameChange: null,
  onLoop: null
};
const DF = {
  extension: B.Asset,
  detection: {
    test: async () => !0,
    add: async (i) => [...i, "gif"],
    remove: async (i) => i.filter((t) => t !== "gif")
  },
  loader: {
    name: "gifLoader",
    test: (i) => Ts.extname(i) === ".gif",
    load: async (i, t) => {
      const s = await (await Wt.get().fetch(i)).arrayBuffer();
      return $T.fromBuffer(s, t == null ? void 0 : t.data);
    },
    unload: async (i) => {
      i.destroy();
    }
  }
};
Ee.add(DF);
const Wn = class Wn {
  static createAsset(t, e, s, r, n, a = !1, o = !1, h = !1) {
    const u = Wn.GRAPHIC_POOL.length ? Wn.GRAPHIC_POOL.pop() : new Wn();
    return u._name = t, u._source = e || null, s ? (u._texture = s, u._initialized = !1) : (u._texture = null, u._initialized = !0), u._usesPalette = h, u._x = r, u._y = n, u._flipH = a, u._flipV = o, u._rectangle = null, u;
  }
  recycle() {
    this._texture = null, Wn.GRAPHIC_POOL.push(this);
  }
  initialize() {
    this._initialized || !this._texture || (this._width = this._texture.width, this._height = this._texture.height, this._initialized = !0);
  }
  get name() {
    return this._name;
  }
  get source() {
    return this._source;
  }
  get texture() {
    return this._texture;
  }
  get usesPalette() {
    return this._usesPalette;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  get width() {
    return this.initialize(), this._width;
  }
  get height() {
    return this.initialize(), this._height;
  }
  get offsetX() {
    return this._flipH ? -this._x : this._x;
  }
  get offsetY() {
    return this._flipV ? -this._y : this._y;
  }
  get flipH() {
    return this._flipH;
  }
  get flipV() {
    return this._flipV;
  }
  get rectangle() {
    return this._rectangle || (this._rectangle = new Kt(0, 0, this.width, this.height)), this._rectangle;
  }
};
Wn.GRAPHIC_POOL = [];
let $g = Wn;
class LF {
  constructor(t, e, s) {
    for (this._palette = t; this._palette.length < 256; ) this._palette.push([0, 0, 0]);
    this._primaryColor = e, this._secondaryColor = s;
  }
  applyPalette(t) {
    const e = ma().texture.generateCanvas(t), s = e.getContext("2d"), r = s.getImageData(0, 0, e.width, e.height);
    for (let a = 0; a < r.data.length; a += 4) {
      let o = this._palette[r.data[a + 1]];
      o === void 0 && (o = [0, 0, 0]), r.data[a] = o[0], r.data[a + 1] = o[1], r.data[a + 2] = o[2];
    }
    s.putImageData(r, 0, 0);
    const n = W.from(e);
    return n.source.hitMap = r.data, n;
  }
  get primaryColor() {
    return this._primaryColor;
  }
  get secondaryColor() {
    return this._secondaryColor;
  }
}
const kh = class kh {
  constructor(t, e) {
    if (!t) throw new Error("invalid_collection");
    this._name = t.name, this._textureSource = e && e.textureSource || null, this._data = t, this._textures = /* @__PURE__ */ new Map(), this._assets = /* @__PURE__ */ new Map(), this._palettes = /* @__PURE__ */ new Map(), this._paletteAssetNames = [], e && this.addLibraryAsset(e.textures), this.define(t);
  }
  static removeFileExtension(t) {
    return t.substring(0, t.lastIndexOf(".")) || t;
  }
  dispose() {
    if (this._palettes && this._palettes.clear(), this._paletteAssetNames && (this.disposePaletteAssets(), this._paletteAssetNames = null), this._assets) {
      for (const t of this._assets.values()) t.recycle();
      this._assets.clear();
    }
  }
  addReference() {
    this._referenceCount++;
  }
  removeReference() {
    this._referenceCount--, this._referenceCount <= 0 && (this._referenceCount = 0, this.disposePaletteAssets(!1));
  }
  define(t) {
    const e = t.assets, s = t.palettes;
    e && this.defineAssets(e), s && this.definePalettes(s);
  }
  defineAssets(t) {
    if (t)
      for (const e in t) {
        const s = t[e];
        if (!s) continue;
        const r = -s.x || 0, n = -s.y || 0;
        let a = !1;
        const o = !1, h = s.usesPalette || !1;
        let u = s.source || "";
        s.flipH && u.length && (a = !0), u.length || (u = e);
        const c = this.getLibraryAsset(u);
        if (!c) continue;
        let l = this.createAsset(e, u, c, a, o, r, n, h);
        if (!l) {
          const _ = this.getAsset(e);
          _ && _.name !== _.source && (l = this.replaceAsset(e, u, c, a, o, r, n, h));
        }
      }
  }
  definePalettes(t) {
    if (t)
      for (const e in t) {
        const s = t[e];
        if (!s) continue;
        const r = s.id.toString();
        if (this._palettes.get(r)) continue;
        let n = 16777215, a = 16777215, o = s.color1;
        o && o.length > 0 && (n = parseInt(o, 16)), o = s.color2, o && o.length > 0 && (a = parseInt(o, 16)), this._palettes.set(r, new LF(s.rgb, n, a));
      }
  }
  createAsset(t, e, s, r, n, a, o, h) {
    if (this._assets.get(t)) return !1;
    const u = $g.createAsset(t, e, s, a, o, r, n, h);
    return this._assets.set(t, u), !0;
  }
  replaceAsset(t, e, s, r, n, a, o, h) {
    const u = this._assets.get(t);
    return u && (this._assets.delete(t), u.recycle()), this.createAsset(t, e, s, r, n, a, o, h);
  }
  getAsset(t) {
    if (!t) return null;
    const e = this._assets.get(t);
    return e || null;
  }
  getAssetWithPalette(t, e) {
    const s = t + "@" + e;
    let r = this.getAsset(s);
    if (!r) {
      if (r = this.getAsset(t), !r || !r.usesPalette) return r;
      const n = this.getPalette(e);
      if (n) {
        const a = n.applyPalette(r.texture);
        a && (this._paletteAssetNames.push(s), this.createAsset(s, r.source + "@" + e, a, r.flipH, r.flipV, r.x, r.y, !1), r = this.getAsset(s));
      }
    }
    return r;
  }
  getTexture(t) {
    return this._textures.get(t);
  }
  getPaletteNames() {
    return Array.from(this._palettes.keys());
  }
  getPaletteColors(t) {
    const e = this.getPalette(t);
    return e ? [e.primaryColor, e.secondaryColor] : null;
  }
  getPalette(t) {
    return t ? this._palettes.get(t) : null;
  }
  addAsset(t, e, s, r = 0, n = 0, a = !1, o = !1) {
    if (!t || !e) return !1;
    const h = this.getLibraryAsset(t);
    return h ? s ? (h.source = e.source, h.frame = e.frame, h.trim = e.trim, h.updateUvs(), !0) : !1 : (this._textures.set(t, e), this.createAsset(t, t, e, a, o, r, n, !1));
  }
  disposeAsset(t) {
    const e = this._assets.get(t);
    if (!e) return;
    this._assets.delete(t);
    const s = this.getLibraryAsset(e.source);
    s && (this._textures.delete(e.source), s.destroy(!0)), e.recycle();
  }
  getLibraryAsset(t) {
    if (!t) return null;
    t = this._name + "_" + t;
    const e = this._textures.get(t);
    return e || null;
  }
  addLibraryAsset(t) {
    if (t)
      for (const e in t) {
        const s = t[e];
        s && this._textures.set(kh.removeFileExtension(e), s);
      }
  }
  disposePaletteAssets(t = !0) {
    if (this._paletteAssetNames && (t || this._paletteAssetNames.length > kh.PALETTE_ASSET_DISPOSE_THRESHOLD)) {
      for (const e of this._paletteAssetNames) this.disposeAsset(e);
      this._paletteAssetNames = [];
    }
  }
  get referenceCount() {
    return this._referenceCount;
  }
  get name() {
    return this._name;
  }
  get textureSource() {
    return this._textureSource;
  }
  get data() {
    return this._data;
  }
  get textures() {
    return this._textures;
  }
  get assets() {
    return this._assets;
  }
};
kh.PALETTE_ASSET_DISPOSE_THRESHOLD = 10;
let Zg = kh;
class FF {
  constructor() {
    this._textures = /* @__PURE__ */ new Map(), this._collections = /* @__PURE__ */ new Map();
  }
  getTexture(t) {
    return t ? this._textures.get(t) : null;
  }
  setTexture(t, e) {
    !t || !e || (e.label = t, this._textures.set(t, e));
  }
  getAsset(t) {
    if (!t) return null;
    for (const e of this._collections.values()) {
      if (!e) continue;
      const s = e.getAsset(t);
      if (s)
        return s;
    }
    return rt.warn(`AssetManager: Asset not found: ${t}`), null;
  }
  addAssetToCollection(t, e, s, r = !0) {
    const n = this.getCollection(t);
    return n ? n.addAsset(e, s, r, 0, 0, !1, !1) : !1;
  }
  getCollection(t) {
    return t ? this._collections.get(t) ?? null : null;
  }
  createCollection(t, e) {
    if (!t) return null;
    const s = new Zg(t, e);
    for (const [r, n] of s.textures.entries()) this.setTexture(r, n);
    return this._collections.set(s.name, s), s;
  }
  async downloadAssets(t) {
    if (!t || !t.length) return Promise.resolve(!0);
    try {
      return await Promise.all(t.map((e) => this.downloadAsset(e))), !0;
    } catch (e) {
      rt.error(e);
    }
    return !1;
  }
  async downloadAsset(t) {
    try {
      if (!t || !t.length) return !1;
      if (t.endsWith(".nitro") || t.endsWith(".gif")) {
        const e = await fetch(t);
        if (!e || e.status !== 200) return !1;
        const s = await e.arrayBuffer();
        if (t.endsWith(".nitro")) {
          const r = await Xg.from(s);
          await this.processAsset(r.texture, r.jsonFile);
        } else {
          const n = $T.fromBuffer(s).texture;
          n && this.setTexture(t, n);
        }
      } else {
        const e = await ra.load(t);
        e && this.setTexture(t, e);
      }
      return !0;
    } catch (e) {
      return rt.error(e), !1;
    }
  }
  async processAsset(t, e) {
    let s = null;
    t && (e != null && e.spritesheet) && Object.keys(e.spritesheet).length && (s = new hg(t, e.spritesheet), await s.parse(), s.textureSource.label = e.name ?? null), this.createCollection(e, s);
  }
  get collections() {
    return this._collections;
  }
}
ra.init();
const wF = new FF(), Rt = () => wF;
class GF {
  constructor() {
    this._listeners = /* @__PURE__ */ new Map();
  }
  dispose() {
    this.removeAllListeners();
  }
  addEventListener(t, e) {
    if (!t || !e) return;
    const s = this._listeners.get(t);
    if (!s) {
      this._listeners.set(t, [e]);
      return;
    }
    rt.events("Added Event Listener", t), s.push(e);
  }
  removeEventListener(t, e) {
    if (!t || !e) return;
    const s = this._listeners.get(t);
    if (!(!s || !s.length)) {
      for (const [r, n] of s.entries())
        if (!(!n || n !== e)) {
          s.splice(r, 1), s.length || this._listeners.delete(t);
          return;
        }
    }
  }
  dispatchEvent(t) {
    return t ? (rt.events("Dispatched Event", t.type), this.processEvent(t), !0) : !1;
  }
  processEvent(t) {
    const e = this._listeners.get(t.type);
    if (!e || !e.length) return;
    const s = [];
    for (const r of e)
      r && s.push(r);
    for (; s.length; ) {
      const r = s.shift();
      try {
        r(t);
      } catch (n) {
        rt.error(n.stack);
        return;
      }
    }
  }
  removeAllListeners() {
    this._listeners.clear();
  }
}
const BF = new GF(), x = () => BF, Qe = class Qe {
};
Qe.CONFIG_LOADED = "CONFIG_LOADED", Qe.CONFIG_FAILED = "CONFIG_FAILED", Qe.LOCALIZATION_LOADED = "LOCALIZATION_LOADED", Qe.LOCALIZATION_FAILED = "LOCALIZATION_FAILED", Qe.SOCKET_OPENED = "SOCKET_OPENED", Qe.SOCKET_CLOSED = "SOCKET_CLOSED", Qe.SOCKET_ERROR = "SOCKET_ERROR", Qe.SOCKET_CONNECTED = "SOCKET_CONNECTED", Qe.AVATAR_ASSET_DOWNLOADED = "AVATAR_ASSET_DOWNLOADED", Qe.AVATAR_ASSET_LOADED = "AVATAR_ASSET_LOADED", Qe.AVATAR_EFFECT_DOWNLOADED = "AVATAR_EFFECT_DOWNLOADED", Qe.AVATAR_EFFECT_LOADED = "AVATAR_EFFECT_LOADED", Qe.FURNITURE_DATA_LOADED = "FURNITURE_DATA_LOADED";
let Ze = Qe;
class qt {
  constructor(t) {
    this._type = t;
  }
  get type() {
    return this._type;
  }
}
const h_ = class h_ extends qt {
  constructor(t) {
    super(t);
  }
};
h_.LOADED = "NCE_LOADED", h_.FAILED = "NCE_FAILED";
let iR = h_;
class A {
  constructor(t, e) {
    this._callBack = t, this._parserClass = e, this._parser = null, this._connection = null;
  }
  dispose() {
    this._callBack = null, this._parserClass = null, this._parser = null, this._connection = null;
  }
  get callBack() {
    return this._callBack;
  }
  get parserClass() {
    return this._parserClass;
  }
  get parser() {
    return this._parser;
  }
  set parser(t) {
    this._parser = t;
  }
  get connection() {
    return this._connection;
  }
  set connection(t) {
    this._connection = t;
  }
}
const no = class no extends qt {
  constructor(t, e, s) {
    super(t), this._connection = e, this._originalEvent = event;
  }
  get connection() {
    return this._connection;
  }
  get originalEvent() {
    return this._originalEvent;
  }
};
no.CONNECTION_OPENED = "SCE_OPEN", no.CONNECTION_CLOSED = "SCE_CLOSED", no.CONNECTION_ERROR = "SCE_ERROR", no.CONNECTION_MESSAGE = "SCE_MESSAGE";
let rR = no;
const zh = class zh extends qt {
  constructor() {
    super(zh.SETTINGS_UPDATED);
  }
  clone() {
    const t = new zh();
    return t._volumeSystem = this._volumeSystem, t._volumeFurni = this._volumeFurni, t._volumeTrax = this._volumeTrax, t._oldChat = this._oldChat, t._roomInvites = this._roomInvites, t._cameraFollow = this._cameraFollow, t._flags = this._flags, t._chatType = this._chatType, t;
  }
  get volumeSystem() {
    return this._volumeSystem;
  }
  set volumeSystem(t) {
    this._volumeSystem = t;
  }
  get volumeFurni() {
    return this._volumeFurni;
  }
  set volumeFurni(t) {
    this._volumeFurni = t;
  }
  get volumeTrax() {
    return this._volumeTrax;
  }
  set volumeTrax(t) {
    this._volumeTrax = t;
  }
  get oldChat() {
    return this._oldChat;
  }
  set oldChat(t) {
    this._oldChat = t;
  }
  get roomInvites() {
    return this._roomInvites;
  }
  set roomInvites(t) {
    this._roomInvites = t;
  }
  get cameraFollow() {
    return this._cameraFollow;
  }
  set cameraFollow(t) {
    this._cameraFollow = t;
  }
  get flags() {
    return this._flags;
  }
  set flags(t) {
    this._flags = t;
  }
  get chatType() {
    return this._chatType;
  }
  set chatType(t) {
    this._chatType = t;
  }
};
zh.SETTINGS_UPDATED = "NSE_SETTINGS_UPDATED";
let Mu = zh;
const RI = class RI extends qt {
  constructor(t, e) {
    super(t), this._sampleCode = e;
  }
  get sampleCode() {
    return this._sampleCode;
  }
};
RI.PLAY_SOUND = "NSOE_PLAY_SOUND";
let nc = RI;
const u_ = class u_ extends qt {
  constructor(t) {
    super(t);
  }
  get iconId() {
    return this._iconId;
  }
  set iconId(t) {
    this._iconId = t;
  }
  get iconName() {
    return this._iconName;
  }
  set iconName(t) {
    this._iconName = t;
  }
};
u_.TOOLBAR_CLICK = "NTE_TOOLBAR_CLICK", u_.SELECT_OWN_AVATAR = "NTE_SELECT_OWN_AVATAR";
let Qg = u_;
const l_ = class l_ extends Qg {
  constructor(t, e, s) {
    super(l_.ANIMATE_ICON), this._image = t, this._x = e, this._y = s;
  }
  get image() {
    return this._image;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
};
l_.ANIMATE_ICON = "NTAIE_ANIMATE_ICON";
let ac = l_;
const OI = class OI extends qt {
  constructor(t, e) {
    super(t), this._library = e;
  }
  get library() {
    return this._library;
  }
};
OI.DOWNLOAD_COMPLETE = "ARELE_DOWNLOAD_COMPLETE";
let Jg = OI;
const yI = class yI extends qt {
  constructor(t, e) {
    super(t), this._library = e;
  }
  get library() {
    return this._library;
  }
};
yI.DOWNLOAD_COMPLETE = "ARLE_DOWNLOAD_COMPLETE";
let tp = yI;
const vI = class vI extends qt {
  constructor(t) {
    super(t);
  }
};
vI.INITIALIZED = "RCWM_INITIALIZED";
let oc = vI;
const ir = class ir extends qt {
  constructor(t, e) {
    super(t), this._connection = e;
  }
  get connection() {
    return this._connection;
  }
};
ir.CONNECTION_ESTABLISHED = "NCE_ESTABLISHED", ir.CONNECTION_CLOSED = "NCE_CLOSED", ir.CONNECTION_ERROR = "NCE_ERROR", ir.CONNECTION_HANDSHAKING = "NCE_HANDSHAKING", ir.CONNECTION_HANDSHAKED = "NCE_HANDSHAKED", ir.CONNECTION_HANDSHAKE_FAILED = "NCE_HANDSHAKE_FAILED", ir.CONNECTION_AUTHENTICATED = "NCE_AUTHENTICATED";
let nR = ir;
const rr = class rr extends qt {
  constructor(t, e) {
    super(t), this._roomId = e;
  }
  get roomId() {
    return this._roomId;
  }
};
rr.INITIALIZED = "REE_INITIALIZED", rr.ENGINE_INITIALIZED = "REE_ENGINE_INITIALIZED", rr.OBJECTS_INITIALIZED = "REE_OBJECTS_INITIALIZED", rr.NORMAL_MODE = "REE_NORMAL_MODE", rr.GAME_MODE = "REE_GAME_MODE", rr.ROOM_ZOOMED = "REE_ROOM_ZOOMED", rr.DISPOSED = "REE_DISPOSED";
let ae = rr;
const c_ = class c_ extends ae {
  constructor(t, e, s, r) {
    super(c_.ROOM_COLOR, t), this._color = e, this._brightness = s, this._bgOnly = r;
  }
  get color() {
    return this._color;
  }
  get brightness() {
    return this._brightness;
  }
  get bgOnly() {
    return this._bgOnly;
  }
};
c_.ROOM_COLOR = "REE_ROOM_COLOR";
let ep = c_;
const Vh = class Vh extends qt {
  constructor(t, e) {
    super(t), this._contentType = e;
  }
  get contentType() {
    return this._contentType;
  }
};
Vh.RCLE_SUCCESS = "RCLE_SUCCESS", Vh.RCLE_FAILURE = "RCLE_FAILURE", Vh.RCLE_CANCEL = "RCLE_CANCEL";
let bs = Vh;
const __ = class __ extends ae {
  constructor(t, e, s) {
    super(__.ROOM_DRAG, t), this._offsetX = e, this._offsetY = s;
  }
  get offsetX() {
    return this._offsetX;
  }
  get offsetY() {
    return this._offsetY;
  }
};
__.ROOM_DRAG = "RDE_ROOM_DRAG";
let sp = __;
const Je = class Je extends ae {
  constructor(t, e, s, r) {
    super(t, e), this._objectId = s, this._category = r;
  }
  get objectId() {
    return this._objectId;
  }
  get category() {
    return this._category;
  }
};
Je.SELECTED = "REOE_SELECTED", Je.DESELECTED = "REOE_DESELECTED", Je.ADDED = "REOE_ADDED", Je.REMOVED = "REOE_REMOVED", Je.PLACED = "REOE_PLACED", Je.PLACED_ON_USER = "REOE_PLACED_ON_USER", Je.CONTENT_UPDATED = "REOE_CONTENT_UPDATED", Je.REQUEST_MOVE = "REOE_REQUEST_MOVE", Je.REQUEST_ROTATE = "REOE_REQUEST_ROTATE", Je.REQUEST_MANIPULATION = "REOE_REQUEST_MANIPULATION", Je.MOUSE_ENTER = "REOE_MOUSE_ENTER", Je.MOUSE_LEAVE = "REOE_MOUSE_LEAVE", Je.DOUBLE_CLICK = "REOE_DOUBLE_CLICK";
let lt = Je;
const Lt = class Lt extends lt {
  constructor(t, e, s, r, n = null) {
    super(t, e, s, r), this._widget = n;
  }
  get widget() {
    return this._widget;
  }
  get contextMenu() {
    return this._widget;
  }
};
Lt.OPEN_WIDGET = "RETWE_OPEN_WIDGET", Lt.CLOSE_WIDGET = "RETWE_CLOSE_WIDGET", Lt.OPEN_FURNI_CONTEXT_MENU = "RETWE_OPEN_FURNI_CONTEXT_MENU", Lt.CLOSE_FURNI_CONTEXT_MENU = "RETWE_CLOSE_FURNI_CONTEXT_MENU", Lt.REQUEST_PLACEHOLDER = "RETWE_REQUEST_PLACEHOLDER", Lt.REQUEST_CREDITFURNI = "RETWE_REQUEST_CREDITFURNI", Lt.REQUEST_STACK_HEIGHT = "RETWE_REQUEST_STACK_HEIGHT", Lt.REQUEST_EXTERNAL_IMAGE = "RETWE_REQUEST_EXTERNAL_IMAGE", Lt.REQUEST_STICKIE = "RETWE_REQUEST_STICKIE", Lt.REQUEST_PRESENT = "RETWE_REQUEST_PRESENT", Lt.REQUEST_TROPHY = "RETWE_REQUEST_TROPHY", Lt.REQUEST_TEASER = "RETWE_REQUEST_TEASER", Lt.REQUEST_ECOTRONBOX = "RETWE_REQUEST_ECOTRONBOX", Lt.REQUEST_DIMMER = "RETWE_REQUEST_DIMMER", Lt.REMOVE_DIMMER = "RETWE_REMOVE_DIMMER", Lt.REQUEST_CLOTHING_CHANGE = "RETWE_REQUEST_CLOTHING_CHANGE", Lt.REQUEST_PLAYLIST_EDITOR = "RETWE_REQUEST_PLAYLIST_EDITOR", Lt.REQUEST_MANNEQUIN = "RETWE_REQUEST_MANNEQUIN", Lt.REQUEST_MONSTERPLANT_SEED_PLANT_CONFIRMATION_DIALOG = "ROWRE_REQUEST_MONSTERPLANT_SEED_PLANT_CONFIRMATION_DIALOG", Lt.REQUEST_PURCHASABLE_CLOTHING_CONFIRMATION_DIALOG = "ROWRE_REQUEST_PURCHASABLE_CLOTHING_CONFIRMATION_DIALOG", Lt.REQUEST_BACKGROUND_COLOR = "RETWE_REQUEST_BACKGROUND_COLOR", Lt.REQUEST_AREA_HIDE = "RETWE_REQUEST_AREA_HIDE", Lt.REQUEST_MYSTERYBOX_OPEN_DIALOG = "RETWE_REQUEST_MYSTERYBOX_OPEN_DIALOG", Lt.REQUEST_EFFECTBOX_OPEN_DIALOG = "RETWE_REQUEST_EFFECTBOX_OPEN_DIALOG", Lt.REQUEST_MYSTERYTROPHY_OPEN_DIALOG = "RETWE_REQUEST_MYSTERYTROPHY_OPEN_DIALOG", Lt.REQUEST_ACHIEVEMENT_RESOLUTION_ENGRAVING = "RETWE_REQUEST_ACHIEVEMENT_RESOLUTION_ENGRAVING", Lt.REQUEST_ACHIEVEMENT_RESOLUTION_FAILED = "RETWE_REQUEST_ACHIEVEMENT_RESOLUTION_FAILED", Lt.REQUEST_FRIEND_FURNITURE_CONFIRM = "RETWE_REQUEST_FRIEND_FURNITURE_CONFIRM", Lt.REQUEST_FRIEND_FURNITURE_ENGRAVING = "RETWE_REQUEST_FRIEND_FURNITURE_ENGRAVING", Lt.REQUEST_BADGE_DISPLAY_ENGRAVING = "RETWE_REQUEST_BADGE_DISPLAY_ENGRAVING", Lt.REQUEST_HIGH_SCORE_DISPLAY = "RETWE_REQUEST_HIGH_SCORE_DISPLAY", Lt.REQUEST_HIDE_HIGH_SCORE_DISPLAY = "RETWE_REQUEST_HIDE_HIGH_SCORE_DISPLAY", Lt.REQUEST_INTERNAL_LINK = "RETWE_REQUEST_INTERNAL_LINK", Lt.REQUEST_ROOM_LINK = "RETWE_REQUEST_ROOM_LINK", Lt.REQUEST_YOUTUBE = "RETWE_REQUEST_YOUTUBE";
let Q = Lt;
const d_ = class d_ extends Q {
  constructor(t, e, s, r) {
    super(d_.UPDATE_STATE_AREA_HIDE, t, e, s), this._isOn = r;
  }
  get isOn() {
    return this._isOn;
  }
};
d_.UPDATE_STATE_AREA_HIDE = "REAHSE_UPDATE_STATE_AREA_HIDE";
let ip = d_;
const f_ = class f_ extends ae {
  constructor(t, e, s, r, n, a) {
    super(f_.ROOM_COLOR, t), this._state = e, this._presetId = s, this._effectId = r, this._color = n, this._brightness = a;
  }
  get state() {
    return this._state;
  }
  get presetId() {
    return this._presetId;
  }
  get effectId() {
    return this._effectId;
  }
  get color() {
    return this._color;
  }
  get brightness() {
    return this._brightness;
  }
};
f_.ROOM_COLOR = "REDSE_ROOM_COLOR";
let rp = f_;
class kF extends lt {
  constructor(t, e, s, r, n, a, o, h, u, c, l, _, d) {
    super(t, e, s, r), this._wallLocation = "", this._x = 0, this._y = 0, this._z = 0, this._direction = 0, this._placedInRoom = !1, this._placedOnFloor = !1, this._placedOnWall = !1, this._instanceData = null, this._wallLocation = n, this._x = a, this._y = o, this._z = h, this._direction = u, this._placedInRoom = c, this._placedOnFloor = l, this._placedOnWall = _, this._instanceData = d;
  }
  get wallLocation() {
    return this._wallLocation;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  get z() {
    return this._z;
  }
  get direction() {
    return this._direction;
  }
  get placedInRoom() {
    return this._placedInRoom;
  }
  get placedOnFloor() {
    return this._placedOnFloor;
  }
  get placedOnWall() {
    return this._placedOnWall;
  }
  get instanceData() {
    return this._instanceData;
  }
}
class zF extends lt {
  constructor(t, e, s, r, n, a) {
    super(t, e, s, r), this._droppedObjectId = n, this._droppedObjectCategory = a;
  }
  get droppedObjectId() {
    return this._droppedObjectId;
  }
  get droppedObjectCategory() {
    return this._droppedObjectCategory;
  }
}
const g_ = class g_ extends lt {
  constructor(t, e, s, r, n, a = 1) {
    super(t, e, s, r), this._soundId = n, this._pitch = a;
  }
  get soundId() {
    return this._soundId;
  }
  get pitch() {
    return this._pitch;
  }
};
g_.PLAY_SOUND = "REOPSE_PLAY_SOUND", g_.PLAY_SOUND_AT_PITCH = "REOPSE_PLAY_SOUND_AT_PITCH";
let Ha = g_;
const ao = class ao extends lt {
};
ao.FURNI_CLICK = "RERAE_FURNI_CLICK", ao.FURNI_DOUBLE_CLICK = "RERAE_FURNI_DOUBLE_CLICK", ao.TOOLTIP_SHOW = "RERAE_TOOLTIP_SHOW", ao.TOOLTIP_HIDE = "RERAE_TOOLTIP_HIDE";
let Ya = ao;
const oo = class oo extends lt {
  constructor(t, e, s, r, n, a = 1) {
    super(t, e, s, r), this._sampleId = n, this._pitch = a;
  }
  get sampleId() {
    return this._sampleId;
  }
  get pitch() {
    return this._pitch;
  }
};
oo.ROOM_OBJECT_INITIALIZED = "ROPSPE_ROOM_OBJECT_INITIALIZED", oo.ROOM_OBJECT_DISPOSED = "ROPSPE_ROOM_OBJECT_DISPOSED", oo.PLAY_SAMPLE = "ROPSPE_PLAY_SAMPLE", oo.CHANGE_PITCH = "ROPSPE_CHANGE_PITCH";
let Ws = oo;
const p_ = class p_ extends lt {
  constructor(t, e, s, r, n = -1, a = -1) {
    super(t, e, s, r), this._inventoryStripId = n, this._furnitureTypeId = a;
  }
  get inventoryStripId() {
    return this._inventoryStripId;
  }
  get furnitureTypeId() {
    return this._furnitureTypeId;
  }
};
p_.USE_PRODUCT_FROM_ROOM = "REUPE_USE_PRODUCT_FROM_ROOM", p_.USE_PRODUCT_FROM_INVENTORY = "REUPE_USE_PRODUCT_FROM_INVENTORY";
let hc = p_;
class ti extends qt {
  constructor(t, e) {
    super(t), this._object = e;
  }
  get object() {
    return this._object;
  }
  get objectId() {
    return this._object ? this._object.id : -1;
  }
  get objectType() {
    return this._object ? this._object.type : null;
  }
}
const CI = class CI extends ti {
  constructor(t, e, s, r = !0) {
    super(t, e), this._badgeId = s, this._groupBadge = r;
  }
  get badgeId() {
    return this._badgeId;
  }
  get groupBadge() {
    return this._groupBadge;
  }
};
CI.LOAD_BADGE = "ROBAE_LOAD_BADGE";
let di = CI;
const m_ = class m_ extends ti {
  constructor(t, e) {
    super(t, e);
  }
};
m_.RODRE_CURRENT_USER_ID = "RODRE_CURRENT_USER_ID", m_.RODRE_URL_PREFIX = "RODRE_URL_PREFIX";
let qs = m_;
const E_ = class E_ extends ti {
  constructor(t, e, s, r, n, a) {
    super(E_.DIMMER_STATE, t), this._state = e, this._presetId = s, this._effectId = r, this._color = n, this._brightness = a;
  }
  get state() {
    return this._state;
  }
  get presetId() {
    return this._presetId;
  }
  get effectId() {
    return this._effectId;
  }
  get color() {
    return this._color;
  }
  get brightness() {
    return this._brightness;
  }
};
E_.DIMMER_STATE = "RODSUE_DIMMER_STATE";
let _a = E_;
const T_ = class T_ extends ti {
  constructor(t, e) {
    super(t, e);
  }
};
T_.ADD_HOLE = "ROFHO_ADD_HOLE", T_.REMOVE_HOLE = "ROFHO_REMOVE_HOLE";
let Ke = T_;
const ze = class ze extends ti {
};
ze.DICE_OFF = "ROFCAE_DICE_OFF", ze.DICE_ACTIVATE = "ROFCAE_DICE_ACTIVATE", ze.USE_HABBOWHEEL = "ROFCAE_USE_HABBOWHEEL", ze.STICKIE = "ROFCAE_STICKIE", ze.ENTER_ONEWAYDOOR = "ROFCAE_ENTER_ONEWAYDOOR", ze.SOUND_MACHINE_INIT = "ROFCAE_SOUND_MACHINE_INIT", ze.SOUND_MACHINE_START = "ROFCAE_SOUND_MACHINE_START", ze.SOUND_MACHINE_STOP = "ROFCAE_SOUND_MACHINE_STOP", ze.SOUND_MACHINE_DISPOSE = "ROFCAE_SOUND_MACHINE_DISPOSE", ze.JUKEBOX_INIT = "ROFCAE_JUKEBOX_INIT", ze.JUKEBOX_START = "ROFCAE_JUKEBOX_START", ze.JUKEBOX_MACHINE_STOP = "ROFCAE_JUKEBOX_MACHINE_STOP", ze.JUKEBOX_DISPOSE = "ROFCAE_JUKEBOX_DISPOSE", ze.MOUSE_BUTTON = "ROFCAE_MOUSE_BUTTON", ze.MOUSE_ARROW = "ROFCAE_MOUSE_ARROW";
let z = ze;
const xI = class xI extends ti {
  constructor(t, e, s, r, n, a) {
    super(t, e), this._enable = s, this._hue = r, this._saturation = n, this._lightness = a;
  }
  get enable() {
    return this._enable;
  }
  get hue() {
    return this._hue;
  }
  get saturation() {
    return this._saturation;
  }
  get lightness() {
    return this._lightness;
  }
};
xI.ROOM_BACKGROUND_COLOR = "ROHSLCEE_ROOM_BACKGROUND_COLOR";
let gr = xI;
const MI = class MI extends ae {
  constructor(t, e, s, r, n, a) {
    super(t, e), this._enable = s, this._hue = r, this._saturation = n, this._lightness = a;
  }
  get enable() {
    return this._enable;
  }
  get hue() {
    return this._hue;
  }
  get saturation() {
    return this._saturation;
  }
  get lightness() {
    return this._lightness;
  }
};
MI.ROOM_BACKGROUND_COLOR = "ROHSLCEE_ROOM_BACKGROUND_COLOR";
let uc = MI;
const yi = class yi extends ti {
  constructor(t, e, s, r = !1, n = !1, a = !1, o = !1) {
    super(t, e), this._eventId = "", this._eventId = s, this._altKey = r, this._ctrlKey = n, this._shiftKey = a, this._buttonDown = o;
  }
  get eventId() {
    return this._eventId;
  }
  get altKey() {
    return this._altKey;
  }
  get ctrlKey() {
    return this._ctrlKey;
  }
  get shiftKey() {
    return this._shiftKey;
  }
  get buttonDown() {
    return this._buttonDown;
  }
  get localX() {
    return this._localX;
  }
  set localX(t) {
    this._localX = t;
  }
  get localY() {
    return this._localY;
  }
  set localY(t) {
    this._localY = t;
  }
  get spriteOffsetX() {
    return this._spriteOffsetX;
  }
  set spriteOffsetX(t) {
    this._spriteOffsetX = t;
  }
  get spriteOffsetY() {
    return this._spriteOffsetY;
  }
  set spriteOffsetY(t) {
    this._spriteOffsetY = t;
  }
};
yi.CLICK = "ROE_MOUSE_CLICK", yi.DOUBLE_CLICK = "ROE_MOUSE_DOUBLE_CLICK", yi.MOUSE_MOVE = "ROE_MOUSE_MOVE", yi.MOUSE_DOWN = "ROE_MOUSE_DOWN", yi.MOUSE_DOWN_LONG = "ROE_MOUSE_DOWN_LONG", yi.MOUSE_UP = "ROE_MOUSE_UP", yi.MOUSE_ENTER = "ROE_MOUSE_ENTER", yi.MOUSE_LEAVE = "ROE_MOUSE_LEAVE";
let at = yi;
const I_ = class I_ extends ti {
  constructor(t, e) {
    super(t, e);
  }
};
I_.POSITION_CHANGED = "ROME_POSITION_CHANGED", I_.OBJECT_REMOVED = "ROME_OBJECT_REMOVED";
let $e = I_;
const S_ = class S_ extends z {
  constructor(t, e, s, r = 1) {
    super(t, e), this._soundId = s, this._pitch = r;
  }
  get soundId() {
    return this._soundId;
  }
  get pitch() {
    return this._pitch;
  }
};
S_.PLAY_SOUND = "ROPSIE_PLAY_SOUND", S_.PLAY_SOUND_AT_PITCH = "ROPSIE_PLAY_SOUND_AT_PITCH";
let Er = S_;
const jn = class jn extends ti {
  constructor(t, e, s = "", r = "") {
    super(t, e), this._imageUrl = "", this._clickUrl = "", this._imageUrl = s, this._clickUrl = r;
  }
  get imageUrl() {
    return this._imageUrl;
  }
  get clickUrl() {
    return this._clickUrl;
  }
};
jn.ROOM_AD_LOAD_IMAGE = "RORAE_ROOM_AD_LOAD_IMAGE", jn.ROOM_AD_FURNI_CLICK = "RORAE_ROOM_AD_FURNI_CLICK", jn.ROOM_AD_FURNI_DOUBLE_CLICK = "RORAE_ROOM_AD_FURNI_DOUBLE_CLICK", jn.ROOM_AD_TOOLTIP_SHOW = "RORAE_ROOM_AD_TOOLTIP_SHOW", jn.ROOM_AD_TOOLTIP_HIDE = "RORAE_ROOM_AD_TOOLTIP_HIDE";
let ee = jn;
const ho = class ho extends ti {
  constructor(t, e, s, r = 1) {
    super(t, e), this._sampleId = s, this._pitch = r;
  }
  get sampleId() {
    return this._sampleId;
  }
  get pitch() {
    return this._pitch;
  }
};
ho.ROOM_OBJECT_INITIALIZED = "ROPSPE_ROOM_OBJECT_INITIALIZED", ho.ROOM_OBJECT_DISPOSED = "ROPSPE_ROOM_OBJECT_DISPOSED", ho.PLAY_SAMPLE = "ROPSPE_PLAY_SAMPLE", ho.CHANGE_PITCH = "ROPSPE_CHANGE_PITCH";
let Ie = ho;
const vi = class vi extends lt {
};
vi.SOUND_MACHINE_INIT = "ROSM_SOUND_MACHINE_INIT", vi.SOUND_MACHINE_SWITCHED_ON = "ROSM_SOUND_MACHINE_SWITCHED_ON", vi.SOUND_MACHINE_SWITCHED_OFF = "ROSM_SOUND_MACHINE_SWITCHED_OFF", vi.SOUND_MACHINE_DISPOSE = "ROSM_SOUND_MACHINE_DISPOSE", vi.JUKEBOX_INIT = "ROSM_JUKEBOX_INIT", vi.JUKEBOX_SWITCHED_ON = "ROSM_JUKEBOX_SWITCHED_ON", vi.JUKEBOX_SWITCHED_OFF = "ROSM_JUKEBOX_SWITCHED_OFF", vi.JUKEBOX_DISPOSE = "ROSM_JUKEBOX_DISPOSE";
let ne = vi;
const A_ = class A_ extends ti {
  constructor(t, e, s = 0) {
    super(t, e), this._state = s;
  }
  get state() {
    return this._state;
  }
};
A_.STATE_CHANGE = "ROSCE_STATE_CHANGE", A_.STATE_RANDOM = "ROSCE_STATE_RANDOM";
let At = A_;
class Ii extends at {
  constructor(t, e, s, r, n, a, o = !1, h = !1, u = !1, c = !1) {
    super(t, e, s, o, h, u, c), this._tileX = r, this._tileY = n, this._tileZ = a;
  }
  get tileX() {
    return this._tileX;
  }
  get tileY() {
    return this._tileY;
  }
  get tileZ() {
    return this._tileZ;
  }
  get tileXAsInt() {
    return Math.trunc(this._tileX + 0.499);
  }
  get tileYAsInt() {
    return Math.trunc(this._tileY + 0.499);
  }
  get tileZAsInt() {
    return Math.trunc(this._tileZ + 0.499);
  }
}
class La extends at {
  constructor(t, e, s, r, n, a, o, h, u, c = !1, l = !1, _ = !1, d = !1) {
    super(t, e, s, c, l, _, d), this._wallLocation = new v(), this._wallWd = new v(), this._wallHt = new v(), this._wallLocation.assign(r), this._wallWd.assign(n), this._wallHt.assign(a), this._x = o, this._y = h, this._direction = u;
  }
  get wallLocation() {
    return this._wallLocation;
  }
  get wallWidth() {
    return this._wallWd;
  }
  get wallHeight() {
    return this._wallHt;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  get direction() {
    return this._direction;
  }
}
const vt = class vt extends ti {
  constructor(t, e) {
    super(t, e);
  }
};
vt.OPEN_WIDGET = "ROWRE_OPEN_WIDGET", vt.CLOSE_WIDGET = "ROWRE_CLOSE_WIDGET", vt.OPEN_FURNI_CONTEXT_MENU = "ROWRE_OPEN_FURNI_CONTEXT_MENU", vt.CLOSE_FURNI_CONTEXT_MENU = "ROWRE_CLOSE_FURNI_CONTEXT_MENU", vt.PLACEHOLDER = "ROWRE_PLACEHOLDER", vt.CREDITFURNI = "ROWRE_CREDITFURNI", vt.STACK_HEIGHT = "ROWRE_STACK_HEIGHT", vt.EXTERNAL_IMAGE = "ROWRE_EXTERNAL_IMAGE", vt.STICKIE = "ROWRE_STICKIE", vt.PRESENT = "ROWRE_PRESENT", vt.TROPHY = "ROWRE_TROPHY", vt.TEASER = "ROWRE_TEASER", vt.ECOTRONBOX = "ROWRE_ECOTRONBOX", vt.DIMMER = "ROWRE_DIMMER", vt.WIDGET_REMOVE_DIMMER = "ROWRE_WIDGET_REMOVE_DIMMER", vt.CLOTHING_CHANGE = "ROWRE_CLOTHING_CHANGE", vt.JUKEBOX_PLAYLIST_EDITOR = "ROWRE_JUKEBOX_PLAYLIST_EDITOR", vt.MANNEQUIN = "ROWRE_MANNEQUIN", vt.PET_PRODUCT_MENU = "ROWRE_PET_PRODUCT_MENU", vt.GUILD_FURNI_CONTEXT_MENU = "ROWRE_GUILD_FURNI_CONTEXT_MENU", vt.MONSTERPLANT_SEED_PLANT_CONFIRMATION_DIALOG = "ROWRE_MONSTERPLANT_SEED_PLANT_CONFIRMATION_DIALOG", vt.PURCHASABLE_CLOTHING_CONFIRMATION_DIALOG = "ROWRE_PURCHASABLE_CLOTHING_CONFIRMATION_DIALOG", vt.BACKGROUND_COLOR = "ROWRE_BACKGROUND_COLOR", vt.AREA_HIDE = "ROWRE_AREA_HIDE", vt.MYSTERYBOX_OPEN_DIALOG = "ROWRE_MYSTERYBOX_OPEN_DIALOG", vt.EFFECTBOX_OPEN_DIALOG = "ROWRE_EFFECTBOX_OPEN_DIALOG", vt.MYSTERYTROPHY_OPEN_DIALOG = "ROWRE_MYSTERYTROPHY_OPEN_DIALOG", vt.ACHIEVEMENT_RESOLUTION_OPEN = "ROWRE_ACHIEVEMENT_RESOLUTION_OPEN", vt.ACHIEVEMENT_RESOLUTION_ENGRAVING = "ROWRE_ACHIEVEMENT_RESOLUTION_ENGRAVING", vt.ACHIEVEMENT_RESOLUTION_FAILED = "ROWRE_ACHIEVEMENT_RESOLUTION_FAILED", vt.FRIEND_FURNITURE_CONFIRM = "ROWRE_FRIEND_FURNITURE_CONFIRM", vt.FRIEND_FURNITURE_ENGRAVING = "ROWRE_FRIEND_FURNITURE_ENGRAVING", vt.BADGE_DISPLAY_ENGRAVING = "ROWRE_BADGE_DISPLAY_ENGRAVING", vt.HIGH_SCORE_DISPLAY = "ROWRE_HIGH_SCORE_DISPLAY", vt.HIDE_HIGH_SCORE_DISPLAY = "ROWRE_HIDE_HIGH_SCORE_DISPLAY", vt.INERNAL_LINK = "ROWRE_INTERNAL_LINK", vt.ROOM_LINK = "ROWRE_ROOM_LINK", vt.YOUTUBE = "ROWRE_YOUTUBE";
let N = vt;
class VF {
  constructor(t, e, s, r, n, a, o = 0, h = 0, u = !1, c = !1, l = !1, _ = !1) {
    this._type = t, this._eventId = e, this._canvasId = s, this._spriteTag = r, this._screenX = n, this._screenY = a, this._localX = o, this._localY = h, this._ctrlKey = u, this._altKey = c, this._shiftKey = l, this._buttonDown = _, this._spriteOffsetX = 0, this._spriteOffsetY = 0;
  }
  get type() {
    return this._type;
  }
  get eventId() {
    return this._eventId;
  }
  get canvasId() {
    return this._canvasId;
  }
  get spriteTag() {
    return this._spriteTag;
  }
  get screenX() {
    return this._screenX;
  }
  get screenY() {
    return this._screenY;
  }
  get localX() {
    return this._localX;
  }
  get localY() {
    return this._localY;
  }
  get ctrlKey() {
    return this._ctrlKey;
  }
  get altKey() {
    return this._altKey;
  }
  get shiftKey() {
    return this._shiftKey;
  }
  get buttonDown() {
    return this._buttonDown;
  }
  get spriteOffsetX() {
    return this._spriteOffsetX;
  }
  set spriteOffsetX(t) {
    this._spriteOffsetX = t;
  }
  get spriteOffsetY() {
    return this._spriteOffsetY;
  }
  set spriteOffsetY(t) {
    this._spriteOffsetY = t;
  }
}
class HF extends qt {
  constructor(t) {
    super(t);
  }
}
const bI = class bI extends HF {
  constructor(t, e) {
    super(t), this._targetLocation = e;
  }
  get targetLocation() {
    return this._targetLocation;
  }
};
bI.ROAME_MOVE_TO = "ROAME_MOVE_TO";
let zo = bI;
const R_ = class R_ extends ae {
  constructor(t, e, s = !1) {
    super(R_.ROOM_ZOOM, t), this._level = e, this._isFlipForced = s;
  }
  get level() {
    return this._level;
  }
  get isFlipForced() {
    return this._isFlipForced;
  }
};
R_.ROOM_ZOOM = "REE_ROOM_ZOOM";
let aR = R_;
const O_ = class O_ extends qt {
  constructor(t, e) {
    super(O_.IMAGE_READY), this._badgeId = t, this._image = e;
  }
  get badgeId() {
    return this._badgeId;
  }
  get image() {
    return this._image;
  }
};
O_.IMAGE_READY = "BIME_BADGE_IMAGE_READY";
let Vo = O_;
const y_ = class y_ extends qt {
  constructor(t, e) {
    super(y_.MYSTERY_BOX_KEYS_UPDATE), this._boxColor = t, this._keyColor = e;
  }
  get boxColor() {
    return this._boxColor;
  }
  get keyColor() {
    return this._keyColor;
  }
};
y_.MYSTERY_BOX_KEYS_UPDATE = "mbke_update";
let np = y_;
const v_ = class v_ extends qt {
  constructor() {
    super(v_.PERKS_UPDATED);
  }
};
v_.PERKS_UPDATED = "PUE_perks_updated";
let oR = v_;
const uo = class uo extends qt {
  constructor(t, e, s = !0) {
    super(t), this._session = e, this._openLandingView = s;
  }
  get session() {
    return this._session;
  }
  get openLandingView() {
    return this._openLandingView;
  }
};
uo.CREATED = "RSE_CREATED", uo.STARTED = "RSE_STARTED", uo.ENDED = "RSE_ENDED", uo.ROOM_DATA = "RSE_ROOM_DATA";
let mt = uo;
const ts = class ts extends mt {
  constructor(t, e, s, r, n, a = 0, o = null, h = -1) {
    super(t, e), this._objectId = s, this._message = r, this._chatType = n, this._links = o, this._extraParam = h, this._style = a;
  }
  get objectId() {
    return this._objectId;
  }
  get message() {
    return this._message;
  }
  get chatType() {
    return this._chatType;
  }
  get links() {
    return this._links;
  }
  get extraParam() {
    return this._extraParam;
  }
  get style() {
    return this._style;
  }
};
ts.CHAT_EVENT = "RSCE_CHAT_EVENT", ts.FLOOD_EVENT = "RSCE_FLOOD_EVENT", ts.CHAT_TYPE_SPEAK = 0, ts.CHAT_TYPE_WHISPER = 1, ts.CHAT_TYPE_SHOUT = 2, ts.CHAT_TYPE_RESPECT = 3, ts.CHAT_TYPE_PETRESPECT = 4, ts.CHAT_TYPE_HAND_ITEM_RECEIVED = 5, ts.CHAT_TYPE_PETTREAT = 6, ts.CHAT_TYPE_PETREVIVE = 7, ts.CHAT_TYPE_PET_REBREED_FERTILIZE = 8, ts.CHAT_TYPE_PET_SPEED_FERTILIZE = 9, ts.CHAT_TYPE_MUTE_REMAINING = 10;
let Jt = ts;
const C_ = class C_ extends mt {
  constructor(t, e, s, r, n, a) {
    super(C_.CONFIRM_PET_BREEDING, t), this._nestId = e, this._pet1 = s, this._pet2 = r, this._rarityCategories = n, this._resultPetTypeId = a;
  }
  get nestId() {
    return this._nestId;
  }
  get pet1() {
    return this._pet1;
  }
  get pet2() {
    return this._pet2;
  }
  get rarityCategories() {
    return this._rarityCategories;
  }
  get resultPetTypeId() {
    return this._resultPetTypeId;
  }
};
C_.CONFIRM_PET_BREEDING = "RSPFUE_CONFIRM_PET_BREEDING";
let ap = C_;
const x_ = class x_ extends mt {
  constructor(t, e, s) {
    super(x_.RSPFUE_CONFIRM_PET_BREEDING_RESULT, t), this._breedingNestStuffId = e, this._result = s;
  }
  get breedingNestStuffId() {
    return this._breedingNestStuffId;
  }
  get result() {
    return this._result;
  }
};
x_.RSPFUE_CONFIRM_PET_BREEDING_RESULT = "RSPFUE_CONFIRM_PET_BREEDING_RESULT";
let op = x_;
const M_ = class M_ extends mt {
  constructor(t, e, s) {
    super(M_.RSDE_DANCE, t), this._roomIndex = e, this._danceId = s;
  }
  get roomIndex() {
    return this._roomIndex;
  }
  get danceId() {
    return this._danceId;
  }
};
M_.RSDE_DANCE = "RSDE_DANCE";
let hp = M_;
class YF {
  constructor(t, e, s, r) {
    this._id = t, this._type = e, this._color = s, this._brightness = r;
  }
  get id() {
    return this._id;
  }
  get type() {
    return this._type;
  }
  get color() {
    return this._color;
  }
  get brightness() {
    return this._brightness;
  }
}
const PI = class PI extends mt {
  constructor(t, e) {
    super(t, e), this._selectedPresetId = 0, this._presets = [];
  }
  storePreset(t, e, s, r) {
    this._presets[t - 1] = new YF(t, e, s, r);
  }
  getPreset(t) {
    return t < 0 || t >= this._presets.length ? null : this._presets[t];
  }
  get presetCount() {
    return this._presets.length;
  }
  get selectedPresetId() {
    return this._selectedPresetId;
  }
  set selectedPresetId(t) {
    this._selectedPresetId = t;
  }
};
PI.ROOM_DIMMER_PRESETS = "RSDPE_PRESETS";
let lc = PI;
const Hh = class Hh extends mt {
  constructor(t, e, s) {
    super(t, e), this._userName = "", this._userName = s;
  }
  get userName() {
    return this._userName;
  }
};
Hh.DOORBELL = "RSDE_DOORBELL", Hh.RSDE_REJECTED = "RSDE_REJECTED", Hh.RSDE_ACCEPTED = "RSDE_ACCEPTED";
let rn = Hh;
const us = class us extends mt {
  constructor(t, e, s = null) {
    super(t, e), this._message = s;
  }
  get message() {
    return this._message;
  }
};
us.RSEME_KICKED = "RSEME_KICKED", us.RSEME_PETS_FORBIDDEN_IN_HOTEL = "RSEME_PETS_FORBIDDEN_IN_HOTEL", us.RSEME_PETS_FORBIDDEN_IN_FLAT = "RSEME_PETS_FORBIDDEN_IN_FLAT", us.RSEME_MAX_PETS = "RSEME_MAX_PETS", us.RSEME_MAX_NUMBER_OF_OWN_PETS = "RSEME_MAX_NUMBER_OF_OWN_PETS", us.RSEME_NO_FREE_TILES_FOR_PET = "RSEME_NO_FREE_TILES_FOR_PET", us.RSEME_SELECTED_TILE_NOT_FREE_FOR_PET = "RSEME_SELECTED_TILE_NOT_FREE_FOR_PET", us.RSEME_BOTS_FORBIDDEN_IN_HOTEL = "RSEME_BOTS_FORBIDDEN_IN_HOTEL", us.RSEME_BOTS_FORBIDDEN_IN_FLAT = "RSEME_BOTS_FORBIDDEN_IN_FLAT", us.RSEME_BOT_LIMIT_REACHED = "RSEME_BOT_LIMIT_REACHED", us.RSEME_SELECTED_TILE_NOT_FREE_FOR_BOT = "RSEME_SELECTED_TILE_NOT_FREE_FOR_BOT", us.RSEME_BOT_NAME_NOT_ACCEPTED = "RSEME_BOT_NAME_NOT_ACCEPTED";
let We = us;
const b_ = class b_ extends mt {
  constructor(t, e, s, r, n) {
    super(b_.FAVOURITE_GROUP_UPDATE, t), this._roomIndex = e, this._habboGroupId = s, this._habboGroupName = n, this._status = r;
  }
  get roomIndex() {
    return this._roomIndex;
  }
  get habboGroupId() {
    return this._habboGroupId;
  }
  get habboGroupName() {
    return this._habboGroupName;
  }
  get status() {
    return this._status;
  }
};
b_.FAVOURITE_GROUP_UPDATE = "RSFGUE_FAVOURITE_GROUP_UPDATE";
let up = b_;
const P_ = class P_ extends mt {
  constructor(t, e, s, r) {
    super(P_.RSFRE_FRIEND_REQUEST, t), this._requestId = 0, this._userId = 0, this._requestId = e, this._userId = s, this._userName = r;
  }
  get requestId() {
    return this._requestId;
  }
  get userId() {
    return this._userId;
  }
  get userName() {
    return this._userName;
  }
};
P_.RSFRE_FRIEND_REQUEST = "RSFRE_FRIEND_REQUEST";
let lp = P_;
const N_ = class N_ extends mt {
  constructor(t, e, s) {
    super(N_.NEST_BREEDING_SUCCESS, t), this._petId = e, this._rarityCategory = s;
  }
  get rarityCategory() {
    return this._rarityCategory;
  }
  get petId() {
    return this._petId;
  }
};
N_.NEST_BREEDING_SUCCESS = "RSPFUE_NEST_BREEDING_SUCCESS";
let cp = N_;
const U_ = class U_ extends mt {
  constructor(t, e, s, r) {
    super(U_.PET_BREEDING, t), this._state = e, this._ownPetId = s, this._otherPetId = r;
  }
  get state() {
    return this._state;
  }
  get ownPetId() {
    return this._ownPetId;
  }
  get otherPetId() {
    return this._otherPetId;
  }
};
U_.PET_BREEDING = "RSPFUE_PET_BREEDING";
let _p = U_;
const D_ = class D_ extends mt {
  constructor(t, e, s) {
    super(D_.PET_BREEDING_RESULT, t), this._resultData = e, this._otherResultData = s;
  }
  get resultData() {
    return this._resultData;
  }
  get otherResultData() {
    return this._otherResultData;
  }
};
D_.PET_BREEDING_RESULT = "RSPFUE_PET_BREEDING_RESULT";
let dp = D_;
const L_ = class L_ extends mt {
  constructor(t, e, s, r) {
    super(L_.PET_COMMANDS, t), this._petId = e, this._allCommandIds = s, this._enabledCommandIds = r;
  }
  get id() {
    return this._petId;
  }
  get commands() {
    return this._allCommandIds;
  }
  get enabledCommands() {
    return this._enabledCommandIds;
  }
};
L_.PET_COMMANDS = "RSPIUE_ENABLED_PET_COMMANDS";
let hR = L_;
const F_ = class F_ extends mt {
  constructor(t, e, s) {
    super(F_.PET_FIGURE_UPDATE, t), this._petId = e, this._figure = s;
  }
  get id() {
    return this._petId;
  }
  get figure() {
    return this._figure;
  }
};
F_.PET_FIGURE_UPDATE = "RSPFUE_PET_FIGURE_UPDATE";
let fp = F_;
const w_ = class w_ extends mt {
  constructor(t, e) {
    super(w_.PET_INFO, t), this._petInfo = e;
  }
  get petInfo() {
    return this._petInfo;
  }
};
w_.PET_INFO = "RSPIUE_PET_INFO";
let gp = w_;
const G_ = class G_ extends mt {
  constructor(t, e, s) {
    super(G_.PET_LEVEL_UPDATE, t), this._petId = e, this._level = s;
  }
  get petId() {
    return this._petId;
  }
  get level() {
    return this._level;
  }
};
G_.PET_LEVEL_UPDATE = "RSPLUE_PET_LEVEL_UPDATE";
let pp = G_;
const B_ = class B_ extends mt {
  constructor(t, e, s, r, n, a) {
    super(t, e), this._objectId = -1, this._nameValidationStatus = 0, this._nameValidationInfo = null, this._objectId = s, this._figureData = r, this._nameValidationStatus = n, this._nameValidationInfo = a;
  }
  get objectId() {
    return this._objectId;
  }
  get figureData() {
    return this._figureData;
  }
  get nameValidationStatus() {
    return this._nameValidationStatus;
  }
  get nameValidationInfo() {
    return this._nameValidationInfo;
  }
};
B_.RSOPPE_OPEN_PET_PACKAGE_REQUESTED = "RSOPPE_OPEN_PET_PACKAGE_REQUESTED", B_.RSOPPE_OPEN_PET_PACKAGE_RESULT = "RSOPPE_OPEN_PET_PACKAGE_RESULT";
let Wa = B_;
const k_ = class k_ extends mt {
  constructor(t, e, s, r, n, a) {
    super(k_.PET_STATUS_UPDATE, t), this._petId = e, this._canBreed = s, this._canHarvest = r, this._canRevive = n, this._hasBreedingPermission = a;
  }
  get petId() {
    return this._petId;
  }
  get canBreed() {
    return this._canBreed;
  }
  get canHarvest() {
    return this._canHarvest;
  }
  get canRevive() {
    return this._canRevive;
  }
  get hasBreedingPermission() {
    return this._hasBreedingPermission;
  }
};
k_.PET_STATUS_UPDATE = "RSPFUE_PET_STATUS_UPDATE";
let mp = k_;
const Yh = class Yh extends mt {
  constructor(t, e, s) {
    super(t, e), this._id = -1, this._numQuestions = 0, this._startMessage = "", this._endMessage = "", this._questionArray = null, this._npsPoll = !1, this._id = s;
  }
  get id() {
    return this._id;
  }
  get headline() {
    return this._headline;
  }
  set headline(t) {
    this._headline = t;
  }
  get summary() {
    return this._summary;
  }
  set summary(t) {
    this._summary = t;
  }
  get numQuestions() {
    return this._numQuestions;
  }
  set numQuestions(t) {
    this._numQuestions = t;
  }
  get startMessage() {
    return this._startMessage;
  }
  set startMessage(t) {
    this._startMessage = t;
  }
  get endMessage() {
    return this._endMessage;
  }
  set endMessage(t) {
    this._endMessage = t;
  }
  get questionArray() {
    return this._questionArray;
  }
  set questionArray(t) {
    this._questionArray = t;
  }
  get npsPoll() {
    return this._npsPoll;
  }
  set npsPoll(t) {
    this._npsPoll = t;
  }
};
Yh.OFFER = "RSPE_POLL_OFFER", Yh.ERROR = "RSPE_POLL_ERROR", Yh.CONTENT = "RSPE_POLL_CONTENT";
let br = Yh;
const NI = class NI extends mt {
  constructor(t, e, s, r, n, a, o, h, u) {
    super(t, e), this._classId = 0, this._itemType = "", this._placedItemId = 0, this._placedItemType = "", this._classId = s, this._itemType = r, this._productCode = n, this._placedItemId = a, this._placedItemType = o, this._placedInRoom = h, this._petFigureString = u;
  }
  get classId() {
    return this._classId;
  }
  get itemType() {
    return this._itemType;
  }
  get productCode() {
    return this._productCode;
  }
  get placedItemId() {
    return this._placedItemId;
  }
  get placedInRoom() {
    return this._placedInRoom;
  }
  get placedItemType() {
    return this._placedItemType;
  }
  get petFigureString() {
    return this._petFigureString;
  }
};
NI.RSPE_PRESENT_OPENED = "RSPE_PRESENT_OPENED";
let cc = NI;
const UI = class UI extends mt {
  constructor(t, e) {
    super(t, e);
  }
};
UI.RSDUE_ALLOW_PETS = "RSDUE_ALLOW_PETS";
let _c = UI;
const kr = class kr extends mt {
  constructor(t, e, s, r = !1) {
    super(kr.QUEUE_STATUS, t), this._name = e, this._target = s, this._queues = /* @__PURE__ */ new Map(), this._isActive = r;
  }
  get isActive() {
    return this._isActive;
  }
  get queueSetName() {
    return this._name;
  }
  get queueSetTarget() {
    return this._target;
  }
  get queueTypes() {
    return Array.from(this._queues.keys());
  }
  getQueueSize(t) {
    return this._queues.get(t);
  }
  addQueue(t, e) {
    this._queues.set(t, e);
  }
};
kr.QUEUE_STATUS = "RSQE_QUEUE_STATUS", kr.QUEUE_TYPE_CLUB = "c", kr.QUEUE_TYPE_NORMAL = "d", kr.QUEUE_TARGET_VISITOR = 2, kr.QUEUE_TARGET_SPECTATOR = 1;
let uR = kr;
const DI = class DI extends mt {
  constructor(t, e) {
    super(t, e);
  }
};
DI.SPECTATOR_MODE = "RSSME_SPECTATOR_MODE";
let dc = DI;
const z_ = class z_ extends mt {
  constructor(t, e, s) {
    super(z_.RSUBE_BADGES, t), this._userId = 0, this._badges = [], this._userId = e, this._badges = s;
  }
  get userId() {
    return this._userId;
  }
  get badges() {
    return this._badges;
  }
};
z_.RSUBE_BADGES = "RSUBE_BADGES";
let Ep = z_;
const V_ = class V_ extends mt {
  constructor(t, e) {
    super(V_.USER_DATA_UPDATED, t), this._addedUsers = e;
  }
  get addedUsers() {
    return this._addedUsers;
  }
};
V_.USER_DATA_UPDATED = "RMUDUE_USER_DATA_UPDATED";
let Tp = V_;
const H_ = class H_ extends mt {
  constructor(t, e, s, r, n, a) {
    super(H_.USER_FIGURE, t), this._roomIndex = 0, this._figure = "", this._gender = "", this._customInfo = "", this._roomIndex = e, this._figure = s, this._gender = r, this._customInfo = n, this._achievementScore = a;
  }
  get roomIndex() {
    return this._roomIndex;
  }
  get figure() {
    return this._figure;
  }
  get gender() {
    return this._gender;
  }
  get customInfo() {
    return this._customInfo;
  }
  get activityPoints() {
    return this._achievementScore;
  }
};
H_.USER_FIGURE = "RSUBE_FIGURE";
let Ip = H_;
const Y_ = class Y_ extends qt {
  constructor(t, e) {
    super(Y_.UTRE_USER_TAGS_RECEIVED), this._userId = t, this._tags = e;
  }
  get userId() {
    return this._userId;
  }
  get tags() {
    return this._tags;
  }
};
Y_.UTRE_USER_TAGS_RECEIVED = "UTRE_USER_TAGS_RECEIVED";
let lR = Y_;
const W_ = class W_ extends mt {
  constructor(t, e, s, r, n = null, a = 0) {
    super(t, e), this._question = "", this._SafeStr_7654 = 0, this._choices = [], this._SafeStr_7651 = [], this._question = s, this._choices = r, this._SafeStr_7651 = n, this._SafeStr_7651 == null && (this._SafeStr_7651 = []), this._SafeStr_7654 = a;
  }
  get question() {
    return this._question;
  }
  get choices() {
    return this._choices.slice();
  }
  get _SafeStr_4173() {
    return this._SafeStr_7651.slice();
  }
  get _SafeStr_4174() {
    return this._SafeStr_7654;
  }
};
W_.VOTE_QUESTION = "RSPE_VOTE_QUESTION", W_.VOTE_RESULT = "RSPE_VOTE_RESULT";
let ja = W_;
const Wh = class Wh extends mt {
  constructor(t, e, s = -1) {
    super(t, e), this._id = -1, this._pollType = null, this._pollId = -1, this._questionId = -1, this._duration = -1, this._question = null, this._userId = -1, this._id = s;
  }
  get id() {
    return this._id;
  }
  get pollType() {
    return this._pollType;
  }
  set pollType(t) {
    this._pollType = t;
  }
  get pollId() {
    return this._pollId;
  }
  set pollId(t) {
    this._pollId = t;
  }
  get questionId() {
    return this._questionId;
  }
  set questionId(t) {
    this._questionId = t;
  }
  get duration() {
    return this._duration;
  }
  set duration(t) {
    this._duration = t;
  }
  get question() {
    return this._question;
  }
  set question(t) {
    this._question = t;
  }
  get userId() {
    return this._userId;
  }
  set userId(t) {
    this._userId = t;
  }
  get value() {
    return this._value;
  }
  set value(t) {
    this._value = t;
  }
  get answerCounts() {
    return this._answerCounts;
  }
  set answerCounts(t) {
    this._answerCounts = t;
  }
};
Wh.QUESTION = "RWPUW_NEW_QUESTION", Wh.FINISHED = "RWPUW_QUESION_FINSIHED", Wh.ANSWERED = "RWPUW_QUESTION_ANSWERED";
let Pr = Wh;
const j_ = class j_ extends qt {
  constructor(t) {
    super(j_.UPDATED), this._uiFlags = t;
  }
  get uiFlags() {
    return this._uiFlags;
  }
};
j_.UPDATED = "APUE_UPDATED";
let Sp = j_;
const X_ = class X_ extends qt {
  constructor(t) {
    super(X_.UNUE_NAME_UPDATED), this._name = t;
  }
  get name() {
    return this._name;
  }
};
X_.UNUE_NAME_UPDATED = "unue_name_updated";
let fc = X_;
const K_ = class K_ extends qt {
  constructor(t, e) {
    super(K_.NOTIFY_PLAYED_SONG), this._name = t, this._creator = e;
  }
  get name() {
    return this._name;
  }
  get creator() {
    return this._creator;
  }
};
K_.NOTIFY_PLAYED_SONG = "UIEW_NOTIFY_PLAYED_SONG";
let Ap = K_;
const jh = class jh extends qt {
  constructor(t, e, s, r) {
    super(t), this._id = s, this._position = r, this._priority = e;
  }
  get id() {
    return this._id;
  }
  get position() {
    return this._position;
  }
  get priority() {
    return this._priority;
  }
};
jh.NPE_USER_PLAY_SONG = "NPE_USER_PLAY_SONG", jh.NPW_USER_STOP_SONG = "NPW_USER_STOP_SONG", jh.NPE_SONG_CHANGED = "NPE_SONG_CHANGED";
let nn = jh;
const q_ = class q_ extends qt {
  constructor(t) {
    super(t);
  }
};
q_.PLUE_PLAY_LIST_UPDATED = "PLUE_PLAY_LIST_UPDATED", q_.PLUE_PLAY_LIST_FULL = "PLUE_PLAY_LIST_FULL";
let Nr = q_;
const LI = class LI extends qt {
  constructor(t) {
    super(t);
  }
};
LI.SDIR_SONG_DISK_INVENTORY_RECEIVENT_EVENT = "SDIR_SONG_DISK_INVENTORY_RECEIVENT_EVENT";
let Xa = LI;
const FI = class FI extends qt {
  constructor(t, e) {
    super(t), this._id = e;
  }
  get id() {
    return this._id;
  }
};
FI.SIR_TRAX_SONG_INFO_RECEIVED = "SIR_TRAX_SONG_INFO_RECEIVED";
let Ho = FI;
const wI = class wI extends qt {
  constructor(t, e) {
    super(t), this._id = e;
  }
  get id() {
    return this._id;
  }
};
wI.TRAX_SONG_COMPLETE = "SME_TRAX_SONG_COMPLETE";
let Yo = wI;
const ni = class ni {
  constructor(t, e, s, r) {
    this._state = ni.NOT_LOADED, this._libraryName = t, this._revision = e, this._downloadUrl = s, this._assetManager = r, this._downloadUrl = this._downloadUrl.replace(/%libname%/gi, this._libraryName), this._downloadUrl = this._downloadUrl.replace(/%revision%/gi, this._revision), this.checkIsLoaded();
  }
  async downloadAsset() {
    if (!(!this._assetManager || this._state === ni.LOADING || this._state === ni.LOADED)) {
      if (!this.checkIsLoaded() && (this._state = ni.LOADING, !await this._assetManager.downloadAsset(this._downloadUrl)))
        throw new Error("Could not download asset");
      this.checkIsLoaded() && x().dispatchEvent(new tp(Ze.AVATAR_ASSET_DOWNLOADED, this));
    }
  }
  checkIsLoaded() {
    return this._assetManager.getCollection(this._libraryName) ? (this._state = ni.LOADED, !0) : !1;
  }
  get libraryName() {
    return this._libraryName;
  }
  get isLoaded() {
    return this._state === ni.LOADED;
  }
};
ni.NOT_LOADED = 0, ni.LOADING = 1, ni.LOADED = 2;
let Rp = ni;
class WF {
  constructor() {
    this._definitions = /* @__PURE__ */ new Map(), this._config = {}, this._missingKeys = [], ic.sayHello();
  }
  async init() {
    await this.reloadConfiguration();
  }
  async reloadConfiguration() {
    try {
      this.resetConfiguration(), this.parseConfiguration(this.getDefaultConfig(), !0);
      const t = this.getValue("config.urls").slice();
      if (!t || !t.length) throw new Error("Invalid configuration urls");
      for (const e of t) {
        if (!e || !e.length) return;
        const s = await fetch(e);
        if (s.status !== 200) throw new Error("Invalid configuration file");
        this.parseConfiguration(await s.json());
      }
    } catch (t) {
      throw new Error(t);
    }
  }
  resetConfiguration() {
    this._definitions.clear(), this._config = {}, this._missingKeys = [];
  }
  parseConfiguration(t, e = !1) {
    if (!t) return !1;
    try {
      const s = new RegExp(/\${(.*?)}/g);
      for (const r in t) {
        let n = t[r];
        typeof n == "string" && (n = this.interpolate(n, s)), this._definitions.has(r) ? e && this.setValue(r, n) : this.setValue(r, n);
      }
      return !0;
    } catch (s) {
      return rt.error(s.stack), !1;
    }
  }
  interpolate(t, e = null) {
    e || (e = new RegExp(/\${(.*?)}/g));
    const s = t.match(e);
    if (s && s.length)
      for (const r of s) {
        const n = this._definitions.get(this.removeInterpolateKey(r));
        n && (t = t.replace(r, n));
      }
    return t;
  }
  removeInterpolateKey(t) {
    return t.replace("${", "").replace("}", "");
  }
  getValue(t, e = null) {
    let s = this._definitions.get(t);
    if (s === void 0) {
      if (this._missingKeys.indexOf(t) >= 0) return e;
      this._missingKeys.push(t), rt.warn(`Missing configuration key: ${t}`), s = e;
    }
    return s;
  }
  setValue(t, e) {
    const s = t.split(".");
    let r = this._config;
    for (let n = 0; n < s.length; n++) {
      const a = s[n].toString();
      if (n !== s.length - 1) {
        r[a] || (r[a] = {}), r = r[a];
        continue;
      }
      r[a] = e;
    }
    this._definitions.set(t, e);
  }
  getDefaultConfig() {
    return window.NitroConfig;
  }
  get definitions() {
    return this._definitions;
  }
}
const jF = new WF(), Ct = () => jF;
class XF {
  constructor(t, e) {
    this._missingMandatoryLibs = [], this._figureMap = /* @__PURE__ */ new Map(), this._figureListeners = /* @__PURE__ */ new Map(), this._incompleteFigures = /* @__PURE__ */ new Map(), this._currentDownloads = [], this._libraryNames = [], this._assets = t, this._structure = e;
  }
  async init() {
    this._missingMandatoryLibs = Ct().getValue("avatar.mandatory.libraries");
    const t = Ct().getValue("avatar.figuremap.url");
    if (!t || !t.length) throw new Error("Invalid figure map url");
    const e = await fetch(t);
    if (e.status !== 200) throw new Error("Invalid figure map file");
    const s = await e.json();
    this.processFigureMap(s.libraries), x().addEventListener(Ze.AVATAR_ASSET_DOWNLOADED, (r) => this.onLibraryLoaded(r)), await this.processMissingLibraries();
  }
  processFigureMap(t) {
    if (!t) return;
    const e = Ct().getValue("avatar.asset.url");
    for (const s of t) {
      if (!s) continue;
      const r = s.id, n = s.revision || "";
      if (this._libraryNames.indexOf(r) >= 0) continue;
      this._libraryNames.push(r);
      const a = new Rp(r, n, e, this._assets);
      for (const o of s.parts) {
        const h = o.id, c = o.type + ":" + h;
        let l = this._figureMap.get(c);
        l || (l = []), l.push(a), this._figureMap.set(c, l);
      }
    }
  }
  async processMissingLibraries() {
    const t = [];
    this._missingMandatoryLibs.forEach((e) => {
      const s = this._figureMap.get(e);
      if (s) for (const r of s) t.push(r.downloadAsset());
    }), this._missingMandatoryLibs = [], await Promise.all(t);
  }
  onLibraryLoaded(t) {
    if (!t || !t.library) return;
    const e = [];
    for (const [r, n] of this._incompleteFigures.entries()) {
      let a = !0;
      for (const o of n)
        if (!(!o || o.isLoaded)) {
          a = !1;
          break;
        }
      if (a) {
        e.push(r);
        const o = this._figureListeners.get(r);
        if (o)
          for (const h of o)
            !h || h.disposed || h.resetFigure(r);
        this._figureListeners.delete(r), x().dispatchEvent(new qt(Ze.AVATAR_ASSET_LOADED));
      }
    }
    for (const r of e)
      r && this._incompleteFigures.delete(r);
    let s = 0;
    for (; s < this._currentDownloads.length; ) {
      const r = this._currentDownloads[s];
      r && r.libraryName === t.library.libraryName && this._currentDownloads.splice(s, 1), s++;
    }
  }
  isAvatarFigureContainerReady(t) {
    return !this.getAvatarFigurePendingLibraries(t).length;
  }
  getAvatarFigurePendingLibraries(t) {
    const e = [];
    if (!t || !this._structure) return e;
    const s = this._structure.figureData;
    if (!s) return e;
    const r = t.getPartTypeIds();
    for (const n of r) {
      const a = s.getSetType(n);
      if (!a) continue;
      const o = a.getPartSet(t.getPartSetId(n));
      if (o)
        for (const h of o.parts) {
          if (!h) continue;
          const u = h.type + ":" + h.id, c = this._figureMap.get(u);
          if (c !== void 0)
            for (const l of c)
              !l || l.isLoaded || e.indexOf(l) >= 0 || e.push(l);
        }
    }
    return e;
  }
  downloadAvatarFigure(t, e) {
    const s = t.getFigureString(), r = this.getAvatarFigurePendingLibraries(t);
    if (r && r.length) {
      if (e && !e.disposed) {
        let n = this._figureListeners.get(s);
        n || (n = [], this._figureListeners.set(s, n)), n.push(e);
      }
      this._incompleteFigures.set(s, r);
      for (const n of r)
        n && n.downloadAsset();
    } else
      e && !e.disposed && e.resetFigure(s);
  }
}
class vl {
  constructor(t) {
    this._parts = /* @__PURE__ */ new Map(), this.parseFigure(t);
  }
  getPartTypeIds() {
    return this.partSets().keys();
  }
  hasPartType(t) {
    return !!this.partSets().get(t);
  }
  getPartSetId(t) {
    const e = this.partSets().get(t);
    return e ? e.get("setid") : 0;
  }
  getPartColorIds(t) {
    const e = this.partSets().get(t);
    return e ? e.get("colorids") : null;
  }
  updatePart(t, e, s) {
    const r = /* @__PURE__ */ new Map();
    r.set("type", t), r.set("setid", e), r.set("colorids", s);
    const n = this.partSets();
    n.delete(t), n.set(t, r);
  }
  removePart(t) {
    this.partSets().delete(t);
  }
  getFigureString() {
    const t = [];
    for (const e of this.partSets().keys()) {
      if (!e) continue;
      let s = [];
      s.push(e), s.push(this.getPartSetId(e)), s = s.concat(this.getPartColorIds(e)), t.push(s.join("-"));
    }
    return t.join(".");
  }
  partSets() {
    return this._parts || (this._parts = /* @__PURE__ */ new Map()), this._parts;
  }
  parseFigure(t) {
    t || (t = "");
    for (const e of t.split(".")) {
      const s = e.split("-");
      if (s.length >= 2) {
        const r = s[0], n = parseInt(s[1]), a = [];
        let o = 2;
        for (; o < s.length; )
          a.push(parseInt(s[o])), o++;
        this.updatePart(r, n, a);
      }
    }
  }
}
class KF {
  constructor(t) {
    this._id = parseInt(t.id), this._value = parseInt(t.id), this._prevents = t.prevents || [], this._preventHeadTurn = t.preventHeadTurn || !1, this._isAnimated = !0, t.animated !== void 0 && t.animated === !1 && (this._isAnimated = !1);
  }
  get id() {
    return this._id;
  }
  get value() {
    return this._value;
  }
  get prevents() {
    return this._prevents;
  }
  get preventHeadTurn() {
    return this._preventHeadTurn;
  }
  get isAnimated() {
    return this._isAnimated;
  }
}
class qF {
  constructor(t) {
    if (this._types = /* @__PURE__ */ new Map(), this._params = /* @__PURE__ */ new Map(), this._defaultParameterValue = "", this._canvasOffsets = /* @__PURE__ */ new Map(), this._id = t.id, this._state = t.state, this._precedence = t.precedence, this._activePartSet = t.activePartSet, this._assetPartDefinition = t.assetPartDefinition, this._lay = t.lay, this._geometryType = t.geometryType, this._isMain = t.main || !1, this._isDefault = t.isDefault || !1, this._isAnimation = t.animation || !1, this._startFromFrameZero = t.startFromFrameZero || !1, this._prevents = t.prevents || [], this._preventHeadTurn = t.preventHeadTurn || !1, t.params && t.params.length > 0)
      for (const e of t.params)
        e && (e.id === "default" ? this._defaultParameterValue = e.value : this._params.set(e.id, e.value));
    if (t.types && t.types.length > 0)
      for (const e of t.types) {
        if (!e) continue;
        const s = new KF(e);
        this._types.set(s.id, s);
      }
  }
  setOffsets(t, e, s) {
    this._canvasOffsets || (this._canvasOffsets = /* @__PURE__ */ new Map());
    let r = this._canvasOffsets.get(t);
    r || (r = /* @__PURE__ */ new Map(), this._canvasOffsets.set(t, r)), r.set(e, s);
  }
  getOffsets(t, e) {
    if (!this._canvasOffsets) return null;
    const s = this._canvasOffsets.get(t);
    return s ? s.get(e) : null;
  }
  getType(t) {
    if (!t) return null;
    const e = this._types.get(parseInt(t));
    return e || null;
  }
  getParameterValue(t) {
    if (!t) return "";
    const e = this._params.get(t);
    return e || this._defaultParameterValue;
  }
  getPrevents(t) {
    return this._prevents.concat(this.getTypePrevents(t));
  }
  getTypePrevents(t) {
    if (!t) return [];
    const e = this._types.get(parseInt(t));
    return e ? e.prevents : [];
  }
  getPreventHeadTurn(t) {
    if (!t) return this._preventHeadTurn;
    const e = this.getType(t);
    return e ? e.preventHeadTurn : this._preventHeadTurn;
  }
  isAnimated(t) {
    if (!t) return !0;
    const e = this.getType(t);
    return e ? e.isAnimated : !0;
  }
  get id() {
    return this._id;
  }
  get state() {
    return this._state;
  }
  get precedence() {
    return this._precedence;
  }
  get activePartSet() {
    return this._activePartSet;
  }
  get assetPartDefinition() {
    return this._assetPartDefinition;
  }
  get lay() {
    return this._lay;
  }
  get geometryType() {
    return this._geometryType;
  }
  get isMain() {
    return this._isMain;
  }
  get isDefault() {
    return this._isDefault;
  }
  get isAnimation() {
    return this._isAnimation;
  }
  get startFromFrameZero() {
    return this._startFromFrameZero;
  }
  get prevents() {
    return this._prevents;
  }
  get preventHeadTurn() {
    return this._preventHeadTurn;
  }
  get params() {
    return this._params;
  }
}
class Op {
  constructor(t, e = "", s = 0) {
    this._actionType = t || "", this._actionParameter = e || "", this._definition = null, this._startFrame = s || 0, this._overridingAction = null;
  }
  dispose() {
    this._actionType = null, this._actionParameter = null, this._definition = null;
  }
  get id() {
    return this._definition ? this._definition.id + "_" + this._actionParameter : "";
  }
  get actionType() {
    return this._actionType;
  }
  get actionParameter() {
    return this._actionParameter;
  }
  set actionParameter(t) {
    this._actionParameter = t;
  }
  get definition() {
    return this._definition;
  }
  set definition(t) {
    this._definition = t;
  }
  get startFrame() {
    return this._startFrame;
  }
  get overridingAction() {
    return this._overridingAction;
  }
  set overridingAction(t) {
    this._overridingAction = t;
  }
}
class $F {
  constructor(t, e) {
    this._assets = t, this._actions = /* @__PURE__ */ new Map(), this._defaultAction = null, this.updateActions(e);
  }
  updateActions(t) {
    if (t) {
      for (const e of t.actions) {
        if (!e || !e.state) continue;
        const s = new qF(e);
        this._actions.set(s.state, s);
      }
      t.actionOffsets && this.parseActionOffsets(t.actionOffsets);
    }
  }
  parseActionOffsets(t) {
    if (!(!t || !t.length))
      for (const e of t) {
        const s = this._actions.get(e.action);
        if (s)
          for (const r of e.offsets) {
            const n = r.size || "", a = r.direction;
            if (n === "" || a === void 0) continue;
            const o = r.x || 0, h = r.y || 0, u = r.z || 0;
            s.setOffsets(n, a, [o, h, u]);
          }
      }
  }
  getActionDefinition(t) {
    if (!t) return null;
    for (const e of this._actions.values())
      if (!(!e || e.id !== t))
        return e;
    return null;
  }
  getActionDefinitionWithState(t) {
    const e = this._actions.get(t);
    return e || null;
  }
  getDefaultAction() {
    if (this._defaultAction) return this._defaultAction;
    for (const t of this._actions.values())
      if (!(!t || !t.isDefault))
        return this._defaultAction = t, t;
    return null;
  }
  getCanvasOffsets(t, e, s) {
    let r = [];
    for (const n of t) {
      if (!n) continue;
      const a = this._actions.get(n.actionType), o = a && a.getOffsets(e, s);
      o && (r = o);
    }
    return r;
  }
  sortActions(t) {
    if (!t) return null;
    t = this.filterActions(t);
    const e = [];
    for (const s of t) {
      if (!s) continue;
      const r = this._actions.get(s.actionType);
      r && (s.definition = r, e.push(s));
    }
    return e.sort((s, r) => {
      if (!s || !r) return 0;
      const n = s.definition.precedence, a = r.definition.precedence;
      return n < a ? 1 : n > a ? -1 : 0;
    }), e;
  }
  filterActions(t) {
    let e = [];
    const s = [];
    for (const r of t) {
      if (!r) continue;
      const n = this._actions.get(r.actionType);
      n && (e = e.concat(n.getPrevents(r.actionParameter)));
    }
    for (const r of t) {
      if (!r) continue;
      let n = r.actionType;
      r.actionType === "fx" && (n = n + ("." + r.actionParameter)), !(e.indexOf(n) >= 0) && s.push(r);
    }
    return s;
  }
}
class ZF {
  constructor() {
    this._cache = /* @__PURE__ */ new Map(), this.setLastAccessTime(Nt());
  }
  dispose() {
    if (this.debugInfo("[dispose]"), !!this._cache) {
      for (const t of this._cache.values())
        t && t.dispose();
      this._cache.clear();
    }
  }
  getDirectionCache(t) {
    const e = this._cache.get(t.toString());
    return e || null;
  }
  updateDirectionCache(t, e) {
    this._cache.set(t.toString(), e);
  }
  setLastAccessTime(t) {
    this._lastAccessTime = t;
  }
  getLastAccessTime() {
    return this._lastAccessTime;
  }
  debugInfo(t) {
  }
}
class cR {
  constructor() {
    this._cache = /* @__PURE__ */ new Map();
  }
  setAction(t, e) {
    this._currentAction || (this._currentAction = t);
    const s = this.getActionCache(this._currentAction);
    s && s.setLastAccessTime(e), this._currentAction = t;
  }
  dispose() {
    if (!this._disposed) {
      if (!this._cache) return;
      this.disposeActions(0, 2147483647), this._cache.clear(), this._cache = null, this._disposed = !0;
    }
  }
  disposeActions(t, e) {
    if (!(!this._cache || this._disposed))
      for (const [s, r] of this._cache.entries()) {
        if (!r) continue;
        const n = r.getLastAccessTime();
        e - n >= t && (r.dispose(), this._cache.delete(s));
      }
  }
  getAction() {
    return this._currentAction;
  }
  setDirection(t) {
    this._currentDirection = t;
  }
  getDirection() {
    return this._currentDirection;
  }
  getActionCache(t = null) {
    return this._currentAction ? (t || (t = this._currentAction), t.overridingAction ? this._cache.get(t.overridingAction) : this._cache.get(t.id)) : null;
  }
  updateActionCache(t, e) {
    t.overridingAction ? this._cache.set(t.overridingAction, e) : this._cache.set(t.id, e);
  }
  debugInfo(t) {
  }
}
class QF {
  constructor(t, e, s) {
    this._image = t, this._regPoint = e, this._offset = new st(0, 0), this._regPoint = e, this._isCacheable = s, this.cleanPoints();
  }
  dispose() {
    this._image && this._image.destroy({
      children: !0
    }), this._image = null, this._regPoint = null, this._offset = null;
  }
  cleanPoints() {
  }
  setRegPoint(t) {
    this._regPoint = t, this.cleanPoints();
  }
  get image() {
    return this._image;
  }
  set image(t) {
    this._image && this._image !== t && this._image.destroy({
      children: !0
    }), this._image = t;
  }
  get regPoint() {
    const t = this._regPoint.clone();
    return t.x += this._offset.x, t.y += this._offset.y, t;
  }
  set offset(t) {
    this._offset = t, this.cleanPoints();
  }
  get isCacheable() {
    return this._isCacheable;
  }
}
class JF {
  constructor(t) {
    this._id = t.id || "", this._align = t.align || "", this._base = t.base || "", this._ink = t.ink || 0, this._blend = 0;
    const e = t.blend;
    e && e.length > 0 && (this._blend = parseInt(e), this._blend > 1 && (this._blend = this._blend / 100));
  }
  get id() {
    return this._id;
  }
  get align() {
    return this._align;
  }
  get base() {
    return this._base;
  }
  get ink() {
    return this._ink;
  }
  get blend() {
    return this._blend;
  }
  get isBlended() {
    return this._blend !== 1;
  }
}
const $_ = class $_ {
  constructor(t, e, s) {
    if (this._id = t.id, this._animationFrame = t.frame || 0, this._dx = t.dx || 0, this._dy = t.dy || 0, this._dz = t.dz || 0, this._directionOffset = t.dd || 0, this._type = e, this._base = t.base || "", this._items = /* @__PURE__ */ new Map(), t.items) for (const r of t.items) this._items.set(r.id, r.base);
    this._base !== "" && this.baseAsInt().toString(), s && (this._action = new Op(s.state, this.base), this._action.definition = s);
  }
  get items() {
    return this._items;
  }
  baseAsInt() {
    let t = 0, e = 0;
    for (; e < this._base.length; )
      t = t + this._base.charCodeAt(e), e++;
    return t;
  }
  get id() {
    return this._id;
  }
  get animationFrame() {
    return this._animationFrame;
  }
  get dx() {
    return this._dx;
  }
  get dy() {
    return this._dy;
  }
  get dz() {
    return this._dz;
  }
  get dd() {
    return this._directionOffset;
  }
  get type() {
    return this._type;
  }
  get base() {
    return this._base;
  }
  get action() {
    return this._action;
  }
};
$_.BODYPART = "bodypart", $_.FX = "fx";
let ui = $_;
var $t = `in vec2 aPosition;
out vec2 vTextureCoord;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, Zt = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}`, tw = `in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform float uGamma;
uniform float uContrast;
uniform float uSaturation;
uniform float uBrightness;
uniform vec4 uColor;

void main()
{
    vec4 c = texture(uTexture, vTextureCoord);

    if (c.a > 0.0) {
        c.rgb /= c.a;

        vec3 rgb = pow(c.rgb, vec3(1. / uGamma));
        rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, uSaturation), uContrast);
        rgb.r *= uColor.r;
        rgb.g *= uColor.g;
        rgb.b *= uColor.b;
        c.rgb = rgb * uBrightness;

        c.rgb *= c.a;
    }

    finalColor = c * uColor.a;
}
`, ew = `struct AdjustmentUniforms {
  uGamma: f32,
  uContrast: f32,
  uSaturation: f32,
  uBrightness: f32,
  uColor: vec4<f32>,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> adjustmentUniforms : AdjustmentUniforms;

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
  var sample = textureSample(uTexture, uSampler, uv);
  let color = adjustmentUniforms.uColor;

  if (sample.a > 0.0) 
  {
    sample = vec4<f32>(sample.rgb / sample.a, sample.a);
    var rgb: vec3<f32> = pow(sample.rgb, vec3<f32>(1. / adjustmentUniforms.uGamma));
    rgb = mix(vec3<f32>(.5), mix(vec3<f32>(dot(vec3<f32>(.2125, .7154, .0721), rgb)), rgb, adjustmentUniforms.uSaturation), adjustmentUniforms.uContrast);
    rgb.r *= color.r;
    rgb.g *= color.g;
    rgb.b *= color.b;
    sample = vec4<f32>(rgb.rgb * adjustmentUniforms.uBrightness, sample.a);
    sample = vec4<f32>(sample.rgb * sample.a, sample.a);
  }

  return sample * color.a;
}`, sw = Object.defineProperty, iw = (i, t, e) => t in i ? sw(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, Yy = (i, t, e) => (iw(i, typeof t != "symbol" ? t + "" : t, e), e);
const Wy = class jy extends xt {
  /**
   * @param options - The options of the adjustment filter.
   */
  constructor(t) {
    t = { ...jy.DEFAULT_OPTIONS, ...t };
    const e = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: ew,
        entryPoint: "mainFragment"
      }
    }), s = It.from({
      vertex: $t,
      fragment: tw,
      name: "adjustment-filter"
    });
    super({
      gpuProgram: e,
      glProgram: s,
      resources: {
        adjustmentUniforms: {
          uGamma: { value: t.gamma, type: "f32" },
          uContrast: { value: t.contrast, type: "f32" },
          uSaturation: { value: t.saturation, type: "f32" },
          uBrightness: { value: t.brightness, type: "f32" },
          uColor: {
            value: [
              t.red,
              t.green,
              t.blue,
              t.alpha
            ],
            type: "vec4<f32>"
          }
        }
      }
    }), Yy(this, "uniforms"), this.uniforms = this.resources.adjustmentUniforms.uniforms;
  }
  /**
   * Amount of luminance
   * @default 1
   */
  get gamma() {
    return this.uniforms.uGamma;
  }
  set gamma(t) {
    this.uniforms.uGamma = t;
  }
  /**
   * Amount of contrast
   * @default 1
   */
  get contrast() {
    return this.uniforms.uContrast;
  }
  set contrast(t) {
    this.uniforms.uContrast = t;
  }
  /**
   * Amount of color saturation
   * @default 1
   */
  get saturation() {
    return this.uniforms.uSaturation;
  }
  set saturation(t) {
    this.uniforms.uSaturation = t;
  }
  /**
   * The overall brightness
   * @default 1
   */
  get brightness() {
    return this.uniforms.uBrightness;
  }
  set brightness(t) {
    this.uniforms.uBrightness = t;
  }
  /**
   * The multiplied red channel
   * @default 1
   */
  get red() {
    return this.uniforms.uColor[0];
  }
  set red(t) {
    this.uniforms.uColor[0] = t;
  }
  /**
   * The multiplied blue channel
   * @default 1
   */
  get green() {
    return this.uniforms.uColor[1];
  }
  set green(t) {
    this.uniforms.uColor[1] = t;
  }
  /**
   * The multiplied green channel
   * @default 1
   */
  get blue() {
    return this.uniforms.uColor[2];
  }
  set blue(t) {
    this.uniforms.uColor[2] = t;
  }
  /**
   * The overall alpha channel
   * @default 1
   */
  get alpha() {
    return this.uniforms.uColor[3];
  }
  set alpha(t) {
    this.uniforms.uColor[3] = t;
  }
};
Yy(Wy, "DEFAULT_OPTIONS", {
  gamma: 1,
  contrast: 1,
  saturation: 1,
  brightness: 1,
  red: 1,
  green: 1,
  blue: 1,
  alpha: 1
});
let Xy = Wy;
var rw = `
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uOffset;

void main(void)
{
    vec4 color = vec4(0.0);

    // Sample top left pixel
    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));

    // Sample top right pixel
    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));

    // Sample bottom right pixel
    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));

    // Sample bottom left pixel
    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));

    // Average
    color *= 0.25;

    finalColor = color;
}`, nw = `struct KawaseBlurUniforms {
  uOffset:vec2<f32>,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let uOffset = kawaseBlurUniforms.uOffset;
  var color: vec4<f32> = vec4<f32>(0.0);

  // Sample top left pixel
  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y));
  // Sample top right pixel
  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y));
  // Sample bottom right pixel
  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y));
  // Sample bottom left pixel
  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y));
  // Average
  color *= 0.25;

  return color;
}`, aw = `
precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uOffset;

uniform vec4 uInputClamp;

void main(void)
{
    vec4 color = vec4(0.0);

    // Sample top left pixel
    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));

    // Sample top right pixel
    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));

    // Sample bottom right pixel
    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));

    // Sample bottom left pixel
    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));

    // Average
    color *= 0.25;

    finalColor = color;
}
`, ow = `struct KawaseBlurUniforms {
  uOffset:vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let uOffset = kawaseBlurUniforms.uOffset;
  var color: vec4<f32> = vec4(0.0);

  // Sample top left pixel
  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));
  // Sample top right pixel
  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));
  // Sample bottom right pixel
  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));
  // Sample bottom left pixel
  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));
  // Average
  color *= 0.25;
    
  return color;
}`, hw = Object.defineProperty, uw = (i, t, e) => t in i ? hw(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, Pn = (i, t, e) => (uw(i, typeof t != "symbol" ? t + "" : t, e), e);
const Ky = class qy extends xt {
  /** @ignore */
  constructor(...t) {
    let e = t[0] ?? {};
    (typeof e == "number" || Array.isArray(e)) && (dt("6.0.0", "KawaseBlurFilter constructor params are now options object. See params: { strength, quality, clamp, pixelSize }"), e = { strength: e }, t[1] !== void 0 && (e.quality = t[1]), t[2] !== void 0 && (e.clamp = t[2])), e = { ...qy.DEFAULT_OPTIONS, ...e };
    const s = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: e != null && e.clamp ? ow : nw,
        entryPoint: "mainFragment"
      }
    }), r = It.from({
      vertex: $t,
      fragment: e != null && e.clamp ? aw : rw,
      name: "kawase-blur-filter"
    });
    super({
      gpuProgram: s,
      glProgram: r,
      resources: {
        kawaseBlurUniforms: {
          uOffset: { value: new Float32Array(2), type: "vec2<f32>" }
        }
      }
    }), Pn(this, "uniforms"), Pn(this, "_pixelSize", { x: 0, y: 0 }), Pn(this, "_clamp"), Pn(this, "_kernels", []), Pn(this, "_blur"), Pn(this, "_quality"), this.uniforms = this.resources.kawaseBlurUniforms.uniforms, this.pixelSize = e.pixelSize ?? { x: 1, y: 1 }, Array.isArray(e.strength) ? this.kernels = e.strength : typeof e.strength == "number" && (this._blur = e.strength, this.quality = e.quality ?? 3), this._clamp = !!e.clamp;
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(t, e, s, r) {
    const n = this.pixelSizeX / e.source.width, a = this.pixelSizeY / e.source.height;
    let o;
    if (this._quality === 1 || this._blur === 0)
      o = this._kernels[0] + 0.5, this.uniforms.uOffset[0] = o * n, this.uniforms.uOffset[1] = o * a, t.applyFilter(this, e, s, r);
    else {
      const h = ps.getSameSizeTexture(e);
      let u = e, c = h, l;
      const _ = this._quality - 1;
      for (let d = 0; d < _; d++)
        o = this._kernels[d] + 0.5, this.uniforms.uOffset[0] = o * n, this.uniforms.uOffset[1] = o * a, t.applyFilter(this, u, c, !0), l = u, u = c, c = l;
      o = this._kernels[_] + 0.5, this.uniforms.uOffset[0] = o * n, this.uniforms.uOffset[1] = o * a, t.applyFilter(this, u, s, r), ps.returnTexture(h);
    }
  }
  /**
    * The amount of blur, value greater than `0`.
    * @default 4
    */
  get strength() {
    return this._blur;
  }
  set strength(t) {
    this._blur = t, this._generateKernels();
  }
  /**
    * The quality of the filter, integer greater than `1`.
    * @default 3
    */
  get quality() {
    return this._quality;
  }
  set quality(t) {
    this._quality = Math.max(1, Math.round(t)), this._generateKernels();
  }
  /**
    * The kernel size of the blur filter, for advanced usage
    * @default [0]
    */
  get kernels() {
    return this._kernels;
  }
  set kernels(t) {
    Array.isArray(t) && t.length > 0 ? (this._kernels = t, this._quality = t.length, this._blur = Math.max(...t)) : (this._kernels = [0], this._quality = 1);
  }
  /**
    * The size of the pixels. Large size is blurrier. For advanced usage.
    * @default {x:1,y:1}
    */
  get pixelSize() {
    return this._pixelSize;
  }
  set pixelSize(t) {
    if (typeof t == "number") {
      this.pixelSizeX = this.pixelSizeY = t;
      return;
    }
    if (Array.isArray(t)) {
      this.pixelSizeX = t[0], this.pixelSizeY = t[1];
      return;
    }
    this._pixelSize = t;
  }
  /**
    * The size of the pixels on the `x` axis. Large size is blurrier. For advanced usage.
    * @default 1
    */
  get pixelSizeX() {
    return this.pixelSize.x;
  }
  set pixelSizeX(t) {
    this.pixelSize.x = t;
  }
  /**
    * The size of the pixels on the `y` axis. Large size is blurrier. For advanced usage.
    * @default 1
    */
  get pixelSizeY() {
    return this.pixelSize.y;
  }
  set pixelSizeY(t) {
    this.pixelSize.y = t;
  }
  /**
    * Get the if the filter is clamped
    * @default false
    */
  get clamp() {
    return this._clamp;
  }
  /** Update padding based on kernel data */
  _updatePadding() {
    this.padding = Math.ceil(this._kernels.reduce((t, e) => t + e + 0.5, 0));
  }
  /** Auto generate kernels by blur & quality */
  _generateKernels() {
    const t = this._blur, e = this._quality, s = [t];
    if (t > 0) {
      let r = t;
      const n = t / e;
      for (let a = 1; a < e; a++)
        r -= n, s.push(r);
    }
    this._kernels = s, this._updatePadding();
  }
};
Pn(Ky, "DEFAULT_OPTIONS", {
  strength: 4,
  quality: 3,
  clamp: !1,
  pixelSize: { x: 1, y: 1 }
});
let $y = Ky;
var lw = `in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform sampler2D uMapTexture;
uniform float uBloomScale;
uniform float uBrightness;

void main() {
    vec4 color = texture(uTexture, vTextureCoord);
    color.rgb *= uBrightness;
    vec4 bloomColor = vec4(texture(uMapTexture, vTextureCoord).rgb, 0.0);
    bloomColor.rgb *= uBloomScale;
    finalColor = color + bloomColor;
}
`, cw = `struct AdvancedBloomUniforms {
  uBloomScale: f32,
  uBrightness: f32,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> advancedBloomUniforms : AdvancedBloomUniforms;
@group(1) @binding(1) var uMapTexture: texture_2d<f32>;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  var color = textureSample(uTexture, uSampler, uv);
  color = vec4<f32>(color.rgb * advancedBloomUniforms.uBrightness, color.a);

  var bloomColor = vec4<f32>(textureSample(uMapTexture, uSampler, uv).rgb, 0.0);
  bloomColor = vec4<f32>(bloomColor.rgb * advancedBloomUniforms.uBloomScale, bloomColor.a);
  
  return color + bloomColor;
}
`, _w = `
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform float uThreshold;

void main() {
    vec4 color = texture(uTexture, vTextureCoord);

    // A simple & fast algorithm for getting brightness.
    // It's inaccuracy , but good enought for this feature.
    float _max = max(max(color.r, color.g), color.b);
    float _min = min(min(color.r, color.g), color.b);
    float brightness = (_max + _min) * 0.5;

    if(brightness > uThreshold) {
        finalColor = color;
    } else {
        finalColor = vec4(0.0, 0.0, 0.0, 0.0);
    }
}
`, dw = `struct ExtractBrightnessUniforms {
  uThreshold: f32,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> extractBrightnessUniforms : ExtractBrightnessUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);

  // A simple & fast algorithm for getting brightness.
  // It's inaccurate, but good enough for this feature.
  let max: f32 = max(max(color.r, color.g), color.b);
  let min: f32 = min(min(color.r, color.g), color.b);
  let brightness: f32 = (max + min) * 0.5;

  return select(vec4<f32>(0.), color, brightness > extractBrightnessUniforms.uThreshold);
}
`, fw = Object.defineProperty, gw = (i, t, e) => t in i ? fw(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, Zy = (i, t, e) => (gw(i, typeof t != "symbol" ? t + "" : t, e), e);
const Qy = class Jy extends xt {
  constructor(t) {
    t = { ...Jy.DEFAULT_OPTIONS, ...t };
    const e = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: dw,
        entryPoint: "mainFragment"
      }
    }), s = It.from({
      vertex: $t,
      fragment: _w,
      name: "extract-brightness-filter"
    });
    super({
      gpuProgram: e,
      glProgram: s,
      resources: {
        extractBrightnessUniforms: {
          uThreshold: { value: t.threshold, type: "f32" }
        }
      }
    }), Zy(this, "uniforms"), this.uniforms = this.resources.extractBrightnessUniforms.uniforms;
  }
  /**
   * Defines how bright a color needs to be extracted.
   * @default 0.5
   */
  get threshold() {
    return this.uniforms.uThreshold;
  }
  set threshold(t) {
    this.uniforms.uThreshold = t;
  }
};
Zy(Qy, "DEFAULT_OPTIONS", {
  threshold: 0.5
});
let pw = Qy;
var mw = Object.defineProperty, Ew = (i, t, e) => t in i ? mw(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, Fa = (i, t, e) => (Ew(i, typeof t != "symbol" ? t + "" : t, e), e);
const Tw = class tv extends xt {
  /**
   * @param options - Options for the AdvancedBloomFilter constructor.
   */
  constructor(t) {
    t = { ...tv.DEFAULT_OPTIONS, ...t };
    const e = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: cw,
        entryPoint: "mainFragment"
      }
    }), s = It.from({
      vertex: $t,
      fragment: lw,
      name: "advanced-bloom-filter"
    });
    super({
      gpuProgram: e,
      glProgram: s,
      resources: {
        advancedBloomUniforms: {
          uBloomScale: { value: t.bloomScale, type: "f32" },
          uBrightness: { value: t.brightness, type: "f32" }
        },
        uMapTexture: W.WHITE
      }
    }), Fa(this, "uniforms"), Fa(this, "bloomScale", 1), Fa(this, "brightness", 1), Fa(this, "_extractFilter"), Fa(this, "_blurFilter"), this.uniforms = this.resources.advancedBloomUniforms.uniforms, this._extractFilter = new pw({
      threshold: t.threshold
    }), this._blurFilter = new $y({
      strength: t.kernels ?? t.blur,
      quality: t.kernels ? void 0 : t.quality
    }), Object.assign(this, t);
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(t, e, s, r) {
    const n = ps.getSameSizeTexture(e);
    this._extractFilter.apply(t, e, n, !0);
    const a = ps.getSameSizeTexture(e);
    this._blurFilter.apply(t, n, a, !0), this.uniforms.uBloomScale = this.bloomScale, this.uniforms.uBrightness = this.brightness, this.resources.uMapTexture = a.source, t.applyFilter(this, e, s, r), ps.returnTexture(a), ps.returnTexture(n);
  }
  /**
   * Defines how bright a color needs to be extracted.
   * @default 0.5
   */
  get threshold() {
    return this._extractFilter.threshold;
  }
  set threshold(t) {
    this._extractFilter.threshold = t;
  }
  /** The kernels of the Blur Filter */
  get kernels() {
    return this._blurFilter.kernels;
  }
  set kernels(t) {
    this._blurFilter.kernels = t;
  }
  /**
   * The strength of the Blur properties simultaneously
   * @default 2
   */
  get blur() {
    return this._blurFilter.strength;
  }
  set blur(t) {
    this._blurFilter.strength = t;
  }
  /**
   * The quality of the Blur Filter
   * @default 4
   */
  get quality() {
    return this._blurFilter.quality;
  }
  set quality(t) {
    this._blurFilter.quality = t;
  }
  /**
   * The pixel size of the Kawase Blur filter
   * @default {x:1,y:1}
   */
  get pixelSize() {
    return this._blurFilter.pixelSize;
  }
  set pixelSize(t) {
    typeof t == "number" && (t = { x: t, y: t }), Array.isArray(t) && (t = { x: t[0], y: t[1] }), this._blurFilter.pixelSize = t;
  }
  /**
   * The horizontal pixelSize of the Kawase Blur filter
   * @default 1
   */
  get pixelSizeX() {
    return this._blurFilter.pixelSizeX;
  }
  set pixelSizeX(t) {
    this._blurFilter.pixelSizeX = t;
  }
  /**
   * The vertical pixel size of the Kawase Blur filter
   * @default 1
   */
  get pixelSizeY() {
    return this._blurFilter.pixelSizeY;
  }
  set pixelSizeY(t) {
    this._blurFilter.pixelSizeY = t;
  }
};
Fa(Tw, "DEFAULT_OPTIONS", {
  threshold: 0.5,
  bloomScale: 1,
  brightness: 1,
  blur: 8,
  quality: 4,
  pixelSize: { x: 1, y: 1 }
});
var Iw = `precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform float uSize;
uniform vec3 uColor;
uniform float uReplaceColor;

uniform vec4 uInputSize;

vec2 mapCoord( vec2 coord )
{
    coord *= uInputSize.xy;
    coord += uInputSize.zw;

    return coord;
}

vec2 unmapCoord( vec2 coord )
{
    coord -= uInputSize.zw;
    coord /= uInputSize.xy;

    return coord;
}

vec2 pixelate(vec2 coord, vec2 size)
{
    return floor(coord / size) * size;
}

vec2 getMod(vec2 coord, vec2 size)
{
    return mod(coord, size) / size;
}

float character(float n, vec2 p)
{
    p = floor(p*vec2(4.0, 4.0) + 2.5);

    if (clamp(p.x, 0.0, 4.0) == p.x)
    {
        if (clamp(p.y, 0.0, 4.0) == p.y)
        {
            if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;
        }
    }
    return 0.0;
}

void main()
{
    vec2 coord = mapCoord(vTextureCoord);

    // get the grid position
    vec2 pixCoord = pixelate(coord, vec2(uSize));
    pixCoord = unmapCoord(pixCoord);

    // sample the color at grid position
    vec4 color = texture(uTexture, pixCoord);

    // brightness of the color as it's perceived by the human eye
    float gray = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;

    // determine the character to use
    float n =  65536.0;             // .
    if (gray > 0.2) n = 65600.0;    // :
    if (gray > 0.3) n = 332772.0;   // *
    if (gray > 0.4) n = 15255086.0; // o
    if (gray > 0.5) n = 23385164.0; // &
    if (gray > 0.6) n = 15252014.0; // 8
    if (gray > 0.7) n = 13199452.0; // @
    if (gray > 0.8) n = 11512810.0; // #

    // get the mod..
    vec2 modd = getMod(coord, vec2(uSize));

    finalColor = (uReplaceColor > 0.5 ? vec4(uColor, 1.) : color) * character( n, vec2(-1.0) + modd * 2.0);
}
`, Sw = `struct AsciiUniforms {
    uSize: f32,
    uColor: vec3<f32>,
    uReplaceColor: f32,
};

struct GlobalFilterUniforms {
    uInputSize:vec4<f32>,
    uInputPixel:vec4<f32>,
    uInputClamp:vec4<f32>,
    uOutputFrame:vec4<f32>,
    uGlobalFrame:vec4<f32>,
    uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> asciiUniforms : AsciiUniforms;

@fragment
fn mainFragment(
    @location(0) uv: vec2<f32>,
    @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
    let pixelSize: f32 = asciiUniforms.uSize;
    let coord: vec2<f32> = mapCoord(uv);

    // get the rounded color..
    var pixCoord: vec2<f32> = pixelate(coord, vec2<f32>(pixelSize));
    pixCoord = unmapCoord(pixCoord);

    var color = textureSample(uTexture, uSampler, pixCoord);

    // determine the character to use
    let gray: f32 = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;
    
    var n: f32 = 65536.0; // .
    if (gray > 0.2) {
        n = 65600.0;    // :
    }
    if (gray > 0.3) {
        n = 332772.0;   // *
    }
    if (gray > 0.4) {
        n = 15255086.0; // o
    }
    if (gray > 0.5) {
        n = 23385164.0; // &
    }
    if (gray > 0.6) {
        n = 15252014.0; // 8
    }
    if (gray > 0.7) {
        n = 13199452.0; // @
    }
    if (gray > 0.8) {
        n = 11512810.0; // #
    }

    // get the mod..
    let modd: vec2<f32> = getMod(coord, vec2<f32>(pixelSize));
    return select(color, vec4<f32>(asciiUniforms.uColor, 1.), asciiUniforms.uReplaceColor > 0.5) * character(n, vec2<f32>(-1.0) + modd * 2.0);
}

fn pixelate(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>
{
    return floor( coord / size ) * size;
}

fn getMod(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>
{
    return moduloVec2( coord , size) / size;
}

fn character(n: f32, p: vec2<f32>) -> f32
{
    var q: vec2<f32> = floor(p*vec2<f32>(4.0, 4.0) + 2.5);

    if (clamp(q.x, 0.0, 4.0) == q.x)
    {
        if (clamp(q.y, 0.0, 4.0) == q.y)
        {
        if (i32(modulo(n/exp2(q.x + 5.0*q.y), 2.0)) == 1)
        {
            return 1.0;
        }
        }
    }

    return 0.0;
}

fn modulo(x: f32, y: f32) -> f32
{
  return x - y * floor(x/y);
}

fn moduloVec2(x: vec2<f32>, y: vec2<f32>) -> vec2<f32>
{
  return x - y * floor(x/y);
}

fn mapCoord(coord: vec2<f32> ) -> vec2<f32>
{
    var mappedCoord: vec2<f32> = coord;
    mappedCoord *= gfu.uInputSize.xy;
    mappedCoord += gfu.uOutputFrame.xy;
    return mappedCoord;
}

fn unmapCoord(coord: vec2<f32> ) -> vec2<f32>
{
    var mappedCoord: vec2<f32> = coord;
    mappedCoord -= gfu.uOutputFrame.xy;
    mappedCoord /= gfu.uInputSize.xy;
    return mappedCoord;
}`, Aw = Object.defineProperty, Rw = (i, t, e) => t in i ? Aw(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, yp = (i, t, e) => (Rw(i, typeof t != "symbol" ? t + "" : t, e), e);
const Ow = class ev extends xt {
  /** @ignore */
  constructor(...t) {
    let e = t[0] ?? {};
    typeof e == "number" && (dt("6.0.0", "AsciiFilter constructor params are now options object. See params: { size, color, replaceColor }"), e = { size: e });
    const s = (e == null ? void 0 : e.color) && e.replaceColor !== !1;
    e = { ...ev.DEFAULT_OPTIONS, ...e };
    const r = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: Sw,
        entryPoint: "mainFragment"
      }
    }), n = It.from({
      vertex: $t,
      fragment: Iw,
      name: "ascii-filter"
    });
    super({
      gpuProgram: r,
      glProgram: n,
      resources: {
        asciiUniforms: {
          uSize: { value: e.size, type: "f32" },
          uColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uReplaceColor: { value: Number(s), type: "f32" }
        }
      }
    }), yp(this, "uniforms"), yp(this, "_color"), this.uniforms = this.resources.asciiUniforms.uniforms, this._color = new Pt(), this.color = e.color ?? 16777215;
  }
  /**
   * The pixel size used by the filter.
   * @default 8
   */
  get size() {
    return this.uniforms.uSize;
  }
  set size(t) {
    this.uniforms.uSize = t;
  }
  /**
   * The resulting color of the ascii characters, as a 3 component RGB or numerical hex
   * @example [1.0, 1.0, 1.0] = 0xffffff
   * @default 0xffffff
   */
  get color() {
    return this._color.value;
  }
  set color(t) {
    this._color.setValue(t);
    const [e, s, r] = this._color.toArray();
    this.uniforms.uColor[0] = e, this.uniforms.uColor[1] = s, this.uniforms.uColor[2] = r;
  }
  /**
   * Determine whether or not to replace the source colors with the provided.
   */
  get replaceColor() {
    return this.uniforms.uReplaceColor > 0.5;
  }
  set replaceColor(t) {
    this.uniforms.uReplaceColor = t ? 1 : 0;
  }
};
yp(Ow, "DEFAULT_OPTIONS", {
  size: 8,
  color: 16777215,
  replaceColor: !1
});
var yw = `precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uTransform;
uniform vec3 uLightColor;
uniform float uLightAlpha;
uniform vec3 uShadowColor;
uniform float uShadowAlpha;

uniform vec4 uInputSize;

void main(void) {
    vec2 transform = vec2(1.0 / uInputSize) * vec2(uTransform.x, uTransform.y);
    vec4 color = texture(uTexture, vTextureCoord);
    float light = texture(uTexture, vTextureCoord - transform).a;
    float shadow = texture(uTexture, vTextureCoord + transform).a;

    color.rgb = mix(color.rgb, uLightColor, clamp((color.a - light) * uLightAlpha, 0.0, 1.0));
    color.rgb = mix(color.rgb, uShadowColor, clamp((color.a - shadow) * uShadowAlpha, 0.0, 1.0));
    finalColor = vec4(color.rgb * color.a, color.a);
}
`, vw = `struct BevelUniforms {
  uLightColor: vec3<f32>,
  uLightAlpha: f32,
  uShadowColor: vec3<f32>,
  uShadowAlpha: f32,
  uTransform: vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> bevelUniforms : BevelUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let transform = vec2<f32>(1.0 / gfu.uInputSize.xy) * vec2<f32>(bevelUniforms.uTransform.x, bevelUniforms.uTransform.y);
  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);
  let lightSample: f32 = textureSample(uTexture, uSampler, uv - transform).a;
  let shadowSample: f32 = textureSample(uTexture, uSampler, uv + transform).a;

  let light = vec4<f32>(bevelUniforms.uLightColor, bevelUniforms.uLightAlpha);
  let shadow = vec4<f32>(bevelUniforms.uShadowColor, bevelUniforms.uShadowAlpha);

  color = vec4<f32>(mix(color.rgb, light.rgb, clamp((color.a - lightSample) * light.a, 0.0, 1.0)), color.a);
  color = vec4<f32>(mix(color.rgb, shadow.rgb, clamp((color.a - shadowSample) * shadow.a, 0.0, 1.0)), color.a);
  
  return vec4<f32>(color.rgb * color.a, color.a);
}`, Cw = Object.defineProperty, xw = (i, t, e) => t in i ? Cw(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, wa = (i, t, e) => (xw(i, typeof t != "symbol" ? t + "" : t, e), e);
const Mw = class sv extends xt {
  /**
   * @param options - Options for the BevelFilter constructor.
   */
  constructor(t) {
    t = { ...sv.DEFAULT_OPTIONS, ...t };
    const e = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: vw,
        entryPoint: "mainFragment"
      }
    }), s = It.from({
      vertex: $t,
      fragment: yw,
      name: "bevel-filter"
    });
    super({
      gpuProgram: e,
      glProgram: s,
      resources: {
        bevelUniforms: {
          uLightColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uLightAlpha: { value: t.lightAlpha, type: "f32" },
          uShadowColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uShadowAlpha: { value: t.shadowAlpha, type: "f32" },
          uTransform: { value: new Float32Array(2), type: "vec2<f32>" }
        }
      },
      // Workaround: https://github.com/pixijs/filters/issues/230
      // applies correctly only if there is at least a single-pixel padding with alpha=0 around an image
      // To solve this problem, a padding of 1 put on the filter should suffice
      padding: 1
    }), wa(this, "uniforms"), wa(this, "_thickness"), wa(this, "_rotation"), wa(this, "_lightColor"), wa(this, "_shadowColor"), this.uniforms = this.resources.bevelUniforms.uniforms, this._lightColor = new Pt(), this._shadowColor = new Pt(), this.lightColor = t.lightColor ?? 16777215, this.shadowColor = t.shadowColor ?? 0, Object.assign(this, t);
  }
  /**
   * The angle of the light in degrees
   * @default 45
   */
  get rotation() {
    return this._rotation / Po;
  }
  set rotation(t) {
    this._rotation = t * Po, this._updateTransform();
  }
  /**
   * The thickness of the bevel
   * @default 2
   */
  get thickness() {
    return this._thickness;
  }
  set thickness(t) {
    this._thickness = t, this._updateTransform();
  }
  /**
   * The color value of the left & top bevel.
   * @example [1.0, 1.0, 1.0] = 0xffffff
   * @default 0xffffff
   */
  get lightColor() {
    return this._lightColor.value;
  }
  set lightColor(t) {
    this._lightColor.setValue(t);
    const [e, s, r] = this._lightColor.toArray();
    this.uniforms.uLightColor[0] = e, this.uniforms.uLightColor[1] = s, this.uniforms.uLightColor[2] = r;
  }
  /**
   * The alpha value of the left & top bevel.
   * @default 0.7
   */
  get lightAlpha() {
    return this.uniforms.uLightAlpha;
  }
  set lightAlpha(t) {
    this.uniforms.uLightAlpha = t;
  }
  /**
   * The color value of the right & bottom bevel.
   * @default 0xffffff
   */
  get shadowColor() {
    return this._shadowColor.value;
  }
  set shadowColor(t) {
    this._shadowColor.setValue(t);
    const [e, s, r] = this._shadowColor.toArray();
    this.uniforms.uShadowColor[0] = e, this.uniforms.uShadowColor[1] = s, this.uniforms.uShadowColor[2] = r;
  }
  /**
   * The alpha value of the right & bottom bevel.
   * @default 0.7
   */
  get shadowAlpha() {
    return this.uniforms.uShadowAlpha;
  }
  set shadowAlpha(t) {
    this.uniforms.uShadowAlpha = t;
  }
  /**
   * Update the transform matrix of offset angle.
   * @private
   */
  _updateTransform() {
    this.uniforms.uTransform[0] = this.thickness * Math.cos(this._rotation), this.uniforms.uTransform[1] = this.thickness * Math.sin(this._rotation);
  }
};
wa(Mw, "DEFAULT_OPTIONS", {
  rotation: 45,
  thickness: 2,
  lightColor: 16777215,
  lightAlpha: 0.7,
  shadowColor: 0,
  shadowAlpha: 0.7
});
var bw = Object.defineProperty, Pw = (i, t, e) => t in i ? bw(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, Cl = (i, t, e) => (Pw(i, typeof t != "symbol" ? t + "" : t, e), e);
const Nw = class iv extends Yl {
  /** @ignore */
  constructor(...t) {
    let e = t[0] ?? {};
    if (typeof e == "number" || Array.isArray(e) || "x" in e && "y" in e) {
      dt("6.0.0", "BloomFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }");
      let s = e;
      Array.isArray(s) && (s = { x: s[0], y: s[1] }), e = { strength: s }, t[1] !== void 0 && (e.quality = t[1]), t[2] !== void 0 && (e.resolution = t[2]), t[3] !== void 0 && (e.kernelSize = t[3]);
    }
    e = { ...iv.DEFAULT_OPTIONS, ...e }, super(), Cl(this, "_blurXFilter"), Cl(this, "_blurYFilter"), Cl(this, "_strength"), this._strength = { x: 2, y: 2 }, e.strength && (typeof e.strength == "number" ? (this._strength.x = e.strength, this._strength.y = e.strength) : (this._strength.x = e.strength.x, this._strength.y = e.strength.y)), this._blurXFilter = new $S({
      ...e,
      horizontal: !0,
      strength: this.strengthX
    }), this._blurYFilter = new $S({
      ...e,
      horizontal: !1,
      strength: this.strengthY
    }), this._blurYFilter.blendMode = "screen", Object.assign(this, e);
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(t, e, s, r) {
    const n = ps.getSameSizeTexture(e);
    t.applyFilter(this, e, s, r), this._blurXFilter.apply(t, e, n, !0), this._blurYFilter.apply(t, n, s, !1), ps.returnTexture(n);
  }
  /**
   * Sets the strength of both the blurX and blurY properties simultaneously
   * @default 2
   */
  get strength() {
    return this._strength;
  }
  set strength(t) {
    this._strength = typeof t == "number" ? { x: t, y: t } : t, this._updateStrength();
  }
  /**
   * Sets the strength of the blur on the `x` axis
   * @default 2
   */
  get strengthX() {
    return this.strength.x;
  }
  set strengthX(t) {
    this.strength.x = t, this._updateStrength();
  }
  /**
   * Sets the strength of the blur on the `y` axis
   * @default 2
   */
  get strengthY() {
    return this.strength.y;
  }
  set strengthY(t) {
    this.strength.y = t, this._updateStrength();
  }
  _updateStrength() {
    this._blurXFilter.blur = this.strengthX, this._blurYFilter.blur = this.strengthY;
  }
  /**
   * @deprecated since 6.0.0
   *
   * The strength of both the blurX and blurY properties simultaneously
   * @default 2
   * @see BloomFilter#strength
   */
  get blur() {
    return dt("6.0.0", "BloomFilter.blur is deprecated, please use BloomFilter.strength instead"), this.strengthX;
  }
  set blur(t) {
    dt("6.0.0", "BloomFilter.blur is deprecated, please use BloomFilter.strength instead"), this.strength = t;
  }
  /**
   * @deprecated since 6.0.0
   *
   * The strength of the blurX property
   * @default 2
   * @see BloomFilter#strengthX
   */
  get blurX() {
    return dt("6.0.0", "BloomFilter.blurX is deprecated, please use BloomFilter.strengthX instead"), this.strengthX;
  }
  set blurX(t) {
    dt("6.0.0", "BloomFilter.blurX is deprecated, please use BloomFilter.strengthX instead"), this.strengthX = t;
  }
  /**
   * @deprecated since 6.0.0
   *
   * The strength of the blurY property
   * @default 2
   * @see BloomFilter#strengthY
   */
  get blurY() {
    return dt("6.0.0", "BloomFilter.blurY is deprecated, please use BloomFilter.strengthY instead"), this.strengthY;
  }
  set blurY(t) {
    dt("6.0.0", "BloomFilter.blurY is deprecated, please use BloomFilter.strengthY instead"), this.strengthY = t;
  }
};
Cl(Nw, "DEFAULT_OPTIONS", {
  strength: { x: 2, y: 2 },
  quality: 4,
  resolution: 1,
  kernelSize: 5
});
var Uw = `precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uDimensions;
uniform vec2 uCenter;
uniform float uRadius;
uniform float uStrength;

uniform vec4 uInputSize;
uniform vec4 uInputClamp;

void main()
{
    vec2 coord = vTextureCoord * uInputSize.xy;
    coord -= uCenter * uDimensions.xy;
    float distance = length(coord);

    if (distance < uRadius) {
        float percent = distance / uRadius;
        if (uStrength > 0.0) {
            coord *= mix(1.0, smoothstep(0.0, uRadius / distance, percent), uStrength * 0.75);
        } else {
            coord *= mix(1.0, pow(percent, 1.0 + uStrength * 0.75) * uRadius / distance, 1.0 - percent);
        }
    }

    coord += uCenter * uDimensions.xy;
    coord /= uInputSize.xy;
    vec2 clampedCoord = clamp(coord, uInputClamp.xy, uInputClamp.zw);
    vec4 color = texture(uTexture, clampedCoord);

    if (coord != clampedCoord) {
        color *= max(0.0, 1.0 - length(coord - clampedCoord));
    }

    finalColor = color;
}
`, Dw = `struct BulgePinchUniforms {
  uDimensions: vec2<f32>,
  uCenter: vec2<f32>,
  uRadius: f32,
  uStrength: f32,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> bulgePinchUniforms : BulgePinchUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let dimensions: vec2<f32> = bulgePinchUniforms.uDimensions;
  let center: vec2<f32> = bulgePinchUniforms.uCenter;
  let radius: f32 = bulgePinchUniforms.uRadius;
  let strength: f32 = bulgePinchUniforms.uStrength;
  var coord: vec2<f32> = (uv * gfu.uInputSize.xy) - center * dimensions.xy;

  let distance: f32 = length(coord);

  if (distance < radius) {
      let percent: f32 = distance / radius;
      if (strength > 0.0) {
          coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);
      } else {
          coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);
      }
  }
    coord += (center * dimensions.xy);
    coord /= gfu.uInputSize.xy;

    let clampedCoord: vec2<f32> = clamp(coord, gfu.uInputClamp.xy, gfu.uInputClamp.zw);
    var color: vec4<f32> = textureSample(uTexture, uSampler, clampedCoord);
    if (coord.x != clampedCoord.x && coord.y != clampedCoord.y) {
        color *= max(0.0, 1.0 - length(coord - clampedCoord));
    }

    return color;
}

fn compareVec2(x: vec2<f32>, y: vec2<f32>) -> bool
{
  if (x.x == y.x && x.y == y.y)
  {
    return true;
  }

  return false;
}`, Lw = Object.defineProperty, Fw = (i, t, e) => t in i ? Lw(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, rv = (i, t, e) => (Fw(i, typeof t != "symbol" ? t + "" : t, e), e);
const ww = class nv extends xt {
  /**
   * @param options - Options for the BulgePinchFilter constructor.
   */
  constructor(t) {
    t = { ...nv.DEFAULT_OPTIONS, ...t };
    const e = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: Dw,
        entryPoint: "mainFragment"
      }
    }), s = It.from({
      vertex: $t,
      fragment: Uw,
      name: "bulge-pinch-filter"
    });
    super({
      gpuProgram: e,
      glProgram: s,
      resources: {
        bulgePinchUniforms: {
          uDimensions: { value: [0, 0], type: "vec2<f32>" },
          uCenter: { value: t.center, type: "vec2<f32>" },
          uRadius: { value: t.radius, type: "f32" },
          uStrength: { value: t.strength, type: "f32" }
        }
      }
    }), rv(this, "uniforms"), this.uniforms = this.resources.bulgePinchUniforms.uniforms, Object.assign(this, t);
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(t, e, s, r) {
    this.uniforms.uDimensions[0] = e.frame.width, this.uniforms.uDimensions[1] = e.frame.height, t.applyFilter(this, e, s, r);
  }
  /**
   * Sets the center of the effect in normalized screen coords.
   * { x: 0, y: 0 } means top-left and { x: 1, y: 1 } mean bottom-right
   * @default {x:0.5,y:0.5}
   */
  get center() {
    return this.uniforms.uCenter;
  }
  set center(t) {
    typeof t == "number" && (t = { x: t, y: t }), Array.isArray(t) && (t = { x: t[0], y: t[1] }), this.uniforms.uCenter = t;
  }
  /**
   * Sets the center of the effect in normalized screen coords on the `x` axis
   * @default 0
   */
  get centerX() {
    return this.uniforms.uCenter.x;
  }
  set centerX(t) {
    this.uniforms.uCenter.x = t;
  }
  /**
   * Sets the center of the effect in normalized screen coords on the `y` axis
   * @default 0
   */
  get centerY() {
    return this.uniforms.uCenter.y;
  }
  set centerY(t) {
    this.uniforms.uCenter.y = t;
  }
  /**
   * The radius of the circle of effect
   * @default 100
   */
  get radius() {
    return this.uniforms.uRadius;
  }
  set radius(t) {
    this.uniforms.uRadius = t;
  }
  /**
   * A value between -1 and 1 (-1 is strong pinch, 0 is no effect, 1 is strong bulge)
   * @default 1
   */
  get strength() {
    return this.uniforms.uStrength;
  }
  set strength(t) {
    this.uniforms.uStrength = t;
  }
};
rv(ww, "DEFAULT_OPTIONS", {
  center: { x: 0.5, y: 0.5 },
  radius: 100,
  strength: 1
});
var Gw = `precision highp float;
in vec2 vTextureCoord;
in vec2 vFilterCoord;
out vec4 finalColor;

const int TYPE_LINEAR = 0;
const int TYPE_RADIAL = 1;
const int TYPE_CONIC = 2;
const int MAX_STOPS = 32;

uniform sampler2D uTexture;
uniform vec4 uOptions;
uniform vec2 uCounts;
uniform vec3 uColors[MAX_STOPS];
uniform vec4 uStops[MAX_STOPS];

const float PI = 3.1415926538;
const float PI_2 = PI*2.;

struct ColorStop {
    float offset;
    vec3 color;
    float alpha;
};

mat2 rotate2d(float angle){
    return mat2(cos(angle), -sin(angle),
    sin(angle), cos(angle));
}

float projectLinearPosition(vec2 pos, float angle){
    vec2 center = vec2(0.5);
    vec2 result = pos - center;
    result = rotate2d(angle) * result;
    result = result + center;
    return clamp(result.x, 0., 1.);
}

float projectRadialPosition(vec2 pos) {
    float r = distance(pos, vec2(0.5));
    return clamp(2.*r, 0., 1.);
}

float projectAnglePosition(vec2 pos, float angle) {
    vec2 center = pos - vec2(0.5);
    float polarAngle=atan(-center.y, center.x);
    return mod(polarAngle + angle, PI_2) / PI_2;
}

float projectPosition(vec2 pos, int type, float angle) {
    if (type == TYPE_LINEAR) {
        return projectLinearPosition(pos, angle);
    } else if (type == TYPE_RADIAL) {
        return projectRadialPosition(pos);
    } else if (type == TYPE_CONIC) {
        return projectAnglePosition(pos, angle);
    }

    return pos.y;
}

void main(void) {
    int uType = int(uOptions[0]);
    float uAngle = uOptions[1];
    float uAlpha = uOptions[2];
    float uReplace = uOptions[3];

    int uNumStops = int(uCounts[0]);
    float uMaxColors = uCounts[1];

    // current/original color
    vec4 currentColor = texture(uTexture, vTextureCoord);

    // skip calculations if gradient alpha is 0
    if (0.0 == uAlpha) {
        finalColor = currentColor;
        return;
    }

    // project position
    float y = projectPosition(vFilterCoord, int(uType), radians(uAngle));

    // check gradient bounds
    float offsetMin = uStops[0][0];
    float offsetMax = 0.0;

    int numStops = int(uNumStops);

    for (int i = 0; i < MAX_STOPS; i++) {
        if (i == numStops-1){ // last index
            offsetMax = uStops[i][0];
        }
    }

    if (y  < offsetMin || y > offsetMax) {
        finalColor = currentColor;
        return;
    }

    // limit colors
    if (uMaxColors > 0.) {
        float stepSize = 1./uMaxColors;
        float stepNumber = float(floor(y/stepSize));
        y = stepSize * (stepNumber + 0.5);// offset by 0.5 to use color from middle of segment
    }

    // find color stops
    ColorStop from;
    ColorStop to;

    for (int i = 0; i < MAX_STOPS; i++) {
        if (y >= uStops[i][0]) {
            from = ColorStop(uStops[i][0], uColors[i], uStops[i][1]);
            to = ColorStop(uStops[i+1][0], uColors[i+1], uStops[i+1][1]);
        }

        if (i == numStops-1){ // last index
            break;
        }
    }

    // mix colors from stops
    vec4 colorFrom = vec4(from.color * from.alpha, from.alpha);
    vec4 colorTo = vec4(to.color * to.alpha, to.alpha);

    float segmentHeight = to.offset - from.offset;
    float relativePos = y - from.offset;// position from 0 to [segmentHeight]
    float relativePercent = relativePos / segmentHeight;// position in percent between [from.offset] and [to.offset].

    float gradientAlpha = uAlpha * currentColor.a;
    vec4 gradientColor = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;

    if (uReplace < 0.5) {
        // mix resulting color with current color
        finalColor = gradientColor + currentColor*(1.-gradientColor.a);
    } else {
        // replace with gradient color
        finalColor = gradientColor;
    }
}
`, Bw = `in vec2 aPosition;
out vec2 vTextureCoord;
out vec2 vFilterCoord;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
    vFilterCoord = vTextureCoord * uInputSize.xy / uOutputFrame.zw;
}
`, _R = `struct BaseUniforms {
  uOptions: vec4<f32>,
  uCounts: vec2<f32>,
};

struct StopsUniforms {
  uColors: array<vec3<f32>, MAX_STOPS>,
  uStops: array<vec4<f32>, MAX_STOPS>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> baseUniforms : BaseUniforms;
@group(1) @binding(1) var<uniform> stopsUniforms : StopsUniforms;

struct VSOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>,
  @location(1) coord : vec2<f32>
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn filterCoord( vTextureCoord:vec2<f32> ) -> vec2<f32>
{
    return vTextureCoord * gfu.uInputSize.xy / gfu.uOutputFrame.zw;
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  let vTextureCoord: vec2<f32> = filterTextureCoord(aPosition);
  return VSOutput(
   filterVertexPosition(aPosition),
   vTextureCoord,
   filterCoord(vTextureCoord),
  );
}

struct ColorStop {
  offset: f32,
  color: vec3<f32>,
  alpha: f32,
};

fn rotate2d(angle: f32) -> mat2x2<f32>{
  return mat2x2(cos(angle), -sin(angle),
  sin(angle), cos(angle));
}

fn projectLinearPosition(pos: vec2<f32>, angle: f32) -> f32 {
  var center: vec2<f32> = vec2<f32>(0.5);
  var result: vec2<f32> = pos - center;
  result = rotate2d(angle) * result;
  result = result + center;
  return clamp(result.x, 0.0, 1.0);
}

fn projectRadialPosition(pos: vec2<f32>) -> f32 {
  var r: f32 = distance(pos, vec2<f32>(0.5));
  return clamp(2.0 * r, 0.0, 1.0);
}

fn projectAnglePosition(pos: vec2<f32>, angle: f32) -> f32 {
  var center: vec2<f32> = pos - vec2<f32>(0.5, 0.5);
  var polarAngle: f32 = atan2(-center.y, center.x);
  return ((polarAngle + angle) % PI_2) / PI_2;
}

fn projectPosition(pos: vec2<f32>, gradientType: i32, angle: f32) -> f32 {
  if (gradientType == TYPE_LINEAR) {
      return projectLinearPosition(pos, angle);
  } else if (gradientType == TYPE_RADIAL) {
      return projectRadialPosition(pos);
  } else if (gradientType == TYPE_CONIC) {
      return projectAnglePosition(pos, angle);
  }

  return pos.y;
}

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>,
  @location(1) coord : vec2<f32>
) -> @location(0) vec4<f32> {
  let uType: i32 = i32(baseUniforms.uOptions[0]);
  let uAngle: f32 = baseUniforms.uOptions[1];
  let uAlpha: f32 = baseUniforms.uOptions[2];
  let uReplace: f32 = baseUniforms.uOptions[3];

  let uNumStops: i32 = i32(baseUniforms.uCounts[0]);
  let uMaxColors: f32 = baseUniforms.uCounts[1];

  // current/original color
  var currentColor: vec4<f32> = textureSample(uTexture, uSampler, uv);

  // skip calculations if gradient alpha is 0
  if (uAlpha == 0.0) { return currentColor; }

  // project position
  var y: f32 = projectPosition(coord, uType, radians(uAngle));

  // check gradient bounds
  var offsetMin: f32 = stopsUniforms.uStops[0][0];
  var offsetMax: f32 = 0.0;

  let numStops: i32 = uNumStops;

  for (var i: i32 = 0; i < MAX_STOPS; i = i + 1) {
      if (i == numStops - 1) { // last index
          offsetMax = stopsUniforms.uStops[i][0];
      }
  }

  if (y  < offsetMin || y > offsetMax) { return currentColor; }

  // limit colors
  if (uMaxColors > 0.0) {
      var stepSize: f32 = 1.0 / uMaxColors;
      var stepNumber: f32 = floor(y / stepSize);
      y = stepSize * (stepNumber + 0.5); // offset by 0.5 to use color from middle of segment
  }

  // find color stops
  var stopFrom: ColorStop;
  var stopTo: ColorStop;

  for (var i: i32 = 0; i < MAX_STOPS; i = i + 1) {
      if (y >= stopsUniforms.uStops[i][0]) {
          stopFrom = ColorStop(stopsUniforms.uStops[i][0], stopsUniforms.uColors[i], stopsUniforms.uStops[i][1]);
          stopTo = ColorStop(stopsUniforms.uStops[i + 1][0], stopsUniforms.uColors[i + 1], stopsUniforms.uStops[i + 1][1]);
      }

      if (i == numStops - 1) { // last index
          break;
      }
  }

  // mix colors from stops
  var colorFrom: vec4<f32> = vec4<f32>(stopFrom.color * stopFrom.alpha, stopFrom.alpha);
  var colorTo: vec4<f32> = vec4<f32>(stopTo.color * stopTo.alpha, stopTo.alpha);

  var segmentHeight: f32 = stopTo.offset - stopFrom.offset;
  var relativePos: f32 = y - stopFrom.offset; // position from 0 to [segmentHeight]
  var relativePercent: f32 = relativePos / segmentHeight; // position in percent between [from.offset] and [to.offset].

  var gradientAlpha: f32 = uAlpha * currentColor.a;
  var gradientColor: vec4<f32> = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;

  if (uReplace < 0.5) {
      // mix resulting color with current color
      return gradientColor + currentColor * (1.0 - gradientColor.a);
  } else {
      // replace with gradient color
      return gradientColor;
  }
}

const PI: f32 = 3.14159265358979323846264;
const PI_2: f32 = PI * 2.0;

const TYPE_LINEAR: i32 = 0;
const TYPE_RADIAL: i32 = 1;
const TYPE_CONIC: i32 = 2;
const MAX_STOPS: i32 = 32;`, va = va || {};
va.stringify = /* @__PURE__ */ function() {
  var i = {
    "visit_linear-gradient": function(t) {
      return i.visit_gradient(t);
    },
    "visit_repeating-linear-gradient": function(t) {
      return i.visit_gradient(t);
    },
    "visit_radial-gradient": function(t) {
      return i.visit_gradient(t);
    },
    "visit_repeating-radial-gradient": function(t) {
      return i.visit_gradient(t);
    },
    visit_gradient: function(t) {
      var e = i.visit(t.orientation);
      return e && (e += ", "), t.type + "(" + e + i.visit(t.colorStops) + ")";
    },
    visit_shape: function(t) {
      var e = t.value, s = i.visit(t.at), r = i.visit(t.style);
      return r && (e += " " + r), s && (e += " at " + s), e;
    },
    "visit_default-radial": function(t) {
      var e = "", s = i.visit(t.at);
      return s && (e += s), e;
    },
    "visit_extent-keyword": function(t) {
      var e = t.value, s = i.visit(t.at);
      return s && (e += " at " + s), e;
    },
    "visit_position-keyword": function(t) {
      return t.value;
    },
    visit_position: function(t) {
      return i.visit(t.value.x) + " " + i.visit(t.value.y);
    },
    "visit_%": function(t) {
      return t.value + "%";
    },
    visit_em: function(t) {
      return t.value + "em";
    },
    visit_px: function(t) {
      return t.value + "px";
    },
    visit_literal: function(t) {
      return i.visit_color(t.value, t);
    },
    visit_hex: function(t) {
      return i.visit_color("#" + t.value, t);
    },
    visit_rgb: function(t) {
      return i.visit_color("rgb(" + t.value.join(", ") + ")", t);
    },
    visit_rgba: function(t) {
      return i.visit_color("rgba(" + t.value.join(", ") + ")", t);
    },
    visit_color: function(t, e) {
      var s = t, r = i.visit(e.length);
      return r && (s += " " + r), s;
    },
    visit_angular: function(t) {
      return t.value + "deg";
    },
    visit_directional: function(t) {
      return "to " + t.value;
    },
    visit_array: function(t) {
      var e = "", s = t.length;
      return t.forEach(function(r, n) {
        e += i.visit(r), n < s - 1 && (e += ", ");
      }), e;
    },
    visit: function(t) {
      if (!t)
        return "";
      var e = "";
      if (t instanceof Array)
        return i.visit_array(t, e);
      if (t.type) {
        var s = i["visit_" + t.type];
        if (s)
          return s(t);
        throw Error("Missing visitor visit_" + t.type);
      } else
        throw Error("Invalid node.");
    }
  };
  return function(t) {
    return i.visit(t);
  };
}();
var va = va || {};
va.parse = /* @__PURE__ */ function() {
  var i = {
    linearGradient: /^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,
    repeatingLinearGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,
    radialGradient: /^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,
    repeatingRadialGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /^\#([0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^rgb/i,
    rgbaColor: /^rgba/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  }, t = "";
  function e(V) {
    var Mt = new Error(t + ": " + V);
    throw Mt.source = t, Mt;
  }
  function s() {
    var V = r();
    return t.length > 0 && e("Invalid input not EOF"), V;
  }
  function r() {
    return y(n);
  }
  function n() {
    return a(
      "linear-gradient",
      i.linearGradient,
      h
    ) || a(
      "repeating-linear-gradient",
      i.repeatingLinearGradient,
      h
    ) || a(
      "radial-gradient",
      i.radialGradient,
      l
    ) || a(
      "repeating-radial-gradient",
      i.repeatingRadialGradient,
      l
    );
  }
  function a(V, Mt, X) {
    return o(Mt, function(ht) {
      var vr = X();
      return vr && (ut(i.comma) || e("Missing comma before color stops")), {
        type: V,
        orientation: vr,
        colorStops: y(C)
      };
    });
  }
  function o(V, Mt) {
    var X = ut(V);
    if (X) {
      ut(i.startCall) || e("Missing (");
      var ht = Mt(X);
      return ut(i.endCall) || e("Missing )"), ht;
    }
  }
  function h() {
    return u() || c();
  }
  function u() {
    return Y("directional", i.sideOrCorner, 1);
  }
  function c() {
    return Y("angular", i.angleValue, 1);
  }
  function l() {
    var V, Mt = _(), X;
    return Mt && (V = [], V.push(Mt), X = t, ut(i.comma) && (Mt = _(), Mt ? V.push(Mt) : t = X)), V;
  }
  function _() {
    var V = d() || f();
    if (V)
      V.at = g();
    else {
      var Mt = p();
      if (Mt) {
        V = Mt;
        var X = g();
        X && (V.at = X);
      } else {
        var ht = m();
        ht && (V = {
          type: "default-radial",
          at: ht
        });
      }
    }
    return V;
  }
  function d() {
    var V = Y("shape", /^(circle)/i, 0);
    return V && (V.style = K() || p()), V;
  }
  function f() {
    var V = Y("shape", /^(ellipse)/i, 0);
    return V && (V.style = k() || p()), V;
  }
  function p() {
    return Y("extent-keyword", i.extentKeywords, 1);
  }
  function g() {
    if (Y("position", /^at/, 0)) {
      var V = m();
      return V || e("Missing positioning value"), V;
    }
  }
  function m() {
    var V = O();
    if (V.x || V.y)
      return {
        type: "position",
        value: V
      };
  }
  function O() {
    return {
      x: k(),
      y: k()
    };
  }
  function y(V) {
    var Mt = V(), X = [];
    if (Mt)
      for (X.push(Mt); ut(i.comma); )
        Mt = V(), Mt ? X.push(Mt) : e("One extra comma");
    return X;
  }
  function C() {
    var V = b();
    return V || e("Expected color definition"), V.length = k(), V;
  }
  function b() {
    return P() || M() || F() || D();
  }
  function D() {
    return Y("literal", i.literalColor, 0);
  }
  function P() {
    return Y("hex", i.hexColor, 1);
  }
  function F() {
    return o(i.rgbColor, function() {
      return {
        type: "rgb",
        value: y(U)
      };
    });
  }
  function M() {
    return o(i.rgbaColor, function() {
      return {
        type: "rgba",
        value: y(U)
      };
    });
  }
  function U() {
    return ut(i.number)[1];
  }
  function k() {
    return Y("%", i.percentageValue, 1) || ft() || K();
  }
  function ft() {
    return Y("position-keyword", i.positionKeywords, 1);
  }
  function K() {
    return Y("px", i.pixelValue, 1) || Y("em", i.emValue, 1);
  }
  function Y(V, Mt, X) {
    var ht = ut(Mt);
    if (ht)
      return {
        type: V,
        value: ht[X]
      };
  }
  function ut(V) {
    var Mt, X;
    return X = /^[\n\r\t\s]+/.exec(t), X && Gt(X[0].length), Mt = V.exec(t), Mt && Gt(Mt[0].length), Mt;
  }
  function Gt(V) {
    t = t.substr(V);
  }
  return function(V) {
    return t = V.toString(), s();
  };
}();
var kw = va.parse;
va.stringify;
function zw(i) {
  const t = kw(qw(i));
  if (t.length === 0)
    throw new Error("Invalid CSS gradient.");
  if (t.length !== 1)
    throw new Error("Unsupported CSS gradient (multiple gradients is not supported).");
  const e = t[0], s = Vw(e.type), r = Hw(e.colorStops), n = Xw(e.orientation);
  return {
    type: s,
    stops: r,
    angle: n
  };
}
function Vw(i) {
  const t = {
    "linear-gradient": 0,
    "radial-gradient": 1
  };
  if (!(i in t))
    throw new Error(`Unsupported gradient type "${i}"`);
  return t[i];
}
function Hw(i) {
  const t = Ww(i), e = [], s = new Pt();
  for (let r = 0; r < i.length; r++) {
    const n = Yw(i[r]), a = s.setValue(n).toArray();
    e.push({
      offset: t[r],
      color: a.slice(0, 3),
      alpha: a[3]
    });
  }
  return e;
}
function Yw(i) {
  switch (i.type) {
    case "hex":
      return `#${i.value}`;
    case "literal":
      return i.value;
    default:
      return `${i.type}(${i.value.join(",")})`;
  }
}
function Ww(i) {
  const t = [];
  for (let n = 0; n < i.length; n++) {
    const a = i[n];
    let o = -1;
    a.type === "literal" && a.length && "type" in a.length && a.length.type === "%" && "value" in a.length && (o = parseFloat(a.length.value) / 100), t.push(o);
  }
  const s = (n) => {
    for (let a = n; a < t.length; a++)
      if (t[a] !== -1)
        return {
          indexDelta: a - n,
          offset: t[a]
        };
    return {
      indexDelta: t.length - 1 - n,
      offset: 1
    };
  };
  let r = 0;
  for (let n = 0; n < t.length; n++) {
    const a = t[n];
    if (a !== -1)
      r = a;
    else if (n === 0)
      t[n] = 0;
    else if (n + 1 === t.length)
      t[n] = 1;
    else {
      const o = s(n), u = (o.offset - r) / (1 + o.indexDelta);
      for (let c = 0; c <= o.indexDelta; c++)
        t[n + c] = r + (c + 1) * u;
      n += o.indexDelta, r = t[n];
    }
  }
  return t.map(jw);
}
function jw(i) {
  return i.toString().length > 6 ? parseFloat(i.toString().substring(0, 6)) : i;
}
function Xw(i) {
  if (typeof i > "u")
    return 0;
  if ("type" in i && "value" in i)
    switch (i.type) {
      case "angular":
        return parseFloat(i.value);
      case "directional":
        return Kw(i.value);
    }
  return 0;
}
function Kw(i) {
  const t = {
    left: 270,
    top: 0,
    bottom: 180,
    right: 90,
    "left top": 315,
    "top left": 315,
    "left bottom": 225,
    "bottom left": 225,
    "right top": 45,
    "top right": 45,
    "right bottom": 135,
    "bottom right": 135
  };
  if (!(i in t))
    throw new Error(`Unsupported directional value "${i}"`);
  return t[i];
}
function qw(i) {
  let t = i.replace(/\s{2,}/gu, " ");
  return t = t.replace(/;/g, ""), t = t.replace(/ ,/g, ","), t = t.replace(/\( /g, "("), t = t.replace(/ \)/g, ")"), t.trim();
}
var $w = Object.defineProperty, Zw = (i, t, e) => t in i ? $w(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, da = (i, t, e) => (Zw(i, typeof t != "symbol" ? t + "" : t, e), e);
const Xf = 90;
function Qw(i) {
  return [...i].sort((t, e) => t.offset - e.offset);
}
const bu = class xl extends xt {
  /**
   * @param options - Options for the ColorGradientFilter constructor.
   */
  constructor(t) {
    if (t && "css" in t ? t = {
      ...zw(t.css || ""),
      alpha: t.alpha ?? xl.defaults.alpha,
      maxColors: t.maxColors ?? xl.defaults.maxColors
    } : t = { ...xl.defaults, ...t }, !t.stops || t.stops.length < 2)
      throw new Error("ColorGradientFilter requires at least 2 color stops.");
    const e = Ot.from({
      vertex: {
        source: _R,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: _R,
        entryPoint: "mainFragment"
      }
    }), s = It.from({
      vertex: Bw,
      fragment: Gw,
      name: "color-gradient-filter"
    }), r = 32;
    super({
      gpuProgram: e,
      glProgram: s,
      resources: {
        baseUniforms: {
          uOptions: {
            value: [
              // Gradient Type
              t.type,
              // Gradient Angle
              t.angle ?? Xf,
              // Master Alpha
              t.alpha,
              // Replace Base Color
              t.replace ? 1 : 0
            ],
            type: "vec4<f32>"
          },
          uCounts: {
            value: [
              // Number of Stops
              t.stops.length,
              // Max Gradient Colors
              t.maxColors
            ],
            type: "vec2<f32>"
          }
        },
        stopsUniforms: {
          uColors: { value: new Float32Array(r * 3), type: "vec3<f32>", size: r },
          // We only need vec2, but we need to pad to eliminate the WGSL warning, TODO: @Mat ?
          uStops: { value: new Float32Array(r * 4), type: "vec4<f32>", size: r }
        }
      }
    }), da(this, "baseUniforms"), da(this, "stopsUniforms"), da(this, "_stops", []), this.baseUniforms = this.resources.baseUniforms.uniforms, this.stopsUniforms = this.resources.stopsUniforms.uniforms, Object.assign(this, t);
  }
  get stops() {
    return this._stops;
  }
  set stops(t) {
    const e = Qw(t), s = new Pt();
    let r, n, a;
    for (let o = 0; o < e.length; o++) {
      s.setValue(e[o].color);
      const h = o * 3;
      [r, n, a] = s.toArray(), this.stopsUniforms.uColors[h] = r, this.stopsUniforms.uColors[h + 1] = n, this.stopsUniforms.uColors[h + 2] = a, this.stopsUniforms.uStops[o * 4] = e[o].offset, this.stopsUniforms.uStops[o * 4 + 1] = e[o].alpha;
    }
    this.baseUniforms.uCounts[0] = e.length, this._stops = e;
  }
  /**
  * The type of gradient
  * @default ColorGradientFilter.LINEAR
  */
  get type() {
    return this.baseUniforms.uOptions[0];
  }
  set type(t) {
    this.baseUniforms.uOptions[0] = t;
  }
  /**
  * The angle of the gradient in degrees
  * @default 90
  */
  get angle() {
    return this.baseUniforms.uOptions[1] + Xf;
  }
  set angle(t) {
    this.baseUniforms.uOptions[1] = t - Xf;
  }
  /**
  * The alpha value of the gradient (0-1)
  * @default 1
  */
  get alpha() {
    return this.baseUniforms.uOptions[2];
  }
  set alpha(t) {
    this.baseUniforms.uOptions[2] = t;
  }
  /**
  * The maximum number of colors to render (0 = no limit)
  * @default 0
  */
  get maxColors() {
    return this.baseUniforms.uCounts[1];
  }
  set maxColors(t) {
    this.baseUniforms.uCounts[1] = t;
  }
  /**
   * If true, the gradient will replace the existing color, otherwise it
   * will be multiplied with it
   * @default false
   */
  get replace() {
    return this.baseUniforms.uOptions[3] > 0.5;
  }
  set replace(t) {
    this.baseUniforms.uOptions[3] = t ? 1 : 0;
  }
};
da(bu, "LINEAR", 0);
da(bu, "RADIAL", 1);
da(bu, "CONIC", 2);
da(bu, "defaults", {
  type: bu.LINEAR,
  stops: [
    { offset: 0, color: 16711680, alpha: 1 },
    { offset: 1, color: 255, alpha: 1 }
  ],
  alpha: 1,
  angle: 90,
  maxColors: 0,
  replace: !1
});
var Jw = `in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform sampler2D uMapTexture;
uniform float uMix;
uniform float uSize;
uniform float uSliceSize;
uniform float uSlicePixelSize;
uniform float uSliceInnerSize;

void main() {
    vec4 color = texture(uTexture, vTextureCoord.xy);
    vec4 adjusted;

    if (color.a > 0.0) {
        color.rgb /= color.a;
        float innerWidth = uSize - 1.0;
        float zSlice0 = min(floor(color.b * innerWidth), innerWidth);
        float zSlice1 = min(zSlice0 + 1.0, innerWidth);
        float xOffset = uSlicePixelSize * 0.5 + color.r * uSliceInnerSize;
        float s0 = xOffset + (zSlice0 * uSliceSize);
        float s1 = xOffset + (zSlice1 * uSliceSize);
        float yOffset = uSliceSize * 0.5 + color.g * (1.0 - uSliceSize);
        vec4 slice0Color = texture(uMapTexture, vec2(s0,yOffset));
        vec4 slice1Color = texture(uMapTexture, vec2(s1,yOffset));
        float zOffset = fract(color.b * innerWidth);
        adjusted = mix(slice0Color, slice1Color, zOffset);

        color.rgb *= color.a;
    }

    finalColor = vec4(mix(color, adjusted, uMix).rgb, color.a);

}`, tG = `struct ColorMapUniforms {
  uMix: f32,
  uSize: f32,
  uSliceSize: f32,
  uSlicePixelSize: f32,
  uSliceInnerSize: f32,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> colorMapUniforms : ColorMapUniforms;
@group(1) @binding(1) var uMapTexture: texture_2d<f32>;
@group(1) @binding(2) var uMapSampler: sampler;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  var color:vec4<f32> = textureSample(uTexture, uSampler, uv);

  var adjusted: vec4<f32>;

  var altColor: vec4<f32> = vec4<f32>(color.rgb / color.a, color.a);
  let innerWidth: f32 = colorMapUniforms.uSize - 1.0;
  let zSlice0: f32 = min(floor(color.b * innerWidth), innerWidth);
  let zSlice1: f32 = min(zSlice0 + 1.0, innerWidth);
  let xOffset: f32 = colorMapUniforms.uSlicePixelSize * 0.5 + color.r * colorMapUniforms.uSliceInnerSize;
  let s0: f32 = xOffset + (zSlice0 * colorMapUniforms.uSliceSize);
  let s1: f32 = xOffset + (zSlice1 * colorMapUniforms.uSliceSize);
  let yOffset: f32 = colorMapUniforms.uSliceSize * 0.5 + color.g * (1.0 - colorMapUniforms.uSliceSize);
  let slice0Color: vec4<f32> = textureSample(uMapTexture, uMapSampler, vec2(s0,yOffset));
  let slice1Color: vec4<f32> = textureSample(uMapTexture, uMapSampler, vec2(s1,yOffset));
  let zOffset: f32 = fract(color.b * innerWidth);
  adjusted = mix(slice0Color, slice1Color, zOffset);
  altColor = vec4<f32>(color.rgb * color.a, color.a);

  let realColor: vec4<f32> = select(color, altColor, color.a > 0.0);

  return vec4<f32>(mix(realColor, adjusted, colorMapUniforms.uMix).rgb, realColor.a);
}`, eG = Object.defineProperty, sG = (i, t, e) => t in i ? eG(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, Qi = (i, t, e) => (sG(i, typeof t != "symbol" ? t + "" : t, e), e);
const iG = class av extends xt {
  /** @ignore */
  constructor(...t) {
    let e = t[0] ?? {};
    if ((e instanceof W || e instanceof ke) && (dt("6.0.0", "ColorMapFilter constructor params are now options object. See params: { colorMap, nearest, mix }"), e = { colorMap: e }, t[1] !== void 0 && (e.nearest = t[1]), t[2] !== void 0 && (e.mix = t[2])), e = { ...av.DEFAULT_OPTIONS, ...e }, !e.colorMap)
      throw Error("No color map texture source was provided to ColorMapFilter");
    const s = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: tG,
        entryPoint: "mainFragment"
      }
    }), r = It.from({
      vertex: $t,
      fragment: Jw,
      name: "color-map-filter"
    });
    super({
      gpuProgram: s,
      glProgram: r,
      resources: {
        colorMapUniforms: {
          uMix: { value: e.mix, type: "f32" },
          uSize: { value: 0, type: "f32" },
          uSliceSize: { value: 0, type: "f32" },
          uSlicePixelSize: { value: 0, type: "f32" },
          uSliceInnerSize: { value: 0, type: "f32" }
        },
        uMapTexture: e.colorMap.source,
        uMapSampler: e.colorMap.source.style
      }
    }), Qi(this, "uniforms"), Qi(this, "_size", 0), Qi(this, "_sliceSize", 0), Qi(this, "_slicePixelSize", 0), Qi(this, "_sliceInnerSize", 0), Qi(this, "_nearest", !1), Qi(this, "_scaleMode", "linear"), Qi(this, "_colorMap"), this.uniforms = this.resources.colorMapUniforms.uniforms, Object.assign(this, e);
  }
  /** The mix from 0 to 1, where 0 is the original image and 1 is the color mapped image. */
  get mix() {
    return this.uniforms.uMix;
  }
  set mix(t) {
    this.uniforms.uMix = t;
  }
  /**
   * The size of one color slice.
   * @readonly
   */
  get colorSize() {
    return this._size;
  }
  /** The colorMap texture. */
  get colorMap() {
    return this._colorMap;
  }
  set colorMap(t) {
    if (!t || t === this.colorMap)
      return;
    const e = t instanceof W ? t.source : t;
    e.style.scaleMode = this._scaleMode, e.autoGenerateMipmaps = !1, this._size = e.height, this._sliceSize = 1 / this._size, this._slicePixelSize = this._sliceSize / this._size, this._sliceInnerSize = this._slicePixelSize * (this._size - 1), this.uniforms.uSize = this._size, this.uniforms.uSliceSize = this._sliceSize, this.uniforms.uSlicePixelSize = this._slicePixelSize, this.uniforms.uSliceInnerSize = this._sliceInnerSize, this.resources.uMapTexture = e, this._colorMap = t;
  }
  /** Whether use NEAREST for colorMap texture. */
  get nearest() {
    return this._nearest;
  }
  set nearest(t) {
    this._nearest = t, this._scaleMode = t ? "nearest" : "linear";
    const e = this._colorMap;
    e && e.source && (e.source.scaleMode = this._scaleMode, e.source.autoGenerateMipmaps = !1, e.source.style.update(), e.source.update());
  }
  /**
   * If the colorMap is based on canvas,
   * and the content of canvas has changed, then call `updateColorMap` for update texture.
   */
  updateColorMap() {
    const t = this._colorMap;
    t != null && t.source && (t.source.update(), this.colorMap = t);
  }
  /**
   * Destroys this filter
   * @default false
   */
  destroy() {
    var t;
    (t = this._colorMap) == null || t.destroy(), super.destroy();
  }
};
Qi(iG, "DEFAULT_OPTIONS", {
  colorMap: W.WHITE,
  nearest: !1,
  mix: 1
});
var rG = `in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec3 uColor;
uniform float uAlpha;

void main(void) {
    vec4 c = texture(uTexture, vTextureCoord);
    finalColor = vec4(mix(c.rgb, uColor.rgb, c.a * uAlpha), c.a);
}
`, nG = `struct ColorOverlayUniforms {
    uColor: vec3<f32>,
    uAlpha: f32,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> colorOverlayUniforms : ColorOverlayUniforms;

@fragment
fn mainFragment(
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
    let c = textureSample(uTexture, uSampler, uv);
    return vec4<f32>(mix(c.rgb, colorOverlayUniforms.uColor.rgb, c.a * colorOverlayUniforms.uAlpha), c.a);
}
`, aG = Object.defineProperty, oG = (i, t, e) => t in i ? aG(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, vp = (i, t, e) => (oG(i, typeof t != "symbol" ? t + "" : t, e), e);
const hG = class ov extends xt {
  /** @ignore */
  constructor(...t) {
    let e = t[0] ?? {};
    (typeof e == "number" || Array.isArray(e) || e instanceof Float32Array) && (dt("6.0.0", "ColorOverlayFilter constructor params are now options object. See params: { color, alpha }"), e = { color: e }, t[1] !== void 0 && (e.alpha = t[1])), e = { ...ov.DEFAULT_OPTIONS, ...e };
    const s = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: nG,
        entryPoint: "mainFragment"
      }
    }), r = It.from({
      vertex: $t,
      fragment: rG,
      name: "color-overlay-filter"
    });
    super({
      gpuProgram: s,
      glProgram: r,
      resources: {
        colorOverlayUniforms: {
          uColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uAlpha: { value: e.alpha, type: "f32" }
        }
      }
    }), vp(this, "uniforms"), vp(this, "_color"), this.uniforms = this.resources.colorOverlayUniforms.uniforms, this._color = new Pt(), this.color = e.color ?? 0;
  }
  /**
   * The over color source
   * @member {number|Array<number>|Float32Array}
   * @default 0x000000
   */
  get color() {
    return this._color.value;
  }
  set color(t) {
    this._color.setValue(t);
    const [e, s, r] = this._color.toArray();
    this.uniforms.uColor[0] = e, this.uniforms.uColor[1] = s, this.uniforms.uColor[2] = r;
  }
  /**
   * The alpha value of the color
   * @default 1
   */
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(t) {
    this.uniforms.uAlpha = t;
  }
};
vp(hG, "DEFAULT_OPTIONS", {
  /** The color of the overlay */
  color: 0,
  /** The alpha of the overlay */
  alpha: 1
});
var uG = `in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec3 uOriginalColor;
uniform vec3 uTargetColor;
uniform float uTolerance;

void main(void) {
    vec4 c = texture(uTexture, vTextureCoord);
    vec3 colorDiff = uOriginalColor - (c.rgb / max(c.a, 0.0000000001));
    float colorDistance = length(colorDiff);
    float doReplace = step(colorDistance, uTolerance);
    finalColor = vec4(mix(c.rgb, (uTargetColor + colorDiff) * c.a, doReplace), c.a);
}
`, lG = `struct ColorReplaceUniforms {
  uOriginalColor: vec3<f32>,
  uTargetColor: vec3<f32>,
  uTolerance: f32,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> colorReplaceUniforms : ColorReplaceUniforms;

@fragment
fn mainFragment(
   @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let sample: vec4<f32> = textureSample(uTexture, uSampler, uv);

  let colorDiff: vec3<f32> = colorReplaceUniforms.uOriginalColor - (sample.rgb / max(sample.a, 0.0000000001));
  let colorDistance: f32 = length(colorDiff);
  let doReplace: f32 = step(colorDistance, colorReplaceUniforms.uTolerance);

  return vec4<f32>(mix(sample.rgb, (colorReplaceUniforms.uTargetColor + colorDiff) * sample.a, doReplace), sample.a);
}`, cG = Object.defineProperty, _G = (i, t, e) => t in i ? cG(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, Ml = (i, t, e) => (_G(i, typeof t != "symbol" ? t + "" : t, e), e);
const dG = class hv extends xt {
  /** @ignore */
  constructor(...t) {
    let e = t[0] ?? {};
    (typeof e == "number" || Array.isArray(e) || e instanceof Float32Array) && (dt("6.0.0", "ColorReplaceFilter constructor params are now options object. See params: { originalColor, targetColor, tolerance }"), e = { originalColor: e }, t[1] !== void 0 && (e.targetColor = t[1]), t[2] !== void 0 && (e.tolerance = t[2])), e = { ...hv.DEFAULT_OPTIONS, ...e };
    const s = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: lG,
        entryPoint: "mainFragment"
      }
    }), r = It.from({
      vertex: $t,
      fragment: uG,
      name: "color-replace-filter"
    });
    super({
      gpuProgram: s,
      glProgram: r,
      resources: {
        colorReplaceUniforms: {
          uOriginalColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uTargetColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uTolerance: { value: e.tolerance, type: "f32" }
        }
      }
    }), Ml(this, "uniforms"), Ml(this, "_originalColor"), Ml(this, "_targetColor"), this.uniforms = this.resources.colorReplaceUniforms.uniforms, this._originalColor = new Pt(), this._targetColor = new Pt(), this.originalColor = e.originalColor ?? 16711680, this.targetColor = e.targetColor ?? 0, Object.assign(this, e);
  }
  /**
   * The color that will be changed.
   * @example [1.0, 1.0, 1.0] = 0xffffff
   * @default 0xff0000
   */
  get originalColor() {
    return this._originalColor.value;
  }
  set originalColor(t) {
    this._originalColor.setValue(t);
    const [e, s, r] = this._originalColor.toArray();
    this.uniforms.uOriginalColor[0] = e, this.uniforms.uOriginalColor[1] = s, this.uniforms.uOriginalColor[2] = r;
  }
  /**
    * The resulting color.
    * @example [1.0, 1.0, 1.0] = 0xffffff
    * @default 0x000000
    */
  get targetColor() {
    return this._targetColor.value;
  }
  set targetColor(t) {
    this._targetColor.setValue(t);
    const [e, s, r] = this._targetColor.toArray();
    this.uniforms.uTargetColor[0] = e, this.uniforms.uTargetColor[1] = s, this.uniforms.uTargetColor[2] = r;
  }
  /**
    * Tolerance/sensitivity of the floating-point comparison between colors (lower = more exact, higher = more inclusive)
    * @default 0.4
    */
  get tolerance() {
    return this.uniforms.uTolerance;
  }
  set tolerance(t) {
    this.uniforms.uTolerance = t;
  }
  /**
   * @deprecated since 6.0.0
   *
   * The resulting color, as a 3 component RGB e.g. [1.0, 0.5, 1.0]
   * @member {number|Array<number>|Float32Array}
   * @default 0x000000
   * @see ColorReplaceFilter#targetColor
   */
  set newColor(t) {
    dt("6.0.0", "ColorReplaceFilter.newColor is deprecated, please use ColorReplaceFilter.targetColor instead"), this.targetColor = t;
  }
  get newColor() {
    return dt("6.0.0", "ColorReplaceFilter.newColor is deprecated, please use ColorReplaceFilter.targetColor instead"), this.targetColor;
  }
  /**
   * @deprecated since 6.0.0
   *
   * Tolerance/sensitivity of the floating-point comparison between colors (lower = more exact, higher = more inclusive)
   * @default 0.4
   * @see ColorReplaceFilter#tolerance
   */
  set epsilon(t) {
    dt("6.0.0", "ColorReplaceFilter.epsilon is deprecated, please use ColorReplaceFilter.tolerance instead"), this.tolerance = t;
  }
  get epsilon() {
    return dt("6.0.0", "ColorReplaceFilter.epsilon is deprecated, please use ColorReplaceFilter.tolerance instead"), this.tolerance;
  }
};
Ml(dG, "DEFAULT_OPTIONS", {
  originalColor: 16711680,
  targetColor: 0,
  tolerance: 0.4
});
var fG = `in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uTexelSize;
uniform mat3 uMatrix;

void main(void)
{
    vec4 c11 = texture(uTexture, vTextureCoord - uTexelSize); // top left
    vec4 c12 = texture(uTexture, vec2(vTextureCoord.x, vTextureCoord.y - uTexelSize.y)); // top center
    vec4 c13 = texture(uTexture, vec2(vTextureCoord.x + uTexelSize.x, vTextureCoord.y - uTexelSize.y)); // top right

    vec4 c21 = texture(uTexture, vec2(vTextureCoord.x - uTexelSize.x, vTextureCoord.y)); // mid left
    vec4 c22 = texture(uTexture, vTextureCoord); // mid center
    vec4 c23 = texture(uTexture, vec2(vTextureCoord.x + uTexelSize.x, vTextureCoord.y)); // mid right

    vec4 c31 = texture(uTexture, vec2(vTextureCoord.x - uTexelSize.x, vTextureCoord.y + uTexelSize.y)); // bottom left
    vec4 c32 = texture(uTexture, vec2(vTextureCoord.x, vTextureCoord.y + uTexelSize.y)); // bottom center
    vec4 c33 = texture(uTexture, vTextureCoord + uTexelSize); // bottom right

    finalColor =
        c11 * uMatrix[0][0] + c12 * uMatrix[0][1] + c13 * uMatrix[0][2] +
        c21 * uMatrix[1][0] + c22 * uMatrix[1][1] + c23 * uMatrix[1][2] +
        c31 * uMatrix[2][0] + c32 * uMatrix[2][1] + c33 * uMatrix[2][2];

    finalColor.a = c22.a;
}`, gG = `struct ConvolutionUniforms {
    uMatrix: mat3x3<f32>,
    uTexelSize: vec2<f32>,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> convolutionUniforms : ConvolutionUniforms;

@fragment
fn mainFragment(
    @location(0) uv: vec2<f32>,
    @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
    let texelSize = convolutionUniforms.uTexelSize;
    let matrix = convolutionUniforms.uMatrix;

    let c11: vec4<f32> = textureSample(uTexture, uSampler, uv - texelSize); // top left
    let c12: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x, uv.y - texelSize.y)); // top center
    let c13: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x + texelSize.x, uv.y - texelSize.y)); // top right

    let c21: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x - texelSize.x, uv.y)); // mid left
    let c22: vec4<f32> = textureSample(uTexture, uSampler, uv); // mid center
    let c23: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x + texelSize.x, uv.y)); // mid right

    let c31: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x - texelSize.x, uv.y + texelSize.y)); // bottom left
    let c32: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x, uv.y + texelSize.y)); // bottom center
    let c33: vec4<f32> = textureSample(uTexture, uSampler, uv + texelSize); // bottom right

    var finalColor: vec4<f32> = vec4<f32>(
        c11 * matrix[0][0] + c12 * matrix[0][1] + c13 * matrix[0][2] +
        c21 * matrix[1][0] + c22 * matrix[1][1] + c23 * matrix[1][2] +
        c31 * matrix[2][0] + c32 * matrix[2][1] + c33 * matrix[2][2]
    );

    finalColor.a = c22.a;

    return finalColor;
}`, pG = Object.defineProperty, mG = (i, t, e) => t in i ? pG(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, uv = (i, t, e) => (mG(i, typeof t != "symbol" ? t + "" : t, e), e);
const EG = class lv extends xt {
  /** @ignore */
  constructor(...t) {
    let e = t[0] ?? {};
    Array.isArray(e) && (dt("6.0.0", "ConvolutionFilter constructor params are now options object. See params: { matrix, width, height }"), e = { matrix: e }, t[1] !== void 0 && (e.width = t[1]), t[2] !== void 0 && (e.height = t[2])), e = { ...lv.DEFAULT_OPTIONS, ...e };
    const s = e.width ?? 200, r = e.height ?? 200, n = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: gG,
        entryPoint: "mainFragment"
      }
    }), a = It.from({
      vertex: $t,
      fragment: fG,
      name: "convolution-filter"
    });
    super({
      gpuProgram: n,
      glProgram: a,
      resources: {
        convolutionUniforms: {
          uMatrix: { value: e.matrix, type: "mat3x3<f32>" },
          uTexelSize: { value: { x: 1 / s, y: 1 / r }, type: "vec2<f32>" }
        }
      }
    }), uv(this, "uniforms"), this.uniforms = this.resources.convolutionUniforms.uniforms, this.width = s, this.height = r;
  }
  /**
   * An array of values used for matrix transformation, specified as a 9 point Array
   * @example
   * const matrix = new Float32Array(9); // 9 elements of value 0
   * const matrix = [0,0.5,0,0.5,1,0.5,0,0.5,0];
   * @default [0,0,0,0,0,0,0,0,0]
   */
  get matrix() {
    return this.uniforms.uMatrix;
  }
  set matrix(t) {
    t.forEach((e, s) => {
      this.uniforms.uMatrix[s] = e;
    });
  }
  /**
   * Width of the object you are transforming
   * @default 200
   */
  get width() {
    return 1 / this.uniforms.uTexelSize.x;
  }
  set width(t) {
    this.uniforms.uTexelSize.x = 1 / t;
  }
  /**
   * Height of the object you are transforming
   * @default 200
   */
  get height() {
    return 1 / this.uniforms.uTexelSize.y;
  }
  set height(t) {
    this.uniforms.uTexelSize.y = 1 / t;
  }
};
uv(EG, "DEFAULT_OPTIONS", {
  matrix: new Float32Array(9),
  width: 200,
  height: 200
});
var TG = `precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec4 uLine;
uniform vec2 uNoise;
uniform vec3 uVignette;
uniform float uSeed;
uniform float uTime;
uniform vec2 uDimensions;

uniform vec4 uInputSize;

const float SQRT_2 = 1.414213;

float rand(vec2 co) {
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

float vignette(vec3 co, vec2 coord)
{
    float outter = SQRT_2 - uVignette[0] * SQRT_2;
    vec2 dir = vec2(0.5) - coord;
    dir.y *= uDimensions.y / uDimensions.x;
    float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignette[2] * SQRT_2), 0.0, 1.0);
    return darker + (1.0 - darker) * (1.0 - uVignette[1]);
}

float noise(vec2 coord)
{
    vec2 pixelCoord = coord * uInputSize.xy;
    pixelCoord.x = floor(pixelCoord.x / uNoise[1]);
    pixelCoord.y = floor(pixelCoord.y / uNoise[1]);
    return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];
}

vec3 interlaceLines(vec3 co, vec2 coord)
{
    vec3 color = co;

    float curvature = uLine[0];
    float lineWidth = uLine[1];
    float lineContrast = uLine[2];
    float verticalLine = uLine[3];

    vec2 dir = vec2(coord * uInputSize.xy / uDimensions - 0.5);

    float _c = curvature > 0. ? curvature : 1.;
    float k = curvature > 0. ? (length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;
    vec2 uv = dir * k;
    float v = verticalLine > 0.5 ? uv.x * uDimensions.x : uv.y * uDimensions.y;
    v *= min(1.0, 2.0 / lineWidth ) / _c;
    float j = 1. + cos(v * 1.2 - uTime) * 0.5 * lineContrast;
    color *= j;

    float segment = verticalLine > 0.5 ? mod((dir.x + .5) * uDimensions.x, 4.) : mod((dir.y + .5) * uDimensions.y, 4.);
    color *= 0.99 + ceil(segment) * 0.015;

    return color;
}

void main(void)
{
    finalColor = texture(uTexture, vTextureCoord);
    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions;

    if (uNoise[0] > 0.0 && uNoise[1] > 0.0)
    {
        float n = noise(vTextureCoord);
        finalColor += vec4(n, n, n, finalColor.a);
    }

    if (uVignette[0] > 0.)
    {
        float v = vignette(finalColor.rgb, coord);
        finalColor *= vec4(v, v, v, finalColor.a);
    }

    if (uLine[1] > 0.0)
    {
        finalColor = vec4(interlaceLines(finalColor.rgb, vTextureCoord), finalColor.a);  
    }
}
`, IG = `struct CRTUniforms {
    uLine: vec4<f32>,
    uNoise: vec2<f32>,
    uVignette: vec3<f32>,
    uSeed: f32,
    uTime: f32,
    uDimensions: vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> crtUniforms : CRTUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
    
  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);
  let coord: vec2<f32> = uv * gfu.uInputSize.xy / crtUniforms.uDimensions;

  let uNoise = crtUniforms.uNoise;

  if (uNoise[0] > 0.0 && uNoise[1] > 0.0)
  {
    color += vec4<f32>(vec3<f32>(noise(uv)), color.a);
  }

  if (crtUniforms.uVignette[0] > 0.)
  {
    color *= vec4<f32>(vec3<f32>(vignette(color.rgb, coord)), color.a);
  }

  if (crtUniforms.uLine[1] > 0.0)
  {
    color = vec4<f32>(vec3<f32>(interlaceLines(color.rgb, uv)), color.a);  
  }

  return color;
}

const SQRT_2: f32 = 1.414213;

fn modulo(x: f32, y: f32) -> f32
{
  return x - y * floor(x/y);
}

fn rand(co: vec2<f32>) -> f32
{
  return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);
}

fn vignette(co: vec3<f32>, coord: vec2<f32>) -> f32
{
  let uVignette = crtUniforms.uVignette;
  let uDimensions = crtUniforms.uDimensions;
  
  let outter: f32 = SQRT_2 - uVignette[0] * SQRT_2;
  var dir: vec2<f32> = vec2<f32>(0.5) - coord;
  dir.y *= uDimensions.y / uDimensions.x;
  let darker: f32 = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignette[2] * SQRT_2), 0.0, 1.0);
  return darker + (1.0 - darker) * (1.0 - uVignette[1]);
}

fn noise(coord: vec2<f32>) -> f32
{
  let uNoise = crtUniforms.uNoise;
  let uSeed = crtUniforms.uSeed;

  var pixelCoord: vec2<f32> = coord * gfu.uInputSize.xy;
  pixelCoord.x = floor(pixelCoord.x / uNoise[1]);
  pixelCoord.y = floor(pixelCoord.y / uNoise[1]);
  return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];
}

fn interlaceLines(co: vec3<f32>, coord: vec2<f32>) -> vec3<f32>
{
  var color = co;

  let uDimensions = crtUniforms.uDimensions;

  let curvature: f32 = crtUniforms.uLine[0];
  let lineWidth: f32 = crtUniforms.uLine[1];
  let lineContrast: f32 = crtUniforms.uLine[2];
  let verticalLine: f32 = crtUniforms.uLine[3];

  let dir: vec2<f32> = vec2<f32>(coord * gfu.uInputSize.xy / uDimensions - 0.5);

  let _c: f32 = select(1., curvature, curvature > 0.);
  let k: f32 = select(1., (length(dir * dir) * 0.25 * _c * _c + 0.935 * _c), curvature > 0.);
  let uv: vec2<f32> = dir * k;
  let v: f32 = select(uv.y * uDimensions.y, uv.x * uDimensions.x, verticalLine > 0.5) * min(1.0, 2.0 / lineWidth ) / _c;
  let j: f32 = 1. + cos(v * 1.2 - crtUniforms.uTime) * 0.5 * lineContrast;
  color *= j;

  let segment: f32 = select(modulo((dir.y + .5) * uDimensions.y, 4.), modulo((dir.x + .5) * uDimensions.x, 4.), verticalLine > 0.5);
  color *= 0.99 + ceil(segment) * 0.015;

  return color;
}`, SG = Object.defineProperty, AG = (i, t, e) => t in i ? SG(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, bl = (i, t, e) => (AG(i, typeof t != "symbol" ? t + "" : t, e), e);
const RG = class cv extends xt {
  /**
   * @param options - Options for the CRTFilter constructor.
   */
  constructor(t) {
    t = { ...cv.DEFAULT_OPTIONS, ...t };
    const e = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: IG,
        entryPoint: "mainFragment"
      }
    }), s = It.from({
      vertex: $t,
      fragment: TG,
      name: "crt-filter"
    });
    super({
      gpuProgram: e,
      glProgram: s,
      resources: {
        crtUniforms: {
          uLine: { value: new Float32Array(4), type: "vec4<f32>" },
          uNoise: { value: new Float32Array(2), type: "vec2<f32>" },
          uVignette: { value: new Float32Array(3), type: "vec3<f32>" },
          uSeed: { value: t.seed, type: "f32" },
          uTime: { value: t.time, type: "f32" },
          uDimensions: { value: new Float32Array(2), type: "vec2<f32>" }
        }
      }
    }), bl(this, "uniforms"), bl(this, "seed"), bl(this, "time"), this.uniforms = this.resources.crtUniforms.uniforms, Object.assign(this, t);
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(t, e, s, r) {
    this.uniforms.uDimensions[0] = e.frame.width, this.uniforms.uDimensions[1] = e.frame.height, this.uniforms.uSeed = this.seed, this.uniforms.uTime = this.time, t.applyFilter(this, e, s, r);
  }
  /**
   * Bend of interlaced lines, higher value means more bend
   * @default 1
   */
  get curvature() {
    return this.uniforms.uLine[0];
  }
  set curvature(t) {
    this.uniforms.uLine[0] = t;
  }
  /**
   * Width of interlaced lines
   * @default 1
   */
  get lineWidth() {
    return this.uniforms.uLine[1];
  }
  set lineWidth(t) {
    this.uniforms.uLine[1] = t;
  }
  /**
   * Contrast of interlaced lines
   * @default 0.25
   */
  get lineContrast() {
    return this.uniforms.uLine[2];
  }
  set lineContrast(t) {
    this.uniforms.uLine[2] = t;
  }
  /**
   * The orientation of the line:
   *
   * `true` create vertical lines, `false` creates horizontal lines
   * @default false
   */
  get verticalLine() {
    return this.uniforms.uLine[3] > 0.5;
  }
  set verticalLine(t) {
    this.uniforms.uLine[3] = t ? 1 : 0;
  }
  /**
   * Opacity/intensity of the noise effect between `0` and `1`
   * @default 0.3
   */
  get noise() {
    return this.uniforms.uNoise[0];
  }
  set noise(t) {
    this.uniforms.uNoise[0] = t;
  }
  /**
   * The size of the noise particles
   * @default 0
   */
  get noiseSize() {
    return this.uniforms.uNoise[1];
  }
  set noiseSize(t) {
    this.uniforms.uNoise[1] = t;
  }
  /**
   * The radius of the vignette effect, smaller values produces a smaller vignette
   * @default 0.3
   */
  get vignetting() {
    return this.uniforms.uVignette[0];
  }
  set vignetting(t) {
    this.uniforms.uVignette[0] = t;
  }
  /**
   * Amount of opacity of vignette
   * @default 1
   */
  get vignettingAlpha() {
    return this.uniforms.uVignette[1];
  }
  set vignettingAlpha(t) {
    this.uniforms.uVignette[1] = t;
  }
  /**
   * Blur intensity of the vignette
   * @default 0.3
   */
  get vignettingBlur() {
    return this.uniforms.uVignette[2];
  }
  set vignettingBlur(t) {
    this.uniforms.uVignette[2] = t;
  }
};
bl(RG, "DEFAULT_OPTIONS", {
  curvature: 1,
  lineWidth: 1,
  lineContrast: 0.25,
  verticalLine: !1,
  noise: 0,
  noiseSize: 1,
  vignetting: 0.3,
  vignettingAlpha: 1,
  vignettingBlur: 0.3,
  time: 0,
  seed: 0
});
var OG = `precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform float uAngle;
uniform float uScale;
uniform bool uGrayScale;

uniform vec4 uInputSize;

float pattern()
{
    float s = sin(uAngle), c = cos(uAngle);
    vec2 tex = vTextureCoord * uInputSize.xy;
    vec2 point = vec2(
        c * tex.x - s * tex.y,
        s * tex.x + c * tex.y
    ) * uScale;
    return (sin(point.x) * sin(point.y)) * 4.0;
    }

    void main()
    {
    vec4 color = texture(uTexture, vTextureCoord);
    vec3 colorRGB = vec3(color);

    if (uGrayScale)
    {
        colorRGB = vec3(color.r + color.g + color.b) / 3.0;
    }

    finalColor = vec4(colorRGB * 10.0 - 5.0 + pattern(), color.a);
}
`, yG = `struct DotUniforms {
  uScale:f32,
  uAngle:f32,
  uGrayScale:f32,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> dotUniforms : DotUniforms;

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);
  let gray: vec3<f32> = vec3<f32>(dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114)));
  // dotUniforms.uGrayScale == 1 doesn't ever pass so it is converted to a float and compared to 0.5 instead 
  let finalColor: vec3<f32> = select(color.rgb, gray, f32(dotUniforms.uGrayScale) >= 0.5);

  return vec4<f32>(finalColor * 10.0 - 5.0 + pattern(uv), color.a);
}

fn pattern(uv: vec2<f32>) -> f32
{
  let s: f32 = sin(dotUniforms.uAngle);
  let c: f32 = cos(dotUniforms.uAngle);
  
  let tex: vec2<f32> = uv * gfu.uInputSize.xy;
  
  let p: vec2<f32> = vec2<f32>(
      c * tex.x - s * tex.y,
      s * tex.x + c * tex.y
  ) * dotUniforms.uScale;

  return (sin(p.x) * sin(p.y)) * 4.0;
}`, vG = Object.defineProperty, CG = (i, t, e) => t in i ? vG(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, xG = (i, t, e) => (CG(i, t + "", e), e);
const MG = class _v extends xt {
  /** @ignore */
  constructor(...t) {
    let e = t[0] ?? {};
    typeof e == "number" && (dt("6.0.0", "DotFilter constructor params are now options object. See params: { scale, angle, grayscale }"), e = { scale: e }, t[1] !== void 0 && (e.angle = t[1]), t[2] !== void 0 && (e.grayscale = t[2])), e = { ..._v.DEFAULT_OPTIONS, ...e };
    const s = {
      uScale: { value: e.scale, type: "f32" },
      uAngle: { value: e.angle, type: "f32" },
      uGrayScale: { value: e.grayscale ? 1 : 0, type: "f32" }
    }, r = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: yG,
        entryPoint: "mainFragment"
      }
    }), n = It.from({
      vertex: $t,
      fragment: OG,
      name: "dot-filter"
    });
    super({
      gpuProgram: r,
      glProgram: n,
      resources: {
        dotUniforms: s
      }
    });
  }
  /**
   * The scale of the effect.
   * @default 1
   */
  get scale() {
    return this.resources.dotUniforms.uniforms.uScale;
  }
  set scale(t) {
    this.resources.dotUniforms.uniforms.uScale = t;
  }
  /**
  * The radius of the effect.
  * @default 5
  */
  get angle() {
    return this.resources.dotUniforms.uniforms.uAngle;
  }
  set angle(t) {
    this.resources.dotUniforms.uniforms.uAngle = t;
  }
  /**
  * Whether to rendering it in gray scale.
  * @default true
  */
  get grayscale() {
    return this.resources.dotUniforms.uniforms.uGrayScale === 1;
  }
  set grayscale(t) {
    this.resources.dotUniforms.uniforms.uGrayScale = t ? 1 : 0;
  }
};
xG(MG, "DEFAULT_OPTIONS", {
  scale: 1,
  angle: 5,
  grayscale: !0
});
var bG = `precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform float uAlpha;
uniform vec3 uColor;
uniform vec2 uOffset;

uniform vec4 uInputSize;

void main(void){
    vec4 sample = texture(uTexture, vTextureCoord - uOffset * uInputSize.zw);

    // Premultiply alpha
    sample.rgb = uColor.rgb * sample.a;

    // alpha user alpha
    sample *= uAlpha;

    finalColor = sample;
}`, PG = `struct DropShadowUniforms {
  uAlpha: f32,
  uColor: vec3<f32>,
  uOffset: vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> dropShadowUniforms : DropShadowUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  var color: vec4<f32> = textureSample(uTexture, uSampler, uv - dropShadowUniforms.uOffset * gfu.uInputSize.zw);

  // Premultiply alpha
  color = vec4<f32>(vec3<f32>(dropShadowUniforms.uColor.rgb * color.a), color.a);
  // alpha user alpha
  color *= dropShadowUniforms.uAlpha;

  return color;
}`, NG = Object.defineProperty, UG = (i, t, e) => t in i ? NG(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, Ga = (i, t, e) => (UG(i, typeof t != "symbol" ? t + "" : t, e), e);
const DG = class dv extends xt {
  /**
   * @param options - Options for the DropShadowFilter constructor.
   */
  constructor(t) {
    t = { ...dv.DEFAULT_OPTIONS, ...t };
    const e = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: PG,
        entryPoint: "mainFragment"
      }
    }), s = It.from({
      vertex: $t,
      fragment: bG,
      name: "drop-shadow-filter"
    });
    super({
      gpuProgram: e,
      glProgram: s,
      resources: {
        dropShadowUniforms: {
          uAlpha: { value: t.alpha, type: "f32" },
          uColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uOffset: { value: t.offset, type: "vec2<f32>" }
        }
      },
      resolution: t.resolution
    }), Ga(this, "uniforms"), Ga(this, "shadowOnly", !1), Ga(this, "_color"), Ga(this, "_blurFilter"), Ga(this, "_basePass"), this.uniforms = this.resources.dropShadowUniforms.uniforms, this._color = new Pt(), this.color = t.color ?? 0, this._blurFilter = new $y({
      strength: t.kernels ?? t.blur,
      quality: t.kernels ? void 0 : t.quality
    }), this._basePass = new xt({
      gpuProgram: Ot.from({
        vertex: {
          source: Zt,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: `
                    @group(0) @binding(1) var uTexture: texture_2d<f32>; 
                    @group(0) @binding(2) var uSampler: sampler;
                    @fragment
                    fn mainFragment(
                        @builtin(position) position: vec4<f32>,
                        @location(0) uv : vec2<f32>
                    ) -> @location(0) vec4<f32> {
                        return textureSample(uTexture, uSampler, uv);
                    }
                    `,
          entryPoint: "mainFragment"
        }
      }),
      glProgram: It.from({
        vertex: $t,
        fragment: `
                in vec2 vTextureCoord;
                out vec4 finalColor;
                uniform sampler2D uTexture;

                void main(void){
                    finalColor = texture(uTexture, vTextureCoord);
                }
                `,
        name: "drop-shadow-filter"
      }),
      resources: {}
    }), Object.assign(this, t);
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(t, e, s, r) {
    const n = ps.getSameSizeTexture(e);
    t.applyFilter(this, e, n, !0), this._blurFilter.apply(t, n, s, r), this.shadowOnly || t.applyFilter(this._basePass, e, s, !1), ps.returnTexture(n);
  }
  /**
   * Set the offset position of the drop-shadow relative to the original image.
   * @default [4,4]
   */
  get offset() {
    return this.uniforms.uOffset;
  }
  set offset(t) {
    this.uniforms.uOffset = t, this._updatePadding();
  }
  /**
   * Set the offset position of the drop-shadow relative to the original image on the `x` axis
   * @default 4
   */
  get offsetX() {
    return this.offset.x;
  }
  set offsetX(t) {
    this.offset.x = t, this._updatePadding();
  }
  /**
   * Set the offset position of the drop-shadow relative to the original image on the `y` axis
   * @default 4
   */
  get offsetY() {
    return this.offset.y;
  }
  set offsetY(t) {
    this.offset.y = t, this._updatePadding();
  }
  /**
   * The color value of shadow.
   * @example [0.0, 0.0, 0.0] = 0x000000
   * @default 0x000000
   */
  get color() {
    return this._color.value;
  }
  set color(t) {
    this._color.setValue(t);
    const [e, s, r] = this._color.toArray();
    this.uniforms.uColor[0] = e, this.uniforms.uColor[1] = s, this.uniforms.uColor[2] = r;
  }
  /**
   * Coefficient for alpha multiplication
   * @default 1
   */
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(t) {
    this.uniforms.uAlpha = t;
  }
  /**
   * The strength of the shadow's blur.
   * @default 2
   */
  get blur() {
    return this._blurFilter.strength;
  }
  set blur(t) {
    this._blurFilter.strength = t, this._updatePadding();
  }
  /**
   * Sets the quality of the Blur Filter
   * @default 4
   */
  get quality() {
    return this._blurFilter.quality;
  }
  set quality(t) {
    this._blurFilter.quality = t, this._updatePadding();
  }
  /** Sets the kernels of the Blur Filter */
  get kernels() {
    return this._blurFilter.kernels;
  }
  set kernels(t) {
    this._blurFilter.kernels = t;
  }
  /**
   * Sets the pixelSize of the Kawase Blur filter
   * @default [1,1]
   */
  get pixelSize() {
    return this._blurFilter.pixelSize;
  }
  set pixelSize(t) {
    typeof t == "number" && (t = { x: t, y: t }), Array.isArray(t) && (t = { x: t[0], y: t[1] }), this._blurFilter.pixelSize = t;
  }
  /**
   * Sets the pixelSize of the Kawase Blur filter on the `x` axis
   * @default 1
   */
  get pixelSizeX() {
    return this._blurFilter.pixelSizeX;
  }
  set pixelSizeX(t) {
    this._blurFilter.pixelSizeX = t;
  }
  /**
   * Sets the pixelSize of the Kawase Blur filter on the `y` axis
   * @default 1
   */
  get pixelSizeY() {
    return this._blurFilter.pixelSizeY;
  }
  set pixelSizeY(t) {
    this._blurFilter.pixelSizeY = t;
  }
  /**
   * Recalculate the proper padding amount.
   * @private
   */
  _updatePadding() {
    const t = Math.max(
      Math.abs(this.offsetX),
      Math.abs(this.offsetY)
    );
    this.padding = t + this.blur * 2 + this.quality * 4;
  }
};
Ga(DG, "DEFAULT_OPTIONS", {
  offset: { x: 4, y: 4 },
  color: 0,
  alpha: 0.5,
  shadowOnly: !1,
  kernels: void 0,
  blur: 2,
  quality: 3,
  pixelSize: { x: 1, y: 1 },
  resolution: 1
});
var LG = `precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform sampler2D uDisplacementMap;
uniform float uSeed;
uniform vec2 uDimensions;
uniform float uAspect;
uniform float uFillMode;
uniform float uOffset;
uniform float uDirection;
uniform vec2 uRed;
uniform vec2 uGreen;
uniform vec2 uBlue;

uniform vec4 uInputSize;
uniform vec4 uInputClamp;

const int TRANSPARENT = 0;
const int ORIGINAL = 1;
const int LOOP = 2;
const int CLAMP = 3;
const int MIRROR = 4;

void main(void)
{
    vec2 coord = (vTextureCoord * uInputSize.xy) / uDimensions;

    if (coord.x > 1.0 || coord.y > 1.0) {
        return;
    }

    float sinDir = sin(uDirection);
    float cosDir = cos(uDirection);

    float cx = coord.x - 0.5;
    float cy = (coord.y - 0.5) * uAspect;
    float ny = (-sinDir * cx + cosDir * cy) / uAspect + 0.5;

    // displacementMap: repeat
    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);

    // displacementMap: mirror
    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);

    vec4 dc = texture(uDisplacementMap, vec2(0.5, ny));

    float displacement = (dc.r - dc.g) * (uOffset / uInputSize.x);

    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * uAspect);

    int fillMode = int(uFillMode);

    if (fillMode == CLAMP) {
        coord = clamp(coord, uInputClamp.xy, uInputClamp.zw);
    } else {
        if( coord.x > uInputClamp.z ) {
            if (fillMode == TRANSPARENT) {
                discard;
            } else if (fillMode == LOOP) {
                coord.x -= uInputClamp.z;
            } else if (fillMode == MIRROR) {
                coord.x = uInputClamp.z * 2.0 - coord.x;
            }
        } else if( coord.x < uInputClamp.x ) {
            if (fillMode == TRANSPARENT) {
                discard;
            } else if (fillMode == LOOP) {
                coord.x += uInputClamp.z;
            } else if (fillMode == MIRROR) {
                coord.x *= -uInputClamp.z;
            }
        }

        if( coord.y > uInputClamp.w ) {
            if (fillMode == TRANSPARENT) {
                discard;
            } else if (fillMode == LOOP) {
                coord.y -= uInputClamp.w;
            } else if (fillMode == MIRROR) {
                coord.y = uInputClamp.w * 2.0 - coord.y;
            }
        } else if( coord.y < uInputClamp.y ) {
            if (fillMode == TRANSPARENT) {
                discard;
            } else if (fillMode == LOOP) {
                coord.y += uInputClamp.w;
            } else if (fillMode == MIRROR) {
                coord.y *= -uInputClamp.w;
            }
        }
    }

    finalColor.r = texture(uTexture, coord + uRed * (1.0 - uSeed * 0.4) / uInputSize.xy).r;
    finalColor.g = texture(uTexture, coord + uGreen * (1.0 - uSeed * 0.3) / uInputSize.xy).g;
    finalColor.b = texture(uTexture, coord + uBlue * (1.0 - uSeed * 0.2) / uInputSize.xy).b;
    finalColor.a = texture(uTexture, coord).a;
}
`, FG = `struct GlitchUniforms {
  uSeed: f32,
  uDimensions: vec2<f32>,
  uAspect: f32,
  uFillMode: f32,
  uOffset: f32,
  uDirection: f32,
  uRed: vec2<f32>,
  uGreen: vec2<f32>,
  uBlue: vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> glitchUniforms : GlitchUniforms;
@group(1) @binding(1) var uDisplacementMap: texture_2d<f32>; 
@group(1) @binding(2) var uDisplacementSampler: sampler; 

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let uSeed: f32 = glitchUniforms.uSeed;
  let uDimensions: vec2<f32> = glitchUniforms.uDimensions;
  let uAspect: f32 = glitchUniforms.uAspect;
  let uOffset: f32 = glitchUniforms.uOffset;
  let uDirection: f32 = glitchUniforms.uDirection;
  let uRed: vec2<f32> = glitchUniforms.uRed;
  let uGreen: vec2<f32> = glitchUniforms.uGreen;
  let uBlue: vec2<f32> = glitchUniforms.uBlue;

  let uInputSize: vec4<f32> = gfu.uInputSize;
  let uInputClamp: vec4<f32> = gfu.uInputClamp;

  var discarded: bool = false;
  var coord: vec2<f32> = (uv * uInputSize.xy) / uDimensions;

    if (coord.x > 1.0 || coord.y > 1.0) {
      discarded = true;
    }

    let sinDir: f32 = sin(uDirection);
    let cosDir: f32 = cos(uDirection);

    let cx: f32 = coord.x - 0.5;
    let cy: f32 = (coord.y - 0.5) * uAspect;
    var ny: f32 = (-sinDir * cx + cosDir * cy) / uAspect + 0.5;

    ny = select(select(ny, -ny, ny < 0.0), 2.0 - ny, ny > 1.0);

    let dc: vec4<f32> = textureSample(uDisplacementMap, uDisplacementSampler, vec2<f32>(0.5, ny));

    let displacement: f32 = (dc.r - dc.g) * (uOffset / uInputSize.x);

    coord = uv + vec2<f32>(cosDir * displacement, sinDir * displacement * uAspect);

    let fillMode: i32 = i32(glitchUniforms.uFillMode);

    if (fillMode == CLAMP) {
      coord = clamp(coord, uInputClamp.xy, uInputClamp.zw);
    } else {
      if (coord.x > uInputClamp.z) {
        if (fillMode == TRANSPARENT) {
          discarded = true;
        } else if (fillMode == LOOP) {
          coord.x = coord.x - uInputClamp.z;
        } else if (fillMode == MIRROR) {
          coord.x = uInputClamp.z * 2.0 - coord.x;
        }
      } else if (coord.x < uInputClamp.x) {
        if (fillMode == TRANSPARENT) {
          discarded = true;
        } else if (fillMode == LOOP) {
          coord.x = coord.x + uInputClamp.z;
        } else if (fillMode == MIRROR) {
          coord.x = coord.x * -uInputClamp.z;
        }
      }

      if (coord.y > uInputClamp.w) {
        if (fillMode == TRANSPARENT) {
          discarded = true;
        } else if (fillMode == LOOP) {
          coord.y = coord.y - uInputClamp.w;
        } else if (fillMode == MIRROR) {
          coord.y = uInputClamp.w * 2.0 - coord.y;
        }
      } else if (coord.y < uInputClamp.y) {
        if (fillMode == TRANSPARENT) {
          discarded = true;
        } else if (fillMode == LOOP) {
          coord.y = coord.y + uInputClamp.w;
        } else if (fillMode == MIRROR) {
          coord.y = coord.y * -uInputClamp.w;
        }
      }
    }

    let seedR: f32 = 1.0 - uSeed * 0.4;
    let seedG: f32 = 1.0 - uSeed * 0.3;
    let seedB: f32 = 1.0 - uSeed * 0.2;

    let offsetR: vec2<f32> = vec2(uRed.x * seedR / uInputSize.x, uRed.y * seedR / uInputSize.y);
    let offsetG: vec2<f32> = vec2(uGreen.x * seedG / uInputSize.x, uGreen.y * seedG / uInputSize.y);
    let offsetB: vec2<f32> = vec2(uBlue.x * seedB / uInputSize.x, uBlue.y * seedB / uInputSize.y);

    let r = textureSample(uTexture, uSampler, coord + offsetR).r;
    let g = textureSample(uTexture, uSampler, coord + offsetG).g;
    let b = textureSample(uTexture, uSampler, coord + offsetB).b;
    let a = textureSample(uTexture, uSampler, coord).a;

    return select(vec4<f32>(r, g, b, a), vec4<f32>(0.0,0.0,0.0,0.0), discarded);
}

const TRANSPARENT: i32 = 0;
const ORIGINAL: i32 = 1;
const LOOP: i32 = 2;
const CLAMP: i32 = 3;
const MIRROR: i32 = 4;`, wG = Object.defineProperty, GG = (i, t, e) => t in i ? wG(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, Si = (i, t, e) => (GG(i, typeof t != "symbol" ? t + "" : t, e), e);
const BG = class fv extends xt {
  /**
   * @param options - Options for the GlitchFilter constructor.
   */
  constructor(t) {
    t = { ...fv.defaults, ...t };
    const e = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: FG,
        entryPoint: "mainFragment"
      }
    }), s = It.from({
      vertex: $t,
      fragment: LG,
      name: "glitch-filter"
    }), r = document.createElement("canvas");
    r.width = 4, r.height = t.sampleSize ?? 512;
    const n = new W({
      source: new Ra({ resource: r })
    });
    super({
      gpuProgram: e,
      glProgram: s,
      resources: {
        glitchUniforms: {
          uSeed: { value: (t == null ? void 0 : t.seed) ?? 0, type: "f32" },
          uDimensions: { value: new Float32Array(2), type: "vec2<f32>" },
          uAspect: { value: 1, type: "f32" },
          uFillMode: { value: (t == null ? void 0 : t.fillMode) ?? 0, type: "f32" },
          uOffset: { value: (t == null ? void 0 : t.offset) ?? 100, type: "f32" },
          uDirection: { value: (t == null ? void 0 : t.direction) ?? 0, type: "f32" },
          uRed: { value: t.red, type: "vec2<f32>" },
          uGreen: { value: t.green, type: "vec2<f32>" },
          uBlue: { value: t.blue, type: "vec2<f32>" }
        },
        uDisplacementMap: n.source,
        uDisplacementSampler: n.source.style
      }
    }), Si(this, "uniforms"), Si(this, "average", !1), Si(this, "minSize", 8), Si(this, "sampleSize", 512), Si(this, "_canvas"), Si(this, "texture"), Si(this, "_slices", 0), Si(this, "_sizes", new Float32Array(1)), Si(this, "_offsets", new Float32Array(1)), this.uniforms = this.resources.glitchUniforms.uniforms, this._canvas = r, this.texture = n, Object.assign(this, t);
  }
  /**
   * Override existing apply method in Filter
   * @private
   */
  apply(t, e, s, r) {
    const { width: n, height: a } = e.frame;
    this.uniforms.uDimensions[0] = n, this.uniforms.uDimensions[1] = a, this.uniforms.uAspect = a / n, t.applyFilter(this, e, s, r);
  }
  /**
   * Randomize the slices size (heights).
   *
   * @private
   */
  _randomizeSizes() {
    const t = this._sizes, e = this._slices - 1, s = this.sampleSize, r = Math.min(this.minSize / s, 0.9 / this._slices);
    if (this.average) {
      const n = this._slices;
      let a = 1;
      for (let o = 0; o < e; o++) {
        const h = a / (n - o), u = Math.max(h * (1 - Math.random() * 0.6), r);
        t[o] = u, a -= u;
      }
      t[e] = a;
    } else {
      let n = 1;
      const a = Math.sqrt(1 / this._slices);
      for (let o = 0; o < e; o++) {
        const h = Math.max(a * n * Math.random(), r);
        t[o] = h, n -= h;
      }
      t[e] = n;
    }
    this.shuffle();
  }
  /**
   * Shuffle the sizes of the slices, advanced usage.
   */
  shuffle() {
    const t = this._sizes, e = this._slices - 1;
    for (let s = e; s > 0; s--) {
      const r = Math.random() * s >> 0, n = t[s];
      t[s] = t[r], t[r] = n;
    }
  }
  /**
   * Randomize the values for offset from -1 to 1
   *
   * @private
   */
  _randomizeOffsets() {
    for (let t = 0; t < this._slices; t++)
      this._offsets[t] = Math.random() * (Math.random() < 0.5 ? -1 : 1);
  }
  /**
   * Regenerating random size, offsets for slices.
   */
  refresh() {
    this._randomizeSizes(), this._randomizeOffsets(), this.redraw();
  }
  /**
   * Redraw displacement bitmap texture, advanced usage.
   */
  redraw() {
    const t = this.sampleSize, e = this.texture, s = this._canvas.getContext("2d");
    s.clearRect(0, 0, 8, t);
    let r, n = 0;
    for (let a = 0; a < this._slices; a++) {
      r = Math.floor(this._offsets[a] * 256);
      const o = this._sizes[a] * t, h = r > 0 ? r : 0, u = r < 0 ? -r : 0;
      s.fillStyle = `rgba(${h}, ${u}, 0, 1)`, s.fillRect(0, n >> 0, t, o + 1 >> 0), n += o;
    }
    e.source.update();
  }
  /**
   * Manually custom slices size (height) of displacement bitmap
   *
   * @member {number[]|Float32Array}
   */
  set sizes(t) {
    const e = Math.min(this._slices, t.length);
    for (let s = 0; s < e; s++)
      this._sizes[s] = t[s];
  }
  get sizes() {
    return this._sizes;
  }
  /**
   * Manually set custom slices offset of displacement bitmap, this is
   * a collection of values from -1 to 1. To change the max offset value
   * set `offset`.
   *
   * @member {number[]|Float32Array}
   */
  set offsets(t) {
    const e = Math.min(this._slices, t.length);
    for (let s = 0; s < e; s++)
      this._offsets[s] = t[s];
  }
  get offsets() {
    return this._offsets;
  }
  /**
   * The count of slices.
   * @default 5
   */
  get slices() {
    return this._slices;
  }
  set slices(t) {
    this._slices !== t && (this._slices = t, this._sizes = new Float32Array(t), this._offsets = new Float32Array(t), this.refresh());
  }
  /**
   * The maximum offset amount of slices.
   * @default 100
   */
  get offset() {
    return this.uniforms.uOffset;
  }
  set offset(t) {
    this.uniforms.uOffset = t;
  }
  /**
   * A seed value for randomizing glitch effect.
   * @default 0
   */
  get seed() {
    return this.uniforms.uSeed;
  }
  set seed(t) {
    this.uniforms.uSeed = t;
  }
  /**
   * The fill mode of the space after the offset.
   * @default FILL_MODES.TRANSPARENT
   */
  get fillMode() {
    return this.uniforms.uFillMode;
  }
  set fillMode(t) {
    this.uniforms.uFillMode = t;
  }
  /**
   * The angle in degree of the offset of slices.
   * @default 0
   */
  get direction() {
    return this.uniforms.uDirection / Po;
  }
  set direction(t) {
    this.uniforms.uDirection = t * Po;
  }
  /**
   * Red channel offset.
   * @default {x:0,y:0}
   */
  get red() {
    return this.uniforms.uRed;
  }
  set red(t) {
    Array.isArray(t) && (t = { x: t[0], y: t[1] }), this.uniforms.uRed = t;
  }
  /**
   * Green channel offset.
   * @default {x:0,y:0}
   */
  get green() {
    return this.uniforms.uGreen;
  }
  set green(t) {
    Array.isArray(t) && (t = { x: t[0], y: t[1] }), this.uniforms.uGreen = t;
  }
  /**
   * Blue offset.
   * @default {x:0,y:0}
   */
  get blue() {
    return this.uniforms.uBlue;
  }
  set blue(t) {
    Array.isArray(t) && (t = { x: t[0], y: t[1] }), this.uniforms.uBlue = t;
  }
  /**
   * Removes all references
   */
  destroy() {
    var t;
    (t = this.texture) == null || t.destroy(!0), this.texture = this._canvas = this.red = this.green = this.blue = this._sizes = this._offsets = null;
  }
};
Si(BG, "defaults", {
  slices: 5,
  offset: 100,
  direction: 0,
  fillMode: 0,
  average: !1,
  seed: 0,
  red: { x: 0, y: 0 },
  green: { x: 0, y: 0 },
  blue: { x: 0, y: 0 },
  minSize: 8,
  sampleSize: 512
});
var kG = `precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uStrength;
uniform vec3 uColor;
uniform float uKnockout;
uniform float uAlpha;

uniform vec4 uInputSize;
uniform vec4 uInputClamp;

const float PI = 3.14159265358979323846264;

// Hard-assignment of DIST and ANGLE_STEP_SIZE instead of using uDistance and uQuality to allow them to be use on GLSL loop conditions
const float DIST = __DIST__;
const float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.);
const float ANGLE_STEP_NUM = ceil(PI * 2. / ANGLE_STEP_SIZE);
const float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.) / 2.;

void main(void) {
    vec2 px = vec2(1.) / uInputSize.xy;

    float totalAlpha = 0.;

    vec2 direction;
    vec2 displaced;
    vec4 curColor;

    for (float angle = 0.; angle < PI * 2.; angle += ANGLE_STEP_SIZE) {
      direction = vec2(cos(angle), sin(angle)) * px;

      for (float curDistance = 0.; curDistance < DIST; curDistance++) {
          displaced = clamp(vTextureCoord + direction * (curDistance + 1.), uInputClamp.xy, uInputClamp.zw);
          curColor = texture(uTexture, displaced);
          totalAlpha += (DIST - curDistance) * curColor.a;
      }
    }
    
    curColor = texture(uTexture, vTextureCoord);

    vec4 glowColor = vec4(uColor, uAlpha);
    bool knockout = uKnockout > .5;
    float innerStrength = uStrength[0];
    float outerStrength = uStrength[1];

    float alphaRatio = totalAlpha / MAX_TOTAL_ALPHA;
    float innerGlowAlpha = (1. - alphaRatio) * innerStrength * curColor.a * uAlpha;
    float innerGlowStrength = min(1., innerGlowAlpha);
    
    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);
    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a) * uAlpha;
    float outerGlowStrength = min(1. - innerColor.a, outerGlowAlpha);
    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;

    if (knockout) {
      float resultAlpha = outerGlowAlpha + innerGlowAlpha;
      finalColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);
    }
    else {
      finalColor = innerColor + outerGlowColor;
    }
}
`, zG = `struct GlowUniforms {
  uDistance: f32,
  uStrength: vec2<f32>,
  uColor: vec3<f32>,
  uAlpha: f32,
  uQuality: f32,
  uKnockout: f32,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> glowUniforms : GlowUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let quality = glowUniforms.uQuality;
  let distance = glowUniforms.uDistance;

  let dist: f32 = glowUniforms.uDistance;
  let angleStepSize: f32 = min(1. / quality / distance, PI * 2.0);
  let angleStepNum: f32 = ceil(PI * 2.0 / angleStepSize);

  let px: vec2<f32> = vec2<f32>(1.0 / gfu.uInputSize.xy);

  var totalAlpha: f32 = 0.0;

  var direction: vec2<f32>;
  var displaced: vec2<f32>;
  var curColor: vec4<f32>;

  for (var angle = 0.0; angle < PI * 2.0; angle += angleStepSize) {
    direction = vec2<f32>(cos(angle), sin(angle)) * px;
    for (var curDistance = 0.0; curDistance < dist; curDistance+=1) {
      displaced = vec2<f32>(clamp(uv + direction * (curDistance + 1.0), gfu.uInputClamp.xy, gfu.uInputClamp.zw));
      curColor = textureSample(uTexture, uSampler, displaced);
      totalAlpha += (dist - curDistance) * curColor.a;
    }
  }
    
  curColor = textureSample(uTexture, uSampler, uv);

  let glowColorRGB = glowUniforms.uColor;
  let glowAlpha = glowUniforms.uAlpha;
  let glowColor = vec4<f32>(glowColorRGB, glowAlpha);
  let knockout: bool = glowUniforms.uKnockout > 0.5;
  let innerStrength = glowUniforms.uStrength[0];
  let outerStrength = glowUniforms.uStrength[1];

  let alphaRatio: f32 = (totalAlpha / (angleStepNum * dist * (dist + 1.0) / 2.0));
  let innerGlowAlpha: f32 = (1.0 - alphaRatio) * innerStrength * curColor.a * glowAlpha;
  let innerGlowStrength: f32 = min(1.0, innerGlowAlpha);
  
  let innerColor: vec4<f32> = mix(curColor, glowColor, innerGlowStrength);
  let outerGlowAlpha: f32 = alphaRatio * outerStrength * (1. - curColor.a) * glowAlpha;
  let outerGlowStrength: f32 = min(1.0 - innerColor.a, outerGlowAlpha);
  let outerGlowColor: vec4<f32> = outerGlowStrength * glowColor.rgba;
  
  if (knockout) {
    let resultAlpha: f32 = outerGlowAlpha + innerGlowAlpha;
    return vec4<f32>(glowColor.rgb * resultAlpha, resultAlpha);
  }
  else {
    return innerColor + outerGlowColor;
  }
}

const PI: f32 = 3.14159265358979323846264;`, VG = Object.defineProperty, HG = (i, t, e) => t in i ? VG(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, Cp = (i, t, e) => (HG(i, typeof t != "symbol" ? t + "" : t, e), e);
const YG = class gv extends xt {
  /**
   * @param options - Options for the GlowFilter constructor.
   */
  constructor(t) {
    t = { ...gv.DEFAULT_OPTIONS, ...t };
    const e = t.distance ?? 10, s = t.quality ?? 0.1, r = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: zG,
        entryPoint: "mainFragment"
      }
    }), n = It.from({
      vertex: $t,
      fragment: kG.replace(/__ANGLE_STEP_SIZE__/gi, `${(1 / s / e).toFixed(7)}`).replace(/__DIST__/gi, `${e.toFixed(0)}.0`),
      name: "glow-filter"
    });
    super({
      gpuProgram: r,
      glProgram: n,
      resources: {
        glowUniforms: {
          uDistance: { value: e, type: "f32" },
          uStrength: { value: [t.innerStrength, t.outerStrength], type: "vec2<f32>" },
          uColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uAlpha: { value: t.alpha, type: "f32" },
          uQuality: { value: s, type: "f32" },
          uKnockout: { value: (t == null ? void 0 : t.knockout) ?? !1 ? 1 : 0, type: "f32" }
        }
      },
      padding: e
    }), Cp(this, "uniforms"), Cp(this, "_color"), this.uniforms = this.resources.glowUniforms.uniforms, this._color = new Pt(), this.color = t.color ?? 16777215;
  }
  /**
   * Only draw the glow, not the texture itself
   * @default false
   */
  get distance() {
    return this.uniforms.uDistance;
  }
  set distance(t) {
    this.uniforms.uDistance = this.padding = t;
  }
  /**
  * The strength of the glow inward from the edge of the sprite.
  * @default 0
  */
  get innerStrength() {
    return this.uniforms.uStrength[0];
  }
  set innerStrength(t) {
    this.uniforms.uStrength[0] = t;
  }
  /**
  * The strength of the glow outward from the edge of the sprite.
  * @default 4
  */
  get outerStrength() {
    return this.uniforms.uStrength[1];
  }
  set outerStrength(t) {
    this.uniforms.uStrength[1] = t;
  }
  /**
  * The color of the glow.
  * @default 0xFFFFFF
  */
  get color() {
    return this._color.value;
  }
  set color(t) {
    this._color.setValue(t);
    const [e, s, r] = this._color.toArray();
    this.uniforms.uColor[0] = e, this.uniforms.uColor[1] = s, this.uniforms.uColor[2] = r;
  }
  /**
  * The alpha of the glow
  * @default 1
  */
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(t) {
    this.uniforms.uAlpha = t;
  }
  /**
  * A number between 0 and 1 that describes the quality of the glow. The higher the number the less performant
  * @default 0.1
  */
  get quality() {
    return this.uniforms.uQuality;
  }
  set quality(t) {
    this.uniforms.uQuality = t;
  }
  /**
  * Only draw the glow, not the texture itself
  * @default false
  */
  get knockout() {
    return this.uniforms.uKnockout === 1;
  }
  set knockout(t) {
    this.uniforms.uKnockout = t ? 1 : 0;
  }
};
Cp(YG, "DEFAULT_OPTIONS", {
  distance: 10,
  outerStrength: 4,
  innerStrength: 0,
  color: 16777215,
  alpha: 1,
  quality: 0.1,
  knockout: !1
});
var WG = `precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uDimensions;
uniform float uParallel;
uniform vec2 uLight;
uniform float uAspect;
uniform float uTime;
uniform vec3 uRay;

uniform vec4 uInputSize;

\${PERLIN}

void main(void) {
    vec2 uDimensions = uDimensions;
    bool uParallel = uParallel > 0.5;
    vec2 uLight = uLight;
    float uAspect = uAspect;

    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions;

    float d;

    if (uParallel) {
        float _cos = uLight.x;
        float _sin = uLight.y;
        d = (_cos * coord.x) + (_sin * coord.y * uAspect);
    } else {
        float dx = coord.x - uLight.x / uDimensions.x;
        float dy = (coord.y - uLight.y / uDimensions.y) * uAspect;
        float dis = sqrt(dx * dx + dy * dy) + 0.00001;
        d = dy / dis;
    }

    float uTime = uTime;
    vec3 uRay = uRay;

    float gain = uRay[0];
    float lacunarity = uRay[1];
    float alpha = uRay[2];

    vec3 dir = vec3(d, d, 0.0);
    float noise = turb(dir + vec3(uTime, 0.0, 62.1 + uTime) * 0.05, vec3(480.0, 320.0, 480.0), lacunarity, gain);
    noise = mix(noise, 0.0, 0.3);
    //fade vertically.
    vec4 mist = vec4(vec3(noise), 1.0) * (1.0 - coord.y);
    mist.a = 1.0;
    // apply user alpha
    mist *= alpha;

    finalColor = texture(uTexture, vTextureCoord) + mist;
}
`, jG = `struct GodrayUniforms {
  uLight: vec2<f32>,
  uParallel: f32,
  uAspect: f32,
  uTime: f32,
  uRay: vec3<f32>,
  uDimensions: vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> godrayUniforms : GodrayUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let uDimensions: vec2<f32> = godrayUniforms.uDimensions;
  let uParallel: bool = godrayUniforms.uParallel > 0.5;
  let uLight: vec2<f32> = godrayUniforms.uLight;
  let uAspect: f32 = godrayUniforms.uAspect;

  let coord: vec2<f32> = uv * gfu.uInputSize.xy / uDimensions;

  var d: f32;

  if (uParallel) {
    let _cos: f32 = uLight.x;
    let _sin: f32 = uLight.y;
    d = (_cos * coord.x) + (_sin * coord.y * uAspect);
  } else {
    let dx: f32 = coord.x - uLight.x / uDimensions.x;
    let dy: f32 = (coord.y - uLight.y / uDimensions.y) * uAspect;
    let dis: f32 = sqrt(dx * dx + dy * dy) + 0.00001;
    d = dy / dis;
  }

  let uTime: f32 = godrayUniforms.uTime;
  let uRay: vec3<f32> = godrayUniforms.uRay;
  
  let gain = uRay[0];
  let lacunarity = uRay[1];
  let alpha = uRay[2];

  let dir: vec3<f32> = vec3<f32>(d, d, 0.0);
  var noise: f32 = turb(dir + vec3<f32>(uTime, 0.0, 62.1 + uTime) * 0.05, vec3<f32>(480.0, 320.0, 480.0), lacunarity, gain);
  noise = mix(noise, 0.0, 0.3);
  //fade vertically.
  var mist: vec4<f32> = vec4<f32>(vec3<f32>(noise), 1.0) * (1.0 - coord.y);
  mist.a = 1.0;
  // apply user alpha
  mist *= alpha;
  return textureSample(uTexture, uSampler, uv) + mist;
}

\${PERLIN}`, XG = `vec3 mod289(vec3 x)
{
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}
vec4 mod289(vec4 x)
{
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}
vec4 permute(vec4 x)
{
    return mod289(((x * 34.0) + 1.0) * x);
}
vec4 taylorInvSqrt(vec4 r)
{
    return 1.79284291400159 - 0.85373472095314 * r;
}
vec3 fade(vec3 t)
{
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}
// Classic Perlin noise, periodic variant
float pnoise(vec3 P, vec3 rep)
{
    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
    Pi0 = mod289(Pi0);
    Pi1 = mod289(Pi1);
    vec3 Pf0 = fract(P); // Fractional part for interpolation
    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = Pi0.zzzz;
    vec4 iz1 = Pi1.zzzz;
    vec4 ixy = permute(permute(ix) + iy);
    vec4 ixy0 = permute(ixy + iz0);
    vec4 ixy1 = permute(ixy + iz1);
    vec4 gx0 = ixy0 * (1.0 / 7.0);
    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
    gx0 = fract(gx0);
    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
    vec4 sz0 = step(gz0, vec4(0.0));
    gx0 -= sz0 * (step(0.0, gx0) - 0.5);
    gy0 -= sz0 * (step(0.0, gy0) - 0.5);
    vec4 gx1 = ixy1 * (1.0 / 7.0);
    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
    gx1 = fract(gx1);
    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
    vec4 sz1 = step(gz1, vec4(0.0));
    gx1 -= sz1 * (step(0.0, gx1) - 0.5);
    gy1 -= sz1 * (step(0.0, gy1) - 0.5);
    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);
    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);
    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);
    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);
    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);
    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);
    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);
    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);
    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
    g000 *= norm0.x;
    g010 *= norm0.y;
    g100 *= norm0.z;
    g110 *= norm0.w;
    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
    g001 *= norm1.x;
    g011 *= norm1.y;
    g101 *= norm1.z;
    g111 *= norm1.w;
    float n000 = dot(g000, Pf0);
    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
    float n111 = dot(g111, Pf1);
    vec3 fade_xyz = fade(Pf0);
    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
    return 2.2 * n_xyz;
}
float turb(vec3 P, vec3 rep, float lacunarity, float gain)
{
    float sum = 0.0;
    float sc = 1.0;
    float totalgain = 1.0;
    for (float i = 0.0; i < 6.0; i++)
    {
        sum += totalgain * pnoise(P * sc, rep);
        sc *= lacunarity;
        totalgain *= gain;
    }
    return abs(sum);
}
`, KG = `// Taken from https://gist.github.com/munrocket/236ed5ba7e409b8bdf1ff6eca5dcdc39

fn moduloVec3(x: vec3<f32>, y: vec3<f32>) -> vec3<f32>
{
  return x - y * floor(x/y);
}
fn mod289Vec3(x: vec3<f32>) -> vec3<f32>
{
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}
fn mod289Vec4(x: vec4<f32>) -> vec4<f32>
{
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}
fn permute4(x: vec4<f32>) -> vec4<f32>
{
    return mod289Vec4(((x * 34.0) + 1.0) * x);
}
fn taylorInvSqrt(r: vec4<f32>) -> vec4<f32>
{
    return 1.79284291400159 - 0.85373472095314 * r;
}
fn fade3(t: vec3<f32>) -> vec3<f32>
{
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}
fn fade2(t: vec2<f32>) -> vec2<f32> { return t * t * t * (t * (t * 6. - 15.) + 10.); }

fn perlinNoise2(P: vec2<f32>) -> f32 {
  var Pi: vec4<f32> = floor(P.xyxy) + vec4<f32>(0., 0., 1., 1.);
  let Pf = fract(P.xyxy) - vec4<f32>(0., 0., 1., 1.);
  Pi = Pi % vec4<f32>(289.); // To avoid truncation effects in permutation
  let ix = Pi.xzxz;
  let iy = Pi.yyww;
  let fx = Pf.xzxz;
  let fy = Pf.yyww;
  let i = permute4(permute4(ix) + iy);
  var gx: vec4<f32> = 2. * fract(i * 0.0243902439) - 1.; // 1/41 = 0.024...
  let gy = abs(gx) - 0.5;
  let tx = floor(gx + 0.5);
  gx = gx - tx;
  var g00: vec2<f32> = vec2<f32>(gx.x, gy.x);
  var g10: vec2<f32> = vec2<f32>(gx.y, gy.y);
  var g01: vec2<f32> = vec2<f32>(gx.z, gy.z);
  var g11: vec2<f32> = vec2<f32>(gx.w, gy.w);
  let norm = 1.79284291400159 - 0.85373472095314 *
      vec4<f32>(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));
  g00 = g00 * norm.x;
  g01 = g01 * norm.y;
  g10 = g10 * norm.z;
  g11 = g11 * norm.w;
  let n00 = dot(g00, vec2<f32>(fx.x, fy.x));
  let n10 = dot(g10, vec2<f32>(fx.y, fy.y));
  let n01 = dot(g01, vec2<f32>(fx.z, fy.z));
  let n11 = dot(g11, vec2<f32>(fx.w, fy.w));
  let fade_xy = fade2(Pf.xy);
  let n_x = mix(vec2<f32>(n00, n01), vec2<f32>(n10, n11), vec2<f32>(fade_xy.x));
  let n_xy = mix(n_x.x, n_x.y, fade_xy.y);
  return 2.3 * n_xy;
}

// Classic Perlin noise, periodic variant
fn perlinNoise3(P: vec3<f32>, rep: vec3<f32>) -> f32
{
    var Pi0: vec3<f32> = moduloVec3(floor(P), rep); // Integer part, modulo period
    var Pi1: vec3<f32> = moduloVec3(Pi0 + vec3<f32>(1.0), rep); // Integer part + 1, mod period
    Pi0 = mod289Vec3(Pi0);
    Pi1 = mod289Vec3(Pi1);
    let Pf0: vec3<f32> = fract(P); // Fractional part for interpolation
    let Pf1: vec3<f32> = Pf0 - vec3<f32>(1.0); // Fractional part - 1.0
    let ix: vec4<f32> = vec4<f32>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    let iy: vec4<f32> = vec4<f32>(Pi0.yy, Pi1.yy);
    let iz0: vec4<f32> = Pi0.zzzz;
    let iz1: vec4<f32> = Pi1.zzzz;
    let ixy: vec4<f32> = permute4(permute4(ix) + iy);
    let ixy0: vec4<f32> = permute4(ixy + iz0);
    let ixy1: vec4<f32> = permute4(ixy + iz1);
    var gx0: vec4<f32> = ixy0 * (1.0 / 7.0);
    var gy0: vec4<f32> = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
    gx0 = fract(gx0);
    let gz0: vec4<f32> = vec4<f32>(0.5) - abs(gx0) - abs(gy0);
    let sz0: vec4<f32> = step(gz0, vec4<f32>(0.0));
    gx0 -= sz0 * (step(vec4<f32>(0.0), gx0) - 0.5);
    gy0 -= sz0 * (step(vec4<f32>(0.0), gy0) - 0.5);
    var gx1: vec4<f32> = ixy1 * (1.0 / 7.0);
    var gy1: vec4<f32> = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
    gx1 = fract(gx1);
    let gz1: vec4<f32> = vec4<f32>(0.5) - abs(gx1) - abs(gy1);
    let sz1: vec4<f32> = step(gz1, vec4<f32>(0.0));
    gx1 -= sz1 * (step(vec4<f32>(0.0), gx1) - 0.5);
    gy1 -= sz1 * (step(vec4<f32>(0.0), gy1) - 0.5);
    var g000: vec3<f32> = vec3<f32>(gx0.x, gy0.x, gz0.x);
    var g100: vec3<f32> = vec3<f32>(gx0.y, gy0.y, gz0.y);
    var g010: vec3<f32> = vec3<f32>(gx0.z, gy0.z, gz0.z);
    var g110: vec3<f32> = vec3<f32>(gx0.w, gy0.w, gz0.w);
    var g001: vec3<f32> = vec3<f32>(gx1.x, gy1.x, gz1.x);
    var g101: vec3<f32> = vec3<f32>(gx1.y, gy1.y, gz1.y);
    var g011: vec3<f32> = vec3<f32>(gx1.z, gy1.z, gz1.z);
    var g111: vec3<f32> = vec3<f32>(gx1.w, gy1.w, gz1.w);
    let norm0: vec4<f32> = taylorInvSqrt(vec4<f32>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
    g000 *= norm0.x;
    g010 *= norm0.y;
    g100 *= norm0.z;
    g110 *= norm0.w;
    let norm1: vec4<f32> = taylorInvSqrt(vec4<f32>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
    g001 *= norm1.x;
    g011 *= norm1.y;
    g101 *= norm1.z;
    g111 *= norm1.w;
    let n000: f32 = dot(g000, Pf0);
    let n100: f32 = dot(g100, vec3<f32>(Pf1.x, Pf0.yz));
    let n010: f32 = dot(g010, vec3<f32>(Pf0.x, Pf1.y, Pf0.z));
    let n110: f32 = dot(g110, vec3<f32>(Pf1.xy, Pf0.z));
    let n001: f32 = dot(g001, vec3<f32>(Pf0.xy, Pf1.z));
    let n101: f32 = dot(g101, vec3<f32>(Pf1.x, Pf0.y, Pf1.z));
    let n011: f32 = dot(g011, vec3<f32>(Pf0.x, Pf1.yz));
    let n111: f32 = dot(g111, Pf1);
    let fade_xyz: vec3<f32> = fade3(Pf0);
    let n_z: vec4<f32> = mix(vec4<f32>(n000, n100, n010, n110), vec4<f32>(n001, n101, n011, n111), fade_xyz.z);
    let n_yz: vec2<f32> = mix(n_z.xy, n_z.zw, fade_xyz.y);
    let n_xyz: f32 = mix(n_yz.x, n_yz.y, fade_xyz.x);
    return 2.2 * n_xyz;
}
fn turb(P: vec3<f32>, rep: vec3<f32>, lacunarity: f32, gain: f32) -> f32
{
    var sum: f32 = 0.0;
    var sc: f32 = 1.0;
    var totalgain: f32 = 1.0;
    for (var i = 0.0; i < 6.0; i += 1)
    {
        sum += totalgain * perlinNoise3(P * sc, rep);
        sc *= lacunarity;
        totalgain *= gain;
    }
    return abs(sum);
}`, qG = Object.defineProperty, $G = (i, t, e) => t in i ? qG(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, Ba = (i, t, e) => ($G(i, typeof t != "symbol" ? t + "" : t, e), e);
const ZG = class pv extends xt {
  /**
   * @param options - Options for the GodrayFilter constructor.
   */
  constructor(t) {
    t = { ...pv.DEFAULT_OPTIONS, ...t };
    const e = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: jG.replace("${PERLIN}", KG),
        entryPoint: "mainFragment"
      }
    }), s = It.from({
      vertex: $t,
      fragment: WG.replace("${PERLIN}", XG),
      name: "god-ray-filter"
    });
    super({
      gpuProgram: e,
      glProgram: s,
      resources: {
        godrayUniforms: {
          uLight: { value: new Float32Array(2), type: "vec2<f32>" },
          uParallel: { value: 0, type: "f32" },
          uAspect: { value: 0, type: "f32" },
          uTime: { value: t.time, type: "f32" },
          uRay: { value: new Float32Array(3), type: "vec3<f32>" },
          uDimensions: { value: new Float32Array(2), type: "vec2<f32>" }
        }
      }
    }), Ba(this, "uniforms"), Ba(this, "time", 0), Ba(this, "_angleLight", [0, 0]), Ba(this, "_angle", 0), Ba(this, "_center"), this.uniforms = this.resources.godrayUniforms.uniforms, Object.assign(this, t);
  }
  /**
   * Override existing apply method in Filter
   * @override
   * @ignore
   */
  apply(t, e, s, r) {
    const n = e.frame.width, a = e.frame.height;
    this.uniforms.uLight[0] = this.parallel ? this._angleLight[0] : this._center.x, this.uniforms.uLight[1] = this.parallel ? this._angleLight[1] : this._center.y, this.uniforms.uDimensions[0] = n, this.uniforms.uDimensions[1] = a, this.uniforms.uAspect = a / n, this.uniforms.uTime = this.time, t.applyFilter(this, e, s, r);
  }
  /**
   * The angle/light-source of the rays in degrees. For instance,
   * a value of 0 is vertical rays, values of 90 or -90 produce horizontal rays
   * @default 30
   */
  get angle() {
    return this._angle;
  }
  set angle(t) {
    this._angle = t;
    const e = t * Po;
    this._angleLight[0] = Math.cos(e), this._angleLight[1] = Math.sin(e);
  }
  /**
   * `true` if light rays are parallel (uses angle), `false` to use the focal `center` point
   * @default true
   */
  get parallel() {
    return this.uniforms.uParallel > 0.5;
  }
  set parallel(t) {
    this.uniforms.uParallel = t ? 1 : 0;
  }
  /**
   * Focal point for non-parallel rays, to use this `parallel` must be set to `false`.
   * @default {x:0,y:0}
   */
  get center() {
    return this._center;
  }
  set center(t) {
    Array.isArray(t) && (t = { x: t[0], y: t[1] }), this._center = t;
  }
  /**
   * Focal point for non-parallel rays on the `x` axis, to use this `parallel` must be set to `false`.
   * @default 0
   */
  get centerX() {
    return this.center.x;
  }
  set centerX(t) {
    this.center.x = t;
  }
  /**
   * Focal point for non-parallel rays on the `y` axis, to use this `parallel` must be set to `false`.
   * @default 0
   */
  get centerY() {
    return this.center.y;
  }
  set centerY(t) {
    this.center.y = t;
  }
  /**
   * General intensity of the effect. A value closer to 1 will produce a more intense effect,
   * where a value closer to 0 will produce a subtler effect
   * @default 0.5
   */
  get gain() {
    return this.uniforms.uRay[0];
  }
  set gain(t) {
    this.uniforms.uRay[0] = t;
  }
  /**
   * The density of the fractal noise.
   * A higher amount produces more rays and a smaller amount produces fewer waves
   * @default 2.5
   */
  get lacunarity() {
    return this.uniforms.uRay[1];
  }
  set lacunarity(t) {
    this.uniforms.uRay[1] = t;
  }
  /**
   * The alpha (opacity) of the rays.  0 is fully transparent, 1 is fully opaque.
   * @default 1
   */
  get alpha() {
    return this.uniforms.uRay[2];
  }
  set alpha(t) {
    this.uniforms.uRay[2] = t;
  }
};
Ba(ZG, "DEFAULT_OPTIONS", {
  angle: 30,
  gain: 0.5,
  lacunarity: 2.5,
  parallel: !0,
  time: 0,
  center: { x: 0, y: 0 },
  alpha: 1
});
var QG = `in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec3 uHsl;
uniform float uAlpha;
uniform float uColorize;

// https://en.wikipedia.org/wiki/Luma_(video)
const vec3 weight = vec3(0.299, 0.587, 0.114);

float getWeightedAverage(vec3 rgb) {
    return rgb.r * weight.r + rgb.g * weight.g + rgb.b * weight.b;
}

// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786?permalink_comment_id=3195243#gistcomment-3195243
const vec3 k = vec3(0.57735, 0.57735, 0.57735);

vec3 hueShift(vec3 color, float angle) {
    float cosAngle = cos(angle);
    return vec3(
    color * cosAngle +
    cross(k, color) * sin(angle) +
    k * dot(k, color) * (1.0 - cosAngle)
    );
}

void main()
{
    vec4 color = texture(uTexture, vTextureCoord);
    vec3 resultRGB = color.rgb;

    float hue = uHsl[0];
    float saturation = uHsl[1];
    float lightness = uHsl[2];

    // colorize
    if (uColorize > 0.5) {
        resultRGB = vec3(getWeightedAverage(resultRGB), 0., 0.);
    }

    // hue
    resultRGB = hueShift(resultRGB, hue);

    // saturation
    // https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/huesaturation.js
    float average = (resultRGB.r + resultRGB.g + resultRGB.b) / 3.0;

    if (saturation > 0.) {
        resultRGB += (average - resultRGB) * (1. - 1. / (1.001 - saturation));
    } else {
        resultRGB -= (average - resultRGB) * saturation;
    }

    // lightness
    resultRGB = mix(resultRGB, vec3(ceil(lightness)) * color.a, abs(lightness));

    // alpha
    finalColor = mix(color, vec4(resultRGB, color.a), uAlpha);
}
`, JG = `struct HslUniforms {
  uHsl:vec3<f32>,
  uColorize:f32,
  uAlpha:f32,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> hslUniforms : HslUniforms;

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
    let color: vec4<f32> = textureSample(uTexture, uSampler, uv);
    var resultRGB: vec3<f32> = color.rgb;

    let hue: f32 = hslUniforms.uHsl[0];
    let saturation: f32 = hslUniforms.uHsl[1];
    let lightness: f32 = hslUniforms.uHsl[2];

    // colorize
    if (hslUniforms.uColorize > 0.5) {
        resultRGB = vec3<f32>(dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114)), 0., 0.);
    }

    // hue
    resultRGB = hueShift(resultRGB, hue);

    // saturation
    // https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/huesaturation.js
    let average: f32 = (resultRGB.r + resultRGB.g + resultRGB.b) / 3.0;

    if (saturation > 0.) {
        resultRGB += (average - resultRGB) * (1. - 1. / (1.001 - saturation));
    } else {
        resultRGB -= (average - resultRGB) * saturation;
    }

    // lightness
    resultRGB = mix(resultRGB, vec3<f32>(ceil(lightness)) * color.a, abs(lightness));

    // alpha
    return mix(color, vec4<f32>(resultRGB, color.a), hslUniforms.uAlpha);
}

// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786?permalink_comment_id=3195243#gistcomment-3195243
const k: vec3<f32> = vec3(0.57735, 0.57735, 0.57735);

fn hueShift(color: vec3<f32>, angle: f32) -> vec3<f32> 
{
    let cosAngle: f32 = cos(angle);
    return vec3<f32>(
    color * cosAngle +
    cross(k, color) * sin(angle) +
    k * dot(k, color) * (1.0 - cosAngle)
    );
}`, t3 = Object.defineProperty, e3 = (i, t, e) => t in i ? t3(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, xp = (i, t, e) => (e3(i, typeof t != "symbol" ? t + "" : t, e), e);
const s3 = class mv extends xt {
  /**
   * @param options - Options for the HslAdjustmentFilter constructor.
   */
  constructor(t) {
    t = { ...mv.DEFAULT_OPTIONS, ...t };
    const e = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: JG,
        entryPoint: "mainFragment"
      }
    }), s = It.from({
      vertex: $t,
      fragment: QG,
      name: "hsl-adjustment-filter"
    });
    super({
      gpuProgram: e,
      glProgram: s,
      resources: {
        hslUniforms: {
          uHsl: { value: new Float32Array(3), type: "vec3<f32>" },
          uColorize: { value: t.colorize ? 1 : 0, type: "f32" },
          uAlpha: { value: t.alpha, type: "f32" }
        }
      }
    }), xp(this, "uniforms"), xp(this, "_hue"), this.uniforms = this.resources.hslUniforms.uniforms, Object.assign(this, t);
  }
  /**
   * The amount of hue in degrees (-180 to 180)
   * @default 0
   */
  get hue() {
    return this._hue;
  }
  set hue(t) {
    this._hue = t, this.uniforms.uHsl[0] = t * (Math.PI / 180);
  }
  /**
   * The amount of lightness (-1 to 1)
   * @default 0
   */
  get saturation() {
    return this.uniforms.uHsl[1];
  }
  set saturation(t) {
    this.uniforms.uHsl[1] = t;
  }
  /**
   * The amount of lightness (-1 to 1)
   * @default 0
   */
  get lightness() {
    return this.uniforms.uHsl[2];
  }
  set lightness(t) {
    this.uniforms.uHsl[2] = t;
  }
  /**
   * Whether to colorize the image
   * @default false
   */
  get colorize() {
    return this.uniforms.uColorize === 1;
  }
  set colorize(t) {
    this.uniforms.uColorize = t ? 1 : 0;
  }
  /**
   * The amount of alpha (0 to 1)
   * @default 1
   */
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(t) {
    this.uniforms.uAlpha = t;
  }
};
xp(s3, "DEFAULT_OPTIONS", {
  hue: 0,
  saturation: 0,
  lightness: 0,
  colorize: !1,
  alpha: 1
});
var i3 = `precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uVelocity;
uniform int uKernelSize;
uniform float uOffset;

uniform vec4 uInputSize;

const int MAX_KERNEL_SIZE = 2048;

// Notice:
// the perfect way:
//    int kernelSize = min(uKernelSize, MAX_KERNELSIZE);
// BUT in real use-case , uKernelSize < MAX_KERNELSIZE almost always.
// So use uKernelSize directly.

void main(void)
{
    vec4 color = texture(uTexture, vTextureCoord);

    if (uKernelSize == 0)
    {
        finalColor = color;
        return;
    }

    vec2 velocity = uVelocity / uInputSize.xy;
    float offset = -uOffset / length(uVelocity) - 0.5;
    int k = uKernelSize - 1;

    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {
        if (i == k) {
            break;
        }
        vec2 bias = velocity * (float(i) / float(k) + offset);
        color += texture(uTexture, vTextureCoord + bias);
    }
    finalColor = color / float(uKernelSize);
}
`, r3 = `struct MotionBlurUniforms {
  uVelocity: vec2<f32>,
  uKernelSize: f32,
  uOffset: f32,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> motionBlurUniforms : MotionBlurUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let uVelocity = motionBlurUniforms.uVelocity;
  let uKernelSize = motionBlurUniforms.uKernelSize;
  let uOffset = motionBlurUniforms.uOffset;

  let velocity: vec2<f32> = uVelocity / gfu.uInputSize.xy;
  let offset: f32 = -uOffset / length(uVelocity) - 0.5;
  let k: i32 = i32(min(uKernelSize - 1, MAX_KERNEL_SIZE - 1));

  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);

  for(var i: i32 = 0; i < k; i += 1) {
    let bias: vec2<f32> = velocity * (f32(i) / f32(k) + offset);
    color += textureSample(uTexture, uSampler, uv + bias);
  }
  
  return select(color / f32(uKernelSize), textureSample(uTexture, uSampler, uv), uKernelSize == 0);
}

const MAX_KERNEL_SIZE: f32 = 2048;`, n3 = Object.defineProperty, a3 = (i, t, e) => t in i ? n3(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, Mp = (i, t, e) => (a3(i, typeof t != "symbol" ? t + "" : t, e), e);
const o3 = class Ev extends xt {
  /** @ignore */
  constructor(...t) {
    let e = t[0] ?? {};
    if (Array.isArray(e) || "x" in e && "y" in e || e instanceof Me) {
      dt("6.0.0", "MotionBlurFilter constructor params are now options object. See params: { velocity, kernelSize, offset }");
      const n = "x" in e ? e.x : e[0], a = "y" in e ? e.y : e[1];
      e = { velocity: { x: n, y: a } }, t[1] !== void 0 && (e.kernelSize = t[1]), t[2] !== void 0 && (e.offset = t[2]);
    }
    e = { ...Ev.DEFAULT_OPTIONS, ...e };
    const s = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: r3,
        entryPoint: "mainFragment"
      }
    }), r = It.from({
      vertex: $t,
      fragment: i3,
      name: "motion-blur-filter"
    });
    super({
      gpuProgram: s,
      glProgram: r,
      resources: {
        motionBlurUniforms: {
          uVelocity: { value: e.velocity, type: "vec2<f32>" },
          uKernelSize: { value: Math.trunc(e.kernelSize ?? 5), type: "i32" },
          uOffset: { value: e.offset, type: "f32" }
        }
      }
    }), Mp(this, "uniforms"), Mp(this, "_kernelSize"), this.uniforms = this.resources.motionBlurUniforms.uniforms, Object.assign(this, e);
  }
  /**
   * Sets the velocity of the motion for blur effect
   * This should be a size 2 array or an object containing `x` and `y` values, you cannot change types
   * once defined in the constructor
   * @default {x:0,y:0}
   */
  get velocity() {
    return this.uniforms.uVelocity;
  }
  set velocity(t) {
    Array.isArray(t) && (t = { x: t[0], y: t[1] }), this.uniforms.uVelocity = t, this._updateDirty();
  }
  /**
   * Sets the velocity of the motion for blur effect on the `x` axis
   * @default 0
   */
  get velocityX() {
    return this.velocity.x;
  }
  set velocityX(t) {
    this.velocity.x = t, this._updateDirty();
  }
  /**
   * Sets the velocity of the motion for blur effect on the `x` axis
   * @default 0
   */
  get velocityY() {
    return this.velocity.y;
  }
  set velocityY(t) {
    this.velocity.y = t, this._updateDirty();
  }
  /**
   * The kernelSize of the blur filter. Must be odd number >= 5
   * @default 5
   */
  get kernelSize() {
    return this._kernelSize;
  }
  set kernelSize(t) {
    this._kernelSize = t, this._updateDirty();
  }
  /**
   * The offset of the blur filter
   * @default 0
   */
  get offset() {
    return this.uniforms.uOffset;
  }
  set offset(t) {
    this.uniforms.uOffset = t;
  }
  _updateDirty() {
    this.padding = (Math.max(Math.abs(this.velocityX), Math.abs(this.velocityY)) >> 0) + 1, this.uniforms.uKernelSize = this.velocityX !== 0 || this.velocityY !== 0 ? this._kernelSize : 0;
  }
};
Mp(o3, "DEFAULT_OPTIONS", {
  velocity: { x: 0, y: 0 },
  kernelSize: 5,
  offset: 0
});
var h3 = `in vec2 vTextureCoord;
out vec4 finalColor;

const int MAX_COLORS = \${MAX_COLORS};

uniform sampler2D uTexture;
uniform vec3 uOriginalColors[MAX_COLORS];
uniform vec3 uTargetColors[MAX_COLORS];
uniform float uTolerance;

void main(void)
{
    finalColor = texture(uTexture, vTextureCoord);

    float alpha = finalColor.a;
    if (alpha < 0.0001)
    {
      return;
    }

    vec3 color = finalColor.rgb / alpha;

    for(int i = 0; i < MAX_COLORS; i++)
    {
      vec3 origColor = uOriginalColors[i];
      if (origColor.r < 0.0)
      {
        break;
      }
      vec3 colorDiff = origColor - color;
      if (length(colorDiff) < uTolerance)
      {
        vec3 targetColor = uTargetColors[i];
        finalColor = vec4((targetColor + colorDiff) * alpha, alpha);
        return;
      }
    }
}
`, u3 = `struct MultiColorReplaceUniforms {
  uOriginalColors: array<vec3<f32>, MAX_COLORS>,
  uTargetColors: array<vec3<f32>, MAX_COLORS>,
  uTolerance:f32,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> multiColorReplaceUniforms : MultiColorReplaceUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let uOriginalColors = multiColorReplaceUniforms.uOriginalColors;
  let uTargetColors = multiColorReplaceUniforms.uTargetColors;
  let uTolerance = multiColorReplaceUniforms.uTolerance;

  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);

  let alpha: f32 = color.a;

  if (alpha > 0.0001)
  {
    var modColor: vec3<f32> = vec3<f32>(color.rgb) / alpha;

    for(var i: i32 = 0; i < MAX_COLORS; i += 1)
    {
      let origColor: vec3<f32> = uOriginalColors[i];
      if (origColor.r < 0.0)
      {
        break;
      }
      let colorDiff: vec3<f32> = origColor - modColor;
      
      if (length(colorDiff) < uTolerance)
      {
        let targetColor: vec3<f32> = uTargetColors[i];
        color = vec4((targetColor + colorDiff) * alpha, alpha);
        return color;
      }
    }
  }

  return color;
}

const MAX_COLORS: i32 = \${MAX_COLORS};`, l3 = Object.defineProperty, c3 = (i, t, e) => t in i ? l3(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, Pl = (i, t, e) => (c3(i, typeof t != "symbol" ? t + "" : t, e), e);
const _3 = class Tv extends xt {
  /** @ignore */
  constructor(...t) {
    let e = t[0] ?? {};
    Array.isArray(e) && (dt("6.0.0", "MultiColorReplaceFilter constructor params are now options object. See params: { replacements, tolerance, maxColors }"), e = { replacements: e }, t[1] && (e.tolerance = t[1]), t[2] && (e.maxColors = t[2])), e = { ...Tv.DEFAULT_OPTIONS, ...e };
    const s = e.maxColors ?? e.replacements.length, r = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: u3.replace(/\$\{MAX_COLORS\}/g, s.toFixed(0)),
        entryPoint: "mainFragment"
      }
    }), n = It.from({
      vertex: $t,
      fragment: h3.replace(/\$\{MAX_COLORS\}/g, s.toFixed(0)),
      name: "multi-color-replace-filter"
    });
    super({
      gpuProgram: r,
      glProgram: n,
      resources: {
        multiColorReplaceUniforms: {
          uOriginalColors: {
            value: new Float32Array(3 * s),
            type: "vec3<f32>",
            size: s
          },
          uTargetColors: {
            value: new Float32Array(3 * s),
            type: "vec3<f32>",
            size: s
          },
          uTolerance: { value: e.tolerance, type: "f32" }
        }
      }
    }), Pl(this, "uniforms"), Pl(this, "_replacements", []), Pl(this, "_maxColors"), this._maxColors = s, this.uniforms = this.resources.multiColorReplaceUniforms.uniforms, this.replacements = e.replacements;
  }
  /**
   * The collection of replacement items. Each item is color-pair
   * (an array length is 2). In the pair, the first value is original color , the second value is target color
   */
  set replacements(t) {
    const e = this.uniforms.uOriginalColors, s = this.uniforms.uTargetColors, r = t.length, n = new Pt();
    if (r > this._maxColors)
      throw new Error(`Length of replacements (${r}) exceeds the maximum colors length (${this._maxColors})`);
    e[r * 3] = -1;
    let a, o, h;
    for (let u = 0; u < r; u++) {
      const c = t[u];
      n.setValue(c[0]), [a, o, h] = n.toArray(), e[u * 3] = a, e[u * 3 + 1] = o, e[u * 3 + 2] = h, n.setValue(c[1]), [a, o, h] = n.toArray(), s[u * 3] = a, s[u * 3 + 1] = o, s[u * 3 + 2] = h;
    }
    this._replacements = t;
  }
  get replacements() {
    return this._replacements;
  }
  /**
    * Should be called after changing any of the contents of the replacements.
    * This is a convenience method for resetting the `replacements`.
    * @todo implement nested proxy to remove the need for this function
    */
  refresh() {
    this.replacements = this._replacements;
  }
  /**
    * The maximum number of color replacements supported by this filter. Can be changed
    * _only_ during construction.
    * @readonly
    */
  get maxColors() {
    return this._maxColors;
  }
  /**
    * Tolerance of the floating-point comparison between colors (lower = more exact, higher = more inclusive)
    * @default 0.05
    */
  get tolerance() {
    return this.uniforms.uTolerance;
  }
  set tolerance(t) {
    this.uniforms.uTolerance = t;
  }
  /**
   * @deprecated since 6.0.0
   *
   * Tolerance of the floating-point comparison between colors (lower = more exact, higher = more inclusive)
   * @default 0.05
   */
  set epsilon(t) {
    dt("6.0.0", "MultiColorReplaceFilter.epsilon is deprecated, please use MultiColorReplaceFilter.tolerance instead"), this.tolerance = t;
  }
  get epsilon() {
    return dt("6.0.0", "MultiColorReplaceFilter.epsilon is deprecated, please use MultiColorReplaceFilter.tolerance instead"), this.tolerance;
  }
};
Pl(_3, "DEFAULT_OPTIONS", {
  replacements: [[16711680, 255]],
  tolerance: 0.05,
  maxColors: void 0
});
var d3 = `precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform float uSepia;
uniform vec2 uNoise;
uniform vec3 uScratch;
uniform vec3 uVignetting;
uniform float uSeed;
uniform vec2 uDimensions;

uniform vec4 uInputSize;

const float SQRT_2 = 1.414213;
const vec3 SEPIA_RGB = vec3(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);

float rand(vec2 co) {
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

vec3 Overlay(vec3 src, vec3 dst)
{
    // if (dst <= 0.5) then: 2 * src * dst
    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)
    return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),
                (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),
                (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));
}


void main()
{
    finalColor = texture(uTexture, vTextureCoord);
    vec3 color = finalColor.rgb;

    if (uSepia > 0.0)
    {
        float gray = (color.x + color.y + color.z) / 3.0;
        vec3 grayscale = vec3(gray);

        color = Overlay(SEPIA_RGB, grayscale);

        color = grayscale + uSepia * (color - grayscale);
    }

    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions.xy;

    float vignette = uVignetting[0];
    float vignetteAlpha = uVignetting[1];
    float vignetteBlur = uVignetting[2];

    if (vignette > 0.0)
    {
        float outter = SQRT_2 - vignette * SQRT_2;
        vec2 dir = vec2(vec2(0.5, 0.5) - coord);
        dir.y *= uDimensions.y / uDimensions.x;
        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignetteBlur * SQRT_2), 0.0, 1.0);
        color.rgb *= darker + (1.0 - darker) * (1.0 - vignetteAlpha);
    }

    float scratch = uScratch[0];
    float scratchDensity = uScratch[1];
    float scratchWidth = uScratch[2];

    if (scratchDensity > uSeed && scratch != 0.0)
    {
        float phase = uSeed * 256.0;
        float s = mod(floor(phase), 2.0);
        float dist = 1.0 / scratchDensity;
        float d = distance(coord, vec2(uSeed * dist, abs(s - uSeed * dist)));
        if (d < uSeed * 0.6 + 0.4)
        {
            highp float period = scratchDensity * 10.0;

            float xx = coord.x * period + phase;
            float aa = abs(mod(xx, 0.5) * 4.0);
            float bb = mod(floor(xx / 0.5), 2.0);
            float yy = (1.0 - bb) * aa + bb * (2.0 - aa);

            float kk = 2.0 * period;
            float dw = scratchWidth / uDimensions.x * (0.75 + uSeed);
            float dh = dw * kk;

            float tine = (yy - (2.0 - dh));

            if (tine > 0.0) {
                float _sign = sign(scratch);

                tine = s * tine / period + scratch + 0.1;
                tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);

                color.rgb *= tine;
            }
        }
    }

    float noise = uNoise[0];
    float noiseSize = uNoise[1];

    if (noise > 0.0 && noiseSize > 0.0)
    {
        vec2 pixelCoord = vTextureCoord.xy * uInputSize.xy;
        pixelCoord.x = floor(pixelCoord.x / noiseSize);
        pixelCoord.y = floor(pixelCoord.y / noiseSize);
        // vec2 d = pixelCoord * noiseSize * vec2(1024.0 + uSeed * 512.0, 1024.0 - uSeed * 512.0);
        // float _noise = snoise(d) * 0.5;
        float _noise = rand(pixelCoord * noiseSize * uSeed) - 0.5;
        color += _noise * noise;
    }

    finalColor.rgb = color;
}`, f3 = `struct OldFilmUniforms {
    uSepia: f32,
    uNoise: vec2<f32>,
    uScratch: vec3<f32>,
    uVignetting: vec3<f32>,
    uSeed: f32,
    uDimensions: vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> oldFilmUniforms : OldFilmUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);

  if (oldFilmUniforms.uSepia > 0.)
  {
    color = vec4<f32>(sepia(color.rgb), color.a);
  }

  let coord: vec2<f32> = uv * gfu.uInputSize.xy / oldFilmUniforms.uDimensions;

  if (oldFilmUniforms.uVignetting[0] > 0.)
  {
    color *= vec4<f32>(vec3<f32>(vignette(color.rgb, coord)), color.a);
  }

  let uScratch = oldFilmUniforms.uScratch; 

  if (uScratch[1] > oldFilmUniforms.uSeed && uScratch[0] != 0.)
  {
    color = vec4<f32>(scratch(color.rgb, coord), color.a);
  }

  let uNoise = oldFilmUniforms.uNoise;

  if (uNoise[0] > 0.0 && uNoise[1] > 0.0)
  {
    color += vec4<f32>(vec3<f32>(noise(uv)), color.a);
  }

  return color;
}

const SQRT_2: f32 = 1.414213;
const SEPIA_RGB: vec3<f32> = vec3<f32>(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);

fn modulo(x: f32, y: f32) -> f32
{
  return x - y * floor(x/y);
}

fn rand(co: vec2<f32>) -> f32
{
  return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);
}

fn overlay(src: vec3<f32>, dst: vec3<f32>) -> vec3<f32>
{
    // if (dst <= 0.5) then: 2 * src * dst
    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)

    return vec3<f32>(
      select((1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)), (2.0 * src.x * dst.x), (dst.x <= 0.5)), 
      select((1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)), (2.0 * src.y * dst.y), (dst.y <= 0.5)),
      select((1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)), (2.0 * src.z * dst.z), (dst.z <= 0.5))
    );
}

fn sepia(co: vec3<f32>) -> vec3<f32>
{
  let gray: f32 = (co.x + co.y + co.z) / 3.0;
  let grayscale: vec3<f32> = vec3<f32>(gray);
  let color = overlay(SEPIA_RGB, grayscale);
  return grayscale + oldFilmUniforms.uSepia * (color - grayscale);
}

fn vignette(co: vec3<f32>, coord: vec2<f32>) -> f32
{
  let uVignetting = oldFilmUniforms.uVignetting;
  let uDimensions = oldFilmUniforms.uDimensions;
  
  let outter: f32 = SQRT_2 - uVignetting[0] * SQRT_2;
  var dir: vec2<f32> = vec2<f32>(vec2<f32>(0.5) - coord);
  dir.y *= uDimensions.y / uDimensions.x;
  let darker: f32 = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignetting[2] * SQRT_2), 0.0, 1.0);
  return darker + (1.0 - darker) * (1.0 - uVignetting[1]);
}

fn scratch(co: vec3<f32>, coord: vec2<f32>) -> vec3<f32>
{
  var color = co;
  let uScratch = oldFilmUniforms.uScratch;
  let uSeed = oldFilmUniforms.uSeed;
  let uDimensions = oldFilmUniforms.uDimensions;

  let phase: f32 = uSeed * 256.0;
  let s: f32 = modulo(floor(phase), 2.0);
  let dist: f32 = 1.0 / uScratch[1];
  let d: f32 = distance(coord, vec2<f32>(uSeed * dist, abs(s - uSeed * dist)));

  if (d < uSeed * 0.6 + 0.4)
  {
    let period: f32 = uScratch[1] * 10.0;

    let xx: f32 = coord.x * period + phase;
    let aa: f32 = abs(modulo(xx, 0.5) * 4.0);
    let bb: f32 = modulo(floor(xx / 0.5), 2.0);
    let yy: f32 = (1.0 - bb) * aa + bb * (2.0 - aa);

    let kk: f32 = 2.0 * period;
    let dw: f32 = uScratch[2] / uDimensions.x * (0.75 + uSeed);
    let dh: f32 = dw * kk;

    var tine: f32 = (yy - (2.0 - dh));

    if (tine > 0.0) {
        let _sign: f32 = sign(uScratch[0]);

        tine = s * tine / period + uScratch[0] + 0.1;
        tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);

        color *= tine;
    }
  }

  return color;
}

fn noise(coord: vec2<f32>) -> f32
{
  let uNoise = oldFilmUniforms.uNoise;
  let uSeed = oldFilmUniforms.uSeed;

  var pixelCoord: vec2<f32> = coord * gfu.uInputSize.xy;
  pixelCoord.x = floor(pixelCoord.x / uNoise[1]);
  pixelCoord.y = floor(pixelCoord.y / uNoise[1]);
  return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];
}`, g3 = Object.defineProperty, p3 = (i, t, e) => t in i ? g3(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, bp = (i, t, e) => (p3(i, typeof t != "symbol" ? t + "" : t, e), e);
const m3 = class Iv extends xt {
  /**
   * @param options - Options for the OldFilmFilter constructor.
   */
  constructor(t) {
    t = { ...Iv.DEFAULT_OPTIONS, ...t };
    const e = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: f3,
        entryPoint: "mainFragment"
      }
    }), s = It.from({
      vertex: $t,
      fragment: d3,
      name: "old-film-filter"
    });
    super({
      gpuProgram: e,
      glProgram: s,
      resources: {
        oldFilmUniforms: {
          uSepia: { value: t.sepia, type: "f32" },
          uNoise: { value: new Float32Array(2), type: "vec2<f32>" },
          uScratch: { value: new Float32Array(3), type: "vec3<f32>" },
          uVignetting: { value: new Float32Array(3), type: "vec3<f32>" },
          uSeed: { value: t.seed, type: "f32" },
          uDimensions: { value: new Float32Array(2), type: "vec2<f32>" }
        }
      }
    }), bp(this, "uniforms"), bp(this, "seed"), this.uniforms = this.resources.oldFilmUniforms.uniforms, Object.assign(this, t);
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(t, e, s, r) {
    this.uniforms.uDimensions[0] = e.frame.width, this.uniforms.uDimensions[1] = e.frame.height, this.uniforms.uSeed = this.seed, t.applyFilter(this, e, s, r);
  }
  /**
   * The amount of saturation of sepia effect,
   * a value of `1` is more saturation and closer to `0` is less, and a value of `0` produces no sepia effect
   * @default 0.3
   */
  get sepia() {
    return this.uniforms.uSepia;
  }
  set sepia(t) {
    this.uniforms.uSepia = t;
  }
  /**
   * Opacity/intensity of the noise effect between `0` and `1`
   * @default 0.3
   */
  get noise() {
    return this.uniforms.uNoise[0];
  }
  set noise(t) {
    this.uniforms.uNoise[0] = t;
  }
  /**
   * The size of the noise particles
   * @default 1
   */
  get noiseSize() {
    return this.uniforms.uNoise[1];
  }
  set noiseSize(t) {
    this.uniforms.uNoise[1] = t;
  }
  /**
   * How often scratches appear
   * @default 0.5
   */
  get scratch() {
    return this.uniforms.uScratch[0];
  }
  set scratch(t) {
    this.uniforms.uScratch[0] = t;
  }
  /**
   * The density of the number of scratches
   * @default 0.3
   */
  get scratchDensity() {
    return this.uniforms.uScratch[1];
  }
  set scratchDensity(t) {
    this.uniforms.uScratch[1] = t;
  }
  /**
   * The width of the scratches
   * @default 1
   */
  get scratchWidth() {
    return this.uniforms.uScratch[2];
  }
  set scratchWidth(t) {
    this.uniforms.uScratch[2] = t;
  }
  /**
   * The radius of the vignette effect, smaller values produces a smaller vignette
   * @default 0.3
   */
  get vignetting() {
    return this.uniforms.uVignetting[0];
  }
  set vignetting(t) {
    this.uniforms.uVignetting[0] = t;
  }
  /**
   * Amount of opacity on the vignette
   * @default 1
   */
  get vignettingAlpha() {
    return this.uniforms.uVignetting[1];
  }
  set vignettingAlpha(t) {
    this.uniforms.uVignetting[1] = t;
  }
  /**
   * Blur intensity of the vignette
   * @default 1
   */
  get vignettingBlur() {
    return this.uniforms.uVignetting[2];
  }
  set vignettingBlur(t) {
    this.uniforms.uVignetting[2] = t;
  }
};
bp(m3, "DEFAULT_OPTIONS", {
  sepia: 0.3,
  noise: 0.3,
  noiseSize: 1,
  scratch: 0.5,
  scratchDensity: 0.3,
  scratchWidth: 1,
  vignetting: 0.3,
  vignettingAlpha: 1,
  vignettingBlur: 0.3,
  seed: 0
});
var E3 = `precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uThickness;
uniform vec3 uColor;
uniform float uAlpha;
uniform float uKnockout;

uniform vec4 uInputClamp;

const float DOUBLE_PI = 2. * 3.14159265358979323846264;
const float ANGLE_STEP = \${ANGLE_STEP};

float outlineMaxAlphaAtPos(vec2 pos) {
    if (uThickness.x == 0. || uThickness.y == 0.) {
        return 0.;
    }

    vec4 displacedColor;
    vec2 displacedPos;
    float maxAlpha = 0.;

    for (float angle = 0.; angle <= DOUBLE_PI; angle += ANGLE_STEP) {
        displacedPos.x = vTextureCoord.x + uThickness.x * cos(angle);
        displacedPos.y = vTextureCoord.y + uThickness.y * sin(angle);
        displacedColor = texture(uTexture, clamp(displacedPos, uInputClamp.xy, uInputClamp.zw));
        maxAlpha = max(maxAlpha, displacedColor.a);
    }

    return maxAlpha;
}

void main(void) {
    vec4 sourceColor = texture(uTexture, vTextureCoord);
    vec4 contentColor = sourceColor * float(uKnockout < 0.5);
    float outlineAlpha = uAlpha * outlineMaxAlphaAtPos(vTextureCoord.xy) * (1.-sourceColor.a);
    vec4 outlineColor = vec4(vec3(uColor) * outlineAlpha, outlineAlpha);
    finalColor = contentColor + outlineColor;
}
`, T3 = `struct OutlineUniforms {
  uThickness:vec2<f32>,
  uColor:vec3<f32>,
  uAlpha:f32,
  uAngleStep:f32,
  uKnockout:f32,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> outlineUniforms : OutlineUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let sourceColor: vec4<f32> = textureSample(uTexture, uSampler, uv);
  let contentColor: vec4<f32> = sourceColor * (1. - outlineUniforms.uKnockout);
  
  let outlineAlpha: f32 = outlineUniforms.uAlpha * outlineMaxAlphaAtPos(uv) * (1. - sourceColor.a);
  let outlineColor: vec4<f32> = vec4<f32>(vec3<f32>(outlineUniforms.uColor) * outlineAlpha, outlineAlpha);
  
  return contentColor + outlineColor;
}

fn outlineMaxAlphaAtPos(uv: vec2<f32>) -> f32 {
  let thickness = outlineUniforms.uThickness;

  if (thickness.x == 0. || thickness.y == 0.) {
    return 0.;
  }
  
  let angleStep = outlineUniforms.uAngleStep;

  var displacedColor: vec4<f32>;
  var displacedPos: vec2<f32>;

  var maxAlpha: f32 = 0.;
  var displaced: vec2<f32>;
  var curColor: vec4<f32>;

  for (var angle = 0.; angle <= DOUBLE_PI; angle += angleStep)
  {
    displaced.x = uv.x + thickness.x * cos(angle);
    displaced.y = uv.y + thickness.y * sin(angle);
    curColor = textureSample(uTexture, uSampler, clamp(displaced, gfu.uInputClamp.xy, gfu.uInputClamp.zw));
    maxAlpha = max(maxAlpha, curColor.a);
  }

  return maxAlpha;
}

const DOUBLE_PI: f32 = 3.14159265358979323846264 * 2.;`, I3 = Object.defineProperty, S3 = (i, t, e) => t in i ? I3(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, ha = (i, t, e) => (S3(i, typeof t != "symbol" ? t + "" : t, e), e);
const ZT = class Nn extends xt {
  /** @ignore */
  constructor(...t) {
    let e = t[0] ?? {};
    typeof e == "number" && (dt("6.0.0", "OutlineFilter constructor params are now options object. See params: { thickness, color, quality, alpha, knockout }"), e = { thickness: e }, t[1] !== void 0 && (e.color = t[1]), t[2] !== void 0 && (e.quality = t[2]), t[3] !== void 0 && (e.alpha = t[3]), t[4] !== void 0 && (e.knockout = t[4])), e = { ...Nn.DEFAULT_OPTIONS, ...e };
    const s = e.quality ?? 0.1, r = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: T3,
        entryPoint: "mainFragment"
      }
    }), n = It.from({
      vertex: $t,
      fragment: E3.replace(/\$\{ANGLE_STEP\}/, Nn.getAngleStep(s).toFixed(7)),
      name: "outline-filter"
    });
    super({
      gpuProgram: r,
      glProgram: n,
      resources: {
        outlineUniforms: {
          uThickness: { value: new Float32Array(2), type: "vec2<f32>" },
          uColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uAlpha: { value: e.alpha, type: "f32" },
          uAngleStep: { value: 0, type: "f32" },
          uKnockout: { value: e.knockout ? 1 : 0, type: "f32" }
        }
      }
    }), ha(this, "uniforms"), ha(this, "_thickness"), ha(this, "_quality"), ha(this, "_color"), this.uniforms = this.resources.outlineUniforms.uniforms, this.uniforms.uAngleStep = Nn.getAngleStep(s), this._color = new Pt(), this.color = e.color ?? 0, Object.assign(this, e);
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(t, e, s, r) {
    this.uniforms.uThickness[0] = this.thickness / e.source.width, this.uniforms.uThickness[1] = this.thickness / e.source.height, t.applyFilter(this, e, s, r);
  }
  /**
   * Get the angleStep by quality
   * @param quality
   */
  static getAngleStep(t) {
    return parseFloat((Math.PI * 2 / Math.max(
      t * Nn.MAX_SAMPLES,
      Nn.MIN_SAMPLES
    )).toFixed(7));
  }
  /**
   * The thickness of the outline
   * @default 1
   */
  get thickness() {
    return this._thickness;
  }
  set thickness(t) {
    this._thickness = this.padding = t;
  }
  /**
   * The color value of the ambient color
   * @example [1.0, 1.0, 1.0] = 0xffffff
   * @default 0x000000
   */
  get color() {
    return this._color.value;
  }
  set color(t) {
    this._color.setValue(t);
    const [e, s, r] = this._color.toArray();
    this.uniforms.uColor[0] = e, this.uniforms.uColor[1] = s, this.uniforms.uColor[2] = r;
  }
  /**
   * Coefficient for alpha multiplication
   * @default 1
   */
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(t) {
    this.uniforms.uAlpha = t;
  }
  /**
   * The quality of the outline from `0` to `1`.
   * Using a higher quality setting will result in more accuracy but slower performance
   * @default 0.1
   */
  get quality() {
    return this._quality;
  }
  set quality(t) {
    this._quality = t, this.uniforms.uAngleStep = Nn.getAngleStep(t);
  }
  /**
   * Whether to only render outline, not the contents.
   * @default false
   */
  get knockout() {
    return this.uniforms.uKnockout === 1;
  }
  set knockout(t) {
    this.uniforms.uKnockout = t ? 1 : 0;
  }
};
ha(ZT, "DEFAULT_OPTIONS", {
  thickness: 1,
  color: 0,
  alpha: 1,
  quality: 0.1,
  knockout: !1
});
ha(ZT, "MIN_SAMPLES", 1);
ha(ZT, "MAX_SAMPLES", 100);
var A3 = `precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform float uRadian;
uniform vec2 uCenter;
uniform float uRadius;
uniform int uKernelSize;

uniform vec4 uInputSize;

const int MAX_KERNEL_SIZE = 2048;

void main(void)
{
    vec4 color = texture(uTexture, vTextureCoord);

    if (uKernelSize == 0)
    {
        finalColor = color;
        return;
    }

    float aspect = uInputSize.y / uInputSize.x;
    vec2 center = uCenter.xy / uInputSize.xy;
    float gradient = uRadius / uInputSize.x * 0.3;
    float radius = uRadius / uInputSize.x - gradient * 0.5;
    int k = uKernelSize - 1;

    vec2 coord = vTextureCoord;
    vec2 dir = vec2(center - coord);
    float dist = length(vec2(dir.x, dir.y * aspect));

    float radianStep = uRadian;
    if (radius >= 0.0 && dist > radius) {
        float delta = dist - radius;
        float gap = gradient;
        float scale = 1.0 - abs(delta / gap);
        if (scale <= 0.0) {
            finalColor = color;
            return;
        }
        radianStep *= scale;
    }
    radianStep /= float(k);

    float s = sin(radianStep);
    float c = cos(radianStep);
    mat2 rotationMatrix = mat2(vec2(c, -s), vec2(s, c));

    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {
        if (i == k) {
            break;
        }

        coord -= center;
        coord.y *= aspect;
        coord = rotationMatrix * coord;
        coord.y /= aspect;
        coord += center;

        vec4 sample = texture(uTexture, coord);

        // switch to pre-multiplied alpha to correctly blur transparent images
        // sample.rgb *= sample.a;

        color += sample;
    }

    finalColor = color / float(uKernelSize);
}
`, R3 = `struct RadialBlurUniforms {
  uRadian: f32,
  uCenter: vec2<f32>,
  uKernelSize: f32,
  uRadius: f32,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> radialBlurUniforms : RadialBlurUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let uRadian = radialBlurUniforms.uRadian;
  let uCenter = radialBlurUniforms.uCenter;
  let uKernelSize = radialBlurUniforms.uKernelSize;
  let uRadius = radialBlurUniforms.uRadius;
  
  var returnColorOnly = false;

  if (uKernelSize == 0)
  {
    returnColorOnly = true;
  }

  let aspect: f32 = gfu.uInputSize.y / gfu.uInputSize.x;
  let center: vec2<f32> = uCenter.xy / gfu.uInputSize.xy;
  let gradient: f32 = uRadius / gfu.uInputSize.x * 0.3;
  let radius: f32 = uRadius / gfu.uInputSize.x - gradient * 0.5;
  let k: i32 = i32(uKernelSize - 1);

  var coord: vec2<f32> = uv;
  let dir: vec2<f32> = vec2<f32>(center - coord);
  let dist: f32 = length(vec2<f32>(dir.x, dir.y * aspect));

  var radianStep: f32 = uRadian;
  
  if (radius >= 0.0 && dist > radius)
  {
    let delta: f32 = dist - radius;
    let gap: f32 = gradient;
    let scale: f32 = 1.0 - abs(delta / gap);
    if (scale <= 0.0) {
      returnColorOnly = true;
    }
    radianStep *= scale;
  }

  radianStep /= f32(k);

  let s: f32 = sin(radianStep);
  let c: f32 = cos(radianStep);
  let rotationMatrix: mat2x2<f32> = mat2x2<f32>(vec2<f32>(c, -s), vec2<f32>(s, c));
  
  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);
  let baseColor = vec4<f32>(color);

  let minK: i32 = min(i32(uKernelSize) - 1, MAX_KERNEL_SIZE - 1);

  for(var i: i32 = 0; i < minK; i += 1) 
  {
    coord -= center;
    coord.y *= aspect;
    coord = rotationMatrix * coord;
    coord.y /= aspect;
    coord += center;
    let sample: vec4<f32> = textureSample(uTexture, uSampler, coord);
    // switch to pre-multiplied alpha to correctly blur transparent images
    // sample.rgb *= sample.a;
    color += sample;
  }

  return select(color / f32(uKernelSize), baseColor, returnColorOnly);
}

const MAX_KERNEL_SIZE: i32 = 2048;`, O3 = Object.defineProperty, y3 = (i, t, e) => t in i ? O3(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, Nl = (i, t, e) => (y3(i, typeof t != "symbol" ? t + "" : t, e), e);
const v3 = class Sv extends xt {
  /** @ignore */
  constructor(...t) {
    let e = t[0] ?? {};
    if (typeof e == "number") {
      if (dt("6.0.0", "RadialBlurFilter constructor params are now options object. See params: { angle, center, kernelSize, radius }"), e = { angle: e }, t[1]) {
        const n = "x" in t[1] ? t[1].x : t[1][0], a = "y" in t[1] ? t[1].y : t[1][1];
        e.center = { x: n, y: a };
      }
      t[2] && (e.kernelSize = t[2]), t[3] && (e.radius = t[3]);
    }
    e = { ...Sv.DEFAULT_OPTIONS, ...e };
    const s = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: R3,
        entryPoint: "mainFragment"
      }
    }), r = It.from({
      vertex: $t,
      fragment: A3,
      name: "radial-blur-filter"
    });
    super({
      gpuProgram: s,
      glProgram: r,
      resources: {
        radialBlurUniforms: {
          uRadian: { value: 0, type: "f32" },
          uCenter: { value: e.center, type: "vec2<f32>" },
          uKernelSize: { value: e.kernelSize, type: "i32" },
          uRadius: { value: e.radius, type: "f32" }
        }
      }
    }), Nl(this, "uniforms"), Nl(this, "_angle"), Nl(this, "_kernelSize"), this.uniforms = this.resources.radialBlurUniforms.uniforms, Object.assign(this, e);
  }
  _updateKernelSize() {
    this.uniforms.uKernelSize = this._angle !== 0 ? this.kernelSize : 0;
  }
  /**
   * Sets the angle in degrees of the motion for blur effect.
   * @default 0
   */
  get angle() {
    return this._angle;
  }
  set angle(t) {
    this._angle = t, this.uniforms.uRadian = t * Math.PI / 180, this._updateKernelSize();
  }
  /**
   * The `x` and `y` offset coordinates to change the position of the center of the circle of effect.
   * This should be a size 2 array or an object containing `x` and `y` values, you cannot change types
   * once defined in the constructor
   * @default {x:0,y:0}
   */
  get center() {
    return this.uniforms.uCenter;
  }
  set center(t) {
    Array.isArray(t) && (t = { x: t[0], y: t[1] }), this.uniforms.uCenter = t;
  }
  /**
   * Sets the velocity of the motion for blur effect on the `x` axis
   * @default 0
   */
  get centerX() {
    return this.center.x;
  }
  set centerX(t) {
    this.center.x = t;
  }
  /**
   * Sets the velocity of the motion for blur effect on the `x` axis
   * @default 0
   */
  get centerY() {
    return this.center.y;
  }
  set centerY(t) {
    this.center.y = t;
  }
  /**
   * The kernelSize of the blur filter. Must be odd number >= 3
   * @default 5
   */
  get kernelSize() {
    return this._kernelSize;
  }
  set kernelSize(t) {
    this._kernelSize = t, this._updateKernelSize();
  }
  /**
   * The maximum size of the blur radius, less than `0` equates to infinity
   * @default -1
   */
  get radius() {
    return this.uniforms.uRadius;
  }
  set radius(t) {
    this.uniforms.uRadius = t < 0 || t === 1 / 0 ? -1 : t;
  }
};
Nl(v3, "DEFAULT_OPTIONS", {
  angle: 0,
  center: { x: 0, y: 0 },
  kernelSize: 5,
  radius: -1
});
var C3 = `precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform float uMirror;
uniform float uBoundary;
uniform vec2 uAmplitude;
uniform vec2 uWavelength;
uniform vec2 uAlpha;
uniform float uTime;
uniform vec2 uDimensions;

uniform vec4 uInputSize;
uniform vec4 uInputClamp;

float rand(vec2 co) {
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main(void)
{
    vec2 pixelCoord = vTextureCoord.xy * uInputSize.xy;
    vec2 coord = pixelCoord / uDimensions;

    if (coord.y < uBoundary) {
        finalColor = texture(uTexture, vTextureCoord);
        return;
    }

    float k = (coord.y - uBoundary) / (1. - uBoundary + 0.0001);
    float areaY = uBoundary * uDimensions.y / uInputSize.y;
    float v = areaY + areaY - vTextureCoord.y;
    float y = uMirror > 0.5 ? v : vTextureCoord.y;

    float _amplitude = ((uAmplitude.y - uAmplitude.x) * k + uAmplitude.x ) / uInputSize.x;
    float _waveLength = ((uWavelength.y - uWavelength.x) * k + uWavelength.x) / uInputSize.y;
    float _alpha = (uAlpha.y - uAlpha.x) * k + uAlpha.x;

    float x = vTextureCoord.x + cos(v * 6.28 / _waveLength - uTime) * _amplitude;
    x = clamp(x, uInputClamp.x, uInputClamp.z);

    vec4 color = texture(uTexture, vec2(x, y));

    finalColor = color * _alpha;
}
`, x3 = `struct ReflectionUniforms {
  uMirror: f32,
  uBoundary: f32,
  uAmplitude: vec2<f32>,
  uWavelength: vec2<f32>,
  uAlpha: vec2<f32>,
  uTime: f32,
  uDimensions: vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> reflectionUniforms : ReflectionUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let uDimensions: vec2<f32> = reflectionUniforms.uDimensions;
  let uBoundary: f32 = reflectionUniforms.uBoundary;
  let uMirror: bool = reflectionUniforms.uMirror > 0.5;
  let uAmplitude: vec2<f32> = reflectionUniforms.uAmplitude;
  let uWavelength: vec2<f32> = reflectionUniforms.uWavelength;
  let uAlpha: vec2<f32> = reflectionUniforms.uAlpha;
  let uTime: f32 = reflectionUniforms.uTime;

  let pixelCoord: vec2<f32> = uv * gfu.uInputSize.xy;
  let coord: vec2<f32> = pixelCoord /uDimensions;
  var returnColorOnly: bool = false;

  if (coord.y < uBoundary) {
    returnColorOnly = true;
  }

  let k: f32 = (coord.y - uBoundary) / (1. - uBoundary + 0.0001);
  let areaY: f32 = uBoundary * uDimensions.y / gfu.uInputSize.y;
  let v: f32 = areaY + areaY - uv.y;
  let y: f32 = select(uv.y, v, uMirror);

  let amplitude: f32 = ((uAmplitude.y - uAmplitude.x) * k + uAmplitude.x ) / gfu.uInputSize.x;
  let waveLength: f32 = ((uWavelength.y - uWavelength.x) * k + uWavelength.x) / gfu.uInputSize.y;
  let alpha: f32 = select((uAlpha.y - uAlpha.x) * k + uAlpha.x, 1., returnColorOnly);

  var x: f32 = uv.x + cos(v * 6.28 / waveLength - uTime) * amplitude;
  x = clamp(x, gfu.uInputClamp.x, gfu.uInputClamp.z);
  
  return textureSample(uTexture, uSampler, select(vec2<f32>(x, y), uv, returnColorOnly)) * alpha;
}

fn rand(co: vec2<f32>) -> f32 
{
  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}`, M3 = Object.defineProperty, b3 = (i, t, e) => t in i ? M3(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, Pp = (i, t, e) => (b3(i, typeof t != "symbol" ? t + "" : t, e), e);
const P3 = class Av extends xt {
  /**
   * @param options - Options for the ReflectionFilter constructor.
   */
  constructor(t) {
    t = { ...Av.DEFAULT_OPTIONS, ...t };
    const e = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: x3,
        entryPoint: "mainFragment"
      }
    }), s = It.from({
      vertex: $t,
      fragment: C3,
      name: "reflection-filter"
    });
    super({
      gpuProgram: e,
      glProgram: s,
      resources: {
        reflectionUniforms: {
          uMirror: { value: t.mirror ? 1 : 0, type: "f32" },
          uBoundary: { value: t.boundary, type: "f32" },
          uAmplitude: { value: t.amplitude, type: "vec2<f32>" },
          uWavelength: { value: t.waveLength, type: "vec2<f32>" },
          uAlpha: { value: t.alpha, type: "vec2<f32>" },
          uTime: { value: t.time, type: "f32" },
          uDimensions: { value: new Float32Array(2), type: "vec2<f32>" }
        }
      }
    }), Pp(this, "uniforms"), Pp(this, "time", 0), this.uniforms = this.resources.reflectionUniforms.uniforms, Object.assign(this, t);
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(t, e, s, r) {
    this.uniforms.uDimensions[0] = e.frame.width, this.uniforms.uDimensions[1] = e.frame.height, this.uniforms.uTime = this.time, t.applyFilter(this, e, s, r);
  }
  /**
   * `true` to reflect the image, `false` for waves-only
   * @default true
   */
  get mirror() {
    return this.uniforms.uMirror > 0.5;
  }
  set mirror(t) {
    this.uniforms.uMirror = t ? 1 : 0;
  }
  /**
   * Vertical position of the reflection point, default is 50% (middle)
   * smaller numbers produce a larger reflection, larger numbers produce a smaller reflection.
   * @default 0.5
   */
  get boundary() {
    return this.uniforms.uBoundary;
  }
  set boundary(t) {
    this.uniforms.uBoundary = t;
  }
  /**
   * Starting and ending amplitude of waves
   * @default [0,20]
   */
  get amplitude() {
    return Array.from(this.uniforms.uAmplitude);
  }
  set amplitude(t) {
    this.uniforms.uAmplitude[0] = t[0], this.uniforms.uAmplitude[1] = t[1];
  }
  /**
   * Starting amplitude of waves
   * @default 0
   */
  get amplitudeStart() {
    return this.uniforms.uAmplitude[0];
  }
  set amplitudeStart(t) {
    this.uniforms.uAmplitude[0] = t;
  }
  /**
   * Starting amplitude of waves
   * @default 20
   */
  get amplitudeEnd() {
    return this.uniforms.uAmplitude[1];
  }
  set amplitudeEnd(t) {
    this.uniforms.uAmplitude[1] = t;
  }
  /**
   * Starting and ending length of waves
   * @default [30,100]
   */
  get waveLength() {
    return Array.from(this.uniforms.uWavelength);
  }
  set waveLength(t) {
    this.uniforms.uWavelength[0] = t[0], this.uniforms.uWavelength[1] = t[1];
  }
  /**
   * Starting wavelength of waves
   * @default 30
   */
  get wavelengthStart() {
    return this.uniforms.uWavelength[0];
  }
  set wavelengthStart(t) {
    this.uniforms.uWavelength[0] = t;
  }
  /**
   * Starting wavelength of waves
   * @default 100
   */
  get wavelengthEnd() {
    return this.uniforms.uWavelength[1];
  }
  set wavelengthEnd(t) {
    this.uniforms.uWavelength[1] = t;
  }
  /**
   * Starting and ending alpha values
   * @default [1,1]
   */
  get alpha() {
    return Array.from(this.uniforms.uAlpha);
  }
  set alpha(t) {
    this.uniforms.uAlpha[0] = t[0], this.uniforms.uAlpha[1] = t[1];
  }
  /**
   * Starting wavelength of waves
   * @default 1
   */
  get alphaStart() {
    return this.uniforms.uAlpha[0];
  }
  set alphaStart(t) {
    this.uniforms.uAlpha[0] = t;
  }
  /**
   * Starting wavelength of waves
   * @default 1
   */
  get alphaEnd() {
    return this.uniforms.uAlpha[1];
  }
  set alphaEnd(t) {
    this.uniforms.uAlpha[1] = t;
  }
};
Pp(P3, "DEFAULT_OPTIONS", {
  mirror: !0,
  boundary: 0.5,
  amplitude: [0, 20],
  waveLength: [30, 100],
  alpha: [1, 1],
  time: 0
});
var N3 = `precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec4 uInputSize;
uniform vec2 uRed;
uniform vec2 uGreen;
uniform vec2 uBlue;

void main(void)
{
   float r = texture(uTexture, vTextureCoord + uRed/uInputSize.xy).r;
   float g = texture(uTexture, vTextureCoord + uGreen/uInputSize.xy).g;
   float b = texture(uTexture, vTextureCoord + uBlue/uInputSize.xy).b;
   float a = texture(uTexture, vTextureCoord).a;
   finalColor = vec4(r, g, b, a);
}
`, U3 = `struct RgbSplitUniforms {
    uRed: vec2<f32>,
    uGreen: vec2<f32>,
    uBlue: vec3<f32>,
};

struct GlobalFilterUniforms {
    uInputSize:vec4<f32>,
    uInputPixel:vec4<f32>,
    uInputClamp:vec4<f32>,
    uOutputFrame:vec4<f32>,
    uGlobalFrame:vec4<f32>,
    uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> rgbSplitUniforms : RgbSplitUniforms;

@fragment
fn mainFragment(
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
    let r = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uRed.x / gfu.uInputSize.x, rgbSplitUniforms.uRed.y / gfu.uInputSize.y)).r;
    let g = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uGreen.x / gfu.uInputSize.x, rgbSplitUniforms.uGreen.y / gfu.uInputSize.y)).g;
    let b = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uBlue.x / gfu.uInputSize.x, rgbSplitUniforms.uBlue.y / gfu.uInputSize.y)).b;
    let a = textureSample(uTexture, uSampler, uv).a;
    return vec4<f32>(r, g, b, a);
}
`, D3 = Object.defineProperty, L3 = (i, t, e) => t in i ? D3(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, Rv = (i, t, e) => (L3(i, typeof t != "symbol" ? t + "" : t, e), e);
const F3 = class Ov extends xt {
  /** @ignore */
  constructor(...t) {
    let e = t[0] ?? {};
    (Array.isArray(e) || "x" in e && "y" in e) && (dt("6.0.0", "RGBSplitFilter constructor params are now options object. See params: { red, green, blue }"), e = { red: e }, t[1] !== void 0 && (e.green = t[1]), t[2] !== void 0 && (e.blue = t[2])), e = { ...Ov.DEFAULT_OPTIONS, ...e };
    const s = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: U3,
        entryPoint: "mainFragment"
      }
    }), r = It.from({
      vertex: $t,
      fragment: N3,
      name: "rgb-split-filter"
    });
    super({
      gpuProgram: s,
      glProgram: r,
      resources: {
        rgbSplitUniforms: {
          uRed: { value: e.red, type: "vec2<f32>" },
          uGreen: { value: e.green, type: "vec2<f32>" },
          uBlue: { value: e.blue, type: "vec2<f32>" }
        }
      }
    }), Rv(this, "uniforms"), this.uniforms = this.resources.rgbSplitUniforms.uniforms, Object.assign(this, e);
  }
  /**
   * Red channel offset.
   * @default {x:-10,y:0}
   */
  get red() {
    return this.uniforms.uRed;
  }
  set red(t) {
    Array.isArray(t) && (t = { x: t[0], y: t[1] }), this.uniforms.uRed = t;
  }
  /**
   * Amount of x-axis offset for the red channel.
   * @default -10
   */
  get redX() {
    return this.red.x;
  }
  set redX(t) {
    this.red.x = t;
  }
  /**
   * Amount of y-axis offset for the red channel.
   * @default 0
   */
  get redY() {
    return this.red.y;
  }
  set redY(t) {
    this.red.y = t;
  }
  /**
   * Green channel offset.
   * @default {x:0,y:10}
   */
  get green() {
    return this.uniforms.uGreen;
  }
  set green(t) {
    Array.isArray(t) && (t = { x: t[0], y: t[1] }), this.uniforms.uGreen = t;
  }
  /**
   * Amount of x-axis offset for the green channel.
   * @default 0
   */
  get greenX() {
    return this.green.x;
  }
  set greenX(t) {
    this.green.x = t;
  }
  /**
   * Amount of y-axis offset for the green channel.
   * @default 10
   */
  get greenY() {
    return this.green.y;
  }
  set greenY(t) {
    this.green.y = t;
  }
  /**
   * Blue channel offset.
   * @default {x:0,y:0}
   */
  get blue() {
    return this.uniforms.uBlue;
  }
  set blue(t) {
    Array.isArray(t) && (t = { x: t[0], y: t[1] }), this.uniforms.uBlue = t;
  }
  /**
   * Amount of x-axis offset for the blue channel.
   * @default 0
   */
  get blueX() {
    return this.blue.x;
  }
  set blueX(t) {
    this.blue.x = t;
  }
  /**
   * Amount of y-axis offset for the blue channel.
   * @default 0
   */
  get blueY() {
    return this.blue.y;
  }
  set blueY(t) {
    this.blue.y = t;
  }
};
Rv(F3, "DEFAULT_OPTIONS", {
  red: { x: -10, y: 0 },
  green: { x: 0, y: 10 },
  blue: { x: 0, y: 0 }
});
var w3 = `
precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uCenter;
uniform float uTime;
uniform float uSpeed;
uniform vec4 uWave;

uniform vec4 uInputSize;
uniform vec4 uInputClamp;

const float PI = 3.14159;

void main()
{
    float uAmplitude = uWave[0];
    float uWavelength = uWave[1];
    float uBrightness = uWave[2];
    float uRadius = uWave[3];

    float halfWavelength = uWavelength * 0.5 / uInputSize.x;
    float maxRadius = uRadius / uInputSize.x;
    float currentRadius = uTime * uSpeed / uInputSize.x;

    float fade = 1.0;

    if (maxRadius > 0.0) {
        if (currentRadius > maxRadius) {
            finalColor = texture(uTexture, vTextureCoord);
            return;
        }
        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);
    }

    vec2 dir = vec2(vTextureCoord - uCenter / uInputSize.xy);
    dir.y *= uInputSize.y / uInputSize.x;
    float dist = length(dir);

    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {
        finalColor = texture(uTexture, vTextureCoord);
        return;
    }

    vec2 diffUV = normalize(dir);

    float diff = (dist - currentRadius) / halfWavelength;

    float p = 1.0 - pow(abs(diff), 2.0);

    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );
    float powDiff = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );

    vec2 offset = diffUV * powDiff / uInputSize.xy;

    // Do clamp :
    vec2 coord = vTextureCoord + offset;
    vec2 clampedCoord = clamp(coord, uInputClamp.xy, uInputClamp.zw);
    vec4 color = texture(uTexture, clampedCoord);
    if (coord != clampedCoord) {
        color *= max(0.0, 1.0 - length(coord - clampedCoord));
    }

    // No clamp :
    // finalColor = texture(uTexture, vTextureCoord + offset);

    color.rgb *= 1.0 + (uBrightness - 1.0) * p * fade;

    finalColor = color;
}
`, G3 = `
struct ShockWaveUniforms {
    uTime: f32,
    uOffset: vec2<f32>,
    uSpeed: f32,
    uWave: vec4<f32>,
};

struct GlobalFilterUniforms {
    uInputSize:vec4<f32>,
    uInputPixel:vec4<f32>,
    uInputClamp:vec4<f32>,
    uOutputFrame:vec4<f32>,
    uGlobalFrame:vec4<f32>,
    uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> shockwaveUniforms : ShockWaveUniforms;

@fragment
fn mainFragment(
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {

    let uTime = shockwaveUniforms.uTime;
    let uOffset = shockwaveUniforms.uOffset;
    let uSpeed = shockwaveUniforms.uSpeed;
    let uAmplitude = shockwaveUniforms.uWave[0];
    let uWavelength = shockwaveUniforms.uWave[1];
    let uBrightness = shockwaveUniforms.uWave[2];
    let uRadius = shockwaveUniforms.uWave[3];
    let halfWavelength: f32 = uWavelength * 0.5 / gfu.uInputSize.x;
    let maxRadius: f32 = uRadius / gfu.uInputSize.x;
    let currentRadius: f32 = uTime * uSpeed / gfu.uInputSize.x;
    var fade: f32 = 1.0;
    var returnColorOnly: bool = false;
    
    if (maxRadius > 0.0) {
        if (currentRadius > maxRadius) {
            returnColorOnly = true;
        }
        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);
    }
    var dir: vec2<f32> = vec2<f32>(uv - uOffset / gfu.uInputSize.xy);
    dir.y *= gfu.uInputSize.y / gfu.uInputSize.x;

    let dist:f32 = length(dir);

    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {
        returnColorOnly = true;
    }

    let diffUV: vec2<f32> = normalize(dir);
    let diff: f32 = (dist - currentRadius) / halfWavelength;
    let p: f32 = 1.0 - pow(abs(diff), 2.0);
    let powDiff: f32 = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );
    let offset: vec2<f32> = diffUV * powDiff / gfu.uInputSize.xy;
    // Do clamp :
    let coord: vec2<f32> = uv + offset;
    let clampedCoord: vec2<f32> = clamp(coord, gfu.uInputClamp.xy, gfu.uInputClamp.zw);

    var clampedColor: vec4<f32> = textureSample(uTexture, uSampler, clampedCoord);
    
    if (boolVec2(coord, clampedCoord)) 
    {
        clampedColor *= max(0.0, 1.0 - length(coord - clampedCoord));
    }
    // No clamp :
    var finalColor = clampedColor;

    return select(finalColor, textureSample(uTexture, uSampler, uv), returnColorOnly);
}

fn boolVec2(x: vec2<f32>, y: vec2<f32>) -> bool
{
    if (x.x == y.x && x.y == y.y)
    {
        return true;
    }
    
    return false;
}

const PI: f32 = 3.14159265358979323846264;
`, B3 = Object.defineProperty, k3 = (i, t, e) => t in i ? B3(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, Np = (i, t, e) => (k3(i, typeof t != "symbol" ? t + "" : t, e), e);
const z3 = class yv extends xt {
  /** @ignore */
  // eslint-disable-next-line max-len
  constructor(...t) {
    let e = t[0] ?? {};
    (Array.isArray(e) || "x" in e && "y" in e) && (dt("6.0.0", "ShockwaveFilter constructor params are now options object. See params: { center, speed, amplitude, wavelength, brightness, radius, time }"), e = { center: e, ...t[1] }, t[2] !== void 0 && (e.time = t[2])), e = { ...yv.DEFAULT_OPTIONS, ...e };
    const s = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: G3,
        entryPoint: "mainFragment"
      }
    }), r = It.from({
      vertex: $t,
      fragment: w3,
      name: "shockwave-filter"
    });
    super({
      gpuProgram: s,
      glProgram: r,
      resources: {
        shockwaveUniforms: {
          uTime: { value: e.time, type: "f32" },
          uCenter: { value: e.center, type: "vec2<f32>" },
          uSpeed: { value: e.speed, type: "f32" },
          uWave: { value: new Float32Array(4), type: "vec4<f32>" }
        }
      }
    }), Np(this, "uniforms"), Np(this, "time"), this.time = 0, this.uniforms = this.resources.shockwaveUniforms.uniforms, Object.assign(this, e);
  }
  apply(t, e, s, r) {
    this.uniforms.uTime = this.time, t.applyFilter(this, e, s, r);
  }
  /**
   * The `x` and `y` center coordinates to change the position of the center of the circle of effect.
   * @default [0,0]
   */
  get center() {
    return this.uniforms.uCenter;
  }
  set center(t) {
    Array.isArray(t) && (t = { x: t[0], y: t[1] }), this.uniforms.uCenter = t;
  }
  /**
   * Sets the center of the effect in normalized screen coords on the `x` axis
   * @default 0
   */
  get centerX() {
    return this.uniforms.uCenter.x;
  }
  set centerX(t) {
    this.uniforms.uCenter.x = t;
  }
  /**
   * Sets the center of the effect in normalized screen coords on the `y` axis
   * @default 0
   */
  get centerY() {
    return this.uniforms.uCenter.y;
  }
  set centerY(t) {
    this.uniforms.uCenter.y = t;
  }
  /**
   * The speed about the shockwave ripples out. The unit is `pixel-per-second`
   * @default 500
   */
  get speed() {
    return this.uniforms.uSpeed;
  }
  set speed(t) {
    this.uniforms.uSpeed = t;
  }
  /**
   * The amplitude of the shockwave
   * @default 30
   */
  get amplitude() {
    return this.uniforms.uWave[0];
  }
  set amplitude(t) {
    this.uniforms.uWave[0] = t;
  }
  /**
   * The wavelength of the shockwave
   * @default 160
   */
  get wavelength() {
    return this.uniforms.uWave[1];
  }
  set wavelength(t) {
    this.uniforms.uWave[1] = t;
  }
  /**
   * The brightness of the shockwave
   * @default 1
   */
  get brightness() {
    return this.uniforms.uWave[2];
  }
  set brightness(t) {
    this.uniforms.uWave[2] = t;
  }
  /**
   * The maximum radius of shockwave. less than `0` means the max is an infinite distance
   * @default -1
   */
  get radius() {
    return this.uniforms.uWave[3];
  }
  set radius(t) {
    this.uniforms.uWave[3] = t;
  }
};
Np(z3, "DEFAULT_OPTIONS", {
  /** The `x` and `y` center coordinates to change the position of the center of the circle of effect. */
  center: { x: 0, y: 0 },
  /** The speed about the shockwave ripples out. The unit is `pixel-per-second` */
  speed: 500,
  /** The amplitude of the shockwave */
  amplitude: 30,
  /** The wavelength of the shockwave */
  wavelength: 160,
  /** The brightness of the shockwave */
  brightness: 1,
  /** The maximum radius of shockwave. less than `0` means the max is an infinite distance */
  radius: -1
});
var V3 = `precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform sampler2D uMapTexture;
uniform vec3 uColor;
uniform float uAlpha;
uniform vec2 uDimensions;

uniform vec4 uInputSize;

void main() {
    vec4 diffuseColor = texture(uTexture, vTextureCoord);
    vec2 lightCoord = (vTextureCoord * uInputSize.xy) / uDimensions;
    vec4 light = texture(uMapTexture, lightCoord);
    vec3 ambient = uColor.rgb * uAlpha;
    vec3 intensity = ambient + light.rgb;
    vec3 color = diffuseColor.rgb * intensity;
    finalColor = vec4(color, diffuseColor.a);
}
`, H3 = `struct SimpleLightmapUniforms {
  uColor: vec3<f32>,
  uAlpha: f32,
  uDimensions: vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> simpleLightmapUniforms : SimpleLightmapUniforms;
@group(1) @binding(1) var uMapTexture: texture_2d<f32>;
@group(1) @binding(2) var uMapSampler: sampler;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>,
) -> @location(0) vec4<f32> {
  let uColor = simpleLightmapUniforms.uColor;
  let uAlpha = simpleLightmapUniforms.uAlpha;
  let uDimensions = simpleLightmapUniforms.uDimensions;

  let diffuseColor: vec4<f32> = textureSample(uTexture, uSampler, uv);
  let lightCoord: vec2<f32> = (uv * gfu.uInputSize.xy) / simpleLightmapUniforms.uDimensions;
  let light: vec4<f32> = textureSample(uMapTexture, uMapSampler, lightCoord);
  let ambient: vec3<f32> = uColor * uAlpha;
  let intensity: vec3<f32> = ambient + light.rgb;
  let finalColor: vec3<f32> = diffuseColor.rgb * intensity;
  return vec4<f32>(finalColor, diffuseColor.a);
}`, Y3 = Object.defineProperty, W3 = (i, t, e) => t in i ? Y3(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, Ul = (i, t, e) => (W3(i, typeof t != "symbol" ? t + "" : t, e), e);
const j3 = class vv extends xt {
  /** @ignore */
  constructor(...t) {
    let e = t[0] ?? {};
    if (e instanceof W && (dt("6.0.0", "SimpleLightmapFilter constructor params are now options object. See params: { lightMap, color, alpha }"), e = { lightMap: e }, t[1] !== void 0 && (e.color = t[1]), t[2] !== void 0 && (e.alpha = t[2])), e = { ...vv.DEFAULT_OPTIONS, ...e }, !e.lightMap)
      throw Error("No light map texture source was provided to SimpleLightmapFilter");
    const s = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: H3,
        entryPoint: "mainFragment"
      }
    }), r = It.from({
      vertex: $t,
      fragment: V3,
      name: "simple-lightmap-filter"
    });
    super({
      gpuProgram: s,
      glProgram: r,
      resources: {
        simpleLightmapUniforms: {
          uColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uAlpha: { value: e.alpha, type: "f32" },
          uDimensions: { value: new Float32Array(2), type: "vec2<f32>" }
        },
        uMapTexture: e.lightMap.source,
        uMapSampler: e.lightMap.source.style
      }
    }), Ul(this, "uniforms"), Ul(this, "_color"), Ul(this, "_lightMap"), this.uniforms = this.resources.simpleLightmapUniforms.uniforms, this._color = new Pt(), this.color = e.color ?? 0, Object.assign(this, e);
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(t, e, s, r) {
    this.uniforms.uDimensions[0] = e.frame.width, this.uniforms.uDimensions[1] = e.frame.height, t.applyFilter(this, e, s, r);
  }
  /** A sprite where your lightmap is rendered */
  get lightMap() {
    return this._lightMap;
  }
  set lightMap(t) {
    this._lightMap = t, this.resources.uMapTexture = t.source, this.resources.uMapSampler = t.source.style;
  }
  /**
   * The color value of the ambient color
   * @example [1.0, 1.0, 1.0] = 0xffffff
   * @default 0x000000
   */
  get color() {
    return this._color.value;
  }
  set color(t) {
    this._color.setValue(t);
    const [e, s, r] = this._color.toArray();
    this.uniforms.uColor[0] = e, this.uniforms.uColor[1] = s, this.uniforms.uColor[2] = r;
  }
  /**
   * Coefficient for alpha multiplication
   * @default 1
   */
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(t) {
    this.uniforms.uAlpha = t;
  }
};
Ul(j3, "DEFAULT_OPTIONS", {
  lightMap: W.WHITE,
  color: 0,
  alpha: 1
});
var X3 = `in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uBlur;
uniform vec2 uStart;
uniform vec2 uEnd;
uniform vec2 uDelta;
uniform vec2 uDimensions;

float random(vec3 scale, float seed)
{
    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
}

void main(void)
{
    vec4 color = vec4(0.0);
    float total = 0.0;

    float blur = uBlur[0];
    float gradientBlur = uBlur[1];

    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);
    vec2 normal = normalize(vec2(uStart.y - uEnd.y, uEnd.x - uStart.x));
    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * uDimensions - uStart, normal)) / gradientBlur) * blur;

    for (float t = -30.0; t <= 30.0; t++)
    {
        float percent = (t + offset - 0.5) / 30.0;
        float weight = 1.0 - abs(percent);
        vec4 sample = texture(uTexture, vTextureCoord + uDelta / uDimensions * percent * radius);
        sample.rgb *= sample.a;
        color += sample * weight;
        total += weight;
    }

    color /= total;
    color.rgb /= color.a + 0.00001;

    finalColor = color;
}
`, K3 = `struct TiltShiftUniforms {
  uBlur: vec2<f32>,
  uStart: vec2<f32>,
  uEnd: vec2<f32>,
  uDelta: vec2<f32>,
  uDimensions: vec2<f32>,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> tiltShiftUniforms : TiltShiftUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let uBlur = tiltShiftUniforms.uBlur[0];
  let uBlurGradient = tiltShiftUniforms.uBlur[1];
  let uStart = tiltShiftUniforms.uStart;
  let uEnd = tiltShiftUniforms.uEnd;
  let uDelta = tiltShiftUniforms.uDelta;
  let uDimensions = tiltShiftUniforms.uDimensions;

  var color: vec4<f32> = vec4<f32>(0.0);
  var total: f32 = 0.0;

  let offset: f32 = random(position, vec3<f32>(12.9898, 78.233, 151.7182), 0.0);
  let normal: vec2<f32> = normalize(vec2<f32>(uStart.y - uEnd.y, uEnd.x - uStart.x));
  let radius: f32 = smoothstep(0.0, 1.0, abs(dot(uv * uDimensions - uStart, normal)) / uBlurGradient) * uBlur;

  for (var t: f32 = -30.0; t <= 30.0; t += 1.0)
  {
    var percent: f32 = (t + offset - 0.5) / 30.0;
    var weight: f32 = 1.0 - abs(percent);
    var sample: vec4<f32> = textureSample(uTexture, uSampler, uv + uDelta / uDimensions * percent * radius);
    sample = vec4<f32>(sample.xyz * sample.a, sample.a); // multiply sample.rgb with sample.a
    color += sample * weight;
    total += weight;
  }

  color /= total;
  color = vec4<f32>(color.xyz / (color.a + 0.00001), color.a); // divide color.rgb by color.a + 0.00001

  return color;
}


fn random(position: vec4<f32>, scale: vec3<f32>, seed: f32) -> f32
{
  return fract(sin(dot(position.xyz + seed, scale)) * 43758.5453 + seed);
}`, q3 = Object.defineProperty, $3 = (i, t, e) => t in i ? q3(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, Up = (i, t, e) => ($3(i, typeof t != "symbol" ? t + "" : t, e), e);
const Z3 = class Cv extends xt {
  constructor(t) {
    const { width: e, height: s } = DO.defaultOptions;
    t = {
      ...Cv.DEFAULT_OPTIONS,
      /** The position to start the effect at. */
      start: { x: 0, y: s / 2 },
      /** The position to end the effect at. */
      end: { x: e, y: s / 2 },
      ...t
    };
    const r = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: K3,
        entryPoint: "mainFragment"
      }
    }), n = It.from({
      vertex: $t,
      fragment: X3,
      name: "tilt-shift-axis-filter"
    });
    super({
      gpuProgram: r,
      glProgram: n,
      resources: {
        tiltShiftUniforms: {
          uBlur: {
            value: new Float32Array([
              t.blur,
              t.gradientBlur
            ]),
            type: "vec2<f32>"
          },
          uStart: { value: t.start, type: "vec2<f32>" },
          uEnd: { value: t.end, type: "vec2<f32>" },
          uDelta: { value: new Float32Array([0, 0]), type: "vec2<f32>" },
          uDimensions: { value: new Float32Array([e, s]), type: "vec2<f32>" }
        }
      }
    }), Up(this, "uniforms"), Up(this, "_tiltAxis"), this.uniforms = this.resources.tiltShiftUniforms.uniforms, this._tiltAxis = t.axis;
  }
  /**
   * Update the dimensions
   * @ignore
  */
  updateDimensions(t) {
    const { uDimensions: e } = this.uniforms;
    e[0] = t.frame.width, e[1] = t.frame.height;
  }
  /**
   * Updates the filter delta values.
   * @ignore
   */
  updateDelta() {
    if (this.uniforms.uDelta[0] = 0, this.uniforms.uDelta[1] = 0, this._tiltAxis === void 0)
      return;
    const t = this.uniforms.uEnd, e = this.uniforms.uStart, s = t.x - e.x, r = t.y - e.y, n = Math.sqrt(s * s + r * r), a = this._tiltAxis === "vertical";
    this.uniforms.uDelta[0] = a ? -r / n : s / n, this.uniforms.uDelta[1] = a ? s / n : r / n;
  }
};
Up(Z3, "DEFAULT_OPTIONS", {
  /** The strength of the blur. */
  blur: 100,
  /** The strength of the blur gradient */
  gradientBlur: 600
});
var Q3 = `precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uTwist;
uniform vec2 uOffset;
uniform vec4 uInputSize;

vec2 mapCoord( vec2 coord )
{
    coord *= uInputSize.xy;
    coord += uInputSize.zw;

    return coord;
}

vec2 unmapCoord( vec2 coord )
{
    coord -= uInputSize.zw;
    coord /= uInputSize.xy;

    return coord;
}

vec2 twist(vec2 coord)
{
    coord -= uOffset;

    float dist = length(coord);
    float uRadius = uTwist[0];
    float uAngle = uTwist[1];

    if (dist < uRadius)
    {
        float ratioDist = (uRadius - dist) / uRadius;
        float angleMod = ratioDist * ratioDist * uAngle;
        float s = sin(angleMod);
        float c = cos(angleMod);
        coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);
    }

    coord += uOffset;

    return coord;
}

void main(void)
{
    vec2 coord = mapCoord(vTextureCoord);
    coord = twist(coord);
    coord = unmapCoord(coord);
    finalColor = texture(uTexture, coord);
}
`, J3 = `struct TwistUniforms {
  uTwist:vec2<f32>,
  uOffset:vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> twistUniforms : TwistUniforms;

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
  return textureSample(uTexture, uSampler, unmapCoord(twist(mapCoord(uv))));
}

fn mapCoord(coord: vec2<f32> ) -> vec2<f32>
{
  var mappedCoord: vec2<f32> = coord;
  mappedCoord *= gfu.uInputSize.xy;
  mappedCoord += gfu.uOutputFrame.xy;
  return mappedCoord;
}

fn unmapCoord(coord: vec2<f32> ) -> vec2<f32>
{
  var mappedCoord: vec2<f32> = coord;
  mappedCoord -= gfu.uOutputFrame.xy;
  mappedCoord /= gfu.uInputSize.xy;
  return mappedCoord;
}

fn twist(coord: vec2<f32>) -> vec2<f32>
{
  var twistedCoord: vec2<f32> = coord;
  let uRadius = twistUniforms.uTwist[0];
  let uAngle = twistUniforms.uTwist[1];
  let uOffset = twistUniforms.uOffset;

  twistedCoord -= uOffset;
  
  let dist = length(twistedCoord);

  if (dist < uRadius)
  {
    let ratioDist: f32 = (uRadius - dist) / uRadius;
    let angleMod: f32 = ratioDist * ratioDist * uAngle;
    let s: f32 = sin(angleMod);
    let c: f32 = cos(angleMod);
    twistedCoord = vec2<f32>(twistedCoord.x * c - twistedCoord.y * s, twistedCoord.x * s + twistedCoord.y * c);
  }

  twistedCoord += uOffset;
  return twistedCoord;
}
`, tB = Object.defineProperty, eB = (i, t, e) => t in i ? tB(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, xv = (i, t, e) => (eB(i, typeof t != "symbol" ? t + "" : t, e), e);
const sB = class Mv extends xt {
  /**
   * @param options - Options for the TwistFilter constructor.
   */
  constructor(t) {
    t = { ...Mv.DEFAULT_OPTIONS, ...t };
    const e = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: J3,
        entryPoint: "mainFragment"
      }
    }), s = It.from({
      vertex: $t,
      fragment: Q3,
      name: "twist-filter"
    });
    super({
      gpuProgram: e,
      glProgram: s,
      resources: {
        twistUniforms: {
          uTwist: {
            value: [t.radius ?? 0, t.angle ?? 0],
            type: "vec2<f32>"
          },
          uOffset: {
            value: t.offset,
            type: "vec2<f32>"
          }
        }
      },
      ...t
    }), xv(this, "uniforms"), this.uniforms = this.resources.twistUniforms.uniforms;
  }
  /**
   * The radius of the twist
   * @default 200
   */
  get radius() {
    return this.uniforms.uTwist[0];
  }
  set radius(t) {
    this.uniforms.uTwist[0] = t;
  }
  /**
   * The angle of the twist
   * @default 4
   */
  get angle() {
    return this.uniforms.uTwist[1];
  }
  set angle(t) {
    this.uniforms.uTwist[1] = t;
  }
  /**
   * The `x` offset coordinate to change the position of the center of the circle of effect
   * @default 0
   */
  get offset() {
    return this.uniforms.uOffset;
  }
  set offset(t) {
    this.uniforms.uOffset = t;
  }
  /**
   * The `x` offset coordinate to change the position of the center of the circle of effect
   * @default 0
   */
  get offsetX() {
    return this.offset.x;
  }
  set offsetX(t) {
    this.offset.x = t;
  }
  /**
   * The `y` offset coordinate to change the position of the center of the circle of effect
   * @default 0
   */
  get offsetY() {
    return this.offset.y;
  }
  set offsetY(t) {
    this.offset.y = t;
  }
};
xv(sB, "DEFAULT_OPTIONS", {
  padding: 20,
  radius: 200,
  angle: 4,
  offset: { x: 0, y: 0 }
});
var iB = `precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform float uStrength;
uniform vec2 uCenter;
uniform vec2 uRadii;

uniform vec4 uInputSize;

const float MAX_KERNEL_SIZE = \${MAX_KERNEL_SIZE};

// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
highp float rand(vec2 co, float seed) {
    const highp float a = 12.9898, b = 78.233, c = 43758.5453;
    highp float dt = dot(co + seed, vec2(a, b)), sn = mod(dt, 3.14159);
    return fract(sin(sn) * c + seed);
}

void main() {
    float minGradient = uRadii[0] * 0.3;
    float innerRadius = (uRadii[0] + minGradient * 0.5) / uInputSize.x;

    float gradient = uRadii[1] * 0.3;
    float radius = (uRadii[1] - gradient * 0.5) / uInputSize.x;

    float countLimit = MAX_KERNEL_SIZE;

    vec2 dir = vec2(uCenter.xy / uInputSize.xy - vTextureCoord);
    float dist = length(vec2(dir.x, dir.y * uInputSize.y / uInputSize.x));

    float strength = uStrength;

    float delta = 0.0;
    float gap;
    if (dist < innerRadius) {
        delta = innerRadius - dist;
        gap = minGradient;
    } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity
        delta = dist - radius;
        gap = gradient;
    }

    if (delta > 0.0) {
        float normalCount = gap / uInputSize.x;
        delta = (normalCount - delta) / normalCount;
        countLimit *= delta;
        strength *= delta;
        if (countLimit < 1.0)
        {
            gl_FragColor = texture(uTexture, vTextureCoord);
            return;
        }
    }

    // randomize the lookup values to hide the fixed number of samples
    float offset = rand(vTextureCoord, 0.0);

    float total = 0.0;
    vec4 color = vec4(0.0);

    dir *= strength;

    for (float t = 0.0; t < MAX_KERNEL_SIZE; t++) {
        float percent = (t + offset) / MAX_KERNEL_SIZE;
        float weight = 4.0 * (percent - percent * percent);
        vec2 p = vTextureCoord + dir * percent;
        vec4 sample = texture(uTexture, p);

        // switch to pre-multiplied alpha to correctly blur transparent images
        // sample.rgb *= sample.a;

        color += sample * weight;
        total += weight;

        if (t > countLimit){
            break;
        }
    }

    color /= total;
    // switch back from pre-multiplied alpha
    // color.rgb /= color.a + 0.00001;

    gl_FragColor = color;
}
`, rB = `struct ZoomBlurUniforms {
    uStrength:f32,
    uCenter:vec2<f32>,
    uRadii:vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> zoomBlurUniforms : ZoomBlurUniforms;

@fragment
fn mainFragment(
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let uStrength = zoomBlurUniforms.uStrength;
  let uCenter = zoomBlurUniforms.uCenter;
  let uRadii = zoomBlurUniforms.uRadii;

  let minGradient: f32 = uRadii[0] * 0.3;
  let innerRadius: f32 = (uRadii[0] + minGradient * 0.5) / gfu.uInputSize.x;

  let gradient: f32 = uRadii[1] * 0.3;
  let radius: f32 = (uRadii[1] - gradient * 0.5) / gfu.uInputSize.x;

  let MAX_KERNEL_SIZE: f32 = \${MAX_KERNEL_SIZE};

  var countLimit: f32 = MAX_KERNEL_SIZE;

  var dir: vec2<f32> = vec2<f32>(uCenter / gfu.uInputSize.xy - uv);
  let dist: f32 = length(vec2<f32>(dir.x, dir.y * gfu.uInputSize.y / gfu.uInputSize.x));

  var strength: f32 = uStrength;

  var delta: f32 = 0.0;
  var gap: f32;

  if (dist < innerRadius) {
      delta = innerRadius - dist;
      gap = minGradient;
  } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity
      delta = dist - radius;
      gap = gradient;
  }

  var returnColorOnly: bool = false;

  if (delta > 0.0) {
    let normalCount: f32 = gap / gfu.uInputSize.x;
    delta = (normalCount - delta) / normalCount;
    countLimit *= delta;
    strength *= delta;
    
    if (countLimit < 1.0)
    {
      returnColorOnly = true;;
    }
  }

  // randomize the lookup values to hide the fixed number of samples
  let offset: f32 = rand(uv, 0.0);

  var total: f32 = 0.0;
  var color: vec4<f32> = vec4<f32>(0.);

  dir *= strength;

  for (var t = 0.0; t < MAX_KERNEL_SIZE; t += 1.0) {
    let percent: f32 = (t + offset) / MAX_KERNEL_SIZE;
    let weight: f32 = 4.0 * (percent - percent * percent);
    let p: vec2<f32> = uv + dir * percent;
    let sample: vec4<f32> = textureSample(uTexture, uSampler, p);
    
    if (t < countLimit)
    {
      color += sample * weight;
      total += weight;
    }
  }

  color /= total;

  return select(color, textureSample(uTexture, uSampler, uv), returnColorOnly);
}

fn modulo(x: f32, y: f32) -> f32
{
  return x - y * floor(x/y);
}

// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
fn rand(co: vec2<f32>, seed: f32) -> f32
{
  let a: f32 = 12.9898;
  let b: f32 = 78.233;
  let c: f32 = 43758.5453;
  let dt: f32 = dot(co + seed, vec2<f32>(a, b));
  let sn: f32 = modulo(dt, 3.14159);
  return fract(sin(sn) * c + seed);
}`, nB = Object.defineProperty, aB = (i, t, e) => t in i ? nB(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, bv = (i, t, e) => (aB(i, typeof t != "symbol" ? t + "" : t, e), e);
const oB = class Pv extends xt {
  /**
   * @param options - Options for the ZoomBlurFilter constructor.
   */
  constructor(t) {
    t = { ...Pv.DEFAULT_OPTIONS, ...t };
    const e = t.maxKernelSize ?? 32, s = Ot.from({
      vertex: {
        source: Zt,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: rB.replace("${MAX_KERNEL_SIZE}", e.toFixed(1)),
        entryPoint: "mainFragment"
      }
    }), r = It.from({
      vertex: $t,
      fragment: iB.replace("${MAX_KERNEL_SIZE}", e.toFixed(1)),
      name: "zoom-blur-filter"
    });
    super({
      gpuProgram: s,
      glProgram: r,
      resources: {
        zoomBlurUniforms: {
          uStrength: { value: t.strength, type: "f32" },
          uCenter: { value: t.center, type: "vec2<f32>" },
          uRadii: { value: new Float32Array(2), type: "vec2<f32>" }
        }
      }
    }), bv(this, "uniforms"), this.uniforms = this.resources.zoomBlurUniforms.uniforms, Object.assign(this, t);
  }
  /**
   * Sets the strength of the zoom blur effect
   * @default 0.1
   */
  get strength() {
    return this.uniforms.uStrength;
  }
  set strength(t) {
    this.uniforms.uStrength = t;
  }
  /**
   * The center of the zoom
   * @default [0,0]
   */
  get center() {
    return this.uniforms.uCenter;
  }
  set center(t) {
    Array.isArray(t) && (t = { x: t[0], y: t[1] }), this.uniforms.uCenter = t;
  }
  /**
   * Sets the center of the effect in normalized screen coords on the `x` axis
   * @default 0
   */
  get centerX() {
    return this.uniforms.uCenter.x;
  }
  set centerX(t) {
    this.uniforms.uCenter.x = t;
  }
  /**
   * Sets the center of the effect in normalized screen coords on the `y` axis
   * @default 0
   */
  get centerY() {
    return this.uniforms.uCenter.y;
  }
  set centerY(t) {
    this.uniforms.uCenter.y = t;
  }
  /**
   * The inner radius of zoom. The part in inner circle won't apply zoom blur effect
   * @default 0
   */
  get innerRadius() {
    return this.uniforms.uRadii[0];
  }
  set innerRadius(t) {
    this.uniforms.uRadii[0] = t;
  }
  /**
   * Outer radius of the effect. less than `0` equates to infinity
   * @default -1
   */
  get radius() {
    return this.uniforms.uRadii[1];
  }
  set radius(t) {
    this.uniforms.uRadii[1] = t < 0 || t === 1 / 0 ? -1 : t;
  }
};
bv(oB, "DEFAULT_OPTIONS", {
  strength: 0.1,
  center: { x: 0, y: 0 },
  innerRadius: 0,
  radius: -1,
  maxKernelSize: 32
});
class hB {
  constructor(t) {
    this._ink = t.ink;
    let e = t.foreground, s = t.background;
    e = e.replace("#", ""), s = s.replace("#", ""), this._foreGround = parseInt(e, 16), this._backGround = parseInt(s, 16), this._colorTransform = null, this._rgb = parseInt(e, 16), this._r = this._rgb >> 16 & 255, this._g = this._rgb >> 8 & 255, this._b = this._rgb >> 0 & 255, this._redMultiplier = this._r / 255 * 1, this._greenMultiplier = this._g / 255 * 1, this._blueMultiplier = this._b / 255 * 1, this._alphaMultiplier = 1, this._paletteIsGrayscale = !0, this._ink === 37 && (this._alphaMultiplier = 0.5, this._paletteIsGrayscale = !1), this._colorTransform = new Xy({ red: this._r / 255, green: this._g / 255, blue: this._b / 255, alpha: this._alphaMultiplier }), this._colorMap = this.generatePaletteMapForGrayscale(this._backGround, this._foreGround);
  }
  get ink() {
    return this._ink;
  }
  get colorTransform() {
    return this._colorTransform;
  }
  get reds() {
    return this._colorMap.get("reds");
  }
  get greens() {
    return this._colorMap.get("greens");
  }
  get blues() {
    return this._colorMap.get("blues");
  }
  get alphas() {
    return this._colorMap.get("alphas");
  }
  get paletteIsGrayscale() {
    return this._paletteIsGrayscale;
  }
  generatePaletteMapForGrayscale(t, e) {
    const s = t >> 24 & 255, r = t >> 16 & 255, n = t >> 8 & 255, a = t & 255, o = e >> 24 & 255, h = e >> 16 & 255, u = e >> 8 & 255, c = e & 255, l = (o - s) / 255, _ = (h - r) / 255, d = (u - n) / 255, f = (c - a) / 255, p = /* @__PURE__ */ new Map(), g = [];
    let m = s, O = r, y = n, C = a;
    for (let b = 0; b < 256; b++) {
      m += l, O += _, y += d, C += f;
      const D = Math.max(0, Math.min(255, Math.round(m))), P = Math.max(0, Math.min(255, Math.round(O))), F = Math.max(0, Math.min(255, Math.round(y))), M = Math.max(0, Math.min(255, Math.round(C))), U = D << 24 | P << 16 | F << 8 | M;
      g.push(U);
    }
    return p.set("alphas", g), p.set("reds", g), p.set("greens", g), p.set("blues", g), p;
  }
}
class uB {
  constructor(t) {
    this._offset = t.offset;
  }
  get offset() {
    return this._offset;
  }
}
class lB {
  constructor(t, e) {
    this._animation = t, this._id = e.id, this._ink = e.ink, this._member = e.member, this._hasStaticY = !!e.staticY, this._hasDirections = !!e.directions, this._dx = [], this._dy = [], this._dz = [];
    const s = e.directionList;
    if (s && s.length)
      for (const r of s) {
        const n = r.id;
        n !== void 0 && (this._dx[n] = r.dx || 0, this._dy[n] = r.dy || 0, this._dz[n] = r.dz || 0);
      }
  }
  getDirectionOffsetX(t) {
    return t < this._dx.length ? this._dx[t] : 0;
  }
  getDirectionOffsetY(t) {
    return t < this._dy.length ? this._dy[t] : 0;
  }
  getDirectionOffsetZ(t) {
    return t < this._dz.length ? this._dz[t] : 0;
  }
  get animation() {
    return this._animation;
  }
  get id() {
    return this._id;
  }
  get ink() {
    return this._ink;
  }
  get member() {
    return this._member;
  }
  get hasDirections() {
    return this._hasDirections;
  }
  get hasStaticY() {
    return this._hasStaticY;
  }
}
const lo = class lo {
  constructor(t, e) {
    if (this._id = e.name, this._description = this._id, this._frames = [], this._spriteData = null, this._avatarData = null, this._directionData = null, this._removeData = null, this._addData = null, this._overriddenActions = null, this._overrideFrames = null, this._resetOnToggle = e.resetOnToggle || !1, e.sprites && e.sprites.length) {
      this._spriteData = [];
      for (const s of e.sprites) this._spriteData.push(new lB(this, s));
    }
    if (e.avatars && e.avatars.length && (this._avatarData = new hB(e.avatars[0])), e.directions && e.directions.length && (this._directionData = new uB(e.directions[0])), e.removes && e.removes.length) {
      this._removeData = [];
      for (const s of e.removes) this._removeData.push(s.id);
    }
    if (e.adds && e.adds.length) {
      this._addData = [];
      for (const s of e.adds) this._addData.push(new JF(s));
    }
    if (e.overrides && e.overrides.length) {
      this._overrideFrames = /* @__PURE__ */ new Map(), this._overriddenActions = /* @__PURE__ */ new Map();
      for (const s of e.overrides) {
        const r = s.name, n = s.override;
        this._overriddenActions.set(n, r);
        const a = [];
        this.parseFrames(a, s.frames, t), this._overrideFrames.set(r, a);
      }
    }
    this.parseFrames(this._frames, e.frames, t);
  }
  parseFrames(t, e, s) {
    if (!(!e || !e.length))
      for (const r of e) {
        let n = 1;
        r.repeats && r.repeats > 1 && (n = r.repeats);
        let a = 0;
        for (; a < n; ) {
          const o = [];
          if (r.bodyparts && r.bodyparts.length)
            for (const h of r.bodyparts) {
              const u = s.getActionDefinition(h.action), c = new ui(h, ui.BODYPART, u);
              o.push(c);
            }
          if (r.fxs && r.fxs.length)
            for (const h of r.fxs) {
              const u = s.getActionDefinition(h.action), c = new ui(h, ui.FX, u);
              o.push(c);
            }
          t.push(o), a++;
        }
      }
  }
  frameCount(t = null) {
    if (!t) return this._frames.length;
    if (this._overrideFrames) {
      const e = this._overrideFrames.get(t);
      if (e) return e.length;
    }
    return 0;
  }
  hasOverriddenActions() {
    return this._overriddenActions ? this._overriddenActions.size > 0 : !1;
  }
  overriddenActionNames() {
    if (!this._overriddenActions) return null;
    const t = [];
    for (const e of this._overriddenActions.keys()) t.push(e);
    return t;
  }
  overridingAction(t) {
    return this._overriddenActions ? this._overriddenActions.get(t) : null;
  }
  getFrame(t, e = null) {
    t < 0 && (t = 0);
    let s = [];
    if (!e)
      this._frames.length > 0 && (s = this._frames[t % this._frames.length]);
    else {
      const r = this._overrideFrames.get(e);
      r && r.length > 0 && (s = r[t % r.length]);
    }
    return s;
  }
  getAnimatedBodyPartIds(t, e = null) {
    const s = [];
    for (const r of this.getFrame(t, e))
      if (r.type === ui.BODYPART)
        s.push(r.id);
      else if (r.type === ui.FX && this._addData && this._addData.length)
        for (const n of this._addData)
          n.id === r.id && s.push(n.align);
    return s;
  }
  getLayerData(t, e, s = null) {
    for (const r of this.getFrame(t, s)) {
      if (r.id === e) return r;
      if (r.type === ui.FX && this._addData && this._addData.length) {
        for (const n of this._addData)
          if (n.align === e && n.id === r.id) return r;
      }
    }
    return null;
  }
  hasAvatarData() {
    return this._avatarData !== null;
  }
  hasDirectionData() {
    return this._directionData !== null;
  }
  hasAddData() {
    return this._addData !== null;
  }
  getAddData(t) {
    if (this._addData) {
      for (const e of this._addData)
        if (e.id === t) return e;
    }
    return null;
  }
  get id() {
    return this._id;
  }
  get spriteData() {
    return this._spriteData || lo.EMPTY_ARRAY;
  }
  get avatarData() {
    return this._avatarData;
  }
  get directionData() {
    return this._directionData;
  }
  get removeData() {
    return this._removeData || lo.EMPTY_ARRAY;
  }
  get addData() {
    return this._addData || lo.EMPTY_ARRAY;
  }
  toString() {
    return this._description;
  }
  get resetOnToggle() {
    return this._resetOnToggle;
  }
};
lo.EMPTY_ARRAY = [];
let Dp = lo;
class cB {
  constructor() {
    this._animations = /* @__PURE__ */ new Map();
  }
  registerAnimation(t, e) {
    if (!e) return !1;
    const s = e[Object.keys(e)[0]], r = new Dp(t, s);
    return this._animations.set(s.name, r), !0;
  }
  getAnimation(t) {
    const e = this._animations.get(t);
    return e || null;
  }
  getLayerData(t, e, s) {
    const r = this.getAnimation(t);
    return r ? r.getLayerData(e, s) : null;
  }
  get animations() {
    return this._animations;
  }
}
class _B {
  constructor(t) {
    this._partList = t, this._images = /* @__PURE__ */ new Map();
  }
  dispose() {
    for (const t of this._images.values()) t && t.dispose();
    this._images = null;
  }
  getPartList() {
    return this._partList;
  }
  getImageContainer(t) {
    const e = this._images.get(this.getCacheKey(t));
    return e || null;
  }
  updateImageContainer(t, e) {
    const s = this.getCacheKey(e), r = this._images.get(s);
    r && r.dispose(), this._images.set(s, t);
  }
  getCacheKey(t) {
    let e = "";
    for (const s of this._partList) e += s.getCacheableKey(t) + "/";
    return e;
  }
  debugInfo(t) {
  }
}
class dR {
  constructor(t, e, s, r, n, a = null) {
    this._texture = t, this._container = a, this._rect = e, this._regPoint = s, this._flipH = r, this._colorTransform = n, r && (this._regPoint.x = -this._regPoint.x + e.width);
  }
  dispose() {
    this._texture = null, this._regPoint = null, this._colorTransform = null;
  }
  get texture() {
    return this._texture;
  }
  get container() {
    return this._container;
  }
  get rect() {
    return this._rect;
  }
  get regPoint() {
    return this._regPoint;
  }
  get flipH() {
    return this._flipH;
  }
  get colorTransform() {
    return this._colorTransform;
  }
  get offsetRect() {
    return new Kt(-this._regPoint.x, -this._regPoint.y, this._rect.width, this._rect.height);
  }
}
const GI = class GI {
  constructor(t, e, s, r) {
    this._structure = t, this._avatar = e, this._assets = s, this._scale = r, this._cache = /* @__PURE__ */ new Map(), this._canvas = null, this._disposed = !1, this._unionImages = [], this._matrix = new ot();
  }
  dispose() {
    if (!this._disposed) {
      if (this._structure = null, this._avatar = null, this._assets = null, this._canvas = null, this._disposed = !0, this._cache) {
        for (const t of this._cache.values())
          t && t.dispose();
        this._cache = null;
      }
      if (this._unionImages) {
        for (const t of this._unionImages)
          t && t.dispose();
        this._unionImages = [];
      }
    }
  }
  disposeInactiveActions(t = 6e4) {
    const e = Nt();
    if (this._cache)
      for (const s of this._cache.values())
        s && s.disposeActions(t, e);
  }
  resetBodyPartCache(t) {
    if (this._cache)
      for (const e of this._cache.values())
        e && e.setAction(t, 0);
  }
  setDirection(t, e) {
    const s = this._structure.getBodyPartsUnordered(t);
    if (s)
      for (const r of s) {
        const n = this.getBodyPartCache(r);
        n && n.setDirection(e);
      }
  }
  setAction(t, e) {
    const s = this._structure.getActiveBodyPartIds(t, this._avatar);
    for (const r of s) {
      const n = this.getBodyPartCache(r);
      n && n.setAction(t, e);
    }
  }
  setGeometryType(t) {
    if (this._geometryType !== t) {
      if (this._geometryType === xr.SITTING && t === xr.VERTICAL || this._geometryType === xr.VERTICAL && t === xr.SITTING || this._geometryType === xr.SNOWWARS_HORIZONTAL && (t = xr.SNOWWARS_HORIZONTAL)) {
        this._geometryType = t, this._canvas = null;
        return;
      }
      this.disposeInactiveActions(0), this._geometryType = t, this._canvas = null;
    }
  }
  getImageContainer(t, e, s = !1) {
    const r = this.getBodyPartCache(t) || new cR();
    this._cache.set(t, r);
    let n = r.getDirection(), a = r.getAction(), o = e;
    a.definition.startFromFrameZero && (o -= a.startFrame);
    let h = a, u = [], c = /* @__PURE__ */ new Map();
    const l = new st();
    if (a.definition.isAnimation) {
      let g = n;
      const m = this._structure.getAnimation(a.definition.state + "." + a.actionParameter), O = e - a.startFrame;
      if (m) {
        const y = m.getLayerData(O, t, a.overridingAction);
        y && (g = (n + y.dd + 8) % 8, l.x = this._scale === ci.LARGE ? y.dx : y.dx / 2, l.y = this._scale === ci.LARGE ? y.dy : y.dy / 2, o = y.animationFrame, y.action && (a = y.action), y.type === ui.BODYPART ? (y.action && (h = y.action), n = g) : y.type === ui.FX && (n = g), c = y.items), u = m.removeData;
      }
    }
    let _ = r.getActionCache(h);
    (!_ || s) && (_ = new ZF(), r.updateActionCache(h, _));
    let d = _.getDirectionCache(n);
    if (!d || s) {
      const g = this._structure.getParts(t, this._avatar.getFigure(), h, this._geometryType, n, u, this._avatar, c);
      d = new _B(g), _.updateDirectionCache(n, d);
    }
    let f = d.getImageContainer(o);
    if (!f || s) {
      const g = d.getPartList();
      if (f = this.renderBodyPart(n, g, o, a), f && !s)
        f.isCacheable && d.updateImageContainer(f, o);
      else
        return null;
    }
    const p = this._structure.getFrameBodyPartOffset(h, n, o, t);
    return l.x += p.x, l.y += p.y, f.offset = l, f;
  }
  getBodyPartCache(t) {
    let e = this._cache.get(t);
    return e || (e = new cR(), this._cache.set(t, e)), e;
  }
  renderBodyPart(t, e, s, r) {
    if (!e || !e.length || !this._canvas && (this._canvas = this._structure.getCanvas(this._scale, this._geometryType), !this._canvas))
      return null;
    const n = Jr.DIRECTION_IS_FLIPPED[t] || !1;
    let a = r.definition.assetPartDefinition, o = !0, h = e.length - 1;
    for (; h >= 0; ) {
      const d = e[h];
      let f = 16777215;
      if (!(t == 7 && (d.partType === "fc" || d.partType === "ey")) && !(d.partType === "ri" && !d.partId)) {
        const p = d.partId, g = d.getFrameDefinition(s);
        let m = d.partType, O = 0;
        g ? (O = g.number, g.assetPartDefinition && g.assetPartDefinition !== "" && (a = g.assetPartDefinition)) : O = d.getFrameIndex(s);
        let y = t, C = !1;
        n && (a === "wav" && (m === as.LEFT_HAND || m === as.LEFT_SLEEVE || m === as.LEFT_COAT_SLEEVE) || a === "drk" && (m === as.RIGHT_HAND || m === as.RIGHT_SLEEVE || m === as.RIGHT_COAT_SLEEVE) || a === "blw" && m === as.RIGHT_HAND || a === "sig" && m === as.LEFT_HAND || a === "respect" && m === as.LEFT_HAND || m === as.RIGHT_HAND_ITEM || m === as.LEFT_HAND_ITEM || m === as.CHEST_PRINT ? C = !0 : (t === 4 ? y = 2 : t === 5 ? y = 1 : t === 6 && (y = 0), d.flippedPartType !== m && (m = d.flippedPartType)));
        let b = this._scale + "_" + a + "_" + m + "_" + p + "_" + y + "_" + O, D = this._assets.getAsset(b);
        if (D || (b = this._scale + "_std_" + m + "_" + p + "_" + y + "_0", D = this._assets.getAsset(b)), D) {
          const P = D.texture;
          if (!P || !P.source)
            o = !1;
          else {
            d.isColorable && d.color && (f = d.color.rgb);
            const F = new st(-D.x, -D.y);
            C && (F.x = F.x + (this._scale === ci.LARGE ? 65 : 31)), this._unionImages.push(new dR(P, D.rectangle, F, C, f));
          }
        }
      }
      h--;
    }
    if (!this._unionImages.length) return null;
    const u = this.createUnionImage(this._unionImages, n), c = this._scale === ci.LARGE ? this._canvas.height - 16 : this._canvas.height - 8, l = new st(-u.regPoint.x, c - u.regPoint.y);
    n && a !== "lay" && (l.x = l.x + (this._scale === ci.LARGE ? 67 : 31));
    let _ = this._unionImages.length - 1;
    for (; _ >= 0; ) {
      const d = this._unionImages.pop();
      d && d.dispose(), _--;
    }
    return new QF(u.container, l, o);
  }
  convertColorToHex(t) {
    let e = (t * 255).toString(16);
    return e.length < 2 && (e = "0" + e), e;
  }
  createUnionImage(t, e) {
    const s = new Kt();
    for (const o of t) o && s.enlarge(o.offsetRect);
    const r = new st(-s.x, -s.y), n = new Qt(), a = new Ft(W.EMPTY);
    a.width = s.width, a.height = s.height, n.addChild(a);
    for (const o of t) {
      if (!o) continue;
      const h = r.clone();
      h.x -= o.regPoint.x, h.y -= o.regPoint.y, e && (h.x = n.width - (h.x + o.rect.width)), e != o.flipH ? (this._matrix.a = -1, this._matrix.tx = o.rect.x + o.rect.width + h.x, this._matrix.ty = h.y - o.rect.y) : (this._matrix.a = 1, this._matrix.tx = h.x - o.rect.x, this._matrix.ty = h.y - o.rect.y);
      const u = new Ft(o.texture);
      u.tint = o.colorTransform, u.setFromMatrix(this._matrix), n.addChild(u);
    }
    return new dR(null, n.getLocalBounds().rectangle, r, e, null, n);
  }
};
GI.DEFAULT_MAX_CACHE_STORAGE_TIME_MS = 6e4;
let Lp = GI;
const zr = class zr {
  constructor(t, e, s, r, n, a = null) {
    this._structure = t, this._assets = e, this._figure = s, this._scale = r, this._effectManager = n, this._effectListener = a, this._disposed = !1, this._canvasOffsets = [], this._actions = [], this._activeTexture = null, this._defaultAction = null, this._frameCounter = 0, this._directionOffset = 0, this._changes = !0, this._isAnimating = !1, this._animationHasResetOnToggle = !1, this._actionsSorted = !1, this._lastActionsString = null, this._currentActionsString = null, this._effectIdInUse = -1, this._animationFrameCount = -1, this._cachedBodyParts = [], this._cachedBodyPartsDirection = -1, this._cachedBodyPartsGeometryType = null, this._cachedBodyPartsAvatarSet = null, this._figure || (this._figure = new vl("hr-893-45.hd-180-2.ch-210-66.lg-270-82.sh-300-91.wa-2007-.ri-1-")), this._scale || (this._scale = ci.LARGE), this._cache = new Lp(this._structure, this, this._assets, this._scale), this.setDirection(zr.DEFAULT_AVATAR_SET, zr.DEFAULT_DIRECTION), this._defaultAction = new Op(et.POSTURE_STAND), this._defaultAction.definition = this._structure.getActionDefinition(zr.DEFAULT_ACTION), this.resetActions(), this._animationFrameCount = 0;
  }
  dispose() {
    this._disposed || (this._structure = null, this._assets = null, this._mainAction = null, this._figure = null, this._avatarSpriteData = null, this._actions = null, this._activeTexture && (on().putTexture(this._activeTexture), this._activeTexture = null), this._cache && (this._cache.dispose(), this._cache = null), this._canvasOffsets = null, this._disposed = !0);
  }
  get disposed() {
    return this._disposed;
  }
  getFigure() {
    return this._figure;
  }
  getScale() {
    return this._scale;
  }
  getPartColor(t) {
    return this._structure.getPartColor(this._figure, t);
  }
  setDirection(t, e) {
    e += this._directionOffset, e < Jr.MIN_DIRECTION ? e = Jr.MAX_DIRECTION + (e + 1) : e > Jr.MAX_DIRECTION && (e -= Jr.MAX_DIRECTION + 1), this._structure.isMainAvatarSet(t) && (this._mainDirection = e), (t === gs.HEAD || t === gs.FULL) && (t === gs.HEAD && this.isHeadTurnPreventedByAction() && (e = this._mainDirection), this._headDirection = e), this._cache.setDirection(t, e), this._changes = !0;
  }
  setDirectionAngle(t, e) {
    this.setDirection(t, Math.floor(e / 45));
  }
  getSprites() {
    return this._sprites;
  }
  getCanvasOffsets() {
    return this._canvasOffsets;
  }
  getLayerData(t) {
    return this._structure.getBodyPartData(t.animation.id, this._frameCounter, t.id);
  }
  updateAnimationByFrames(t = 1) {
    this._frameCounter += t, this._changes = !0;
  }
  resetAnimationFrameCounter() {
    this._frameCounter = 0, this._changes = !0;
  }
  getBodyParts(t, e, s) {
    return (s !== this._cachedBodyPartsDirection || e !== this._cachedBodyPartsGeometryType || t !== this._cachedBodyPartsAvatarSet) && (this._cachedBodyPartsDirection = s, this._cachedBodyPartsGeometryType = e, this._cachedBodyPartsAvatarSet = t, this._cachedBodyParts = this._structure.getBodyParts(t, e, s)), this._cachedBodyParts;
  }
  buildAvatarContainer(t, e) {
    const s = this.getBodyParts(e, this._mainAction.definition.geometryType, this._mainDirection), r = new Qt();
    let n = s.length - 1;
    for (; n >= 0; ) {
      const a = s[n], o = this._cache.getImageContainer(a, this._frameCounter);
      if (o) {
        const h = o.image;
        if (h) {
          const u = new Qt();
          u.addChild(h);
          const c = o.regPoint.clone();
          c.x += t.offset.x, c.y += t.offset.y, c.x += t.regPoint.x, c.y += t.regPoint.y, u.x = Math.floor(c.x), u.y = Math.floor(c.y), r.addChild(u);
        }
      }
      n--;
    }
    return r.filters = [], this._avatarSpriteData && (this._avatarSpriteData.colorTransform && (r.filters = [...Array.from(r.filters), this._avatarSpriteData.colorTransform]), this._avatarSpriteData.paletteIsGrayscale && (r.filters = [...Array.from(r.filters), oF(), new Kg({
      palette: this._avatarSpriteData.reds,
      channel: 0
    })], console.log(r.filters))), r;
  }
  processAsTexture(t, e = !1) {
    if (!this._changes) return this._activeTexture;
    if (!this._mainAction) return null;
    this._actionsSorted || this.endActionAppends();
    const s = this._structure.getCanvas(this._scale, this._mainAction.definition.geometryType);
    if (!s || (this._activeTexture && (this._activeTexture.width !== s.width || this._activeTexture.height !== s.height) && (on().putTexture(this._activeTexture), this._activeTexture = null), this._activeTexture || (this._activeTexture = on().getTexture(s.width, s.height)), !this._activeTexture)) return null;
    const r = this.buildAvatarContainer(s, t);
    return ma().render({
      target: this._activeTexture,
      container: r,
      clear: !0
    }), r.destroy(), this._activeTexture.source.hitMap = null, this._changes = !1, this._activeTexture;
  }
  processAsImageUrl(t, e = 1) {
    const s = this.processAsTexture(t, !1);
    return ma().texture.generateCanvas(s).toDataURL("image/png");
  }
  processAsContainer(t) {
    if (!this._mainAction) return null;
    this._actionsSorted || this.endActionAppends();
    const e = this._structure.getCanvas(this._scale, this._mainAction.definition.geometryType);
    return e ? this.buildAvatarContainer(e, t) : null;
  }
  // TODO this needs to be added still
  applyPalette(t, e = [], s = [], r = []) {
    const n = le.generateCanvas(t), a = n.getContext("2d"), o = a.getImageData(0, 0, n.width, n.height), h = o.data;
    for (let c = 0; c < h.length; c += 4) {
      if (e.length == 256) {
        let l = e[h[c]];
        l === void 0 && (l = 0), h[c] = l >> 16 & 255, h[c + 1] = l >> 8 & 255, h[c + 2] = l & 255;
      }
      if (s.length == 256) {
        let l = s[h[c + 1]];
        l === void 0 && (l = 0), h[c] = l >> 16 & 255, h[c + 1] = l >> 8 & 255, h[c + 2] = l & 255;
      }
      if (r.length == 256) {
        let l = s[h[c + 2]];
        l === void 0 && (l = 0), h[c] = l >> 16 & 255, h[c + 1] = l >> 8 & 255, h[c + 2] = l & 255;
      }
    }
    a.putImageData(o, 0, 0);
    const u = new Ft(W.from(n));
    return le.writeToTexture(u, t, !0), t;
  }
  getDirection() {
    return this._mainDirection;
  }
  initActionAppends() {
    this._actions = [], this._actionsSorted = !1, this._currentActionsString = "";
  }
  endActionAppends() {
    if (this.sortActions()) {
      for (const t of this._sortedActions)
        t.actionType === et.EFFECT && (this._effectManager.isAvatarEffectReady(parseInt(t.actionParameter)) || this._effectManager.downloadAvatarEffect(parseInt(t.actionParameter), this));
      this.resetActions(), this.setActionsToParts();
    }
  }
  appendAction(t, ...e) {
    let s = "";
    switch (this._actionsSorted = !1, e && e.length > 0 && (s = e[0]), s != null && (s = s.toString()), t) {
      case et.POSTURE:
        switch (s) {
          case et.POSTURE_LAY:
          case et.POSTURE_WALK:
          case et.POSTURE_STAND:
          case et.POSTURE_SWIM:
          case et.POSTURE_FLOAT:
          case et.POSTURE_SIT:
          case et.SNOWWAR_RUN:
          case et.SNOWWAR_DIE_FRONT:
          case et.SNOWWAR_DIE_BACK:
          case et.SNOWWAR_PICK:
          case et.SNOWWAR_THROW:
            (s === et.POSTURE_LAY || s === et.POSTURE_LAY || s === et.POSTURE_LAY) && s === et.POSTURE_LAY && (this._mainDirection == 0 ? this.setDirection(gs.FULL, 4) : this.setDirection(gs.FULL, 2)), this.addActionData(s);
            break;
        }
        break;
      case et.GESTURE:
        switch (s) {
          case et.GESTURE_AGGRAVATED:
          case et.GESTURE_SAD:
          case et.GESTURE_SMILE:
          case et.GESTURE_SURPRISED:
            this.addActionData(s);
            break;
        }
        break;
      case et.EFFECT:
      case et.DANCE:
      case et.TALK:
      case et.EXPRESSION_WAVE:
      case et.SLEEP:
      case et.SIGN:
      case et.EXPRESSION_RESPECT:
      case et.EXPRESSION_BLOW_A_KISS:
      case et.EXPRESSION_LAUGH:
      case et.EXPRESSION_CRY:
      case et.EXPRESSION_IDLE:
      case et.EXPRESSION_SNOWBOARD_OLLIE:
      case et.EXPRESSION_SNOWBORD_360:
      case et.EXPRESSION_RIDE_JUMP:
        et.EFFECT, this.addActionData(t, s);
        break;
      case et.CARRY_OBJECT:
      case et.USE_OBJECT: {
        const r = this._structure.getActionDefinitionWithState(t);
        r && (s = r.getParameterValue(s)), this.addActionData(t, s);
        break;
      }
    }
    return !0;
  }
  addActionData(t, e = "") {
    this._actions || (this._actions = []), this._actions.some(
      (r) => r.actionType === t && r.actionParameter === e
    ) || this._actions.push(new Op(t, e, this._frameCounter));
  }
  isAnimating() {
    return this._isAnimating || this._animationFrameCount > 1;
  }
  resetActions() {
    return this._animationHasResetOnToggle = !1, this._isAnimating = !1, this._sprites = [], this._avatarSpriteData = null, this._directionOffset = 0, this._structure.removeDynamicItems(this), this._mainAction = this._defaultAction, this._mainAction.definition = this._defaultAction.definition, this.resetBodyPartCache(this._defaultAction), !0;
  }
  isHeadTurnPreventedByAction() {
    if (!this._sortedActions) return !1;
    for (const t of this._sortedActions) {
      const e = this._structure.getActionDefinitionWithState(t.actionType);
      if (e != null && e.getPreventHeadTurn(t.actionParameter)) return !0;
    }
    return !1;
  }
  sortActions() {
    let t = !1, e = !1, s = !1;
    if (this._currentActionsString = "", this._sortedActions = this._structure.sortActions(this._actions), this._animationFrameCount = this._structure.maxFrames(this._sortedActions), !this._sortedActions)
      this._canvasOffsets = [0, 0, 0], this._lastActionsString !== "" && (t = !0, this._lastActionsString = "");
    else {
      this._canvasOffsets = this._structure.getCanvasOffsets(this._sortedActions, this._scale, this._mainDirection);
      for (const r of this._sortedActions)
        if (this._currentActionsString += r.actionType + r.actionParameter, r.actionType === et.EFFECT) {
          const n = parseInt(r.actionParameter);
          this._effectIdInUse !== n && (s = !0), this._effectIdInUse = n, e = !0;
        }
      e || (this._effectIdInUse > -1 && (s = !0), this._effectIdInUse = -1), s && this._cache.disposeInactiveActions(), this._lastActionsString != this._currentActionsString && (t = !0, this._lastActionsString = this._currentActionsString);
    }
    return this._actionsSorted = !0, t;
  }
  setActionsToParts() {
    if (!this._sortedActions) return;
    const t = Nt(), e = [];
    for (const s of this._sortedActions) e.push(s.actionType);
    for (const s of this._sortedActions)
      if (s && s.definition && s.definition.isAnimation) {
        const r = this._structure.getAnimation(`${s.definition.state}.${s.actionParameter}`);
        if (r && r.hasOverriddenActions()) {
          const n = r.overriddenActionNames();
          if (n)
            for (const a of n)
              e.includes(a) && (s.overridingAction = r.overridingAction(a));
        }
        r && r.resetOnToggle && (this._animationHasResetOnToggle = !0);
      }
    for (const s of this._sortedActions)
      if (s && s.definition && (s.definition.isAnimation && s.actionParameter === "" && (s.actionParameter = "1"), this.setActionToParts(s, t), s.definition.isAnimation)) {
        this._isAnimating = s.definition.isAnimated(s.actionParameter);
        const r = this._structure.getAnimation(`${s.definition.state}.${s.actionParameter}`);
        r && (this._sprites = [...this._sprites, ...r.spriteData], r.hasDirectionData() && (this._directionOffset = r.directionData.offset), r.hasAvatarData() && (this._avatarSpriteData = r.avatarData));
      }
  }
  setActionToParts(t, e) {
    !t || !t.definition || t.definition.assetPartDefinition === "" || (t.definition.isMain && (this._mainAction = t, this._cache.setGeometryType(t.definition.geometryType)), this._cache.setAction(t, e), this._changes = !0);
  }
  resetBodyPartCache(t) {
    !t || t.definition.assetPartDefinition === "" || (t.definition.isMain && (this._mainAction = t, this._cache.setGeometryType(t.definition.geometryType)), this._cache.resetBodyPartCache(t), this._changes = !0);
  }
  isPlaceholder() {
    return !1;
  }
  get animationHasResetOnToggle() {
    return this._animationHasResetOnToggle;
  }
  resetEffect(t) {
    t === this._effectIdInUse && (this.resetActions(), this.setActionsToParts(), this._animationHasResetOnToggle = !0, this._changes = !0, this._effectListener && this._effectListener.resetEffect(t));
  }
};
zr.DEFAULT_ACTION = "Default", zr.DEFAULT_DIRECTION = 2, zr.DEFAULT_AVATAR_SET = gs.FULL;
let gc = zr;
class Dl {
  constructor(t) {
    this._number = t.number, this._assetPartDefinition = t.assetPartDefinition || null;
  }
  get number() {
    return this._number;
  }
  get assetPartDefinition() {
    return this._assetPartDefinition;
  }
}
class dB {
  constructor(t) {
    if (this._frames = [], t.frames && t.frames.length > 0)
      for (const e of t.frames) {
        if (!e) continue;
        this._frames.push(new Dl(e));
        let s = e.repeats || 0;
        if (s > 1) for (; --s > 0; ) this._frames.push(this._frames[this._frames.length - 1]);
      }
  }
  get frames() {
    return this._frames;
  }
}
const co = class co {
  constructor(t) {
    if (this._id = t.id, this._actionParts = /* @__PURE__ */ new Map(), this._bodyPartOffsets = /* @__PURE__ */ new Map(), this._frameCount = 0, this._frameIndexes = [], t.parts && t.parts.length > 0)
      for (const e of t.parts) {
        if (!e) continue;
        const s = new dB(e);
        this._actionParts.set(e.setType, s), this._frameCount = Math.max(this._frameCount, s.frames.length);
      }
    if (t.offsets && t.offsets.frames && t.offsets.frames.length > 0)
      for (const e of t.offsets.frames) {
        if (!e) continue;
        const s = e.id;
        this._frameCount = Math.max(this._frameCount, s);
        const r = /* @__PURE__ */ new Map();
        if (this._bodyPartOffsets.set(s, r), e.directions && e.directions.length > 0)
          for (const n of e.directions) {
            if (!n) continue;
            const a = n.id, o = /* @__PURE__ */ new Map();
            if (r.set(a, o), n.bodyParts && n.bodyParts.length > 0)
              for (const h of n.bodyParts) {
                if (!h) continue;
                const u = h.id;
                let c = 0, l = 0;
                h.dx !== void 0 && (c = h.dx), h.dy !== void 0 && (l = h.dy), o.set(u, new st(c, l));
              }
          }
        if (this._frameIndexes.push(s), e.repeats !== void 0) {
          let n = e.repeats || 0;
          if (n > 1) for (; --n > 0; ) this._frameIndexes.push(s);
        }
      }
  }
  getPart(t) {
    if (!t) return null;
    const e = this._actionParts.get(t);
    return e || null;
  }
  getFrameBodyPartOffset(t, e, s) {
    const r = e % this._frameIndexes.length, n = this._frameIndexes[r], a = this._bodyPartOffsets.get(n);
    if (!a) return co.DEFAULT_OFFSET;
    const o = a.get(t);
    if (!o) return co.DEFAULT_OFFSET;
    const h = o.get(s);
    return h || co.DEFAULT_OFFSET;
  }
  get id() {
    return this._id;
  }
  get parts() {
    return this._actionParts;
  }
  get frameCount() {
    return this._frameCount;
  }
};
co.DEFAULT_OFFSET = new st(0, 0);
let Pu = co;
class fB {
  constructor() {
    this._actions = /* @__PURE__ */ new Map();
  }
  parse(t) {
    if (t && t.length > 0)
      for (const e of t) {
        if (!e) continue;
        const s = new Pu(e);
        this._actions.set(s.id, s);
      }
    return !0;
  }
  appendJSON(t) {
    for (const e of t.action)
      this._actions.set(e.id, new Pu(e));
    return !0;
  }
  getAction(t) {
    const e = this._actions.get(t.id);
    return e || null;
  }
  getFrameCount(t) {
    const e = this.getAction(t);
    return e ? e.frameCount : 0;
  }
}
class gB {
  constructor(t, e) {
    this._id = t.id, this._width = t.width, this._height = t.height, this._offset = new st(t.dx, t.dy), e == ci.LARGE ? this._regPoint = new st((this._width - 64) / 2, 0) : this._regPoint = new st((this._width - 32) / 2, 0);
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get offset() {
    return this._offset;
  }
  get id() {
    return this._id;
  }
  get regPoint() {
    return this._regPoint;
  }
}
class pB {
  constructor(t) {
    if (!t) throw new Error("invalid_data");
    this._id = t.id, this._type = t.type, this._index = t.index, this._colorLayerIndex = t.colorindex, this._paletteMapId = -1, this._breed = -1;
  }
  get id() {
    return this._id;
  }
  get type() {
    return this._type;
  }
  get breed() {
    return this._breed;
  }
  get index() {
    return this._index;
  }
  get colorLayerIndex() {
    return this._colorLayerIndex;
  }
  get paletteMap() {
    return this._paletteMapId;
  }
}
class mB {
  constructor(t, e) {
    if (!t || !e) throw new Error("invalid_data");
    this._id = e.id, this._type = t, this._gender = e.gender, this._clubLevel = e.club, this._isColorable = e.colorable, this._isSelectable = e.selectable, this._parts = [], this._hiddenLayers = [], this._isPreSelectable = e.preselectable, this._isSellable = e.sellable;
    for (const s of e.parts) {
      const r = new pB(s), n = this.getPartIndex(r);
      n !== -1 ? this._parts.splice(n, 0, r) : this._parts.push(r);
    }
    if (e.hiddenLayers)
      for (const s of e.hiddenLayers) this._hiddenLayers.push(s.partType);
  }
  dispose() {
    this._parts = null, this._hiddenLayers = null;
  }
  getPartIndex(t) {
    const e = this._parts.length;
    if (!e) return -1;
    for (let s = 0; s < e; s++) {
      const r = this._parts[s];
      if (r && !(r.type !== t.type || r.index > t.index))
        return s;
    }
    return -1;
  }
  getPart(t, e) {
    for (const s of this._parts)
      if (!(s.type !== t || s.id !== e))
        return s;
    return null;
  }
  get id() {
    return this._id;
  }
  get type() {
    return this._type;
  }
  get gender() {
    return this._gender;
  }
  get clubLevel() {
    return this._clubLevel;
  }
  get isColorable() {
    return this._isColorable;
  }
  get isSelectable() {
    return this._isSelectable;
  }
  get parts() {
    return this._parts;
  }
  get hiddenLayers() {
    return this._hiddenLayers;
  }
  get isPreSelectable() {
    return this._isPreSelectable;
  }
  get isSellable() {
    return this._isSellable;
  }
}
class EB {
  constructor(t) {
    if (!t) throw new Error("invalid_data");
    this._id = t.id, this._index = t.index, this._clubLevel = t.club || 0, this._isSelectable = t.selectable, this._rgb = parseInt("0x" + t.hexCode, 16);
  }
  get id() {
    return this._id;
  }
  get index() {
    return this._index;
  }
  get clubLevel() {
    return this._clubLevel;
  }
  get isSelectable() {
    return this._isSelectable;
  }
  get rgb() {
    return this._rgb;
  }
}
class fR {
  constructor(t) {
    if (!t) throw new Error("invalid_data");
    this._id = t.id, this._colors = new be(), this.append(t);
  }
  append(t) {
    for (const e of t.colors) {
      const s = new EB(e);
      this._colors.add(e.id.toString(), s);
    }
  }
  getColor(t) {
    return t === void 0 || t < 0 ? null : this._colors.getValue(t.toString()) || null;
  }
  get id() {
    return this._id;
  }
  get colors() {
    return this._colors;
  }
}
class Kf {
  constructor(t) {
    if (!t) throw new Error("invalid_data");
    this._type = t.type, this._paletteId = t.paletteId, this._isMandatory = {}, this._isMandatory.F = [t.mandatory_f_0, t.mandatory_f_1], this._isMandatory.M = [t.mandatory_m_0, t.mandatory_m_1], this._partSets = new be(), this.append(t);
  }
  dispose() {
    for (const t of this._partSets.getValues())
      t.dispose();
    this._partSets = null;
  }
  cleanUp(t) {
    for (const e of t.sets) {
      const s = e.id.toString(), r = this._partSets.getValue(s);
      r && (r.dispose(), this._partSets.remove(s));
    }
  }
  append(t) {
    if (!(!t || !t.sets))
      for (const e of t.sets) this._partSets.add(e.id.toString(), new mB(this._type, e));
  }
  getDefaultPartSet(t) {
    for (const e of this._partSets.getValues())
      if (e && e.clubLevel === 0 && (e.gender === t || e.gender === "U"))
        return e;
    return null;
  }
  getPartSet(t) {
    return this._partSets.getValue(t.toString());
  }
  get type() {
    return this._type;
  }
  get paletteID() {
    return this._paletteId;
  }
  isMandatory(t, e) {
    return this._isMandatory[t.toUpperCase()][Math.min(e, 1)];
  }
  optionalFromClubLevel(t) {
    return this._isMandatory[t.toUpperCase()].indexOf(!1);
  }
  get partSets() {
    return this._partSets;
  }
}
class TB {
  constructor() {
    this._palettes = /* @__PURE__ */ new Map(), this._setTypes = /* @__PURE__ */ new Map();
  }
  dispose() {
  }
  parse(t) {
    if (!t) return !1;
    for (const e of t.palettes) {
      const s = new fR(e);
      s && this._palettes.set(s.id.toString(), s);
    }
    for (const e of t.setTypes) {
      const s = new Kf(e);
      s && this._setTypes.set(s.type, s);
    }
    return !0;
  }
  injectJSON(t) {
    for (const e of t.setTypes) {
      const s = this._setTypes.get(e.type);
      s ? s.cleanUp(e) : this._setTypes.set(e.type, new Kf(e));
    }
    this.appendJSON(t);
  }
  appendJSON(t) {
    if (!t) return !1;
    for (const e of t.palettes) {
      const s = e.id.toString(), r = this._palettes.get(s);
      r ? r.append(e) : this._palettes.set(s, new fR(e));
    }
    for (const e of t.setTypes) {
      const s = e.type, r = this._setTypes.get(s);
      r ? r.append(e) : this._setTypes.set(s, new Kf(e));
    }
    return !1;
  }
  getMandatorySetTypeIds(t, e) {
    const s = [];
    for (const r of this._setTypes.values())
      !r || !r.isMandatory(t, e) || s.push(r.type);
    return s;
  }
  getDefaultPartSet(t, e) {
    const s = this._setTypes.get(t);
    return s ? s.getDefaultPartSet(e) : null;
  }
  getSetType(t) {
    return this._setTypes.get(t) || null;
  }
  getPalette(t) {
    return this._palettes.get(t.toString()) || null;
  }
  getFigurePartSet(t) {
    for (const e of this._setTypes.values()) {
      const s = e.getPartSet(t);
      if (s)
        return s;
    }
    return null;
  }
}
class gR {
  constructor(t) {
    if (this._id = t.id, this._parts = [], t.activeParts && t.activeParts.length > 0)
      for (const e of t.activeParts)
        e && this._parts.push(e.setType);
  }
  get parts() {
    return this._parts;
  }
}
class qf {
  constructor(t) {
    if (!t) throw new Error("invalid_data");
    this._setType = t.setType, this._flippedSetType = t.flippedSetType || null, this._removeSetType = t.removeSetType || null, this._appendToFigure = !1, this._staticId = -1;
  }
  hasStaticId() {
    return this._staticId >= 0;
  }
  get staticId() {
    return this._staticId;
  }
  set staticId(t) {
    this._staticId = t;
  }
  get setType() {
    return this._setType;
  }
  get flippedSetType() {
    return this._flippedSetType;
  }
  set flippedSetType(t) {
    this._flippedSetType = t;
  }
  get removeSetType() {
    return this._removeSetType;
  }
  get appendToFigure() {
    return this._appendToFigure;
  }
  set appendToFigure(t) {
    this._appendToFigure = t;
  }
}
class IB {
  constructor() {
    this._parts = /* @__PURE__ */ new Map(), this._activePartSets = /* @__PURE__ */ new Map();
  }
  parse(t) {
    if (t.partSet && t.partSet.length > 0)
      for (const e of t.partSet)
        e && this._parts.set(e.setType, new qf(e));
    if (t.activePartSets && t.activePartSets.length > 0)
      for (const e of t.activePartSets)
        e && this._activePartSets.set(e.id, new gR(e));
    return !0;
  }
  appendJSON(t) {
    if (t.partSet && t.partSet.length > 0)
      for (const e of t.partSet)
        e && this._parts.set(e.setType, new qf(e));
    if (t.activePartSets && t.activePartSets.length > 0)
      for (const e of t.activePartSets)
        e && this._activePartSets.set(e.id, new gR(e));
    return !1;
  }
  getActiveParts(t) {
    const e = this._activePartSets.get(t.activePartSet);
    return e ? e.parts : [];
  }
  getPartDefinition(t) {
    const e = this._parts.get(t);
    return e || null;
  }
  addPartDefinition(t) {
    const e = t.setType;
    let s = this._parts.get(e);
    return s || (s = new qf(t), this._parts.set(e, s)), s;
  }
  getActivePartSet(t) {
    const e = this._activePartSets.get(t.activePartSet);
    return e || null;
  }
  get parts() {
    return this._parts;
  }
  get activePartSets() {
    return this._activePartSets;
  }
}
class $f {
  constructor(t, e, s, r, n, a, o, h, u = "", c = !1, l = 1) {
    this._bodyPartId = t, this._partType = e, this._partId = s, this._color = r, this._frames = n, this._action = a, this._isColorable = o, this._paletteMapId = h, this._flippedPartType = u, this._isBlendable = c, this._partType === "ey" && (this._isColorable = !1);
  }
  getFrameIndex(t) {
    if (!this._frames || !this._frames.length) return 0;
    const e = t % this._frames.length;
    return this._frames[e] instanceof Dl ? this._frames[e].number : e;
  }
  getFrameDefinition(t) {
    const e = t % this._frames.length;
    return this._frames && this._frames.length > e && this._frames[e] instanceof Dl ? this._frames[e] : null;
  }
  getCacheableKey(t) {
    const e = t % this._frames.length;
    if (this._frames && this._frames.length > e && this._frames[e] instanceof Dl) {
      const s = this._frames[e];
      return this.partId + ":" + s.assetPartDefinition + ":" + s.number;
    }
    return this.partId + ":" + e;
  }
  get bodyPartId() {
    return this._bodyPartId;
  }
  get partType() {
    return this._partType;
  }
  get partId() {
    return this._partId;
  }
  get color() {
    return this._color;
  }
  get action() {
    return this._action;
  }
  get isColorable() {
    return this._isColorable;
  }
  set isColorable(t) {
    this._isColorable = t;
  }
  get paletteMapId() {
    return this._paletteMapId;
  }
  get flippedPartType() {
    return this._flippedPartType;
  }
  get isBlendable() {
    return this._isBlendable;
  }
  toString() {
    return [this._bodyPartId, this._partType, this._partId].join(":");
  }
}
class QT {
  constructor(t) {
    if (this._id = t.id, this._isMain = t.main || !1, this._avatarSets = /* @__PURE__ */ new Map(), this._bodyParts = [], this._allBodyParts = [], t.avatarSets && t.avatarSets.length > 0)
      for (const s of t.avatarSets) {
        if (!s) continue;
        const r = new QT(s);
        this._avatarSets.set(r.id, r);
      }
    if (t.bodyParts && t.bodyParts.length > 0)
      for (const s of t.bodyParts)
        s && this._bodyParts.push(s.id);
    let e = this._bodyParts.concat();
    for (const s of this._avatarSets.values())
      s && (e = e.concat(s.getBodyParts()));
    this._allBodyParts = e;
  }
  findAvatarSet(t) {
    if (t === this._id) return this;
    for (const e of this._avatarSets.values())
      if (e && e.findAvatarSet(t))
        return e;
    return null;
  }
  getBodyParts() {
    return this._allBodyParts.concat();
  }
  get id() {
    return this._id;
  }
  get isMain() {
    if (this._isMain) return !0;
    for (const t of this._avatarSets.values())
      if (t && t.isMain)
        return !0;
    return !1;
  }
}
class pR extends Gy {
  constructor(t, e = !1) {
    super(parseFloat(t.x), parseFloat(t.y), parseFloat(t.z)), this._id = t.id, this._radius = parseFloat(t.radius), this._normal = new v(parseFloat(t.nx), parseFloat(t.ny), parseFloat(t.nz)), this._isDoubleSided = t.double || !1, this._isDynamic = e;
  }
  getDistance(t) {
    const e = Math.abs(t.z - this.transformedLocation.z - this._radius), s = Math.abs(t.z - this.transformedLocation.z + this._radius);
    return Math.min(e, s);
  }
  get id() {
    return this._id;
  }
  get normal() {
    return this._normal;
  }
  get isDoubleSided() {
    return this._isDoubleSided;
  }
  toString() {
    return `${this._id}: ${this.location.toString()} - ${this.transformedLocation.toString()}`;
  }
  get isDynamic() {
    return this._isDynamic;
  }
}
class SB extends Gy {
  constructor(t) {
    if (super(parseFloat(t.x), parseFloat(t.y), parseFloat(t.z)), this._id = t.id, this._radius = parseFloat(t.radius), this._parts = /* @__PURE__ */ new Map(), this._dynamicParts = /* @__PURE__ */ new Map(), t.items && t.items.length > 0)
      for (const e of t.items) {
        if (!e) continue;
        const s = new pR(e);
        this._parts.set(s.id, s);
      }
  }
  getDynamicParts(t) {
    const e = this._dynamicParts.get(t), s = [];
    if (e)
      for (const r in e) {
        const n = e[r];
        n && s.push(n);
      }
    return s;
  }
  getPartIds(t) {
    const e = [];
    for (const s of this._parts.values())
      s && e.push(s.id);
    if (t) {
      const s = this._dynamicParts.get(t);
      if (s)
        for (const r in s) {
          const n = s[r];
          n && e.push(n.id);
        }
    }
    return e;
  }
  removeDynamicParts(t) {
    return this._dynamicParts.delete(t), !0;
  }
  addPart(t, e) {
    if (this.hasPart(t.id, e)) return !1;
    let s = this._dynamicParts.get(e);
    return s || (s = {}, this._dynamicParts.set(e, s)), s[t.id] = new pR(t, !0), !0;
  }
  hasPart(t, e) {
    let s = this._parts.get(t) || null;
    return !s && this._dynamicParts.get(e) !== void 0 && (s = this._dynamicParts.get(e)[t] || null), s !== null;
  }
  getParts(t, e, s, r) {
    const n = [];
    for (const h of this._parts.values())
      h && (h.applyTransform(t), n.push([h.getDistance(e), h]));
    const a = this._dynamicParts.get(r);
    if (a)
      for (const h in a) {
        const u = a[h];
        u && (u.applyTransform(t), n.push([u.getDistance(e), u]));
      }
    n.sort((h, u) => {
      const c = h[0], l = u[0];
      return c < l ? -1 : c > l ? 1 : 0;
    });
    const o = [];
    for (const h of n)
      h && o.push(h[1].id);
    return o;
  }
  getDistance(t) {
    const e = Math.abs(t.z - this.transformedLocation.z - this._radius), s = Math.abs(t.z - this.transformedLocation.z + this._radius);
    return Math.min(e, s);
  }
  get id() {
    return this._id;
  }
  get radius() {
    return this._radius;
  }
}
class AB {
  constructor(t) {
    this._camera = new v(0, 0, 10), this._avatarSet = new QT(t.avatarSets[0]), this._geometryTypes = /* @__PURE__ */ new Map(), this._itemIdToBodyPartMap = /* @__PURE__ */ new Map(), this._transformation = new Oh(), this._canvases = /* @__PURE__ */ new Map();
    const e = t.camera;
    if (e && (this._camera.x = parseFloat(e.x), this._camera.y = parseFloat(e.y), this._camera.z = parseFloat(e.z)), t.canvases && t.canvases.length > 0)
      for (const s of t.canvases) {
        if (!s) continue;
        const r = s.scale, n = /* @__PURE__ */ new Map();
        if (s.geometries && s.geometries.length > 0)
          for (const a of s.geometries) {
            if (!a) continue;
            const o = new gB(a, r);
            n.set(o.id, o);
          }
        this._canvases.set(r, n);
      }
    if (t.types && t.types.length > 0)
      for (const s of t.types) {
        if (!s) continue;
        const r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
        if (s.bodyParts && s.bodyParts.length > 0)
          for (const a of s.bodyParts) {
            if (!a) continue;
            const o = new SB(a);
            r.set(o.id, o);
            for (const h of o.getPartIds(null))
              n.set(h, o);
          }
        this._geometryTypes.set(s.id, r), this._itemIdToBodyPartMap.set(s.id, n);
      }
  }
  removeDynamicItems(t) {
    for (const e of this._geometryTypes.values())
      if (e)
        for (const s of e.values())
          s && s.removeDynamicParts(t);
  }
  getBodyPartIdsInAvatarSet(t) {
    const e = this._avatarSet.findAvatarSet(t);
    return e ? e.getBodyParts() : [];
  }
  isMainAvatarSet(t) {
    const e = this._avatarSet.findAvatarSet(t);
    return e ? e.isMain : !1;
  }
  getCanvas(t, e) {
    const s = this._canvases.get(t);
    return s && s.get(e) || null;
  }
  typeExists(t) {
    return !!this._geometryTypes.get(t);
  }
  hasBodyPart(t, e) {
    if (this.typeExists(t)) {
      const s = this._geometryTypes.get(t);
      if (s && s.get(e)) return !0;
    }
    return !1;
  }
  getBodyPartIDs(t) {
    const e = this.getBodyPartsOfType(t), s = [];
    if (e)
      for (const r of e.values())
        r && s.push(r.id);
    return s;
  }
  getBodyPartsOfType(t) {
    return this.typeExists(t) ? this._geometryTypes.get(t) : /* @__PURE__ */ new Map();
  }
  getBodyPart(t, e) {
    return this.getBodyPartsOfType(t).get(e) || null;
  }
  getBodyPartOfItem(t, e, s) {
    const r = this._itemIdToBodyPartMap.get(t);
    if (r) {
      const n = r.get(e);
      if (n) return n;
      const a = this.getBodyPartsOfType(t);
      if (a) {
        for (const o of a.values())
          if (o && o.hasPart(e, s))
            return o;
      }
    }
    return null;
  }
  getBodyPartsInAvatarSet(t, e) {
    const s = this.getBodyPartIdsInAvatarSet(e), r = [];
    for (const n of s) {
      if (!n) continue;
      const a = t.get(n);
      a && r.push(a);
    }
    return r;
  }
  getBodyPartsAtAngle(t, e, s) {
    if (!s) return [];
    const r = this.getBodyPartsOfType(s), n = this.getBodyPartsInAvatarSet(r, t), a = [], o = [];
    this._transformation = Oh.getYRotationMatrix(e);
    for (const h of n.values())
      h && (h.applyTransform(this._transformation), a.push([h.getDistance(this._camera), h]));
    a.sort((h, u) => {
      const c = h[0], l = u[0];
      return c < l ? -1 : c > l ? 1 : 0;
    });
    for (const h of a)
      h && o.push(h[1].id);
    return o;
  }
  getParts(t, e, s, r, n) {
    if (this.hasBodyPart(t, e)) {
      const a = this.getBodyPartsOfType(t).get(e);
      return this._transformation = Oh.getYRotationMatrix(s), a.getParts(this._transformation, this._camera, r, n);
    }
    return [];
  }
}
class RB {
  constructor(t) {
    this._renderManager = t, this._geometry = null, this._figureData = new TB(), this._partSetsData = new IB(), this._animationData = new fB(), this._animationManager = new cB(), this._mandatorySetTypeIds = {}, this._actionManager = null, this._defaultAction = null;
  }
  init() {
  }
  initGeometry(t) {
    t && (this._geometry = new AB(t));
  }
  initActions(t, e) {
    e && (this._actionManager = new $F(t, e), this._defaultAction = this._actionManager.getDefaultAction());
  }
  updateActions(t) {
    this._actionManager.updateActions(t), this._defaultAction = this._actionManager.getDefaultAction();
  }
  initPartSets(t) {
    return t && this._partSetsData.parse(t) ? (this._partSetsData.getPartDefinition("ri").appendToFigure = !0, this._partSetsData.getPartDefinition("li").appendToFigure = !0, !0) : !1;
  }
  initAnimation(t) {
    return t ? this._animationData.parse(t) : !1;
  }
  initFigureData(t) {
    return t ? this._figureData.parse(t) : !1;
  }
  injectFigureData(t) {
    this._figureData.injectJSON(t);
  }
  registerAnimations(t, e = "fx", s = 200) {
    let r = 0;
    for (; r < s; ) {
      const n = t.getCollection(e + r);
      if (n) {
        const a = n.data;
        this._animationManager.registerAnimation(this, a.animations);
      }
      r++;
    }
  }
  registerAnimation(t) {
    this._animationManager.registerAnimation(this, t);
  }
  getPartColor(t, e, s = 0) {
    const r = t.getPartColorIds(e);
    if (!r || r.length < s) return null;
    const n = this._figureData.getSetType(e);
    if (n == null) return null;
    const a = this._figureData.getPalette(n.paletteID);
    return a ? a.getColor(r[s]) : null;
  }
  getBodyPartData(t, e, s) {
    return this._animationManager.getLayerData(t, e, s);
  }
  getAnimation(t) {
    return this._animationManager.getAnimation(t);
  }
  getActionDefinition(t) {
    return this._actionManager.getActionDefinition(t);
  }
  getActionDefinitionWithState(t) {
    return this._actionManager.getActionDefinitionWithState(t);
  }
  isMainAvatarSet(t) {
    return this._geometry.isMainAvatarSet(t);
  }
  sortActions(t) {
    return this._actionManager.sortActions(t);
  }
  maxFrames(t) {
    let e = 0;
    for (const s of t)
      e = Math.max(e, this._animationData.getFrameCount(s.definition));
    return e;
  }
  getMandatorySetTypeIds(t, e) {
    return this._mandatorySetTypeIds[t] || (this._mandatorySetTypeIds[t] = []), this._mandatorySetTypeIds[t][e] ? this._mandatorySetTypeIds[t][e] : (this._mandatorySetTypeIds[t][e] = this._figureData.getMandatorySetTypeIds(t, e), this._mandatorySetTypeIds[t][e]);
  }
  getDefaultPartSet(t, e) {
    return this._figureData.getDefaultPartSet(t, e);
  }
  getCanvasOffsets(t, e, s) {
    return this._actionManager.getCanvasOffsets(t, e, s);
  }
  getCanvas(t, e) {
    return this._geometry.getCanvas(t, e);
  }
  removeDynamicItems(t) {
    this._geometry.removeDynamicItems(t);
  }
  getActiveBodyPartIds(t, e) {
    let s = [];
    const r = [], n = t.definition.geometryType;
    if (t.definition.isAnimation) {
      const a = t.definition.state + "." + t.actionParameter, o = this._animationManager.getAnimation(a);
      if (o && (s = o.getAnimatedBodyPartIds(0, t.overridingAction), o.hasAddData())) {
        const h = {
          id: "",
          x: 0,
          y: 0,
          z: 0,
          radius: 0.01,
          nx: 0,
          ny: 0,
          nz: -1,
          double: 1
        }, u = {
          setType: ""
        };
        for (const c of o.addData) {
          const l = this._geometry.getBodyPart(n, c.align);
          if (l) {
            h.id = c.id, l.addPart(h, e), u.setType = c.id;
            const _ = this._partSetsData.addPartDefinition(u);
            _.appendToFigure = !0, c.base === "" && (_.staticId = 1), r.indexOf(l.id) === -1 && r.push(l.id);
          }
        }
      }
      for (const h of s) {
        const u = this._geometry.getBodyPart(n, h);
        u && r.indexOf(u.id) === -1 && r.push(u.id);
      }
    } else {
      s = this._partSetsData.getActiveParts(t.definition);
      for (const a of s) {
        const o = this._geometry.getBodyPartOfItem(n, a, e);
        o && r.indexOf(o.id) === -1 && r.push(o.id);
      }
    }
    return r;
  }
  getBodyPartsUnordered(t) {
    return this._geometry.getBodyPartIdsInAvatarSet(t);
  }
  getBodyParts(t, e, s) {
    const r = Jr.DIRECTION_TO_ANGLE[s];
    return this._geometry.getBodyPartsAtAngle(t, r, e);
  }
  getFrameBodyPartOffset(t, e, s, r) {
    const n = this._animationData.getAction(t.definition);
    return n ? n.getFrameBodyPartOffset(e, s, r) : Pu.DEFAULT_OFFSET;
  }
  getParts(t, e, s, r, n, a, o, h = null) {
    let u = null, c = [], l = null;
    if (!s) return [];
    const _ = this._partSetsData.getActiveParts(s.definition), d = [];
    let f = [0];
    const p = this._animationData.getAction(s.definition);
    if (s.definition.isAnimation) {
      const y = s.definition.state + "." + s.actionParameter, C = this._animationManager.getAnimation(y);
      if (C) {
        f = this.getPopulatedArray(C.frameCount(s.overridingAction));
        for (const b of C.getAnimatedBodyPartIds(0, s.overridingAction))
          if (b === t) {
            const D = this._geometry.getBodyPart(r, b);
            if (D)
              for (const P of D.getDynamicParts(o))
                _.push(P.id);
          }
      }
    }
    const g = this._geometry.getParts(r, t, n, _, o), m = e.getPartTypeIds();
    for (const y of m) {
      if (h && h.get(y))
        continue;
      const C = e.getPartSetId(y), b = e.getPartColorIds(y), D = this._figureData.getSetType(y);
      if (D) {
        const P = this._figureData.getPalette(D.paletteID);
        if (P) {
          const F = D.getPartSet(C);
          if (F) {
            a = a.concat(F.hiddenLayers);
            for (const M of F.parts)
              if (g.indexOf(M.type) > -1) {
                if (p) {
                  const Y = p.getPart(M.type);
                  Y ? c = Y.frames : c = f;
                } else
                  c = f;
                u = s.definition, _.indexOf(M.type) === -1 && (u = this._defaultAction);
                const U = this._partSetsData.getPartDefinition(M.type);
                let k = U ? U.flippedSetType : M.type;
                (!k || k === "") && (k = M.type), b && b.length > M.colorLayerIndex - 1 && (l = P.getColor(b[M.colorLayerIndex - 1]));
                const ft = M.colorLayerIndex > 0, K = new $f(t, M.type, M.id.toString(), l, c, u, ft, M.paletteMap, k);
                d.push(K);
              }
          }
        }
      }
    }
    const O = [];
    for (const y of g) {
      let C = null, b = !1;
      const D = h && h.get(y);
      for (const P of d)
        P.partType === y && (D ? C = P.color : (b = !0, a.indexOf(y) === -1 && O.push(P)));
      if (!b) {
        if (D) {
          const P = h.get(y);
          let F = 0, M = 0;
          for (; M < P.length; )
            F = F + P.charCodeAt(M), M++;
          if (p) {
            const k = p.getPart(y);
            k ? c = k.frames : c = f;
          } else
            c = f;
          const U = new $f(t, y, P, C, c, s.definition, C != null, -1, y, !1, 1);
          O.push(U);
        } else if (_.indexOf(y) > -1) {
          const P = this._geometry.getBodyPartOfItem(r, y, o);
          if (t === P.id) {
            const F = this._partSetsData.getPartDefinition(y);
            let M = !1, U = 1;
            if (F.appendToFigure) {
              let k = "1";
              if (s.actionParameter !== "" && (k = s.actionParameter), F.hasStaticId() && (k = F.staticId.toString()), p) {
                const K = p.getPart(y);
                K ? c = K.frames : c = f;
              } else
                c = f;
              const ft = new $f(t, y, k, null, c, s.definition, !1, -1, y, M, U);
              O.push(ft);
            }
          }
        }
      }
    }
    return O;
  }
  getPopulatedArray(t) {
    const e = [];
    let s = 0;
    for (; s < t; )
      e.push(s), s++;
    return e;
  }
  getItemIds() {
    if (this._actionManager) {
      const t = this._actionManager.getActionDefinition("CarryItem").params, e = [];
      for (const s of t.values()) e.push(s);
      return e;
    }
    return [];
  }
  get renderManager() {
    return this._renderManager;
  }
  get figureData() {
    return this._figureData;
  }
  get partData() {
    return this._partSetsData;
  }
  get animationManager() {
    return this._animationManager;
  }
}
const ws = class ws {
  constructor(t, e, s, r) {
    this._state = ws.NOT_LOADED, this._animation = null, this._libraryName = t, this._revision = e, this._downloadUrl = s, this._assetManager = r, this._downloadUrl = this._downloadUrl.replace(/%libname%/gi, this._libraryName), this._downloadUrl = this._downloadUrl.replace(/%revision%/gi, this._revision), this.checkIsLoaded();
  }
  async downloadAsset() {
    if (!(!this._assetManager || this._state === ws.LOADING || this._state === ws.LOADED)) {
      if (!this.checkIsLoaded() && (this._state = ws.LOADING, !await this._assetManager.downloadAsset(this._downloadUrl)))
        throw new Error("Could not download asset");
      this.checkIsLoaded() && x().dispatchEvent(new Jg(Ze.AVATAR_EFFECT_DOWNLOADED, this));
    }
  }
  checkIsLoaded() {
    const t = this._assetManager.getCollection(this._libraryName);
    return t ? (this._state = ws.LOADED, this._animation = t.data.animations, !0) : !1;
  }
  get libraryName() {
    return this._libraryName;
  }
  get animation() {
    return this._animation;
  }
  get isLoaded() {
    return this._state === ws.LOADED;
  }
};
ws.DOWNLOAD_COMPLETE = "EADL_DOWNLOAD_COMPLETE", ws.NOT_LOADED = 0, ws.LOADING = 1, ws.LOADED = 2;
let Fp = ws;
class OB {
  constructor(t, e) {
    this._missingMandatoryLibs = [], this._effectMap = /* @__PURE__ */ new Map(), this._effectListeners = /* @__PURE__ */ new Map(), this._incompleteEffects = /* @__PURE__ */ new Map(), this._currentDownloads = [], this._libraryNames = [], this._assets = t, this._structure = e;
  }
  async init() {
    this._missingMandatoryLibs = Ct().getValue("avatar.mandatory.effect.libraries");
    const t = Ct().getValue("avatar.effectmap.url");
    if (!t || !t.length) throw new Error("Invalid effect map url");
    const e = await fetch(t);
    if (e.status !== 200) throw new Error("Invalid effect map file");
    const s = await e.json();
    this.processEffectMap(s.effects), x().addEventListener(Ze.AVATAR_EFFECT_DOWNLOADED, (r) => this.onLibraryLoaded(r)), await this.processMissingLibraries();
  }
  processEffectMap(t) {
    if (!t) return;
    const e = Ct().getValue("avatar.asset.effect.url");
    for (const s of t) {
      if (!s) continue;
      const r = s.id, n = s.lib, a = s.revision || "";
      if (this._libraryNames.indexOf(n) >= 0) continue;
      this._libraryNames.push(n);
      const o = new Fp(n, a, e, this._assets);
      let h = this._effectMap.get(r);
      h || (h = []), h.push(o), this._effectMap.set(r, h);
    }
  }
  async processMissingLibraries() {
    const t = [];
    this._missingMandatoryLibs.forEach((e) => {
      const s = this._effectMap.get(e);
      if (s) for (const r of s) t.push(r.downloadAsset());
    }), this._missingMandatoryLibs = [], await Promise.all(t);
  }
  onLibraryLoaded(t) {
    if (!t || !t.library) return;
    const e = [];
    this._structure.registerAnimation(t.library.animation);
    for (const [r, n] of this._incompleteEffects.entries()) {
      let a = !0;
      for (const o of n)
        if (!(!o || o.isLoaded)) {
          a = !1;
          break;
        }
      if (a) {
        e.push(r);
        const o = this._effectListeners.get(r);
        for (const h of o)
          !h || h.disposed || h.resetEffect(parseInt(r));
        this._effectListeners.delete(r), x().dispatchEvent(new qt(Ze.AVATAR_EFFECT_LOADED));
      }
    }
    for (const r of e) this._incompleteEffects.delete(r);
    let s = 0;
    for (; s < this._currentDownloads.length; ) {
      const r = this._currentDownloads[s];
      r && r.libraryName === t.library.libraryName && this._currentDownloads.splice(s, 1), s++;
    }
  }
  isAvatarEffectReady(t) {
    return !this.getAvatarEffectPendingLibraries(t).length;
  }
  getAvatarEffectPendingLibraries(t) {
    const e = [];
    if (!this._structure) return e;
    const s = this._effectMap.get(t.toString());
    if (s)
      for (const r of s)
        !r || r.isLoaded || e.indexOf(r) === -1 && e.push(r);
    return e;
  }
  downloadAvatarEffect(t, e) {
    const s = this.getAvatarEffectPendingLibraries(t);
    if (s && s.length) {
      if (e && !e.disposed) {
        let r = this._effectListeners.get(t.toString());
        r || (r = []), r.push(e), this._effectListeners.set(t.toString(), r);
      }
      this._incompleteEffects.set(t.toString(), s);
      for (const r of s)
        r && r.downloadAsset();
    } else
      e && !e.disposed && e.resetEffect(t);
  }
}
const _t = class _t {
  constructor() {
    this._gender = "M", this._avatarEffectType = -1;
  }
  loadAvatarData(t, e) {
    this._data = /* @__PURE__ */ new Map(), this._colors = /* @__PURE__ */ new Map(), this._gender = e, this.parseFigureString(t);
  }
  dispose() {
    this._data = null, this._colors = null, this._isDisposed = !0;
  }
  get disposed() {
    return this._isDisposed;
  }
  parseFigureString(t) {
    if (t)
      for (const e of t.split(".")) {
        const s = e.split("-");
        if (s.length > 0) {
          const r = s[0], n = parseInt(s[1]), a = [];
          let o = 2;
          for (; o < s.length; )
            a.push(parseInt(s[o])), o++;
          a.length || a.push(0), this.savePartSetId(r, n, !1), this.savePartSetColourId(r, a, !1);
        }
      }
  }
  hasSetType(t) {
    return !!this._data.get(t);
  }
  getPartSetId(t) {
    return this.hasSetType(t) ? this._data.get(t) : -1;
  }
  getColourIds(t) {
    return this._colors.get(t) ? this._colors.get(t) : [];
  }
  getFigureString() {
    let t = "";
    const e = [];
    for (const [r, n] of this._data.entries()) {
      let a = r + "-" + n;
      const o = this._colors.get(r);
      if (o) for (const h of o) a = a + ("-" + h);
      e.push(a);
    }
    let s = 0;
    for (; s < e.length; )
      t = t + e[s], s < e.length - 1 && (t = t + "."), s++;
    return t;
  }
  savePartData(t, e, s, r = !1) {
    this.savePartSetId(t, e, r), this.savePartSetColourId(t, s, r);
  }
  savePartSetId(t, e, s = !0) {
    switch (t) {
      case _t.HD:
      case _t.HAIR:
      case _t.HAT:
      case _t.HEAD_ACCESSORIES:
      case _t.EYE_ACCESSORIES:
      case _t.FACE_ACCESSORIES:
      case _t.SHIRT:
      case _t.JACKET:
      case _t.CHEST_ACCESSORIES:
      case _t.CHEST_PRINTS:
      case _t.TROUSERS:
      case _t.SHOES:
      case _t.TROUSER_ACCESSORIES:
        e >= 0 ? this._data.set(t, e) : this._data.delete(t);
    }
  }
  savePartSetColourId(t, e, s = !0) {
    switch (t) {
      case _t.HD:
      case _t.HAIR:
      case _t.HAT:
      case _t.HEAD_ACCESSORIES:
      case _t.EYE_ACCESSORIES:
      case _t.FACE_ACCESSORIES:
      case _t.SHIRT:
      case _t.JACKET:
      case _t.CHEST_ACCESSORIES:
      case _t.CHEST_PRINTS:
      case _t.TROUSERS:
      case _t.SHOES:
      case _t.TROUSER_ACCESSORIES:
        this._colors.set(t, e);
        return;
    }
  }
  getFigureStringWithFace(t) {
    const e = [_t.HD];
    let s = "";
    const r = [];
    for (const a of e) {
      const o = this._colors.get(a);
      if (o) {
        let h = this._data.get(a);
        a === _t.HD && (h = t);
        let u = a + "-" + h;
        if (h >= 0) {
          let c = 0;
          for (; c < o.length; )
            u = u + ("-" + o[c]), c++;
        }
        r.push(u);
      }
    }
    let n = 0;
    for (; n < r.length; )
      s = s + r[n], n < r.length - 1 && (s = s + "."), n++;
    return s;
  }
  get gender() {
    return this._gender;
  }
};
_t.MALE = "M", _t.FEMALE = "F", _t.UNISEX = "U", _t.SCALE = "h", _t.STD = "std", _t.DEFAULT_FRAME = "0", _t.HD = "hd", _t.HAIR = "hr", _t.HAT = "ha", _t.HEAD_ACCESSORIES = "he", _t.EYE_ACCESSORIES = "ea", _t.FACE_ACCESSORIES = "fa", _t.JACKET = "cc", _t.SHIRT = "ch", _t.CHEST_ACCESSORIES = "ca", _t.CHEST_PRINTS = "cp", _t.TROUSERS = "lg", _t.SHOES = "sh", _t.TROUSER_ACCESSORIES = "wa", _t.BLOCKED_FX_TYPES = [28, 29, 30, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 68];
let wp = _t;
class yB extends gc {
  constructor(t, e, s, r, n) {
    super(t, e, s, r, n, null);
  }
  isPlaceholder() {
    return !0;
  }
}
class vB {
  constructor(t, e) {
    this._name = t, this._link = e.link, this._flipH = e.flipH, this._flipV = e.flipV;
  }
  get name() {
    return this._name;
  }
  get link() {
    return this._link;
  }
  get flipH() {
    return this._flipH;
  }
  get flipV() {
    return this._flipV;
  }
}
class CB {
  constructor(t, e) {
    this._avatarRenderManager = t, this._aliases = /* @__PURE__ */ new Map(), this._assets = e, this._missingAssetNames = [];
  }
  dispose() {
    this._assets = null, this._aliases = null;
  }
  reset() {
    this.init();
  }
  init() {
    for (const t of this._assets.collections.values()) {
      if (!t) continue;
      const e = t.data && t.data.aliases;
      if (e)
        for (const s in e) {
          const r = e[s];
          r && this._aliases.set(s, new vB(s, r));
        }
    }
  }
  hasAlias(t) {
    return !!this._aliases.get(t);
  }
  getAssetName(t) {
    let e = t, s = 5;
    for (; this.hasAlias(e) && s >= 0; )
      e = this._aliases.get(e).link, s--;
    return e;
  }
  getAsset(t) {
    if (!this._assets) return null;
    t = this.getAssetName(t);
    const e = this._assets.getAsset(t);
    return e || null;
  }
}
const xB = {
  animations: [
    {
      id: "Move",
      parts: [
        {
          setType: "bd",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wlk"
            },
            {
              number: 1,
              assetPartDefinition: "wlk"
            },
            {
              number: 2,
              assetPartDefinition: "wlk"
            },
            {
              number: 3,
              assetPartDefinition: "wlk"
            }
          ]
        },
        {
          setType: "bds",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wlk"
            },
            {
              number: 1,
              assetPartDefinition: "wlk"
            },
            {
              number: 2,
              assetPartDefinition: "wlk"
            },
            {
              number: 3,
              assetPartDefinition: "wlk"
            }
          ]
        },
        {
          setType: "ss",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wlk"
            },
            {
              number: 1,
              assetPartDefinition: "wlk"
            },
            {
              number: 2,
              assetPartDefinition: "wlk"
            },
            {
              number: 3,
              assetPartDefinition: "wlk"
            }
          ]
        },
        {
          setType: "lg",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wlk"
            },
            {
              number: 1,
              assetPartDefinition: "wlk"
            },
            {
              number: 2,
              assetPartDefinition: "wlk"
            },
            {
              number: 3,
              assetPartDefinition: "wlk"
            }
          ]
        },
        {
          setType: "sh",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wlk"
            },
            {
              number: 1,
              assetPartDefinition: "wlk"
            },
            {
              number: 2,
              assetPartDefinition: "wlk"
            },
            {
              number: 3,
              assetPartDefinition: "wlk"
            }
          ]
        },
        {
          setType: "lh",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wlk"
            },
            {
              number: 1,
              assetPartDefinition: "wlk"
            },
            {
              number: 2,
              assetPartDefinition: "wlk"
            },
            {
              number: 3,
              assetPartDefinition: "wlk"
            }
          ]
        },
        {
          setType: "lhs",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wlk"
            },
            {
              number: 1,
              assetPartDefinition: "wlk"
            },
            {
              number: 2,
              assetPartDefinition: "wlk"
            },
            {
              number: 3,
              assetPartDefinition: "wlk"
            }
          ]
        },
        {
          setType: "ls",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wlk"
            },
            {
              number: 1,
              assetPartDefinition: "wlk"
            },
            {
              number: 2,
              assetPartDefinition: "wlk"
            },
            {
              number: 3,
              assetPartDefinition: "wlk"
            }
          ]
        },
        {
          setType: "lc",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wlk"
            },
            {
              number: 1,
              assetPartDefinition: "wlk"
            },
            {
              number: 2,
              assetPartDefinition: "wlk"
            },
            {
              number: 3,
              assetPartDefinition: "wlk"
            }
          ]
        },
        {
          setType: "rh",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wlk"
            },
            {
              number: 1,
              assetPartDefinition: "wlk"
            },
            {
              number: 2,
              assetPartDefinition: "wlk"
            },
            {
              number: 3,
              assetPartDefinition: "wlk"
            }
          ]
        },
        {
          setType: "rhs",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wlk"
            },
            {
              number: 1,
              assetPartDefinition: "wlk"
            },
            {
              number: 2,
              assetPartDefinition: "wlk"
            },
            {
              number: 3,
              assetPartDefinition: "wlk"
            }
          ]
        },
        {
          setType: "rs",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wlk"
            },
            {
              number: 1,
              assetPartDefinition: "wlk"
            },
            {
              number: 2,
              assetPartDefinition: "wlk"
            },
            {
              number: 3,
              assetPartDefinition: "wlk"
            }
          ]
        },
        {
          setType: "rc",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wlk"
            },
            {
              number: 1,
              assetPartDefinition: "wlk"
            },
            {
              number: 2,
              assetPartDefinition: "wlk"
            },
            {
              number: 3,
              assetPartDefinition: "wlk"
            }
          ]
        },
        {
          setType: "ch",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wlk"
            },
            {
              number: 1,
              assetPartDefinition: "wlk"
            },
            {
              number: 2,
              assetPartDefinition: "wlk"
            },
            {
              number: 3,
              assetPartDefinition: "wlk"
            }
          ]
        }
      ]
    },
    {
      id: "Wave",
      parts: [
        {
          setType: "lh",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wav"
            },
            {
              number: 1,
              assetPartDefinition: "wav"
            }
          ]
        },
        {
          setType: "lhs",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wav"
            },
            {
              number: 1,
              assetPartDefinition: "wav"
            }
          ]
        },
        {
          setType: "ls",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wav"
            },
            {
              number: 1,
              assetPartDefinition: "wav"
            }
          ]
        },
        {
          setType: "lc",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wav"
            },
            {
              number: 1,
              assetPartDefinition: "wav"
            }
          ]
        },
        {
          setType: "ch",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wav"
            },
            {
              number: 1,
              assetPartDefinition: "wav"
            },
            {
              number: 2,
              assetPartDefinition: "wav"
            },
            {
              number: 3,
              assetPartDefinition: "wav"
            }
          ]
        }
      ]
    },
    {
      id: "Talk",
      parts: [
        {
          setType: "hd",
          frames: [
            {
              number: 0,
              assetPartDefinition: "spk"
            },
            {
              number: 1,
              assetPartDefinition: "spk"
            }
          ]
        },
        {
          setType: "fc",
          frames: [
            {
              number: 0,
              assetPartDefinition: "spk"
            },
            {
              number: 1,
              assetPartDefinition: "spk"
            }
          ]
        },
        {
          setType: "fa",
          frames: [
            {
              number: 0,
              assetPartDefinition: "spk"
            },
            {
              number: 1,
              assetPartDefinition: "spk"
            }
          ]
        }
      ]
    },
    {
      id: "Sign",
      parts: [
        {
          setType: "lh",
          frames: [
            {
              number: 0,
              assetPartDefinition: "sig"
            }
          ]
        },
        {
          setType: "li",
          frames: [
            {
              number: 0,
              assetPartDefinition: "sig"
            }
          ]
        },
        {
          setType: "ls",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wav"
            }
          ]
        },
        {
          setType: "lc",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wav"
            }
          ]
        }
      ]
    },
    {
      id: "Respect",
      parts: [
        {
          setType: "lh",
          frames: [
            {
              number: 0,
              assetPartDefinition: "respect",
              repeats: 15
            },
            {
              number: 1,
              assetPartDefinition: "respect",
              repeats: 15
            }
          ]
        },
        {
          setType: "ls",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wav",
              repeats: 15
            },
            {
              number: 1,
              assetPartDefinition: "wav",
              repeats: 15
            }
          ]
        },
        {
          setType: "lc",
          frames: [
            {
              number: 0,
              assetPartDefinition: "wav",
              repeats: 15
            },
            {
              number: 1,
              assetPartDefinition: "wav",
              repeats: 15
            }
          ]
        }
      ]
    },
    {
      id: "Blow",
      parts: [
        {
          setType: "rh",
          frames: [
            {
              number: 0,
              assetPartDefinition: "blw",
              repeats: 10
            },
            {
              number: 1,
              assetPartDefinition: "blw",
              repeats: 10
            }
          ]
        },
        {
          setType: "rs",
          frames: [
            {
              number: 0,
              assetPartDefinition: "drk"
            }
          ]
        },
        {
          setType: "rc",
          frames: [
            {
              number: 0,
              assetPartDefinition: "drk"
            }
          ]
        },
        {
          setType: "ri",
          frames: [
            {
              number: 0,
              assetPartDefinition: ""
            }
          ]
        },
        {
          setType: "ey",
          frames: [
            {
              number: 0,
              assetPartDefinition: "std",
              repeats: 10
            },
            {
              number: 0,
              assetPartDefinition: "eyb",
              repeats: 10
            }
          ]
        },
        {
          setType: "fc",
          frames: [
            {
              number: 0,
              assetPartDefinition: "std",
              repeats: 10
            },
            {
              number: 0,
              assetPartDefinition: "blw",
              repeats: 10
            }
          ]
        }
      ]
    },
    {
      id: "Laugh",
      parts: [
        {
          setType: "rh",
          frames: [
            {
              number: 0,
              assetPartDefinition: "blw"
            }
          ]
        },
        {
          setType: "rs",
          frames: [
            {
              number: 0,
              assetPartDefinition: "drk"
            }
          ]
        },
        {
          setType: "rc",
          frames: [
            {
              number: 0,
              assetPartDefinition: "drk"
            }
          ]
        },
        {
          setType: "ri",
          frames: [
            {
              number: 0,
              assetPartDefinition: ""
            }
          ]
        },
        {
          setType: "ey",
          frames: [
            {
              number: 0,
              assetPartDefinition: "std",
              repeats: 2
            }
          ]
        },
        {
          setType: "fc",
          frames: [
            {
              number: 0,
              assetPartDefinition: "sml"
            }
          ]
        }
      ],
      offsets: {
        frames: [
          {
            id: 0,
            directions: [
              {
                id: 0,
                bodyParts: [
                  {
                    id: "head",
                    dx: 0,
                    dy: 1
                  }
                ]
              },
              {
                id: 1,
                bodyParts: [
                  {
                    id: "head",
                    dx: 0,
                    dy: 1
                  }
                ]
              },
              {
                id: 2,
                bodyParts: [
                  {
                    id: "head",
                    dx: 0,
                    dy: 1
                  }
                ]
              },
              {
                id: 3,
                bodyParts: [
                  {
                    id: "head",
                    dx: 0,
                    dy: 1
                  }
                ]
              },
              {
                id: 4,
                bodyParts: [
                  {
                    id: "head",
                    dx: 0,
                    dy: 1
                  }
                ]
              },
              {
                id: 5,
                bodyParts: [
                  {
                    id: "head",
                    dx: 0,
                    dy: 1
                  }
                ]
              },
              {
                id: 6,
                bodyParts: [
                  {
                    id: "head",
                    dx: 0,
                    dy: 1
                  }
                ]
              },
              {
                id: 7,
                bodyParts: [
                  {
                    id: "head",
                    dx: 0,
                    dy: 1
                  }
                ]
              }
            ]
          },
          {
            id: 1,
            directions: [
              {
                id: 0,
                bodyParts: [
                  {
                    id: "head",
                    dx: 0,
                    dy: 0
                  }
                ]
              },
              {
                id: 1,
                bodyParts: [
                  {
                    id: "head",
                    dx: 0,
                    dy: 0
                  }
                ]
              },
              {
                id: 2,
                bodyParts: [
                  {
                    id: "head",
                    dx: 0,
                    dy: 0
                  }
                ]
              },
              {
                id: 3,
                bodyParts: [
                  {
                    id: "head",
                    dx: 0,
                    dy: 0
                  }
                ]
              },
              {
                id: 4,
                bodyParts: [
                  {
                    id: "head",
                    dx: 0,
                    dy: 0
                  }
                ]
              },
              {
                id: 5,
                bodyParts: [
                  {
                    id: "head",
                    dx: 0,
                    dy: 0
                  }
                ]
              },
              {
                id: 6,
                bodyParts: [
                  {
                    id: "head",
                    dx: 0,
                    dy: 0
                  }
                ]
              },
              {
                id: 7,
                bodyParts: [
                  {
                    id: "head",
                    dx: 0,
                    dy: 0
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      id: "Swim",
      parts: [
        {
          setType: "bds",
          frames: [
            {
              number: 0,
              assetPartDefinition: "swm"
            },
            {
              number: 1,
              assetPartDefinition: "swm"
            },
            {
              number: 2,
              assetPartDefinition: "swm"
            },
            {
              number: 3,
              assetPartDefinition: "swm"
            }
          ]
        },
        {
          setType: "ss",
          frames: [
            {
              number: 0,
              assetPartDefinition: "swm"
            },
            {
              number: 1,
              assetPartDefinition: "swm"
            },
            {
              number: 2,
              assetPartDefinition: "swm"
            },
            {
              number: 3,
              assetPartDefinition: "swm"
            }
          ]
        },
        {
          setType: "lhs",
          frames: [
            {
              number: 0,
              assetPartDefinition: "swm"
            },
            {
              number: 1,
              assetPartDefinition: "swm"
            },
            {
              number: 2,
              assetPartDefinition: "swm"
            },
            {
              number: 3,
              assetPartDefinition: "swm"
            }
          ]
        },
        {
          setType: "rhs",
          frames: [
            {
              number: 0,
              assetPartDefinition: "swm"
            },
            {
              number: 1,
              assetPartDefinition: "swm"
            },
            {
              number: 2,
              assetPartDefinition: "swm"
            },
            {
              number: 3,
              assetPartDefinition: "swm"
            }
          ]
        }
      ]
    },
    {
      id: "Float",
      parts: [
        {
          setType: "bds",
          frames: [
            {
              number: 3,
              assetPartDefinition: "sws"
            },
            {
              number: 3,
              assetPartDefinition: "sws"
            },
            {
              number: 2,
              assetPartDefinition: "sws"
            },
            {
              number: 1,
              assetPartDefinition: "sws"
            },
            {
              number: 0,
              assetPartDefinition: "sws"
            }
          ]
        },
        {
          setType: "ss",
          frames: [
            {
              number: 0,
              assetPartDefinition: "sws"
            }
          ]
        },
        {
          setType: "lhs",
          frames: [
            {
              number: 0,
              assetPartDefinition: "sws"
            },
            {
              number: 0,
              assetPartDefinition: "sws"
            },
            {
              number: 1,
              assetPartDefinition: "sws"
            },
            {
              number: 1,
              assetPartDefinition: "sws"
            },
            {
              number: 2,
              assetPartDefinition: "sws"
            },
            {
              number: 3,
              assetPartDefinition: "sws"
            },
            {
              number: 3,
              assetPartDefinition: "sws"
            },
            {
              number: 2,
              assetPartDefinition: "sws"
            },
            {
              number: 1,
              assetPartDefinition: "sws"
            },
            {
              number: 1,
              assetPartDefinition: "sws"
            }
          ]
        },
        {
          setType: "rhs",
          frames: [
            {
              number: 0,
              assetPartDefinition: "sws"
            },
            {
              number: 0,
              assetPartDefinition: "sws"
            },
            {
              number: 1,
              assetPartDefinition: "sws"
            },
            {
              number: 1,
              assetPartDefinition: "sws"
            },
            {
              number: 2,
              assetPartDefinition: "sws"
            },
            {
              number: 3,
              assetPartDefinition: "sws"
            },
            {
              number: 3,
              assetPartDefinition: "sws"
            },
            {
              number: 2,
              assetPartDefinition: "sws"
            },
            {
              number: 1,
              assetPartDefinition: "sws"
            },
            {
              number: 1,
              assetPartDefinition: "sws"
            }
          ]
        }
      ]
    }
  ]
}, MB = {
  geometry: {
    direction: 0,
    camera: {
      x: 0,
      y: 0,
      z: 10
    },
    canvases: [
      {
        scale: "h",
        geometries: [
          {
            id: "vertical",
            width: 90,
            height: 130,
            dx: 0,
            dy: 0
          },
          {
            id: "sitting",
            width: 90,
            height: 130,
            dx: 0,
            dy: 0
          },
          {
            id: "horizontal",
            width: 128,
            height: 80,
            dx: 30,
            dy: 0
          },
          {
            id: "swhorizontal",
            width: 192,
            height: 120,
            dx: 0,
            dy: -40
          }
        ]
      },
      {
        scale: "sh",
        geometries: [
          {
            id: "vertical",
            width: 45,
            height: 72,
            dx: 0,
            dy: 0
          },
          {
            id: "sitting",
            width: 45,
            height: 72,
            dx: 0,
            dy: 0
          },
          {
            id: "horizontal",
            width: 64,
            height: 50,
            dx: 15,
            dy: -10
          },
          {
            id: "swhorizontal",
            width: 96,
            height: 70,
            dx: 0,
            dy: -20
          },
          {
            id: "swim",
            width: 64,
            height: 70,
            dx: 0,
            dy: 0
          }
        ]
      }
    ],
    avatarSets: [
      {
        id: "full",
        avatarSets: [
          {
            id: "body",
            main: !0,
            bodyParts: [
              {
                id: "top"
              },
              {
                id: "bottom"
              },
              {
                id: "behind"
              },
              {
                id: "torso"
              },
              {
                id: "leftitem"
              },
              {
                id: "rightitem"
              },
              {
                id: "leftarm"
              },
              {
                id: "rightarm"
              }
            ]
          },
          {
            id: "head",
            bodyParts: [
              {
                id: "head"
              }
            ]
          }
        ]
      }
    ],
    types: [
      {
        id: "vertical",
        bodyParts: [
          {
            id: "top",
            x: 0,
            y: 0,
            z: 0,
            radius: 2
          },
          {
            id: "bottom",
            x: 0,
            y: 0,
            z: 0,
            radius: 1e-3
          },
          {
            id: "behind",
            x: 0,
            y: 0,
            z: 0.2,
            radius: 0.3
          },
          {
            id: "torso",
            x: 0,
            y: 0,
            z: 0,
            radius: 0.4,
            items: [
              {
                id: "bd",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "bds",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "ch",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.04,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "sh",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.02,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "lg",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.03,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ss",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.04,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "cp",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.045,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "wa",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.05,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "cc",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.06,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ca",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.07,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "leftitem",
            x: 0,
            y: 0,
            z: -0.29,
            radius: 0.3,
            items: [
              {
                id: "li",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "rightitem",
            x: 0,
            y: 0,
            z: -0.29,
            radius: 0.3,
            items: [
              {
                id: "ri",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "leftarm",
            x: -1,
            y: 0,
            z: -0.51,
            radius: 0.5,
            items: [
              {
                id: "lh",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "lhs",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ls",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.02,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "lc",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.025,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "rightarm",
            x: 1,
            y: 0,
            z: -0.51,
            radius: 0.5,
            items: [
              {
                id: "rh",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "rhs",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "rs",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.02,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "rc",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.025,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "head",
            x: 0,
            y: 0,
            z: 0,
            radius: 0.5,
            items: [
              {
                id: "hd",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "fc",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.02,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ey",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.03,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "hr",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.04,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "hrb",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.05,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "fa",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.06,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ea",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.07,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ha",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.08,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "he",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.09,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          }
        ]
      },
      {
        id: "sitting",
        bodyParts: [
          {
            id: "top",
            x: 0,
            y: 0,
            z: 0,
            radius: 2
          },
          {
            id: "bottom",
            x: 0,
            y: 0,
            z: 0,
            radius: 1e-3
          },
          {
            id: "behind",
            x: 0,
            y: 0,
            z: 0.2,
            radius: 0.3
          },
          {
            id: "torso",
            x: 0,
            y: 0,
            z: 0,
            radius: 0.4,
            items: [
              {
                id: "bd",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "bds",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "ch",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.03,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "sh",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.04,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "lg",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.02,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ss",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.04,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "cp",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.045,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "wa",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.05,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "cc",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.06,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ca",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.07,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "leftitem",
            x: 0,
            y: 0,
            z: -0.29,
            radius: 0.3,
            items: [
              {
                id: "li",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "rightitem",
            x: 0,
            y: 0,
            z: -0.29,
            radius: 0.3,
            items: [
              {
                id: "ri",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "leftarm",
            x: -1,
            y: 0,
            z: -0.51,
            radius: 0.5,
            items: [
              {
                id: "lh",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "lhs",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ls",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.02,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "lc",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.025,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "rightarm",
            x: 1,
            y: 0,
            z: -0.51,
            radius: 0.5,
            items: [
              {
                id: "rh",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "rhs",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "rs",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.02,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "rc",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.025,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "head",
            x: 0,
            y: 0,
            z: 0,
            radius: 0.5,
            items: [
              {
                id: "hd",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "fc",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.02,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ey",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.03,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "hr",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.04,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "hrb",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.05,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "fa",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.06,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ea",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.07,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ha",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.08,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "he",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.09,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          }
        ]
      },
      {
        id: "horizontal",
        bodyParts: [
          {
            id: "torso",
            x: 0,
            y: 0,
            z: 0,
            radius: 0.4,
            items: [
              {
                id: "bd",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "bds",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "ch",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.02,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "cp",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.025,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "sh",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.04,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "lg",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.03,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ss",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.03,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "wa",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.05,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "cc",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.06,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ca",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.07,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "leftitem",
            x: 0,
            y: 0,
            z: -0.29,
            radius: 0.3,
            items: [
              {
                id: "li",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "rightitem",
            x: 0,
            y: 0,
            z: -0.29,
            radius: 0.3,
            items: [
              {
                id: "ri",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "leftarm",
            x: -1,
            y: 0,
            z: -0.51,
            radius: 0.6,
            items: [
              {
                id: "lh",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "lhs",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ls",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.02,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "lc",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.025,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "rightarm",
            x: 1,
            y: 0,
            z: -0.51,
            radius: 0.6,
            items: [
              {
                id: "rh",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "rhs",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "rs",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.02,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "rc",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.025,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "head",
            x: 0,
            y: 0,
            z: 0,
            radius: 0.5,
            items: [
              {
                id: "hd",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "fc",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.02,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ey",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.03,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "hr",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.04,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "hrb",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.05,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "fa",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.06,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ea",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.07,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ha",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.08,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "he",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.09,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          }
        ]
      },
      {
        id: "swhorizontal",
        bodyParts: [
          {
            id: "torso",
            x: 0,
            y: 0,
            z: 0,
            radius: 0.4,
            items: [
              {
                id: "bd",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "bds",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "ch",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.02,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "cp",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.025,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "sh",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.04,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "lg",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.03,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ss",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.03,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "wa",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.05,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "cc",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.06,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ca",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.07,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "leftitem",
            x: 0,
            y: 0,
            z: -0.29,
            radius: 0.3,
            items: [
              {
                id: "li",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "rightitem",
            x: 0,
            y: 0,
            z: -0.29,
            radius: 0.3,
            items: [
              {
                id: "ri",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "leftarm",
            x: -1,
            y: 0,
            z: -0.51,
            radius: 0.6,
            items: [
              {
                id: "lh",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "lhs",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ls",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.02,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "lc",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.025,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "rightarm",
            x: 1,
            y: 0,
            z: -0.51,
            radius: 0.6,
            items: [
              {
                id: "rh",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "rhs",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "rs",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.02,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "rc",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.025,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "head",
            x: 0,
            y: 0,
            z: 0,
            radius: 0.5,
            items: [
              {
                id: "hd",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "fc",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.02,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ey",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.03,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "hr",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.04,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "hrb",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.05,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "fa",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.06,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ea",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.07,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ha",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.08,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "he",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.09,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          }
        ]
      },
      {
        id: "swim",
        bodyParts: [
          {
            id: "torso",
            x: 0,
            y: 0,
            z: 0,
            radius: 0.4,
            items: [
              {
                id: "bds",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "ss",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.03,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "leftarm",
            x: -1,
            y: 0,
            z: 0,
            radius: 0.6,
            items: [
              {
                id: "lhs",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "rightarm",
            x: 1,
            y: 0,
            z: 0,
            radius: 0.6,
            items: [
              {
                id: "rhs",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          },
          {
            id: "head",
            x: 0,
            y: 0,
            z: 0,
            radius: 0.5,
            items: [
              {
                id: "hd",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.01,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "fc",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.02,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ey",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.03,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "hr",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.04,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "hrb",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.05,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !0
              },
              {
                id: "fa",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.06,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ea",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.07,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "ha",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.08,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              },
              {
                id: "he",
                x: 0,
                y: 0,
                z: 0,
                radius: 0.09,
                nx: 0,
                ny: 0,
                nz: -1,
                double: !1
              }
            ]
          }
        ]
      }
    ]
  }
}, bB = {
  partSets: {
    partSet: [
      {
        setType: "ri",
        flippedSetType: "ri"
      },
      {
        setType: "ri",
        flippedSetType: "ri"
      },
      {
        setType: "rh",
        flippedSetType: "lh"
      },
      {
        setType: "rhs",
        flippedSetType: "lhs"
      },
      {
        setType: "rs",
        swim: "0",
        flippedSetType: "ls"
      },
      {
        setType: "rc",
        flippedSetType: "lc"
      },
      {
        setType: "bd"
      },
      {
        setType: "bds"
      },
      {
        setType: "ss"
      },
      {
        setType: "sh"
      },
      {
        setType: "lg"
      },
      {
        setType: "ch"
      },
      {
        setType: "cp"
      },
      {
        setType: "cc"
      },
      {
        setType: "hd"
      },
      {
        setType: "fc"
      },
      {
        setType: "ey"
      },
      {
        setType: "hr"
      },
      {
        setType: "hrb",
        removeSetType: "hr"
      },
      {
        setType: "li",
        flippedSetType: "li"
      },
      {
        setType: "lh",
        flippedSetType: "rh"
      },
      {
        setType: "lhs",
        flippedSetType: "rhs"
      },
      {
        setType: "ls",
        flippedSetType: "rs"
      },
      {
        setType: "lc",
        flippedSetType: "rc"
      },
      {
        setType: "wa"
      },
      {
        setType: "ea"
      },
      {
        setType: "ca"
      },
      {
        setType: "fa"
      },
      {
        setType: "ha"
      },
      {
        setType: "he"
      }
    ],
    activePartSets: [
      {
        id: "figure",
        activeParts: [
          {
            setType: "rh"
          },
          {
            setType: "rh"
          },
          {
            setType: "rhs"
          },
          {
            setType: "rs"
          },
          {
            setType: "rc"
          },
          {
            setType: "bd"
          },
          {
            setType: "bds"
          },
          {
            setType: "ss"
          },
          {
            setType: "sh"
          },
          {
            setType: "lg"
          },
          {
            setType: "ch"
          },
          {
            setType: "cp"
          },
          {
            setType: "cc"
          },
          {
            setType: "wa"
          },
          {
            setType: "hd"
          },
          {
            setType: "fc"
          },
          {
            setType: "ey"
          },
          {
            setType: "hr"
          },
          {
            setType: "hrb"
          },
          {
            setType: "lh"
          },
          {
            setType: "lhs"
          },
          {
            setType: "ls"
          },
          {
            setType: "lc"
          },
          {
            setType: "ea"
          },
          {
            setType: "ca"
          },
          {
            setType: "fa"
          },
          {
            setType: "ha"
          },
          {
            setType: "he"
          }
        ]
      },
      {
        id: "head",
        activeParts: [
          {
            setType: "hd"
          },
          {
            setType: "fc"
          },
          {
            setType: "ey"
          },
          {
            setType: "hr"
          },
          {
            setType: "hrb"
          },
          {
            setType: "ea"
          },
          {
            setType: "fa"
          },
          {
            setType: "ha"
          },
          {
            setType: "he"
          }
        ]
      },
      {
        id: "speak",
        activeParts: [
          {
            setType: "hd"
          },
          {
            setType: "hr"
          },
          {
            setType: "hrb"
          },
          {
            setType: "fc"
          },
          {
            setType: "fa"
          },
          {
            setType: "ha"
          }
        ]
      },
      {
        id: "gesture",
        activeParts: [
          {
            setType: "ey"
          },
          {
            setType: "fc"
          }
        ]
      },
      {
        id: "eye",
        activeParts: [
          {
            setType: "ey"
          }
        ]
      },
      {
        id: "handRight",
        activeParts: [
          {
            setType: "rh"
          },
          {
            setType: "rhs"
          },
          {
            setType: "rs"
          },
          {
            setType: "rc"
          },
          {
            setType: "ri"
          }
        ]
      },
      {
        id: "handRightAndHead",
        activeParts: [
          {
            setType: "rh"
          },
          {
            setType: "rhs"
          },
          {
            setType: "rs"
          },
          {
            setType: "rc"
          },
          {
            setType: "ri"
          },
          {
            setType: "ey"
          },
          {
            setType: "fc"
          },
          {
            setType: "hd"
          }
        ]
      },
      {
        id: "handLeft",
        activeParts: [
          {
            setType: "lh"
          },
          {
            setType: "lhs"
          },
          {
            setType: "ls"
          },
          {
            setType: "lc"
          },
          {
            setType: "li"
          }
        ]
      },
      {
        id: "walk",
        activeParts: [
          {
            setType: "bd"
          },
          {
            setType: "bds"
          },
          {
            setType: "ss"
          },
          {
            setType: "lg"
          },
          {
            setType: "lh"
          },
          {
            setType: "lhs"
          },
          {
            setType: "rh"
          },
          {
            setType: "rhs"
          },
          {
            setType: "ls"
          },
          {
            setType: "lc"
          },
          {
            setType: "rs"
          },
          {
            setType: "rc"
          },
          {
            setType: "sh"
          }
        ]
      },
      {
        id: "sit",
        activeParts: [
          {
            setType: "bd"
          },
          {
            setType: "bds"
          },
          {
            setType: "ss"
          },
          {
            setType: "lg"
          },
          {
            setType: "sh"
          },
          {
            setType: "cc"
          }
        ]
      },
      {
        id: "itemRight",
        activeParts: [
          {
            setType: "ri"
          }
        ]
      },
      {
        id: "swim",
        activeParts: [
          {
            setType: "bds"
          },
          {
            setType: "ss"
          },
          {
            setType: "lhs"
          },
          {
            setType: "rhs"
          }
        ]
      },
      {
        id: "snowwarrun",
        activeParts: [
          {
            setType: "ch"
          }
        ]
      },
      {
        id: "snowwarpick",
        activeParts: [
          {
            setType: "ch"
          },
          {
            setType: "hd"
          }
        ]
      },
      {
        id: "snowwardiefront",
        activeParts: [
          {
            setType: "ch"
          },
          {
            setType: "hd"
          }
        ]
      },
      {
        id: "snowwardieback",
        activeParts: [
          {
            setType: "ch"
          },
          {
            setType: "hd"
          }
        ]
      },
      {
        id: "snowwarthrow",
        activeParts: [
          {
            setType: "ch"
          }
        ]
      }
    ]
  }
}, Z_ = class Z_ {
  constructor() {
    this._structure = new RB(this), this._aliasCollection = new CB(this, Rt()), this._avatarAssetDownloadManager = new XF(Rt(), this._structure), this._effectAssetDownloadManager = new OB(Rt(), this._structure), this._placeHolderFigure = new vl(Z_.DEFAULT_FIGURE);
  }
  async init() {
    var t, e, s;
    (t = this._structure) == null || t.initGeometry(MB.geometry), (e = this._structure) == null || e.initPartSets(bB.partSets), await this.loadActions(), (s = this._structure) == null || s.initAnimation(xB.animations), await this.loadFigureData(), this._aliasCollection.init(), x().addEventListener(Ze.AVATAR_ASSET_LOADED, () => this._aliasCollection.reset()), x().addEventListener(Ze.AVATAR_EFFECT_LOADED, () => this._aliasCollection.reset()), await this._avatarAssetDownloadManager.init(), await this._effectAssetDownloadManager.init();
  }
  async loadActions() {
    const t = Ct().getValue("avatar.default.actions");
    t && this._structure.initActions(Rt(), t);
    const e = Ct().getValue("avatar.actions.url");
    if (!e || !e.length) throw new Error("Invalid avatar action url");
    const s = await fetch(e);
    if (s.status !== 200) throw new Error("Invalid avatar action file");
    this._structure.updateActions(await s.json());
  }
  async loadFigureData() {
    var r;
    const t = Ct().getValue("avatar.default.figuredata");
    t && ((r = this._structure) == null || r.initFigureData(t));
    const e = Ct().getValue("avatar.figuredata.url");
    if (!e || !e.length) throw new Error("Invalid figure data url");
    const s = await fetch(e);
    if (s.status !== 200) throw new Error("Invalid figure data file");
    this._structure.figureData.appendJSON(await s.json()), this._structure.init();
  }
  createFigureContainer(t) {
    return new vl(t);
  }
  isFigureContainerReady(t) {
    return this._avatarAssetDownloadManager ? this._avatarAssetDownloadManager.isAvatarFigureContainerReady(t) : !1;
  }
  createAvatarImage(t, e, s, r = null, n = null) {
    if (!this._structure || !this._avatarAssetDownloadManager) return null;
    const a = new vl(t);
    return s && this.validateAvatarFigure(a, s), this._avatarAssetDownloadManager.isAvatarFigureContainerReady(a) ? new gc(this._structure, this._aliasCollection, a, e, this._effectAssetDownloadManager, n) : (this._avatarAssetDownloadManager.downloadAvatarFigure(a, r), new yB(this._structure, this._aliasCollection, this._placeHolderFigure, e, this._effectAssetDownloadManager));
  }
  downloadAvatarFigure(t, e) {
    this._avatarAssetDownloadManager && this._avatarAssetDownloadManager.downloadAvatarFigure(t, e);
  }
  validateAvatarFigure(t, e) {
    let s = !1;
    const r = this._structure.getMandatorySetTypeIds(e, 2);
    if (r) {
      const n = this._structure.figureData;
      for (const a of r)
        if (t.hasPartType(a)) {
          const o = n.getSetType(a);
          if (o && !o.getPartSet(t.getPartSetId(a))) {
            const u = this._structure.getDefaultPartSet(a, e);
            u && (t.updatePart(a, u.id, [0]), s = !0);
          }
        } else {
          const o = this._structure.getDefaultPartSet(a, e);
          o && (t.updatePart(a, o.id, [0]), s = !0);
        }
    }
    return !s;
  }
  getFigureClubLevel(t, e, s = null) {
    if (!this._structure) return 0;
    const r = this._structure.figureData, n = Array.from(t.getPartTypeIds());
    let a = 0;
    for (const o of n) {
      const h = r.getSetType(o);
      if (!h) continue;
      const u = t.getPartSetId(o), c = h.getPartSet(u);
      if (c) {
        a = Math.max(c.clubLevel, a);
        const l = r.getPalette(h.paletteID), _ = t.getPartColorIds(o);
        for (const d of _) {
          const f = l.getColor(d);
          f && (a = Math.max(f.clubLevel, a));
        }
      }
    }
    s || (s = this._structure.getBodyPartsUnordered(gs.FULL));
    for (const o of s) {
      const h = r.getSetType(o);
      h && n.indexOf(o) === -1 && (a = Math.max(h.optionalFromClubLevel(e), a));
    }
    return a;
  }
  isValidFigureSetForGender(t, e) {
    const r = this.structureData.getFigurePartSet(t);
    return !!(r && (r.gender.toUpperCase() === "U" || r.gender.toUpperCase() === e.toUpperCase()));
  }
  getFigureStringWithFigureIds(t, e, s) {
    const r = new wp();
    r.loadAvatarData(t, e);
    const n = this.resolveFigureSets(s);
    for (const a of n)
      r.savePartData(a.type, a.id, r.getColourIds(a.type));
    return r.getFigureString();
  }
  resolveFigureSets(t) {
    const e = this.structureData, s = [];
    for (const r of t) {
      const n = e.getFigurePartSet(r);
      n && s.push(n);
    }
    return s;
  }
  getMandatoryAvatarPartSetIds(t, e) {
    return this._structure ? this._structure.getMandatorySetTypeIds(t, e) : null;
  }
  getAssetByName(t) {
    return this._aliasCollection.getAsset(t);
  }
  get assets() {
    return Rt();
  }
  get structure() {
    return this._structure;
  }
  get structureData() {
    return this._structure ? this._structure.figureData : null;
  }
  get downloadManager() {
    return this._avatarAssetDownloadManager;
  }
};
Z_.DEFAULT_FIGURE = "hd-99999-99999";
let Gp = Z_;
const PB = new Gp(), mR = () => PB;
class NB {
  constructor(t, e = -1, s = null, r = null, n = null) {
    this._minLevel = -1, this._texture = null, this._colorMatrix = null, this._blendMode = null, this._name = t, this._minLevel = e, this._texture = s, this._colorMatrix = r, this._blendMode = n;
  }
  get name() {
    return this._name;
  }
  get texture() {
    return this._texture;
  }
  set texture(t) {
    this._texture = t;
  }
  get colorMatrix() {
    return this._colorMatrix;
  }
  set colorMatrix(t) {
    this._colorMatrix = t;
  }
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(t) {
    this._blendMode = t;
  }
  get minLevel() {
    return this._minLevel;
  }
}
class UB {
  constructor() {
    this._effects = /* @__PURE__ */ new Map(), this._isLoaded = !1;
  }
  async init() {
    if (this._isLoaded) return;
    this._isLoaded = !0;
    const t = Ct().getValue("image.library.url") + "Habbo-Stories/", e = Ct().getValue("camera.available.effects");
    for (const s of e) {
      if (!s.enabled) continue;
      const r = new NB(s.name, s.minLevel);
      if (s.colorMatrix.length)
        r.colorMatrix = s.colorMatrix;
      else {
        const n = `${t}${s.name}.png`;
        await Rt().downloadAsset(n), r.texture = Rt().getTexture(n), r.blendMode = s.blendMode;
      }
      this._effects.set(r.name, r);
    }
    x().dispatchEvent(new oc(oc.INITIALIZED));
  }
  async applyEffects(t, e, s) {
    const r = new Qt(), n = new Ft(t);
    r.addChild(n), s && n.scale.set(2);
    const a = [], o = (h, u, c) => {
      const l = new Sh();
      {
        const _ = [], d = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
        for (let f = 0; f < h.length; f++)
          _.push(h[f] * c + d[f] * (1 - c));
        l.matrix = _;
      }
      return l;
    };
    for (const h of e) {
      const u = h.effect;
      if (u)
        if (u.colorMatrix) {
          const c = o(u.colorMatrix, !1, h.strength);
          a.push(c);
        } else {
          const c = new Ft(u.texture);
          c.alpha = h.strength, c.blendMode = u.blendMode, r.addChild(c);
        }
    }
    return r.filters = a, await le.generateImage(n);
  }
  get effects() {
    return this._effects;
  }
  get isLoaded() {
    return this._isLoaded;
  }
}
const DB = new UB(), Qrt = () => DB;
class Jrt {
  constructor(t, e) {
    this._effect = t, this._strength = e;
  }
  get effect() {
    return this._effect;
  }
  get strength() {
    return this._strength;
  }
}
class LB {
  constructor() {
    this._messageIdByEvent = /* @__PURE__ */ new Map(), this._messageIdByComposer = /* @__PURE__ */ new Map(), this._messageInstancesById = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._messageIdByEvent.clear(), this._messageIdByComposer.clear(), this._messageInstancesById.clear();
  }
  registerMessages(t) {
    for (const [e, s] of t.events) this.registerMessageEventClass(e, s);
    for (const [e, s] of t.composers) this.registerMessageComposerClass(e, s);
  }
  registerMessageEventClass(t, e) {
    !t || !e || this._messageIdByEvent.set(e, t);
  }
  registerMessageComposerClass(t, e) {
    !t || !e || this._messageIdByComposer.set(e, t);
  }
  registerMessageEvent(t) {
    if (!t) return;
    const e = this.getEventId(t);
    if (!e) return;
    let s = this._messageInstancesById.get(e);
    (!s || !s.length) && (s = [], this._messageInstancesById.set(e, s)), s.push(t);
  }
  removeMessageEvent(t) {
    if (!t) return;
    const e = this.getEventId(t);
    if (!e) return;
    const s = this._messageInstancesById.get(e);
    if (s) {
      for (const [r, n] of s.entries())
        if (n && n === t) {
          s.splice(r, 1), s.length === 0 && this._messageInstancesById.delete(e), n.dispose();
          return;
        }
    }
  }
  getEvents(t) {
    if (!t) return;
    const e = this._messageInstancesById.get(t);
    if (e)
      return e;
  }
  getEventId(t) {
    if (!t) return -1;
    const e = t instanceof A ? t.constructor : t, s = this._messageIdByEvent.get(e);
    return s || -1;
  }
  getComposerId(t) {
    if (!t) return -1;
    const e = this._messageIdByComposer.get(t.constructor);
    return e || -1;
  }
}
const E = class E {
};
E.AREA_HIDE = 6001, E.ACHIEVEMENT_LIST = 305, E.AUTHENTICATED = 2491, E.AUTHENTICATION = -1, E.AVAILABILITY_STATUS = 2033, E.BUILDERS_CLUB_EXPIRED = 1452, E.CLUB_OFFERS = 2405, E.CATALOG_PAGE = 804, E.CATALOG_PAGE_LIST = 1032, E.CATALOG_PURCHASE_OK = 869, E.CATALOG_PURCHASE_ERROR = 1404, E.CATALOG_PURCHASE_NOT_ALLOWED = 3770, E.PRODUCT_OFFER = 3388, E.LIMITED_SOLD_OUT = 377, E.CATALOG_PUBLISHED = 1866, E.CFH_RESULT_MESSAGE = 3635, E.CLIENT_LATENCY = 10, E.CLIENT_PING = 3928, E.DESKTOP_CAMPAIGN = 1745, E.DESKTOP_NEWS = 286, E.DESKTOP_VIEW = 122, E.BUNDLE_DISCOUNT_RULESET = 2347, E.FIRST_LOGIN_OF_DAY = 793, E.FURNITURE_ALIASES = 1723, E.FURNITURE_DATA = 2547, E.FURNITURE_FLOOR = 1778, E.FURNITURE_FLOOR_ADD = 1534, E.FURNITURE_FLOOR_REMOVE = 2703, E.FURNITURE_FLOOR_UPDATE = 3776, E.FURNITURE_ITEMDATA = 2202, E.FURNITURE_STATE = 2376, E.FURNITURE_GROUP_CONTEXT_MENU_INFO = 3293, E.FURNITURE_POSTIT_STICKY_POLE_OPEN = 2366, E.GAME_CENTER_ACHIEVEMENTS = 2265, E.GAME_CENTER_GAME_LIST = 222, E.GAME_CENTER_STATUS = 2893, E.GAME_CENTER_IN_ARENA_QUEUE = 872, E.GAME_CENTER_STOP_COUNTER = 3191, E.GAME_CENTER_USER_LEFT_GAME = 3138, E.GAME_CENTER_DIRECTORY_STATUS = 2246, E.GAME_CENTER_STARTING_GAME_FAILED = 2142, E.GAME_CENTER_JOINING_FAILED = 1730, E.GAMESTATUSMESSAGE = 3805, E.GAMEACHIEVEMENTS = 1689, E.GAMEINVITE = 904, E.JOININGQUEUEFAILED = 3035, E.JOINEDQUEUEMESSAGE = 2260, E.LEFTQUEUE = 1477, E.LOAD_GAME_URL = 2624, E.LOADGAME = 3654, E.UNLOADGAME = 1715, E.ACHIEVEMENTRESOLUTIONCOMPLETED = 740, E.ACHIEVEMENTRESOLUTIONPROGRESS = 3370, E.ACHIEVEMENTRESOLUTIONS = 66, E.GENERIC_ALERT = 3801, E.MODERATOR_MESSAGE = 2030, E.GENERIC_ERROR = 1600, E.GIFT_WRAPPER_CONFIG = 2234, E.GROUP_BADGES = 2402, E.GROUP_CREATE_OPTIONS = 2159, E.GROUP_FORUM_DATA = 3011, E.GROUP_FORUM_LIST = 3001, E.GROUP_FORUM_THREADS = 1073, E.GROUP_FORUM_POST = 2049, E.GROUP_FORUM_POST_THREAD = 1862, E.GROUP_FORUM_THREAD_MESSAGES = 509, E.GROUP_FORUM_UNREAD_COUNT = 2379, E.GROUP_FORUM_UPDATE_MESSAGE = 324, E.GROUP_FORUM_UPDATE_THREAD = 2528, E.GROUP_INFO = 1702, E.GROUP_LIST = 420, E.GROUP_MEMBER = 265, E.GROUP_MEMBERS = 1200, E.GROUP_MEMBERS_REFRESH = 2445, E.GROUP_MEMBER_REMOVE_CONFIRM = 1876, E.GROUP_PURCHASED = 2808, E.GROUP_SETTINGS = 3965, E.GROUP_BADGE_PARTS = 2238, E.GROUP_MEMBERSHIP_REQUESTED = 1180, E.GROUP_DETAILS_CHANGED = 1459, E.GROUP_HABBO_JOIN_FAILED = 762, E.GUILD_EDIT_FAILED = 3988, E.GUILD_MEMBER_MGMT_FAILED = 818, E.ITEM_DIMMER_SETTINGS = 2710, E.ITEM_STACK_HELPER = 2816, E.ITEM_WALL = 1369, E.ITEM_WALL_ADD = 2187, E.ITEM_WALL_REMOVE = 3208, E.ITEM_WALL_UPDATE = 2009, E.MARKETPLACE_CONFIG = 1823, E.MESSENGER_ACCEPT_FRIENDS = 896, E.MESSENGER_CHAT = 1587, E.MESSENGER_FIND_FRIENDS = 1210, E.MESSENGER_FOLLOW_FAILED = 3048, E.MESSENGER_FRIEND_NOTIFICATION = 3082, E.MESSENGER_FRIENDS = 3130, E.MESSENGER_INIT = 1605, E.MESSENGER_INSTANCE_MESSAGE_ERROR = 3359, E.MESSENGER_INVITE = 3870, E.MESSENGER_INVITE_ERROR = 462, E.MESSENGER_MESSAGE_ERROR = 892, E.MESSENGER_MINIMAIL_COUNT = 2803, E.MESSENGER_MINIMAIL_NEW = 1911, E.MESSENGER_RELATIONSHIPS = 2016, E.MESSENGER_REQUEST = 2219, E.MESSENGER_REQUEST_ERROR = 892, E.MESSENGER_REQUESTS = 280, E.MESSENGER_SEARCH = 973, E.MESSENGER_UPDATE = 2800, E.MODERATION_REPORT_DISABLED = 1651, E.MODERATION_TOOL = 2696, E.MODERATION_USER_INFO = 2866, E.MOTD_MESSAGES = 2035, E.NAVIGATOR_CATEGORIES = 1562, E.NAVIGATOR_COLLAPSED = 1543, E.NAVIGATOR_EVENT_CATEGORIES = 3244, E.NAVIGATOR_LIFTED = 3104, E.NAVIGATOR_METADATA = 3052, E.NAVIGATOR_OPEN_ROOM_CREATOR = 2064, E.NAVIGATOR_SEARCH = 2690, E.NAVIGATOR_SEARCHES = 3984, E.NAVIGATOR_SETTINGS = 518, E.THUMBNAIL_UPDATE_RESULT = 1927, E.CAN_CREATE_ROOM = 378, E.CATEGORIES_WITH_VISITOR_COUNT = 1455, E.COMPETITION_ROOMS_DATA = 3954, E.CONVERTED_ROOM_ID = 1331, E.GUEST_ROOM_SEARCH_RESULT = 52, E.NOTIFICATION_LIST = 1992, E.NOTIFICATION_OFFER_REWARD_DELIVERED = 2125, E.NOTIFICATION_SIMPLE_ALERT = 5100, E.NOTIFICATION_ELEMENT_POINTER = 1787, E.PET_FIGURE_UPDATE = 1924, E.PET_INFO = 2901, E.PET_TRAINING_PANEL = 1164, E.PET_LEVEL_UPDATE = 2824, E.PET_SCRATCH_FAILED = 1130, E.PET_OPEN_PACKAGE_REQUESTED = 2380, E.PET_OPEN_PACKAGE_RESULT = 546, E.PET_BREEDING = 1746, E.PET_CONFIRM_BREEDING_RESULT = 1625, E.PET_GO_TO_BREEDING_NEST_FAILURE = 2621, E.PET_NEST_BREEDING_SUCCESS = 2527, E.PET_CONFIRM_BREEDING_REQUEST = 634, E.PET_BREEDING_RESULT = 1553, E.RECYCLER_PRIZES = 3164, E.RECYCLER_STATUS = 3433, E.RECYCLER_FINISHED = 468, E.ROOM_BAN_LIST = 1869, E.ROOM_BAN_REMOVE = 3429, E.ROOM_CREATED = 1304, E.ROOM_DOORBELL = 2309, E.ROOM_DOORBELL_ACCEPTED = 3783, E.ROOM_DOORBELL_REJECTED = 878, E.ROOM_ENTER = 758, E.ROOM_ENTER_ERROR = 899, E.ROOM_FORWARD = 160, E.ROOM_HEIGHT_MAP = 2753, E.ROOM_HEIGHT_MAP_UPDATE = 558, E.ROOM_INFO = 687, E.ROOM_INFO_OWNER = 749, E.ROOM_MODEL = 1301, E.ROOM_MODEL_BLOCKED_TILES = 3990, E.ROOM_MODEL_DOOR = 1664, E.ROOM_MODEL_NAME = 2031, E.ROOM_MUTED = 2533, E.ROOM_MUTE_USER = 826, E.ROOM_PAINT = 2454, E.ROOM_PROMOTION = 2274, E.ROOM_QUEUE_STATUS = 2208, E.ROOM_RIGHTS = 780, E.ROOM_RIGHTS_CLEAR = 2392, E.ROOM_RIGHTS_LIST = 1284, E.ROOM_RIGHTS_LIST_ADD = 2088, E.ROOM_RIGHTS_LIST_REMOVE = 1327, E.ROOM_RIGHTS_OWNER = 339, E.ROOM_ROLLING = 3207, E.ROOM_SCORE = 482, E.ROOM_SETTINGS = 1498, E.ROOM_SETTINGS_CHAT = 1191, E.ROOM_SETTINGS_SAVE = 948, E.ROOM_SETTINGS_SAVE_ERROR = 1555, E.ROOM_INFO_UPDATED = 3297, E.ROOM_SPECTATOR = 1033, E.ROOM_THICKNESS = 3547, E.ROOM_GET_FILTER_WORDS = 2937, E.ROOM_MESSAGE_NOTIFICATION = 1634, E.ROOM_POPULAR_TAGS_RESULT = 2012, E.INFO_FEED_ENABLE = 3284, E.SECURITY_MACHINE = 1488, E.MYSTERY_BOX_KEYS = 2833, E.GOTMYSTERYBOXPRIZEMESSAGE = 3712, E.CANCELMYSTERYBOXWAITMESSAGE = 596, E.SHOWMYSTERYBOXWAITMESSAGE = 3201, E.TRADE_ACCEPTED = 2568, E.TRADE_CLOSED = 1373, E.TRADE_COMPLETED = 1001, E.TRADE_CONFIRMATION = 2720, E.TRADE_LIST_ITEM = 2024, E.TRADE_NOT_OPEN = 3128, E.TRADE_OPEN = 2505, E.TRADE_OPEN_FAILED = 217, E.TRADE_OTHER_NOT_ALLOWED = 1254, E.TRADE_YOU_NOT_ALLOWED = 3058, E.TRADE_NO_SUCH_ITEM = 2873, E.UNIT = 374, E.UNIT_CHANGE_NAME = 2182, E.UNIT_CHAT = 1446, E.UNIT_CHAT_SHOUT = 1036, E.UNIT_CHAT_WHISPER = 2704, E.UNIT_DANCE = 2233, E.UNIT_EFFECT = 1167, E.UNIT_EXPRESSION = 1631, E.UNIT_HAND_ITEM = 1474, E.UNIT_IDLE = 1797, E.UNIT_INFO = 3920, E.UNIT_NUMBER = 2324, E.UNIT_REMOVE = 2661, E.UNIT_STATUS = 1640, E.UNIT_TYPING = 1717, E.UNSEEN_ITEMS = 2103, E.USER_ACHIEVEMENT_SCORE = 1968, E.USER_BADGES = 717, E.USER_BADGES_ADD = 2493, E.USER_BADGES_CURRENT = 1087, E.USER_BOT_REMOVE = 233, E.USER_BOTS = 3086, E.USER_CHANGE_NAME = 118, E.USER_CLOTHING = 1450, E.USER_CREDITS = 3475, E.USER_CURRENCY = 2018, E.ACTIVITY_POINT_NOTIFICATION = 2275, E.USER_EFFECTS = 340, E.USER_FAVORITE_ROOM = 2524, E.USER_FAVORITE_ROOM_COUNT = 151, E.USER_FIGURE = 2429, E.USER_FURNITURE = 994, E.USER_FURNITURE_ADD = 104, E.USER_FURNITURE_POSTIT_PLACED = 1501, E.USER_FURNITURE_REFRESH = 3151, E.USER_FURNITURE_REMOVE = 159, E.USER_HOME_ROOM = 2875, E.ROOM_EVENT_CANCEL = 3479, E.ROOM_EVENT = 1840, E.USER_IGNORED = 126, E.USER_IGNORED_RESULT = 207, E.USER_INFO = 2725, E.USER_OUTFITS = 3315, E.USER_PERKS = 2586, E.USER_PERMISSIONS = 411, E.USER_PET_ADD = 2101, E.USER_PET_REMOVE = 3253, E.USER_PETS = 3522, E.USER_PROFILE = 3898, E.USER_RESPECT = 2815, E.USER_SANCTION_STATUS = 3679, E.USER_SETTINGS = 513, E.USER_SUBSCRIPTION = 954, E.USER_WARDROBE_PAGE = 3315, E.USER_CLASSIFICATION = 966, E.GET_USER_TAGS = 1255, E.WIRED_ACTION = 1434, E.WIRED_CONDITION = 1108, E.WIRED_ERROR = 156, E.WIRED_OPEN = 1830, E.WIRED_REWARD = 178, E.WIRED_SAVE = 1155, E.WIRED_TRIGGER = 383, E.PLAYING_GAME = 448, E.FURNITURE_STATE_2 = 3431, E.REMOVE_BOT_FROM_INVENTORY = 233, E.ADD_BOT_TO_INVENTORY = 1352, E.ACHIEVEMENT_PROGRESSED = 2107, E.MODTOOL_ROOM_INFO = 1333, E.MODTOOL_USER_CHATLOG = 3377, E.MODTOOL_ROOM_CHATLOG = 3434, E.MODTOOL_VISITED_ROOMS_USER = 1752, E.MODERATOR_ACTION_RESULT = 2335, E.ISSUE_DELETED = 3192, E.ISSUE_INFO = 3609, E.ISSUE_PICK_FAILED = 3150, E.CFH_CHATLOG = 607, E.MODERATOR_TOOL_PREFERENCES = 1576, E.LOVELOCK_FURNI_START = 3753, E.LOVELOCK_FURNI_FRIEND_COMFIRMED = 382, E.LOVELOCK_FURNI_FINISHED = 770, E.GIFT_RECEIVER_NOT_FOUND = 1517, E.GIFT_OPENED = 56, E.FLOOD_CONTROL = 566, E.REMAINING_MUTE = 826, E.USER_EFFECT_LIST = 340, E.USER_EFFECT_LIST_ADD = 2867, E.USER_EFFECT_LIST_REMOVE = 2228, E.USER_EFFECT_ACTIVATE = 1959, E.AVATAR_EFFECT_SELECTED = 3473, E.CLUB_GIFT_INFO = 619, E.REDEEM_VOUCHER_ERROR = 714, E.REDEEM_VOUCHER_OK = 3336, E.IN_CLIENT_LINK = 2023, E.BOT_COMMAND_CONFIGURATION = 1618, E.BOT_SKILL_LIST_UPDATE = 69, E.BOT_FORCE_OPEN_CONTEXT_MENU = 296, E.HAND_ITEM_RECEIVED = 354, E.PET_PLACING_ERROR = 2913, E.BOT_ERROR = 639, E.MARKETPLACE_SELL_ITEM = 54, E.MARKETPLACE_ITEM_STATS = 725, E.MARKETPLACE_OWN_ITEMS = 3884, E.MARKETPLACE_CANCEL_SALE = 3264, E.MARKETPLACE_ITEM_POSTED = 1359, E.MARKETPLACE_ITEMS_SEARCHED = 680, E.MARKETPLACE_AFTER_ORDER_STATUS = 2032, E.CATALOG_RECEIVE_PET_BREEDS = 3331, E.CATALOG_APPROVE_NAME_RESULT = 1503, E.OBJECTS_DATA_UPDATE = 1453, E.PET_EXPERIENCE = 2156, E.COMMUNITY_GOAL_VOTE_EVENT = 1435, E.PROMO_ARTICLES = 286, E.COMMUNITY_GOAL_EARNED_PRIZES = 3319, E.COMMUNITY_GOAL_PROGRESS = 2525, E.CONCURRENT_USERS_GOAL_PROGRESS = 2737, E.QUEST_DAILY = 1878, E.QUEST_CANCELLED = 3027, E.QUEST_COMPLETED = 949, E.COMMUNITY_GOAL_HALL_OF_FAME = 3005, E.EPIC_POPUP = 3945, E.SEASONAL_QUESTS = 1122, E.QUESTS = 3625, E.QUEST = 230, E.BONUS_RARE_INFO = 1533, E.CRAFTABLE_PRODUCTS = 1e3, E.CRAFTING_RECIPE = 2774, E.CRAFTING_RECIPES_AVAILABLE = 2124, E.CRAFTING_RESULT = 618, E.CAMERA_PUBLISH_STATUS = 2057, E.CAMERA_PURCHASE_OK = 2783, E.CAMERA_STORAGE_URL = 3696, E.CAMERA_SNAPSHOT = 463, E.COMPETITION_STATUS = 133, E.INIT_CAMERA = 3878, E.THUMBNAIL_STATUS = 3595, E.ACHIEVEMENT_NOTIFICATION = 806, E.CLUB_GIFT_NOTIFICATION = 2188, E.INTERSTITIAL_MESSAGE = 1808, E.ROOM_AD_ERROR = 1759, E.AVAILABILITY_TIME = 600, E.HOTEL_CLOSED_AND_OPENS = 3728, E.HOTEL_CLOSES_AND_OPENS_AT = 2771, E.HOTEL_WILL_CLOSE_MINUTES = 1050, E.HOTEL_MAINTENANCE = 1350, E.JUKEBOX_PLAYLIST_FULL = 105, E.JUKEBOX_SONG_DISKS = 34, E.NOW_PLAYING = 469, E.OFFICIAL_SONG_ID = 1381, E.PLAYLIST = 1748, E.PLAYLIST_SONG_ADDED = 1140, E.TRAX_SONG_INFO = 3365, E.USER_SONG_DISKS_INVENTORY = 2602, E.CHECK_USER_NAME = 563, E.CFH_SANCTION = 2782, E.CFH_TOPICS = 325, E.CFH_SANCTION_STATUS = 2221, E.CAMPAIGN_CALENDAR_DATA = 2531, E.CAMPAIGN_CALENDAR_DOOR_OPENED = 2551, E.BUILDERS_CLUB_FURNI_COUNT = 3828, E.BUILDERS_CLUB_SUBSCRIPTION = 1452, E.CATALOG_PAGE_EXPIRATION = 2668, E.CATALOG_EARLIEST_EXPIRY = 2515, E.CLUB_GIFT_SELECTED = 659, E.TARGET_OFFER_NOT_FOUND = 1237, E.TARGET_OFFER = 119, E.DIRECT_SMS_CLUB_BUY = 195, E.ROOM_AD_PURCHASE = 2468, E.NOT_ENOUGH_BALANCE = 3914, E.LIMITED_OFFER_APPEARING_NEXT = 44, E.IS_OFFER_GIFTABLE = 761, E.CLUB_EXTENDED_OFFER = 3964, E.SEASONAL_CALENDAR_OFFER = 1889, E.COMPETITION_ENTRY_SUBMIT = 1177, E.COMPETITION_VOTING_INFO = 3506, E.COMPETITION_TIMING_CODE = 1745, E.COMPETITION_USER_PART_OF = 3841, E.COMPETITION_NO_OWNED_ROOMS = 2064, E.COMPETITION_SECONDS_UNTIL = 3926, E.BADGE_POINT_LIMITS = 2501, E.BADGE_REQUEST_FULFILLED = 2998, E.HELPER_TALENT_TRACK = 3406, E.TALENT_TRACK_LEVEL = 1203, E.TALENT_TRACK_LEVEL_UP = 638, E.USER_BANNED = 1683, E.BOT_RECEIVED = 3684, E.PET_LEVEL_NOTIFICATION = 859, E.PET_RECEIVED = 1111, E.MODERATION_CAUTION = 1890, E.YOUTUBE_CONTROL_VIDEO = 1554, E.YOUTUBE_DISPLAY_PLAYLISTS = 1112, E.YOUTUBE_DISPLAY_VIDEO = 1411, E.CFH_DISABLED_NOTIFY = 1651, E.QUESTION = 2665, E.POLL_CONTENTS = 2997, E.POLL_ERROR = 662, E.POLL_OFFER = 3785, E.POLL_ROOM_RESULT = 5201, E.POLL_START_ROOM = 5200, E.QUESTION_ANSWERED = 2589, E.QUESTION_FINISHED = 1066, E.CFH_PENDING_CALLS = 1121, E.GUIDE_ON_DUTY_STATUS = 1548, E.GUIDE_SESSION_ATTACHED = 1591, E.GUIDE_SESSION_DETACHED = 138, E.GUIDE_SESSION_ENDED = 1456, E.GUIDE_SESSION_ERROR = 673, E.GUIDE_SESSION_INVITED_TO_GUIDE_ROOM = 219, E.GUIDE_SESSION_MESSAGE = 841, E.GUIDE_SESSION_PARTNER_IS_TYPING = 1016, E.GUIDE_SESSION_REQUESTER_ROOM = 1847, E.GUIDE_SESSION_STARTED = 3209, E.GUIDE_TICKET_CREATION_RESULT = 3285, E.GUIDE_TICKET_RESOLUTION = 2674, E.GUIDE_REPORTING_STATUS = 3463, E.HOTEL_MERGE_NAME_CHANGE = 1663, E.ISSUE_CLOSE_NOTIFICATION = 934, E.QUIZ_DATA = 2927, E.QUIZ_RESULTS = 2772, E.CFH_PENDING_CALLS_DELETED = 77, E.CFH_REPLY = 3796, E.CHAT_REVIEW_SESSION_DETACHED = 30, E.CHAT_REVIEW_SESSION_OFFERED_TO_GUIDE = 735, E.CHAT_REVIEW_SESSION_RESULTS = 3276, E.CHAT_REVIEW_SESSION_STARTED = 143, E.CHAT_REVIEW_SESSION_VOTING_STATUS = 1829, E.SCR_SEND_KICKBACK_INFO = 3277, E.PET_STATUS = 1907, E.GROUP_DEACTIVATE = 3129, E.PET_RESPECTED = 2788, E.PET_SUPPLEMENT = 3441, E.NOOBNESS_LEVEL = 3738, E.DISCONNECT_REASON = 4e3, E.CAN_CREATE_ROOM_EVENT = 2599, E.FAVORITE_GROUP_UDPATE = 3403, E.NO_SUCH_FLAT = 84, E.ROOM_SETTINGS_ERROR = 2897, E.SHOW_ENFORCE_ROOM_CATEGORY = 3896, E.CUSTOM_USER_NOTIFICATION = 909, E.NEW_USER_EXPERIENCE_GIFT_OFFER = 3575, E.RESTORE_CLIENT = 426, E.FIREWORK_CHARGE_DATA = 5210, E.NEW_USER_EXPERIENCE_NOT_COMPLETE = 3639, E.CONNECTION_ERROR = 1004, E.ACCOUNT_SAFETY_LOCK_STATUS_CHANGE = 1243, E.PHONE_COLLECTION_STATE = 2890, E.PHONE_TRY_NUMBER_RESULT = 800, E.PHONE_TRY_VERIFICATION_CODE_RESULT = 91, E.EXTENDED_PROFILE_CHANGED = 876, E.WELCOME_GIFT_CHANGE_EMAIL_RESULT = 2293, E.WELCOME_GIFT_STATUS = 2707, E.HANDSHAKE_INIT_DIFFIE = 1347, E.HANDSHAKE_COMPLETE_DIFFIE = 3885, E.RENTABLE_SPACE_RENT_OK = 2046, E.RENTABLE_SPACE_STATUS = 3559, E.RENTABLE_SPACE_RENT_FAILED = 1868, E.EMAIL_STATUS = 612, E.CHANGE_EMAIL_RESULT = 1815, E.WEEKLY_GAME_REWARD = 2641, E.WEEKLY_GAME_REWARD_WINNERS = 3097, E.WEEKLY_COMPETITIVE_LEADERBOARD = 3512, E.WEEKLY_COMPETITIVE_FRIENDS_LEADERBOARD = 3560, E.WEEKLY_GAME2_FRIENDS_LEADERBOARD = 2270, E.WEEKLY_GAME2_LEADERBOARD = 2196, E.RENTABLE_FURNI_RENT_OR_BUYOUT_OFFER = 35, E.HANDSHAKE_IDENTITY_ACCOUNT = 3523;
let R = E;
class FB {
  flush() {
    return this._canShowInterstitial = !1, !0;
  }
  parse(t) {
    return t ? (this._canShowInterstitial = t.readBoolean(), !0) : !1;
  }
  get canShowInterstitial() {
    return this._canShowInterstitial;
  }
}
class wB {
  flush() {
    return this._errorCode = 0, this._filteredText = null, !0;
  }
  parse(t) {
    return t ? (this._errorCode = t.readInt(), this._filteredText = t.readString(), !0) : !1;
  }
  get errorCode() {
    return this._errorCode;
  }
  get filteredText() {
    return this._filteredText;
  }
}
class GB {
  flush() {
    return this._isOpen = !1, this._onShutdown = !1, this._isAuthenticUser = !1, !0;
  }
  parse(t) {
    return t ? (this._isOpen = t.readBoolean(), this._onShutdown = t.readBoolean(), t.bytesAvailable && (this._isAuthenticUser = t.readBoolean()), !0) : !1;
  }
  get isOpen() {
    return this._isOpen;
  }
  get onShutdown() {
    return this._onShutdown;
  }
  get isAuthenticUser() {
    return this._isAuthenticUser;
  }
}
class BB {
  flush() {
    return this._isOpen = !1, this._minutesUntilChange = 0, !0;
  }
  parse(t) {
    return t ? (this._isOpen = t.readInt() > 0, this._minutesUntilChange = t.readInt(), !0) : !1;
  }
  get isOpen() {
    return this._isOpen;
  }
  get minutesUntilChange() {
    return this._minutesUntilChange;
  }
}
class kB {
  flush() {
    return this._openHour = 0, this._openMinute = 0, !0;
  }
  parse(t) {
    return t ? (this._openHour = t.readInt(), this._openMinute = t.readInt(), !0) : !1;
  }
  get openHour() {
    return this._openHour;
  }
  get openMinute() {
    return this._openMinute;
  }
}
class zB {
  flush() {
    return this._openHour = 0, this._openMinute = 0, this._userThrownOutAtClose = !1, !0;
  }
  parse(t) {
    return t ? (this._openHour = t.readInt(), this._openMinute = t.readInt(), this._userThrownOutAtClose = t.readBoolean(), !0) : !1;
  }
  get openHour() {
    return this._openHour;
  }
  get openMinute() {
    return this._openMinute;
  }
  get userThrowOutAtClose() {
    return this._userThrownOutAtClose;
  }
}
class VB {
  flush() {
    return this._minutes = 0, !0;
  }
  parse(t) {
    return t ? (this._minutes = t.readInt(), !0) : !1;
  }
  get openMinute() {
    return this._minutes;
  }
}
class HB {
  flush() {
    return this._isInMaintenance = !1, this._minutesUntilMaintenance = 0, this._duration = 15, !0;
  }
  parse(t) {
    return t ? (this._isInMaintenance = t.readBoolean(), this._minutesUntilMaintenance = t.readInt(), t.bytesAvailable && (this._duration = t.readInt()), !0) : !1;
  }
  get isInMaintenance() {
    return this._isInMaintenance;
  }
  get minutesUntilMaintenance() {
    return this._minutesUntilMaintenance;
  }
  get duration() {
    return this._duration;
  }
}
class YB {
  flush() {
    return this._resultCode = -1, this._name = "", this._nameSuggestions = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._resultCode = t.readInt(), this._name = t.readString();
    let e = t.readInt();
    for (; e > 0; )
      this._nameSuggestions.push(t.readString()), e--;
    return !0;
  }
  get resultCode() {
    return this._resultCode;
  }
  get name() {
    return this._name;
  }
  get nameSuggestions() {
    return this._nameSuggestions;
  }
}
class WB {
  flush() {
    return this._resultCode = -1, this._name = "", this._nameSuggestions = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._resultCode = t.readInt(), this._name = t.readString();
    let e = t.readInt();
    for (; e > 0; )
      this._nameSuggestions.push(t.readString()), e--;
    return !0;
  }
  get resultCode() {
    return this._resultCode;
  }
  get name() {
    return this._name;
  }
  get nameSuggestions() {
    return this._nameSuggestions;
  }
}
class jB {
  flush() {
    return this._figure = "", this._gender = "", !0;
  }
  parse(t) {
    return t ? (this._figure = t.readString(), this._gender = t.readString(), this._gender && (this._gender = this._gender.toUpperCase()), !0) : !1;
  }
  get figure() {
    return this._figure;
  }
  get gender() {
    return this._gender;
  }
}
class XB {
  constructor(t) {
    this._slotId = t.readInt(), this._figureString = t.readString(), this._gender = t.readString();
  }
  get slotId() {
    return this._slotId;
  }
  get figureString() {
    return this._figureString;
  }
  get gender() {
    return this._gender;
  }
}
class KB {
  flush() {
    return this._state = 0, this._outfits = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._state = t.readInt();
    let e = t.readInt();
    for (; e > 0; )
      this._outfits.push(new XB(t)), e--;
    return !0;
  }
  get state() {
    return this._state;
  }
  get outfits() {
    return this._outfits;
  }
}
class JT {
  constructor(t) {
    if (!t) throw new Error("invalid_parser");
    this._id = t.readInt(), this._name = t.readString(), this._motto = t.readString(), this._gender = t.readString(), this._figure = t.readString();
  }
  get id() {
    return this._id;
  }
  get name() {
    return this._name;
  }
  get motto() {
    return this._motto;
  }
  get figure() {
    return this._figure;
  }
  get gender() {
    return this._gender;
  }
}
class qB {
  flush() {
    return this._item = null, this._openInventory = !1, !0;
  }
  parse(t) {
    return t ? (this._item = new JT(t), this._openInventory = t.readBoolean(), !0) : !1;
  }
  get item() {
    return this._item;
  }
  openInventory() {
    return this._openInventory;
  }
}
class $B {
  flush() {
    return this._items = null, !0;
  }
  parse(t) {
    this._items = /* @__PURE__ */ new Map();
    let e = t.readInt();
    for (; e > 0; ) {
      const s = new JT(t);
      this._items.set(s.id, s), e--;
    }
    return !0;
  }
  get items() {
    return this._items;
  }
}
class ZB {
  flush() {
    return this._boughtAsGift = !1, this._item = null, !0;
  }
  parse(t) {
    return t ? (this._boughtAsGift = t.readBoolean(), this._item = new JT(t), !0) : !1;
  }
  get boughtAsGift() {
    return this._boughtAsGift;
  }
  get item() {
    return this._item;
  }
}
class QB {
  flush() {
    return this._itemId = 0, !0;
  }
  parse(t) {
    return t ? (this._itemId = t.readInt(), !0) : !1;
  }
  get itemId() {
    return this._itemId;
  }
}
class JB {
  constructor(t) {
    this._name = t.readString(), this._id = t.readInt(), this._consequence = t.readString();
  }
  get name() {
    return this._name;
  }
  get id() {
    return this._id;
  }
  get consequence() {
    return this._consequence;
  }
}
class tk {
  constructor(t) {
    this._topics = [], this._name = t.readString();
    let e = t.readInt();
    for (; e > 0; )
      this._topics.push(new JB(t)), e--;
  }
  dispose() {
    this._disposed || (this._disposed = !0, this._topics = null);
  }
  get disposed() {
    return this._disposed;
  }
  get name() {
    return this._name;
  }
  get topics() {
    return this._topics;
  }
}
class ek {
  constructor(t) {
    this._tradeLockInfo = "", this._machineBanInfo = "", this._name = t.readString(), this._sanctionLengthInHours = t.readInt(), this._probationDays = t.readInt(), this._avatarOnly = t.readBoolean(), t.bytesAvailable && (this._tradeLockInfo = t.readString()), t.bytesAvailable && (this._machineBanInfo = t.readString());
  }
  get name() {
    return this._name;
  }
  get sanctionLengthInHours() {
    return this._sanctionLengthInHours;
  }
  get avatarOnly() {
    return this._avatarOnly;
  }
  get tradeLockInfo() {
    return this._tradeLockInfo;
  }
  get machineBanInfo() {
    return this._machineBanInfo;
  }
}
class sk {
  flush() {
    return this._issueId = -1, this._accountId = 1, this._sanctionType = null, !0;
  }
  parse(t) {
    return t ? (this._issueId = t.readInt(), this._accountId = t.readInt(), this._sanctionType = new ek(t), !0) : !1;
  }
  get issueId() {
    return this._issueId;
  }
  get accountId() {
    return this._accountId;
  }
  get sanctionType() {
    return this._sanctionType;
  }
}
class ik {
  flush() {
    return this._callForHelpCategories = null, !0;
  }
  parse(t) {
    if (!t) return !1;
    this._callForHelpCategories = [];
    let e = t.readInt();
    for (; e > 0; )
      this._callForHelpCategories.push(new tk(t)), e--;
    return !0;
  }
  get callForHelpCategories() {
    return this._callForHelpCategories;
  }
}
class rk {
  flush() {
    return this._isSanctionNew = !1, this._isSanctionActive = !1, this._sanctionName = null, this._sanctionLengthHours = 0, this._sanctionReason = null, this._sanctionCreationTime = null, this._probationHoursLeft = 0, this._nextSanctionName = null, this._nextSanctionLengthHours = 0, this._hasCustomMute = !1, this._tradeLockExpiryTime = null, !0;
  }
  parse(t) {
    return t ? (this._isSanctionNew = t.readBoolean(), this._isSanctionActive = t.readBoolean(), this._sanctionName = t.readString(), this._sanctionLengthHours = t.readInt(), t.readInt(), this._sanctionReason = t.readString(), this._sanctionCreationTime = t.readString(), this._probationHoursLeft = t.readInt(), this._nextSanctionName = t.readString(), this._nextSanctionLengthHours = t.readInt(), t.readInt(), this._hasCustomMute = t.readBoolean(), t.bytesAvailable && (this._tradeLockExpiryTime = t.readString()), !0) : !1;
  }
  get isSanctionNew() {
    return this._isSanctionNew;
  }
  get isSanctionActive() {
    return this._isSanctionActive;
  }
  get sanctionName() {
    return this._sanctionName;
  }
  get sanctionLengthHours() {
    return this._sanctionLengthHours;
  }
  get sanctionReason() {
    return this._sanctionReason;
  }
  get sanctionCreationTime() {
    return this._sanctionCreationTime;
  }
  get probationHoursLeft() {
    return this._probationHoursLeft;
  }
  get nextSanctionName() {
    return this._nextSanctionName;
  }
  get nextSanctionLengthHours() {
    return this._nextSanctionLengthHours;
  }
  get hasCustomMute() {
    return this._hasCustomMute;
  }
  get tradeLockExpiryTime() {
    return this._tradeLockExpiryTime;
  }
}
class nk {
  constructor() {
    this._ok = !1, this._secondsToWait = 0;
  }
  flush() {
    return this._ok = !1, this._secondsToWait = 0, this._extraDataId = null, !0;
  }
  parse(t) {
    return t ? (this._ok = t.readBoolean(), this._secondsToWait = t.readInt(), this._ok && t.bytesAvailable && (this._extraDataId = t.readString()), !0) : !1;
  }
  get ok() {
    return this._ok;
  }
  get secondsToWait() {
    return this._secondsToWait;
  }
  get extraDataId() {
    return this._extraDataId;
  }
}
class ak {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class ok {
  flush() {
    return this._roomType = null, this._roomId = -1, !0;
  }
  parse(t) {
    return t ? (this._roomType = t.readString(), this._roomId = t.readInt(), !0) : !1;
  }
  get roomType() {
    return this._roomType;
  }
  get roomId() {
    return this._roomId;
  }
}
class hk {
  flush() {
    return this._url = "", !0;
  }
  parse(t) {
    return t ? (this._url = t.readString(), !0) : !1;
  }
  get url() {
    return this._url;
  }
}
class uk {
  constructor() {
    this._ok = !1, this._errorReason = null;
  }
  flush() {
    return this._ok = !1, this._errorReason = null, !0;
  }
  parse(t) {
    return t ? (this._ok = t.readBoolean(), this._errorReason = t.readString(), !0) : !1;
  }
  get ok() {
    return this._ok;
  }
  get errorReason() {
    return this._errorReason;
  }
}
class lk {
  constructor() {
    this._creditPrice = 0, this._ducketPrice = 0, this._publishDucketPrice = 0;
  }
  flush() {
    return this._creditPrice = 0, this._ducketPrice = 0, this._publishDucketPrice = 0, !0;
  }
  parse(t) {
    return t ? (this._creditPrice = t.readInt(), this._ducketPrice = t.readInt(), t.bytesAvailable && (this._publishDucketPrice = t.readInt()), !0) : !1;
  }
  get creditPrice() {
    return this._creditPrice;
  }
  get ducketPrice() {
    return this._ducketPrice;
  }
  get publishDucketPrice() {
    return this._publishDucketPrice;
  }
}
class ck {
  constructor() {
    this._ok = !0, this._renderLimitHit = !1;
  }
  flush() {
    return this._ok = !0, this._renderLimitHit = !1, !0;
  }
  parse(t) {
    return t ? (t.bytesAvailable && (this._ok = t.readBoolean(), this._renderLimitHit = t.readBoolean()), !0) : !1;
  }
  get ok() {
    return this._ok;
  }
  get isRenderLimitHit() {
    return this._renderLimitHit;
  }
}
class tI {
  parse(t) {
    if (!t) return !1;
    this._campaignName = t.readString(), this._campaignImage = t.readString(), this._currentDay = t.readInt(), this._campaignDays = t.readInt(), this._openedDays = [];
    let e = t.readInt();
    for (let s = 0; s < e; s++)
      this._openedDays.push(t.readInt());
    this._missedDays = [], e = t.readInt();
    for (let s = 0; s < e; s++)
      this._missedDays.push(t.readInt());
    return !0;
  }
  clone() {
    const t = new tI();
    return t.campaignDays = this._campaignDays, t.campaignImage = this._campaignImage, t.campaignName = this._campaignName, t.currentDay = this._currentDay, t.missedDays = this._missedDays, t.openedDays = this._openedDays, t;
  }
  get campaignName() {
    return this._campaignName;
  }
  set campaignName(t) {
    this._campaignName = t;
  }
  get campaignImage() {
    return this._campaignImage;
  }
  set campaignImage(t) {
    this._campaignImage = t;
  }
  get currentDay() {
    return this._currentDay;
  }
  set currentDay(t) {
    this._currentDay = t;
  }
  get campaignDays() {
    return this._campaignDays;
  }
  set campaignDays(t) {
    this._campaignDays = t;
  }
  get openedDays() {
    return this._openedDays;
  }
  set openedDays(t) {
    this._openedDays = t;
  }
  get missedDays() {
    return this._missedDays;
  }
  set missedDays(t) {
    this._missedDays = t;
  }
}
class _k {
  flush() {
    return this._calendarData = null, !0;
  }
  parse(t) {
    return t ? (this._calendarData = new tI(), this._calendarData.parse(t), !0) : !1;
  }
  get calendarData() {
    return this._calendarData;
  }
}
class dk {
  flush() {
    return this._doorOpened = !1, this._productName = null, this._customImage = null, this._furnitureClassName = null, !0;
  }
  parse(t) {
    return t ? (this._doorOpened = t.readBoolean(), this._productName = t.readString(), this._customImage = t.readString(), this._furnitureClassName = t.readString(), !0) : !1;
  }
  get doorOpened() {
    return this._doorOpened;
  }
  get productName() {
    return this._productName;
  }
  get customImage() {
    return this._customImage;
  }
  get furnitureClassName() {
    return this._furnitureClassName;
  }
}
class fk {
  flush() {
    return this._totalCoinsForBonus = -1, this._coinsStillRequiredToBuy = -1, this._productType = "", this._productClassId = -1, !0;
  }
  parse(t) {
    return t ? (this._productType = t.readString(), this._productClassId = t.readInt(), this._totalCoinsForBonus = t.readInt(), this._coinsStillRequiredToBuy = t.readInt(), !0) : !1;
  }
  get totalCoinsForBonus() {
    return this._totalCoinsForBonus;
  }
  get coinsStillRequiredToBuy() {
    return this._coinsStillRequiredToBuy;
  }
  get productType() {
    return this._productType;
  }
  get productClassId() {
    return this._productClassId;
  }
}
class gk {
  flush() {
    return this._furniCount = 0, !0;
  }
  parse(t) {
    return t ? (this._furniCount = t.readInt(), !0) : !1;
  }
  get furniCount() {
    return this._furniCount;
  }
}
class pk {
  flush() {
    return this._secondsLeft = 0, this._furniLimit = 0, this._maxFurniLimit = 0, this._secondsLeftWithGrace = 0, !0;
  }
  parse(t) {
    return t ? (this._secondsLeft = t.readInt(), this._furniLimit = t.readInt(), this._maxFurniLimit = t.readInt(), t.bytesAvailable ? this._secondsLeftWithGrace = t.readInt() : this._secondsLeftWithGrace = this._secondsLeft, !0) : !1;
  }
  get secondsLeft() {
    return this._secondsLeft;
  }
  get furniLimit() {
    return this._furniLimit;
  }
  get maxFurniLimit() {
    return this._maxFurniLimit;
  }
  get secondsLeftWithGrace() {
    return this._secondsLeftWithGrace;
  }
}
class mk {
  constructor(t) {
    this._maxPurchaseSize = t.readInt(), this._bundleSize = t.readInt(), this._bundleDiscountSize = t.readInt(), this._bonusThreshold = t.readInt(), this._additionalBonusDiscountThresholdQuantities = [];
    let e = t.readInt();
    for (; e > 0; )
      this._additionalBonusDiscountThresholdQuantities.push(t.readInt()), e--;
  }
  get maxPurchaseSize() {
    return this._maxPurchaseSize;
  }
  get bundleSize() {
    return this._bundleSize;
  }
  get bundleDiscountSize() {
    return this._bundleDiscountSize;
  }
  get bonusThreshold() {
    return this._bonusThreshold;
  }
  get additionalBonusDiscountThresholdQuantities() {
    return this._additionalBonusDiscountThresholdQuantities;
  }
}
class Ek {
  flush() {
    return this._bundleDiscountRuleset = null, !0;
  }
  parse(t) {
    return t ? (this._bundleDiscountRuleset = new mk(t), !0) : !1;
  }
  get bundleDiscountRuleset() {
    return this._bundleDiscountRuleset;
  }
}
class eI {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this.flush(), this.parse(t);
  }
  flush() {
    return this._visible = !1, this._icon = 0, this._pageId = -1, this._pageName = null, this._localization = null, this._children = [], this._offerIds = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._visible = t.readBoolean(), this._icon = t.readInt(), this._pageId = t.readInt(), this._pageName = t.readString(), this._localization = t.readString();
    let e = t.readInt();
    for (; e > 0; )
      this._offerIds.push(t.readInt()), e--;
    let s = t.readInt();
    for (; s > 0; )
      this._children.push(new eI(t)), s--;
    return !0;
  }
  get visible() {
    return this._visible;
  }
  get icon() {
    return this._icon;
  }
  get pageId() {
    return this._pageId;
  }
  get pageName() {
    return this._pageName;
  }
  get localization() {
    return this._localization;
  }
  get children() {
    return this._children;
  }
  get offerIds() {
    return this._offerIds;
  }
}
class Tk {
  flush() {
    return this._root = null, !0;
  }
  parse(t) {
    return t ? (this._root = new eI(t), this._newAdditionsAvailable = t.readBoolean(), this._catalogType = t.readString(), !0) : !1;
  }
  get root() {
    return this._root;
  }
  get newAdditionsAvailable() {
    return this._newAdditionsAvailable;
  }
  get catalogType() {
    return this._catalogType;
  }
}
class Ik {
  constructor(t) {
    this._images = [], this._texts = [];
    let e = t.readInt();
    for (; e > 0; )
      this._images.push(t.readString()), e--;
    let s = t.readInt();
    for (; s > 0; )
      this._texts.push(t.readString()), s--;
  }
  get images() {
    return this._images;
  }
  get texts() {
    return this._texts;
  }
}
class Sk {
  flush() {
    return this._pageName = null, this._pageId = 0, this._secondsToExpiry = 0, this._image = null, !0;
  }
  parse(t) {
    return t ? (this._pageId = t.readInt(), this._pageName = t.readString(), this._secondsToExpiry = t.readInt(), this._image = t.readString(), !0) : !1;
  }
  get pageName() {
    return this._pageName;
  }
  get pageId() {
    return this._pageId;
  }
  get secondsToExpiry() {
    return this._secondsToExpiry;
  }
  get image() {
    return this._image;
  }
}
class jd {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this.flush(), this.parse(t);
  }
  flush() {
    return this._productType = null, this._furniClassId = -1, this._extraParam = null, this._productCount = 0, this._uniqueLimitedItem = !1, this._uniqueLimitedItemSeriesSize = 0, this._uniqueLimitedItemsLeft = 0, !0;
  }
  parse(t) {
    switch (this._productType = t.readString().toUpperCase(), this._productType) {
      case en.BADGE:
        return this._extraParam = t.readString(), this._productCount = 1, !0;
      default:
        return this._furniClassId = t.readInt(), this._extraParam = t.readString(), this._productCount = t.readInt(), this._uniqueLimitedItem = t.readBoolean(), this._uniqueLimitedItem && (this._uniqueLimitedItemSeriesSize = t.readInt(), this._uniqueLimitedItemsLeft = t.readInt()), !0;
    }
  }
  get productType() {
    return this._productType;
  }
  get furniClassId() {
    return this._furniClassId;
  }
  get extraParam() {
    return this._extraParam;
  }
  get productCount() {
    return this._productCount;
  }
  get uniqueLimitedItem() {
    return this._uniqueLimitedItem;
  }
  get uniqueLimitedSeriesSize() {
    return this._uniqueLimitedItemSeriesSize;
  }
  get uniqueLimitedItemsLeft() {
    return this._uniqueLimitedItemsLeft;
  }
}
class Xd {
  constructor(t) {
    this._offerId = t.readInt(), this._localizationId = t.readString(), this._rent = t.readBoolean(), this._priceCredits = t.readInt(), this._priceActivityPoints = t.readInt(), this._priceActivityPointsType = t.readInt(), this._giftable = t.readBoolean(), this._products = [];
    let e = t.readInt();
    for (; e > 0; )
      this._products.push(new jd(t)), e--;
    this._clubLevel = t.readInt(), this._bundlePurchaseAllowed = t.readBoolean(), this._isPet = t.readBoolean(), this._previewImage = t.readString();
  }
  get offerId() {
    return this._offerId;
  }
  get localizationId() {
    return this._localizationId;
  }
  get rent() {
    return this._rent;
  }
  get priceCredits() {
    return this._priceCredits;
  }
  get priceActivityPoints() {
    return this._priceActivityPoints;
  }
  get priceActivityPointsType() {
    return this._priceActivityPointsType;
  }
  get clubLevel() {
    return this._clubLevel;
  }
  get giftable() {
    return this._giftable;
  }
  get bundlePurchaseAllowed() {
    return this._bundlePurchaseAllowed;
  }
  get isPet() {
    return this._isPet;
  }
  get previewImage() {
    return this._previewImage;
  }
  get products() {
    return this._products;
  }
}
const Vr = class Vr {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this.flush(), this.parse(t);
  }
  flush() {
    return this._type = -1, this._position = null, this._itemName = null, this._itemPromoImage = null, this._catalogPageLocation = null, this._productCode = null, this._productOfferId = 0, this._expirationTime = 0, !0;
  }
  parse(t) {
    if (!t) return !1;
    switch (this._position = t.readInt(), this._itemName = t.readString(), this._itemPromoImage = t.readString(), this._type = t.readInt(), this._type) {
      case Vr.ITEM_CATALOGUE_PAGE:
        this._catalogPageLocation = t.readString();
        break;
      case Vr.ITEM_PRODUCT_OFFER:
        this._productOfferId = t.readInt();
        break;
      case Vr.ITEM_IAP:
        this._productCode = t.readString();
        break;
    }
    const e = t.readInt();
    return this._expirationTime = e > 0 ? e * 1e3 + 0 : 0, !0;
  }
  get type() {
    return this._type;
  }
  get position() {
    return this._position;
  }
  get itemName() {
    return this._itemName;
  }
  get itemPromoImage() {
    return this._itemPromoImage;
  }
  get catalogPageLocation() {
    return this._catalogPageLocation;
  }
  get productCode() {
    return this._productCode;
  }
  get productOfferId() {
    return this._productOfferId;
  }
  get expirationTime() {
    return this._expirationTime;
  }
};
Vr.ITEM_CATALOGUE_PAGE = 0, Vr.ITEM_PRODUCT_OFFER = 1, Vr.ITEM_IAP = 2;
let Bp = Vr;
class Ak {
  flush() {
    return this._pageId = -1, this._catalogType = null, this._layoutCode = null, this._localization = null, this._offers = [], this._offerId = -1, this._acceptSeasonCurrencyAsCredits = !1, this._frontPageItems = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._pageId = t.readInt(), this._catalogType = t.readString(), this._layoutCode = t.readString(), this._localization = new Ik(t);
    let e = t.readInt();
    for (; e > 0; )
      this._offers.push(new Xd(t)), e--;
    if (this._offerId = t.readInt(), this._acceptSeasonCurrencyAsCredits = t.readBoolean(), t.bytesAvailable) {
      let s = t.readInt();
      for (; s > 0; )
        this._frontPageItems.push(new Bp(t)), s--;
    }
    return !0;
  }
  get pageId() {
    return this._pageId;
  }
  get catalogType() {
    return this._catalogType;
  }
  get layoutCode() {
    return this._layoutCode;
  }
  get localization() {
    return this._localization;
  }
  get offers() {
    return this._offers;
  }
  get offerId() {
    return this._offerId;
  }
  get acceptSeasonCurrencyAsCredits() {
    return this._acceptSeasonCurrencyAsCredits;
  }
  get frontPageItems() {
    return this._frontPageItems;
  }
}
class Rk {
  flush() {
    return this._pageName = null, this._secondsToExpiry = 0, this._image = null, !0;
  }
  parse(t) {
    return t ? (this._pageName = t.readString(), this._secondsToExpiry = t.readInt(), this._image = t.readString(), !0) : !1;
  }
  get pageName() {
    return this._pageName;
  }
  get secondsToExpiry() {
    return this._secondsToExpiry;
  }
  get image() {
    return this._image;
  }
}
class Ok {
  flush() {
    return this._instantlyRefreshCatalogue = !1, this._newFurniDataHash = null, !0;
  }
  parse(t) {
    return t ? (this._instantlyRefreshCatalogue = t.readBoolean(), t.bytesAvailable && (this._newFurniDataHash = t.readString()), !0) : !1;
  }
  get instantlyRefreshCatalogue() {
    return this._instantlyRefreshCatalogue;
  }
  get newFurniDataHash() {
    return this._newFurniDataHash;
  }
}
class yk {
  constructor(t) {
    this._offerId = t.readInt(), this._isVip = t.readBoolean(), this._daysRequired = t.readInt(), this._isSelectable = t.readBoolean();
  }
  get offerId() {
    return this._offerId;
  }
  get isVip() {
    return this._isVip;
  }
  get isSelectable() {
    return this._isSelectable;
  }
  get daysRequired() {
    return this._daysRequired;
  }
}
class vk {
  flush() {
    return !0;
  }
  parse(t) {
    if (!t) return !1;
    this._offers = [], this._giftData = /* @__PURE__ */ new Map(), this._daysUntilNextGift = t.readInt(), this._giftsAvailable = t.readInt();
    const e = t.readInt();
    for (let r = 0; r < e; r++)
      this._offers.push(new Xd(t));
    const s = t.readInt();
    for (let r = 0; r < s; r++) {
      const n = new yk(t);
      this._giftData.set(n.offerId, n);
    }
    return !0;
  }
  get offers() {
    return this._offers;
  }
  get daysUntilNextGift() {
    return this._daysUntilNextGift;
  }
  get giftsAvailable() {
    return this._giftsAvailable;
  }
  set giftsAvailable(t) {
    this._giftsAvailable = t;
  }
  getOfferExtraData(t) {
    return t ? this._giftData.get(t) : null;
  }
  get giftData() {
    return this._giftData;
  }
}
class Ck {
  flush() {
    return this._productCode = null, this._products = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._productCode = t.readString();
    let e = t.readInt();
    for (; e > 0; )
      this._products.push(new jd(t)), e--;
    return !0;
  }
  get productCode() {
    return this._productCode;
  }
  get products() {
    return this._products;
  }
}
class Nv {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this._offerId = t.readInt(), this._productCode = t.readString(), t.readBoolean(), this._priceCredits = t.readInt(), this._priceActivityPoints = t.readInt(), this._priceActivityPointsType = t.readInt(), this._vip = t.readBoolean(), this._months = t.readInt(), this._extraDays = t.readInt(), this._giftable = t.readBoolean(), this._daysLeftAfterPurchase = t.readInt(), this._year = t.readInt(), this._month = t.readInt(), this._day = t.readInt();
  }
  get offerId() {
    return this._offerId;
  }
  get productCode() {
    return this._productCode;
  }
  get priceCredits() {
    return this._priceCredits;
  }
  get priceActivityPoints() {
    return this._priceActivityPoints;
  }
  get priceActivityPointsType() {
    return this._priceActivityPointsType;
  }
  get vip() {
    return this._vip;
  }
  get months() {
    return this._months;
  }
  get extraDays() {
    return this._extraDays;
  }
  get daysLeftAfterPurchase() {
    return this._daysLeftAfterPurchase;
  }
  get year() {
    return this._year;
  }
  get month() {
    return this._month;
  }
  get day() {
    return this._day;
  }
  get giftable() {
    return this._giftable;
  }
}
class xk extends Nv {
  constructor(t) {
    super(t), this._originalPrice = t.readInt(), this._originalActivityPointPrice = t.readInt(), this._originalActivityPointType = t.readInt(), this._subscriptionDaysLeft = t.readInt();
  }
  get originalPrice() {
    return this._originalPrice * this.months;
  }
  get originalActivityPointPrice() {
    return this._originalActivityPointPrice * this.months;
  }
  get originalActivityPointType() {
    return this._originalActivityPointType;
  }
  get discountCreditAmount() {
    return this._originalPrice * this.months - this.priceCredits;
  }
  get discountActivityPointAmount() {
    return this.originalActivityPointPrice * this.months - this.priceActivityPoints;
  }
  get subscriptionDaysLeft() {
    return this._subscriptionDaysLeft;
  }
}
class Mk {
  flush() {
    return this._available = !1, this._pricePointUrl = null, this._market = null, this._lengthInDays = 0, !0;
  }
  parse(t) {
    return t ? (this._pricePointUrl = t.readString(), this._pricePointUrl !== "" && (this._available = !0), this._market = t.readString(), this._lengthInDays = t.readInt(), !0) : !1;
  }
  get available() {
    return this._available;
  }
  get pricePointUrl() {
    return this._pricePointUrl;
  }
  get market() {
    return this._market;
  }
  get lengthInDays() {
    return this._lengthInDays;
  }
}
class bk {
  constructor(t) {
    this._stuffId = t.readInt(), this._charges = t.readInt(), this._SafeStr_6935 = t.readInt(), this._SafeStr_6936 = t.readInt(), this._SafeStr_6518 = t.readInt(), this._SafeStr_7875 = t.readInt();
  }
  get stuffId() {
    return this._stuffId;
  }
  get charges() {
    return this._charges;
  }
  get _SafeStr_5946() {
    return this._SafeStr_6935;
  }
  get _SafeStr_5944() {
    return this._SafeStr_6936;
  }
  get _SafeStr_7876() {
    return this._SafeStr_7875;
  }
  get _SafeStr_5945() {
    return this._SafeStr_6518;
  }
}
class Pk {
  flush() {
    return this._fireworkChargeData = null, !0;
  }
  parse(t) {
    return t ? (this._fireworkChargeData = new bk(t), !0) : !1;
  }
  get fireworkChargeData() {
    return this._fireworkChargeData;
  }
}
class Nk {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class Uk {
  constructor() {
    this._isEnabled = !1, this._price = null, this._giftWrappers = null, this._boxTypes = null, this._ribbonTypes = null, this._giftFurnis = null;
  }
  flush() {
    return this._boxTypes = null, this._giftFurnis = null, this._giftWrappers = null, this._ribbonTypes = null, this._isEnabled = null, this._price = null, !0;
  }
  parse(t) {
    if (!t) return !1;
    const e = [], s = [], r = [], n = [];
    this._isEnabled = t.readBoolean(), this._price = t.readInt();
    let a = t.readInt(), o = 0;
    for (; o < a; )
      e.push(t.readInt()), o++;
    for (a = t.readInt(), o = 0; o < a; )
      s.push(t.readInt()), o++;
    for (a = t.readInt(), o = 0; o < a; )
      r.push(t.readInt()), o++;
    for (a = t.readInt(), o = 0; o < a; )
      n.push(t.readInt()), o++;
    return this._giftWrappers = e, this._ribbonTypes = r, this._giftFurnis = n, this._boxTypes = s, !0;
  }
  get giftWrappers() {
    return this._giftWrappers;
  }
  get ribbonTypes() {
    return this._ribbonTypes;
  }
  get giftFurnis() {
    return this._giftFurnis;
  }
  get boxTypes() {
    return this._boxTypes;
  }
  get isEnabled() {
    return this._isEnabled;
  }
  get price() {
    return this._price;
  }
}
class Dk {
  flush() {
    return this._offer = null, !0;
  }
  parse(t) {
    return t ? (this._offer = new xk(t), !0) : !1;
  }
  get offer() {
    return this._offer;
  }
}
class Lk {
  flush() {
    return this._offers = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; )
      this._offers.push(new Nv(t)), e--;
    return !0;
  }
  get offers() {
    return this._offers;
  }
}
class Fk {
  flush() {
    return this._offerId = 0, this._isGiftable = !1, !0;
  }
  parse(t) {
    return t ? (this._offerId = t.readInt(), this._isGiftable = t.readBoolean(), !0) : !1;
  }
  get offerId() {
    return this._offerId;
  }
  get isGiftable() {
    return this._isGiftable;
  }
}
class wk {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class Gk {
  flush() {
    return this._appearsInSeconds = -1, this._pageId = -1, this._offerId = -1, this._productType = "", !0;
  }
  parse(t) {
    return t ? (this._appearsInSeconds = t.readInt(), this._pageId = t.readInt(), this._offerId = t.readInt(), this._productType = t.readString(), !0) : !1;
  }
  get appearsInSeconds() {
    return this._appearsInSeconds;
  }
  get pageId() {
    return this._pageId;
  }
  get offerId() {
    return this._offerId;
  }
  get productType() {
    return this._productType;
  }
}
class Bk {
  constructor() {
    this._notEnoughCredits = !1, this._notEnoughActivityPoints = !1, this._activityPointType = 0;
  }
  flush() {
    return this._notEnoughCredits = !1, this._notEnoughActivityPoints = !1, this._activityPointType = 0, !0;
  }
  parse(t) {
    return t ? (this._notEnoughCredits = t.readBoolean(), this._notEnoughActivityPoints = t.readBoolean(), t.bytesAvailable && (this._activityPointType = t.readInt()), !0) : !1;
  }
  get notEnoughCredits() {
    return this._notEnoughCredits;
  }
  get notEnoughActivityPoints() {
    return this._notEnoughActivityPoints;
  }
  get activityPointType() {
    return this._activityPointType;
  }
}
class kk {
  flush() {
    return this._offer = null, !0;
  }
  parse(t) {
    return t ? (this._offer = new Xd(t), !0) : !1;
  }
  get offer() {
    return this._offer;
  }
}
class zk {
  flush() {
    return this._code = 0, !0;
  }
  parse(t) {
    return t ? (this._code = t.readInt(), !0) : !1;
  }
  get code() {
    return this._code;
  }
}
class Vk {
  flush() {
    return this._code = 0, !0;
  }
  parse(t) {
    return t ? (this._code = t.readInt(), !0) : !1;
  }
  get code() {
    return this._code;
  }
}
class Hk {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this.flush(), this.parse(t);
  }
  flush() {
    return this._offerId = -1, this._localizationId = null, this._rent = !1, this._priceCredits = 0, this._priceActivityPoints = 0, this._priceActivityPointsType = 0, this._clubLevel = 0, this._giftable = !1, this._bundlePurchaseAllowed = !1, this._products = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._offerId = t.readInt(), this._localizationId = t.readString(), this._rent = t.readBoolean(), this._priceCredits = t.readInt(), this._priceActivityPoints = t.readInt(), this._priceActivityPointsType = t.readInt(), this._giftable = t.readBoolean();
    let e = t.readInt();
    for (; e > 0; )
      this._products.push(new jd(t)), e--;
    return this._clubLevel = t.readInt(), this._bundlePurchaseAllowed = t.readBoolean(), !0;
  }
  get offerId() {
    return this._offerId;
  }
  get localizationId() {
    return this._localizationId;
  }
  get rent() {
    return this._rent;
  }
  get priceCredits() {
    return this._priceCredits;
  }
  get priceActivityPoints() {
    return this._priceActivityPoints;
  }
  get priceActivityPointsType() {
    return this._priceActivityPointsType;
  }
  get clubLevel() {
    return this._clubLevel;
  }
  get giftable() {
    return this._giftable;
  }
  get bundlePurchaseAllowed() {
    return this._bundlePurchaseAllowed;
  }
  get products() {
    return this._products;
  }
}
class Yk {
  flush() {
    return this._offer = null, !0;
  }
  parse(t) {
    return t ? (this._offer = new Hk(t), !0) : !1;
  }
  get offer() {
    return this._offer;
  }
}
class Wk {
  flush() {
    return this._clubLevel = 0, this._securityLevel = 0, this._isAmbassador = !1, !0;
  }
  parse(t) {
    return t ? (this._clubLevel = t.readInt(), this._securityLevel = t.readInt(), this._isAmbassador = t.readBoolean(), !0) : !1;
  }
  get clubLevel() {
    return this._clubLevel;
  }
  get securityLevel() {
    return this._securityLevel;
  }
  get isAmbassador() {
    return this._isAmbassador;
  }
}
const Q_ = class Q_ {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._status = t.readInt(), !0) : !1;
  }
  get status() {
    return this._status;
  }
};
Q_.SAFETY_LOCK_STATUS_LOCKED = 0, Q_.SAFETY_LOCK_STATUS_UNLOCKED = 1;
let pc = Q_;
class jk {
  flush() {
    return this._result = -1, this._validationInfo = "", !0;
  }
  parse(t) {
    return t ? (this._result = t.readInt(), this._validationInfo = t.readString(), !0) : !1;
  }
  get result() {
    return this._result;
  }
  get validationInfo() {
    return this._validationInfo;
  }
}
const BI = class BI {
  flush() {
    return this._result = -1, !0;
  }
  parse(t) {
    return t ? (this._result = t.readInt(), !0) : !1;
  }
  get result() {
    return this._result;
  }
};
BI.EMAIL_STATUS_OK = 0;
let kp = BI;
class Xk {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this.flush(), this.parse(t);
  }
  flush() {
    return this._relationshipStatusType = bg.NONE, this._friendCount = 0, this._randomFriendId = 0, this._randomFriendFigure = null, this._randomFriendName = null, !0;
  }
  parse(t) {
    return t ? (this._relationshipStatusType = t.readInt(), this._friendCount = t.readInt(), this._randomFriendId = t.readInt(), this._randomFriendName = t.readString(), this._randomFriendFigure = t.readString(), !0) : !1;
  }
  get relationshipStatusType() {
    return this._relationshipStatusType;
  }
  get friendCount() {
    return this._friendCount;
  }
  get randomFriendId() {
    return this._randomFriendId;
  }
  get randomFriendName() {
    return this._randomFriendName;
  }
  get randomFriendFigure() {
    return this._randomFriendFigure;
  }
}
class Kk {
  flush() {
    return this._userId = 0, this._relationshipStatusMap = null, !0;
  }
  parse(t) {
    if (!t) return !1;
    this._userId = t.readInt(), this._relationshipStatusMap = new be();
    const e = t.readInt();
    for (let s = 0; s < e; s++) {
      const r = new Xk(t);
      this._relationshipStatusMap.add(r.relationshipStatusType, r);
    }
    return !0;
  }
  get userId() {
    return this._userId;
  }
  get relationshipStatusMap() {
    return this._relationshipStatusMap;
  }
}
class qk {
  flush() {
    return this._userId = null, this._badges = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._userId = t.readInt();
    let e = t.readInt();
    for (; e > 0; ) {
      t.readInt();
      const s = t.readString();
      this._badges.push(s), e--;
    }
    return !0;
  }
  get userId() {
    return this._userId;
  }
  get badges() {
    return this._badges;
  }
}
class tnt {
  flush() {
    return this._figure = null, this._gender = null, !0;
  }
  parse(t) {
    return t ? (this._figure = t.readString(), this._gender = t.readString(), !0) : !1;
  }
  get figure() {
    return this._figure;
  }
  get gender() {
    return this._gender;
  }
}
class $k {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this.flush(), this.parse(t);
  }
  flush() {
    return this._userId = 0, this._username = null, this._figure = null, this._gender = null, this._motto = null, this._realName = null, this._directMail = !1, this._respectsReceived = 0, this._respectsRemaining = 0, this._respectsPetRemaining = 0, this._streamPublishingAllowed = !1, this._lastAccessDate = null, this._canChangeName = !1, this._safetyLocked = !1, !0;
  }
  parse(t) {
    return t ? (this._userId = t.readInt(), this._username = t.readString(), this._figure = t.readString(), this._gender = t.readString(), this._motto = t.readString(), this._realName = t.readString(), this._directMail = t.readBoolean(), this._respectsReceived = t.readInt(), this._respectsRemaining = t.readInt(), this._respectsPetRemaining = t.readInt(), this._streamPublishingAllowed = t.readBoolean(), this._lastAccessDate = t.readString(), this._canChangeName = t.readBoolean(), this._safetyLocked = t.readBoolean(), !0) : !1;
  }
  get userId() {
    return this._userId;
  }
  get username() {
    return this._username;
  }
  get figure() {
    return this._figure;
  }
  get gender() {
    return this._gender;
  }
  get motto() {
    return this._motto;
  }
  get realName() {
    return this._realName;
  }
  get directMail() {
    return this._directMail;
  }
  get respectsReceived() {
    return this._respectsReceived;
  }
  get respectsRemaining() {
    return this._respectsRemaining;
  }
  get respectsPetRemaining() {
    return this._respectsPetRemaining;
  }
  get streamPublishingAllowed() {
    return this._streamPublishingAllowed;
  }
  get lastAccessedDate() {
    return this._lastAccessDate;
  }
  get canChangeName() {
    return this._canChangeName;
  }
  get safetyLocked() {
    return this._safetyLocked;
  }
}
class Zk {
  flush() {
    return this._userInfo = null, !0;
  }
  parse(t) {
    return !(!t || (this._userInfo = new $k(t), !this._userInfo));
  }
  get userInfo() {
    return this._userInfo;
  }
}
class Qk {
  flush() {
    return this._webId = -1, this._id = -1, this._newName = "", !0;
  }
  parse(t) {
    return t ? (this._webId = t.readInt(), this._id = t.readInt(), this._newName = t.readString(), !0) : !1;
  }
  get webId() {
    return this._webId;
  }
  get id() {
    return this._id;
  }
  get newName() {
    return this._newName;
  }
}
class Uv {
  constructor(t) {
    this._groupId = t.readInt(), this._groupName = t.readString(), this._badgeCode = t.readString(), this._colorA = t.readString(), this._colorB = t.readString(), this._favourite = t.readBoolean(), this._ownerId = t.readInt(), this._hasForum = t.readBoolean();
  }
  get groupId() {
    return this._groupId;
  }
  get groupName() {
    return this._groupName;
  }
  get badgeCode() {
    return this._badgeCode;
  }
  get colorA() {
    return this._colorA;
  }
  get colorB() {
    return this._colorB;
  }
  get favourite() {
    return this._favourite;
  }
  get ownerId() {
    return this._ownerId;
  }
  get hasForum() {
    return this._hasForum;
  }
}
class Jk {
  flush() {
    return this._id = 0, this._username = null, this._figure = null, this._motto = null, this._registration = null, this._achievementPoints = 0, this._friendsCount = 0, this._isMyFriend = !1, this._requestSent = !1, this._isOnline = !1, this._groups = [], this._secondsSinceLastVisit = 0, this._openProfileWindow = !1, !0;
  }
  parse(t) {
    if (!t) return !1;
    this._id = t.readInt(), this._username = t.readString(), this._figure = t.readString(), this._motto = t.readString(), this._registration = t.readString(), this._achievementPoints = t.readInt(), this._friendsCount = t.readInt(), this._isMyFriend = t.readBoolean(), this._requestSent = t.readBoolean(), this._isOnline = t.readBoolean();
    const e = t.readInt();
    for (let s = 0; s < e; s++)
      this._groups.push(new Uv(t));
    return this._secondsSinceLastVisit = t.readInt(), this._openProfileWindow = t.readBoolean(), !0;
  }
  get id() {
    return this._id;
  }
  get username() {
    return this._username;
  }
  get figure() {
    return this._figure;
  }
  get motto() {
    return this._motto;
  }
  get registration() {
    return this._registration;
  }
  get achievementPoints() {
    return this._achievementPoints;
  }
  get friendsCount() {
    return this._friendsCount;
  }
  get isMyFriend() {
    return this._isMyFriend;
  }
  get requestSent() {
    return this._requestSent;
  }
  get isOnline() {
    return this._isOnline;
  }
  get groups() {
    return this._groups;
  }
  get secondsSinceLastVisit() {
    return this._secondsSinceLastVisit;
  }
  get openProfileWindow() {
    return this._openProfileWindow;
  }
}
class tz {
  flush() {
    return this._volumeSystem = 0, this._volumeFurni = 0, this._volumeTrax = 0, this._oldChat = !1, this._roomInvites = !1, this._cameraFollow = !1, this._flags = 0, this._chatType = 0, !0;
  }
  parse(t) {
    return t ? (this._volumeSystem = t.readInt(), this._volumeFurni = t.readInt(), this._volumeTrax = t.readInt(), this._oldChat = t.readBoolean(), this._roomInvites = t.readBoolean(), this._cameraFollow = t.readBoolean(), this._flags = t.readInt(), this._chatType = t.readInt(), !0) : !1;
  }
  get volumeSystem() {
    return this._volumeSystem;
  }
  get volumeFurni() {
    return this._volumeFurni;
  }
  get volumeTrax() {
    return this._volumeTrax;
  }
  get oldChat() {
    return this._oldChat;
  }
  get roomInvites() {
    return this._roomInvites;
  }
  get cameraFollow() {
    return this._cameraFollow;
  }
  get flags() {
    return this._flags;
  }
  get chatType() {
    return this._chatType;
  }
}
class ez {
  flush() {
    return this._roomUnitId = -1, this._tags = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._roomUnitId = t.readInt();
    let e = t.readInt();
    for (; e > 0; )
      this._tags.push(t.readString()), e--;
    return !0;
  }
  get roomUnitId() {
    return this._roomUnitId;
  }
  get tags() {
    return this._tags;
  }
}
class sz {
  flush() {
    return this._email = null, this._isVerified = !1, this._allowChange = !1, !0;
  }
  parse(t) {
    return t ? (this._email = t.readString(), this._isVerified = t.readBoolean(), this._allowChange = t.readBoolean(), !0) : !1;
  }
  get email() {
    return this._email;
  }
  get isVerified() {
    return this._isVerified;
  }
  get allowChange() {
    return this._allowChange;
  }
}
class iz {
  flush() {
    return this._userId = -1, !0;
  }
  parse(t) {
    return t ? (this._userId = t.readInt(), !0) : !1;
  }
  get userId() {
    return this._userId;
  }
}
class rz {
  flush() {
    return this._groupId = -1, !0;
  }
  parse(t) {
    return t ? (this._groupId = t.readInt(), !0) : !1;
  }
  get groupId() {
    return this._groupId;
  }
}
class nz {
  flush() {
    return this._groupId = -1, this._requester = null, !0;
  }
  parse(t) {
    return t ? (this._groupId = t.readInt(), this._requester = new rE(t), !0) : !1;
  }
  get groupId() {
    return this._groupId;
  }
  get requester() {
    return this._requester;
  }
}
const kI = class kI {
  flush() {
    return this._reason = -1, !0;
  }
  parse(t) {
    return t ? (this._reason = t.readInt(), !0) : !1;
  }
  get reason() {
    return this._reason;
  }
};
kI.INSUFFICIENT_SUBSCRIPTION_LEVEL = 2;
let zp = kI;
class az {
  flush() {
    return this._guildId = -1, this._reason = -1, !0;
  }
  parse(t) {
    return t ? (this._guildId = t.readInt(), this._reason = t.readInt(), !0) : !1;
  }
  get guildId() {
    return this._guildId;
  }
  get reason() {
    return this._reason;
  }
}
class oz {
  flush() {
    return this._groups = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; )
      this._groups.push(new Uv(t)), e--;
    return !0;
  }
  get groups() {
    return this._groups;
  }
}
class hz {
  flush() {
    return this._badges = /* @__PURE__ */ new Map(), !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; ) {
      const s = t.readInt(), r = t.readString();
      this._badges.set(s, r), e--;
    }
    return !0;
  }
  get badges() {
    return this._badges;
  }
}
const zI = class zI {
  flush() {
    return this._reason = -1, !0;
  }
  parse(t) {
    return t ? (this._reason = t.readInt(), !0) : !1;
  }
  get reason() {
    return this._reason;
  }
};
zI.INSUFFICIENT_SUBSCRIPTION_LEVEL = 4;
let Vp = zI;
class uz {
  flush() {
    return this._ignoredUsers = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._ignoredUsers = [];
    let e = t.readInt();
    for (; e > 0; )
      this._ignoredUsers.push(t.readString()), e--;
    return !0;
  }
  get ignoredUsers() {
    return this._ignoredUsers;
  }
}
class lz {
  flush() {
    return this._result = -1, this._name = null, !0;
  }
  parse(t) {
    return t ? (this._result = t.readInt(), this._name = t.readString(), !0) : !1;
  }
  get result() {
    return this._result;
  }
  get name() {
    return this._name;
  }
}
class cz {
  flush() {
    return this._link = null, !0;
  }
  parse(t) {
    return t ? (this._link = t.readString(), !0) : !1;
  }
  get link() {
    return this._link;
  }
}
class _z {
  flush() {
    return this._credits = null, !0;
  }
  parse(t) {
    return t ? (this._credits = t.readString(), !0) : !1;
  }
  get credits() {
    return this._credits;
  }
}
class dz {
  flush() {
    return this._currencies = /* @__PURE__ */ new Map(), !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; )
      this._currencies.set(t.readInt(), t.readInt()), e--;
    return !0;
  }
  get currencies() {
    return this._currencies;
  }
}
const _o = class _o {
  flush() {
    return this._productName = null, this._daysToPeriodEnd = 0, this._memberPeriods = 0, this._periodsSubscribedAhead = 0, this._responseType = 0, this._hasEverBeenMember = !1, this._isVip = !1, this._pastClubDays = 0, this._pastVipDays = 0, this._minutesUntilExpiration = 0, this._minutesSinceLastModified = 0, !0;
  }
  parse(t) {
    return t ? (this._productName = t.readString(), this._daysToPeriodEnd = t.readInt(), this._memberPeriods = t.readInt(), this._periodsSubscribedAhead = t.readInt(), this._responseType = t.readInt(), this._hasEverBeenMember = t.readBoolean(), this._isVip = t.readBoolean(), this._pastClubDays = t.readInt(), this._pastVipDays = t.readInt(), this._minutesUntilExpiration = t.readInt(), t.bytesAvailable && (this._minutesSinceLastModified = t.readInt()), !0) : !1;
  }
  get productName() {
    return this._productName;
  }
  get daysToPeriodEnd() {
    return this._daysToPeriodEnd;
  }
  get memberPeriods() {
    return this._memberPeriods;
  }
  get periodsSubscribedAhead() {
    return this._periodsSubscribedAhead;
  }
  get responseType() {
    return this._responseType;
  }
  get hasEverBeenMember() {
    return this._hasEverBeenMember;
  }
  get isVip() {
    return this._isVip;
  }
  get pastClubDays() {
    return this._pastClubDays;
  }
  get pastVipDays() {
    return this._pastVipDays;
  }
  get minutesUntilExpiration() {
    return this._minutesUntilExpiration;
  }
  get minutesSinceLastModified() {
    return this._minutesSinceLastModified;
  }
};
_o.RESPONSE_TYPE_LOGIN = 1, _o.RESPONSE_TYPE_PURCHASE = 2, _o.RESPONSE_TYPE_DISCOUNT_AVAILABLE = 3, _o.RESPONSE_TYPE_CITIZENSHIP_DISCOUNT = 4;
let Hp = _o;
const fo = class fo {
  constructor(t) {
    if (this._unseen = 0, !t) throw new Error("invalid_parser");
    this._achievementId = t.readInt(), this._level = t.readInt(), this._badgeId = t.readString(), this._scoreAtStartOfLevel = t.readInt(), this._scoreLimit = Math.max(1, t.readInt()), this._levelRewardPoints = t.readInt(), this._levelRewardPointType = t.readInt(), this._currentPoints = t.readInt(), this._finalLevel = t.readBoolean(), this._category = t.readString(), this._subCategory = t.readString(), this._levelCount = t.readInt(), this._displayMethod = t.readInt();
  }
  get achievementId() {
    return this._achievementId;
  }
  get badgeId() {
    return this._badgeId;
  }
  get level() {
    return this._level;
  }
  get scoreAtStartOfLevel() {
    return this._scoreAtStartOfLevel;
  }
  get scoreLimit() {
    return this._scoreLimit - this._scoreAtStartOfLevel;
  }
  get levelRewardPoints() {
    return this._levelRewardPoints;
  }
  get levelRewardPointType() {
    return this._levelRewardPointType;
  }
  get currentPoints() {
    return this._currentPoints - this._scoreAtStartOfLevel;
  }
  get finalLevel() {
    return this._finalLevel;
  }
  get category() {
    return this._category;
  }
  get subCategory() {
    return this._subCategory;
  }
  get levelCount() {
    return this._levelCount;
  }
  get firstLevelAchieved() {
    return this._level > 1 || this._finalLevel;
  }
  setMaxProgress() {
    this._currentPoints = this._scoreLimit;
  }
  get displayMethod() {
    return this._displayMethod;
  }
  get progress() {
    return this._currentPoints;
  }
  get toNextProgress() {
    return this._scoreLimit;
  }
  set unseen(t) {
    this._unseen = t;
  }
  get unseen() {
    return this._unseen;
  }
  reset(t) {
    this._achievementId = t._achievementId, this._level = t._level, this._badgeId = t._badgeId, this._scoreAtStartOfLevel = t._scoreAtStartOfLevel, this._scoreLimit = t._scoreLimit, this._levelRewardPoints = t._levelRewardPoints, this._levelRewardPointType = t._levelRewardPointType, this._currentPoints = t._currentPoints, this._finalLevel = t._finalLevel, this._category = t.category, this._subCategory = t._subCategory, this._levelCount = t._levelCount, this._displayMethod = t._displayMethod;
  }
};
fo.DISPLAY_METHOD_OBSOLETE = -1, fo.DISPLAY_METHOD_SHOW_LEVEL_PROGRESS = 0, fo.DISPLAY_METHOD_NEVER_SHOW_PROGRESS = 1, fo.DISPLAY_METHOD_SHOW_TOTAL_PROGRESS = 2;
let mc = fo;
class fz {
  flush() {
    return this._achievement = null, !0;
  }
  parse(t) {
    return t ? (this._achievement = new mc(t), !0) : !1;
  }
  get achievement() {
    return this._achievement;
  }
}
const J_ = class J_ {
  constructor(t) {
    this._achievementId = t.readInt(), this._level = t.readInt(), this._badgeId = t.readString(), this._requiredLevel = t.readInt(), this._state = t.readInt();
  }
  dispose() {
    this._achievementId = 0, this._level = 0, this._badgeId = "", this._requiredLevel = 0;
  }
  get achievementId() {
    return this._achievementId;
  }
  get level() {
    return this._level;
  }
  get badgeId() {
    return this._badgeId;
  }
  get requiredLevel() {
    return this._requiredLevel;
  }
  get enabled() {
    return this._state === J_.STATE_SELECTABLE;
  }
  get state() {
    return this._state;
  }
};
J_.STATE_SELECTABLE = 0;
let Yp = J_;
class gz {
  flush() {
    return this._achievements = [], this._defaultCategory = null, !0;
  }
  parse(t) {
    if (!t) return !1;
    this._achievements = [];
    let e = t.readInt();
    for (; e > 0; )
      this._achievements.push(new mc(t)), e--;
    return this._defaultCategory = t.readString(), !0;
  }
  get achievements() {
    return this._achievements;
  }
  get defaultCategory() {
    return this._defaultCategory;
  }
}
class pz {
  flush() {
    return this._score = 0, !0;
  }
  parse(t) {
    return t ? (this._score = t.readInt(), !0) : !1;
  }
  get score() {
    return this._score;
  }
}
class mz {
  get type() {
    return this._type;
  }
  set type(t) {
    this._type = t;
  }
  get subType() {
    return this._subType;
  }
  set subType(t) {
    this._subType = t;
  }
  get duration() {
    return this._duration;
  }
  set duration(t) {
    this._duration = t;
  }
  get inactiveEffectsInInventory() {
    return this._inactiveEffectsInInventory;
  }
  set inactiveEffectsInInventory(t) {
    this._inactiveEffectsInInventory = t;
  }
  get secondsLeftIfActive() {
    return this._secondsLeftIfActive;
  }
  set secondsLeftIfActive(t) {
    this._secondsLeftIfActive = t;
  }
  get isPermanent() {
    return this._permanent;
  }
  set isPermanent(t) {
    this._permanent = t;
  }
}
class Ez {
  flush() {
    return this._type = 0, this._duration = 0, this._isPermanent = !1, !0;
  }
  parse(t) {
    return t ? (this._type = t.readInt(), this._duration = t.readInt(), this._isPermanent = t.readBoolean(), !0) : !1;
  }
  get type() {
    return this._type;
  }
  get duration() {
    return this._duration;
  }
  get isPermanent() {
    return this._isPermanent;
  }
}
class Tz {
  flush() {
    return this._type = 0, this._subType = 0, this._duration = 0, this._permanent = !1, !0;
  }
  parse(t) {
    return t ? (this._type = t.readInt(), this._subType = t.readInt(), this._duration = t.readInt(), this._permanent = t.readBoolean(), !0) : !1;
  }
  get type() {
    return this._type;
  }
  get subType() {
    return this._subType;
  }
  get duration() {
    return this._duration;
  }
  get isPermanent() {
    return this._permanent;
  }
}
class Iz {
  flush() {
    return this._type = 0, !0;
  }
  parse(t) {
    return t ? (this._type = t.readInt(), !0) : !1;
  }
  get type() {
    return this._type;
  }
}
class Sz {
  flush() {
    return this._type = 0, !0;
  }
  parse(t) {
    return t ? (this._type = t.readInt(), !0) : !1;
  }
  get type() {
    return this._type;
  }
}
class Az {
  flush() {
    return this._effects = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; ) {
      const s = new mz();
      s.type = t.readInt(), s.subType = t.readInt(), s.duration = t.readInt(), s.inactiveEffectsInInventory = t.readInt(), s.secondsLeftIfActive = t.readInt(), s.isPermanent = t.readBoolean(), this._effects.push(s), e--;
    }
    return !0;
  }
  get effects() {
    return this._effects;
  }
}
class Rz {
  constructor(t, e) {
    if (!e) throw new Error("invalid_parser");
    this._badgeId = "ACH_" + t + e.readInt(), this._limit = e.readInt();
  }
  get badgeId() {
    return this._badgeId;
  }
  get limit() {
    return this._limit;
  }
}
class Oz {
  flush() {
    return this._data = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; ) {
      const s = t.readString(), r = t.readInt();
      let n = 0;
      for (; n < r; )
        this._data.push(new Rz(s, t)), n++;
      e--;
    }
    return !0;
  }
  get data() {
    return this._data;
  }
}
class yz {
  flush() {
    return this._badgeId = 0, this._badgeCode = null, !0;
  }
  parse(t) {
    return t ? (this._badgeId = t.readInt(), this._badgeCode = t.readString(), !0) : !1;
  }
  get badgeId() {
    return this._badgeId;
  }
  get badgeCode() {
    return this._badgeCode;
  }
}
class vz {
  flush() {
    return this._allBadgeCodes = [], this._activeBadgeCodes = null, this._badgeIds = null, !0;
  }
  parse(t) {
    if (!t) return !1;
    this._allBadgeCodes = [], this._activeBadgeCodes = [], this._badgeIds = new be();
    let e = t.readInt();
    for (; e > 0; ) {
      const s = t.readInt(), r = t.readString();
      this._badgeIds.add(r, s), this._allBadgeCodes.push(r), e--;
    }
    for (e = t.readInt(); e > 0; ) {
      t.readInt();
      const s = t.readString();
      this._activeBadgeCodes.push(s), e--;
    }
    return !0;
  }
  getBadgeId(t) {
    return this._badgeIds.getValue(t);
  }
  getAllBadgeCodes() {
    return this._allBadgeCodes;
  }
  getActiveBadgeCodes() {
    return this._activeBadgeCodes;
  }
}
class Cz {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._requestCode = t.readString(), this._fulfilled = t.readBoolean(), !0) : !1;
  }
  get requestCode() {
    return this._requestCode;
  }
  get fulfilled() {
    return this._fulfilled;
  }
}
class xz {
  flush() {
    return this._figureSetIds = [], this._boundFurnitureNames = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; )
      this._figureSetIds.push(t.readInt()), e--;
    let s = t.readInt();
    for (; s > 0; )
      this._boundFurnitureNames.push(t.readString()), s--;
    return !0;
  }
  get figureSetIds() {
    return this._figureSetIds;
  }
  get boundsFurnitureNames() {
    return this._boundFurnitureNames;
  }
}
class Mz {
  flush() {
    return this._itemId = 0, !0;
  }
  parse(t) {
    return t ? (this._itemId = t.readInt(), !0) : !1;
  }
  get itemId() {
    return this._itemId;
  }
}
class bz {
  flush() {
    return this._itemId = 0, !0;
  }
  parse(t) {
    return t ? (this._itemId = t.readInt(), !0) : !1;
  }
  get itemId() {
    return this._itemId;
  }
}
const go = class go {
  flush() {
    return this._reason = 0, this._parameter = "", !0;
  }
  parse(t) {
    return t ? (this._reason = t.readInt(), this._parameter = t.readString(), !0) : !1;
  }
  get reason() {
    return this._reason;
  }
  get parameter() {
    return this._parameter;
  }
};
go.REASON_FULL = 1, go.REASON_CLOSED = 2, go.REASON_QUEUE_ERROR = 3, go.REASON_BANNED = 4;
let Wp = go;
class Pz {
  flush() {
    return this._userName = null, !0;
  }
  parse(t) {
    return t ? (this._userName = t.readString(), !0) : !1;
  }
  get userName() {
    return this._userName;
  }
}
class Nz {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class Uz {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class Dz {
  flush() {
    return this._controllerLevel = mr.NONE, !0;
  }
  parse(t) {
    return t ? (this._controllerLevel = t.readInt(), !0) : !1;
  }
  get controllerLevel() {
    return this._controllerLevel;
  }
}
class Lz {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class Fz {
  flush() {
    return this._roomId = 0, !0;
  }
  parse(t) {
    return t ? (this._roomId = t.readInt(), !0) : !1;
  }
  get roomId() {
    return this._roomId;
  }
}
class wz {
  flush() {
    return this._botId = -1, this._commandId = -1, this._data = "", !0;
  }
  parse(t) {
    return t ? (this._botId = t.readInt(), this._commandId = t.readInt(), this._data = t.readString(), !0) : !1;
  }
  get botId() {
    return this._botId;
  }
  get commandId() {
    return this._commandId;
  }
  get data() {
    return this._data;
  }
}
class Gz {
  flush() {
    return this._botId = -1, !0;
  }
  parse(t) {
    return t ? (this._botId = t.readInt(), !0) : !1;
  }
  get botId() {
    return this._botId;
  }
}
class Bz {
  constructor(t) {
    this._id = t.readInt(), this._data = t.readString();
  }
  get id() {
    return this._id;
  }
  get data() {
    return this._data;
  }
}
class kz {
  flush() {
    return this._botId = -1, this._skillList = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._botId = t.readInt();
    let e = t.readInt();
    for (; e > 0; )
      this._skillList.push(new Bz(t)), e--;
    return !0;
  }
  get botId() {
    return this._botId;
  }
  get skillList() {
    return this._skillList;
  }
}
class zz {
  constructor(t) {
    this._userId = t.readInt(), this._userName = t.readString();
  }
  get userId() {
    return this._userId;
  }
  get userName() {
    return this._userName;
  }
}
class Vz {
  flush() {
    return this._roomId = 0, this._bannedUsers = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._roomId = t.readInt();
    let e = t.readInt();
    for (; e > 0; )
      this._bannedUsers.push(new zz(t)), e--;
    return !0;
  }
  get roomId() {
    return this._roomId;
  }
  get bannedUsers() {
    return this._bannedUsers;
  }
}
class Hz {
  constructor(t) {
    this._userId = t.readInt(), this._userName = t.readString();
  }
  get userId() {
    return this._userId;
  }
  get userName() {
    return this._userName;
  }
  get selected() {
    return this._selected;
  }
  set selected(t) {
    this._selected = t;
  }
}
class Yz {
  flush() {
    return this._roomId = 0, this._data = null, !0;
  }
  parse(t) {
    return t ? (this._roomId = t.readInt(), this._data = new Hz(t), !0) : !1;
  }
  get roomId() {
    return this._roomId;
  }
  get data() {
    return this._data;
  }
}
class Wz {
  flush() {
    return this._roomId = 0, this._userId = 0, !0;
  }
  parse(t) {
    return t ? (this._roomId = t.readInt(), this._userId = t.readInt(), !0) : !1;
  }
  get roomId() {
    return this._roomId;
  }
  get userId() {
    return this._userId;
  }
}
class jz {
  flush() {
    return this._roomId = 0, this._users = /* @__PURE__ */ new Map(), !0;
  }
  parse(t) {
    if (!t) return !1;
    this._roomId = t.readInt();
    let e = t.readInt();
    for (; e > 0; ) {
      const s = t.readInt(), r = t.readString();
      this._users.set(s, r), e--;
    }
    return !0;
  }
  get roomId() {
    return this._roomId;
  }
  get users() {
    return this._users;
  }
}
class Xz {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._isMuted = t.readBoolean(), !0) : !1;
  }
  get isMuted() {
    return this._isMuted;
  }
}
class Kz {
  flush() {
    return this._roomId = 0, !0;
  }
  parse(t) {
    return t ? (this._roomId = t.readInt(), !0) : !1;
  }
  get roomId() {
    return this._roomId;
  }
}
const ys = class ys {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this._mode = t.readInt(), this._weight = t.readInt(), this._speed = t.readInt(), this._distance = t.readInt(), this._protection = t.readInt();
  }
  get mode() {
    return this._mode;
  }
  get weight() {
    return this._weight;
  }
  get speed() {
    return this._speed;
  }
  get distance() {
    return this._distance;
  }
  get protection() {
    return this._protection;
  }
};
ys.CHAT_MODE_FREE_FLOW = 0, ys.CHAT_MODE_LINE_BY_LINE = 1, ys.CHAT_BUBBLE_WIDTH_WIDE = 0, ys.CHAT_BUBBLE_WIDTH_NORMAL = 1, ys.CHAT_BUBBLE_WIDTH_THIN = 2, ys.CHAT_SCROLL_SPEED_FAST = 0, ys.CHAT_SCROLL_SPEED_NORMAL = 1, ys.CHAT_SCROLL_SPEED_SLOW = 2, ys.FLOOD_FILTER_STRICT = 0, ys.FLOOD_FILTER_NORMAL = 1, ys.FLOOD_FILTER_LOOSE = 2;
let Nu = ys;
const Xh = class Xh {
  constructor(t) {
    this._allowMute = t.readInt(), this._allowKick = t.readInt(), this._allowBan = t.readInt();
  }
  get allowMute() {
    return this._allowMute;
  }
  get allowKick() {
    return this._allowKick;
  }
  get allowBan() {
    return this._allowBan;
  }
};
Xh.MODERATION_LEVEL_NONE = 0, Xh.MODERATION_LEVEL_USER_WITH_RIGHTS = 1, Xh.MODERATION_LEVEL_ALL = 2;
let Ec = Xh;
const Le = class Le {
  constructor() {
    this._roomId = -1, this._name = null, this._description = null, this._doorMode = Le.DOORMODE_OPEN, this._categoryId = -1, this._maximumVisitors = 0, this._maximumVisitorsLimit = 0, this._tags = [], this._tradeMode = Le.TRADEMODE_NOT_ALLOWED, this._allowPets = !1, this._allowFoodConsume = !1, this._allowWalkThrough = !1, this._hideWalls = !1, this._wallThickness = 0, this._floorThickness = 0, this._controllersById = /* @__PURE__ */ new Map(), this._controllerList = null, this._highlightedUserId = -1, this._bannedUsersById = /* @__PURE__ */ new Map(), this._bannedUsersList = null, this._roomModerationSettings = null, this._chatSettings = null, this._allowNavigatorDynamicCats = !1;
  }
  static from(t) {
    const e = new Le();
    return e._roomId = t._roomId, e._name = t._name, e._description = t._description, e._doorMode = t._doorMode, e._categoryId = t._categoryId, e._maximumVisitors = t._maximumVisitors, e._maximumVisitorsLimit = t._maximumVisitorsLimit, e._tags = t._tags, e._tradeMode = t._tradeMode, e._allowPets = t._allowPets, e._allowFoodConsume = t._allowFoodConsume, e._allowWalkThrough = t._allowWalkThrough, e._hideWalls = t._hideWalls, e._wallThickness = t._wallThickness, e._floorThickness = t._floorThickness, e._controllersById = t._controllersById, e._controllerList = t._controllerList, e._highlightedUserId = t._highlightedUserId, e._bannedUsersById = t._bannedUsersById, e._bannedUsersList = t._bannedUsersList, e._roomModerationSettings = t._roomModerationSettings, e._chatSettings = t._chatSettings, e._allowNavigatorDynamicCats = t._allowNavigatorDynamicCats, e;
  }
  static getDoorModeLocalizationKey(t) {
    switch (t) {
      case Le.DOORMODE_OPEN:
        return "${navigator.door.mode.open}";
      case Le.DOORMODE_CLOSED:
        return "${navigator.door.mode.closed}";
      case Le.DOORMODE_PASSWORD:
        return "${navigator.door.mode.password}";
      case Le.DOORMODE_INVISIBLE:
        return "${navigator.door.mode.invisible}";
      case Le.DOORMODE_NOOBS_ONLY:
        return "${navigator.door.mode.noobs_only}";
    }
    return "";
  }
  get tradeMode() {
    return this._tradeMode;
  }
  set tradeMode(t) {
    this._tradeMode = t;
  }
  get allowPets() {
    return this._allowPets;
  }
  set allowPets(t) {
    this._allowPets = t;
  }
  get allowFoodConsume() {
    return this._allowFoodConsume;
  }
  set allowFoodConsume(t) {
    this._allowFoodConsume = t;
  }
  get allowWalkThrough() {
    return this._allowWalkThrough;
  }
  set allowWalkThrough(t) {
    this._allowWalkThrough = t;
  }
  get hideWalls() {
    return this._hideWalls;
  }
  set hideWalls(t) {
    this._hideWalls = t;
  }
  get wallThickness() {
    return this._wallThickness;
  }
  set wallThickness(t) {
    this._wallThickness = t;
  }
  get floorThickness() {
    return this._floorThickness;
  }
  set floorThickness(t) {
    this._floorThickness = t;
  }
  get roomId() {
    return this._roomId;
  }
  set roomId(t) {
    this._roomId = t;
  }
  get name() {
    return this._name;
  }
  set name(t) {
    this._name = t;
  }
  get description() {
    return this._description;
  }
  set description(t) {
    this._description = t;
  }
  get doorMode() {
    return this._doorMode;
  }
  set doorMode(t) {
    this._doorMode = t;
  }
  get categoryId() {
    return this._categoryId;
  }
  set categoryId(t) {
    this._categoryId = t;
  }
  get maximumVisitors() {
    return this._maximumVisitors;
  }
  set maximumVisitors(t) {
    this._maximumVisitors = t;
  }
  get maximumVisitorsLimit() {
    return this._maximumVisitorsLimit;
  }
  set maximumVisitorsLimit(t) {
    this._maximumVisitorsLimit = t;
  }
  get tags() {
    return this._tags;
  }
  set tags(t) {
    this._tags = t;
  }
  setFlatController(t, e) {
    this._controllersById.set(t, e), this._controllerList = null, this._highlightedUserId = t;
  }
  get roomModerationSettings() {
    return this._roomModerationSettings;
  }
  set roomModerationSettings(t) {
    this._roomModerationSettings = t;
  }
  get controllersById() {
    return this._controllersById;
  }
  set controllersById(t) {
    this._controllersById = t;
  }
  get controllerList() {
    if (!this._controllerList) {
      this._controllerList = [];
      for (const t of this._controllersById.values()) this._controllerList.push(t);
      this._controllerList.sort((t, e) => t.userName.localeCompare(e.userName));
    }
    return this._controllerList;
  }
  get highlightedUserId() {
    return this._highlightedUserId;
  }
  setBannedUser(t, e) {
    this._bannedUsersById.set(t, e), this._bannedUsersList = null;
  }
  get bannedUsersById() {
    return this._bannedUsersById;
  }
  get bannedUsersList() {
    if (!this._bannedUsersList) {
      this._bannedUsersList = [];
      for (const t of this._bannedUsersById.values()) this._bannedUsersList.push(t);
      this._bannedUsersList.sort((t, e) => t.userName.localeCompare(e.userName));
    }
    return this._bannedUsersList;
  }
  get chatSettings() {
    return this._chatSettings;
  }
  set chatSettings(t) {
    this._chatSettings = t;
  }
  get allowNavigatorDynamicCats() {
    return this._allowNavigatorDynamicCats;
  }
  set allowNavigatorDynamicCats(t) {
    this._allowNavigatorDynamicCats = t;
  }
};
Le.DOORMODE_OPEN = 0, Le.DOORMODE_CLOSED = 1, Le.DOORMODE_PASSWORD = 2, Le.DOORMODE_INVISIBLE = 3, Le.DOORMODE_NOOBS_ONLY = 4, Le.TRADEMODE_NOT_ALLOWED = 0, Le.TRADEMODE_WITH_CONTROLLER = 1, Le.TRADEMODE_ALLOWED = 2;
let jp = Le;
class qz {
  flush() {
    return this._roomSettingsData = null, !0;
  }
  parse(t) {
    if (!t) return !1;
    this._roomSettingsData = new jp(), this._roomSettingsData.roomId = t.readInt(), this._roomSettingsData.name = t.readString(), this._roomSettingsData.description = t.readString(), this._roomSettingsData.doorMode = t.readInt(), this._roomSettingsData.categoryId = t.readInt(), this._roomSettingsData.maximumVisitors = t.readInt(), this._roomSettingsData.maximumVisitorsLimit = t.readInt(), this._roomSettingsData.tags = [];
    let e = t.readInt();
    for (; e > 0; )
      this._roomSettingsData.tags.push(t.readString()), e--;
    return this._roomSettingsData.tradeMode = t.readInt(), this._roomSettingsData.allowPets = t.readInt() === 1, this._roomSettingsData.allowFoodConsume = t.readInt() === 1, this._roomSettingsData.allowWalkThrough = t.readInt() === 1, this._roomSettingsData.hideWalls = t.readInt() === 1, this._roomSettingsData.wallThickness = t.readInt(), this._roomSettingsData.floorThickness = t.readInt(), this._roomSettingsData.chatSettings = new Nu(t), this._roomSettingsData.allowNavigatorDynamicCats = t.readBoolean(), this._roomSettingsData.roomModerationSettings = new Ec(t), !0;
  }
  get data() {
    return this._roomSettingsData;
  }
}
class $z {
  flush() {
    return this._roomId = 0, this._code = 0, !0;
  }
  parse(t) {
    return t ? (this._roomId = t.readInt(), this._code = t.readInt(), !0) : !1;
  }
  get roomId() {
    return this._roomId;
  }
  get code() {
    return this._code;
  }
}
class Zz {
  flush() {
    return this._roomId = 0, !0;
  }
  parse(t) {
    return t ? (this._roomId = t.readInt(), !0) : !1;
  }
  get roomId() {
    return this._roomId;
  }
}
const es = class es {
  flush() {
    return this._roomId = 0, this._code = 0, this._message = null, !0;
  }
  parse(t) {
    return t ? (this._roomId = t.readInt(), this._code = t.readInt(), this._message = t.readString(), !0) : !1;
  }
  get roomId() {
    return this._roomId;
  }
  get code() {
    return this._code;
  }
  get message() {
    return this._message;
  }
};
es.ERROR_ROOM_NOT_FOUND = 1, es.ERROR_NOT_OWNER = 2, es.ERROR_INVALID_DOOR_MODE = 3, es.ERROR_INVALID_USER_LIMIT = 4, es.ERROR_INVALID_PASSWORD = 5, es.ERROR_INVALID_CATEGORY = 6, es.ERROR_INVALID_NAME = 7, es.ERROR_UNACCEPTABLE_NAME = 8, es.ERROR_INVALID_DESCRIPTION = 9, es.ERROR_UNACCEPTABLE_DESCRIPTION = 10, es.ERROR_INVALID_TAG = 11, es.ERROR_NON_USER_CHOOSABLE_TAG = 12, es.ERROR_TOO_MANY_CHARACTERS_IN_TAG = 13;
let Xp = es;
class Qz {
  flush() {
    return this._selectionType = 0, !0;
  }
  parse(t) {
    return t ? (this._selectionType = t.readInt(), !0) : !1;
  }
  get selectionType() {
    return this._selectionType;
  }
}
class Jz {
  flush() {
    return this._roomId = 0, this._userId = 0, !0;
  }
  parse(t) {
    return t ? (this._roomId = t.readInt(), this._userId = t.readInt(), !0) : !1;
  }
  get roomId() {
    return this._roomId;
  }
  get userId() {
    return this._userId;
  }
}
class t4 {
  flush() {
    return this._chat = null, !0;
  }
  parse(t) {
    return t ? (this._chat = new Nu(t), !0) : !1;
  }
  get chat() {
    return this._chat;
  }
}
const Pe = class Pe {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this.flush(), this.parse(t);
  }
  flush() {
    return this._roomId = 0, this._roomName = null, this._ownerId = 0, this._ownerName = null, this._doorMode = 0, this._userCount = 0, this._maxUserCount = 0, this._description = null, this._tradeMode = 2, this._score = 0, this._ranking = 0, this._categoryId = 0, this._totalStars = 0, this._groupId = 0, this._groupName = null, this._groupBadge = null, this._tags = [], this._bitMask = 0, this._thumbnail = null, this._allowPets = !1, this._showOwner = !0, this._displayAd = !1, this._adName = null, this._adDescription = null, this._adExpiresIn = 0, this._allInRoomMuted = !1, this._canMute = !1, this._officialRoomPicRef = null, !0;
  }
  parse(t) {
    return t ? (this._roomId = t.readInt(), this._roomName = t.readString(), this._ownerId = t.readInt(), this._ownerName = t.readString(), this._doorMode = t.readInt(), this._userCount = t.readInt(), this._maxUserCount = t.readInt(), this._description = t.readString(), this._tradeMode = t.readInt(), this._score = t.readInt(), this._ranking = t.readInt(), this._categoryId = t.readInt(), this.parseTags(t), this.parseBitMask(t), !0) : !1;
  }
  parseTags(t) {
    if (!t) return !1;
    this._tags = [];
    let e = t.readInt();
    for (; e > 0; )
      this._tags.push(t.readString()), e--;
    return !0;
  }
  parseBitMask(t) {
    return t ? (this._bitMask = t.readInt(), this._bitMask & Pe.THUMBNAIL_BITMASK && (this._officialRoomPicRef = t.readString()), this._bitMask & Pe.GROUPDATA_BITMASK && (this._groupId = t.readInt(), this._groupName = t.readString(), this._groupBadge = t.readString()), this._bitMask & Pe.ROOMAD_BITMASK && (this._adName = t.readString(), this._adDescription = t.readString(), this._adExpiresIn = t.readInt()), this._showOwner = (this._bitMask & Pe.SHOWOWNER_BITMASK) > 0, this._allowPets = (this._bitMask & Pe.ALLOW_PETS_BITMASK) > 0, this._displayAd = (this._bitMask & Pe.DISPLAY_ROOMAD_BITMASK) > 0, this._thumbnail = null, !0) : !1;
  }
  get roomId() {
    return this._roomId;
  }
  get roomName() {
    return this._roomName;
  }
  set roomName(t) {
    this._roomName = t;
  }
  get ownerId() {
    return this._ownerId;
  }
  get ownerName() {
    return this._ownerName;
  }
  get doorMode() {
    return this._doorMode;
  }
  get userCount() {
    return this._userCount;
  }
  get maxUserCount() {
    return this._maxUserCount;
  }
  get description() {
    return this._description;
  }
  get tradeMode() {
    return this._tradeMode;
  }
  get score() {
    return this._score;
  }
  get ranking() {
    return this._ranking;
  }
  get categoryId() {
    return this._categoryId;
  }
  get tags() {
    return this._tags;
  }
  get officialRoomPicRef() {
    return this._officialRoomPicRef;
  }
  get habboGroupId() {
    return this._groupId;
  }
  get groupName() {
    return this._groupName;
  }
  get groupBadgeCode() {
    return this._groupBadge;
  }
  get roomAdName() {
    return this._adName;
  }
  get roomAdDescription() {
    return this._adDescription;
  }
  get roomAdExpiresInMin() {
    return this._adExpiresIn;
  }
  get showOwner() {
    return this._showOwner;
  }
  get allowPets() {
    return this._allowPets;
  }
  get displayRoomEntryAd() {
    return this._displayAd;
  }
  get canMute() {
    return this._canMute;
  }
  set canMute(t) {
    this._canMute = t;
  }
  get allInRoomMuted() {
    return this._allInRoomMuted;
  }
  set allInRoomMuted(t) {
    this._allInRoomMuted = t;
  }
};
Pe.THUMBNAIL_BITMASK = 1, Pe.GROUPDATA_BITMASK = 2, Pe.ROOMAD_BITMASK = 4, Pe.SHOWOWNER_BITMASK = 8, Pe.ALLOW_PETS_BITMASK = 16, Pe.DISPLAY_ROOMAD_BITMASK = 32, Pe.OPEN_STATE = 0, Pe.DOORBELL_STATE = 1, Pe.PASSWORD_STATE = 2, Pe.INVISIBLE_STATE = 3, Pe.NOOB_STATE = 4;
let Wo = Pe;
class e4 {
  flush() {
    return this._roomId = 0, this._isOwner = !1, !0;
  }
  parse(t) {
    return t ? (this._roomId = t.readInt(), this._isOwner = t.readBoolean(), !0) : !1;
  }
  get roomId() {
    return this._roomId;
  }
  get isOwner() {
    return this._isOwner;
  }
}
class s4 {
  flush() {
    return this._totalLikes = 0, this._canLike = !1, !0;
  }
  parse(t) {
    return t ? (this._totalLikes = t.readInt(), this._canLike = t.readBoolean(), !0) : !1;
  }
  get totalLikes() {
    return this._totalLikes;
  }
  get canLike() {
    return this._canLike;
  }
}
class i4 {
  constructor(t) {
    this._furniId = t.readInt(), this._on = t.readBoolean(), this._rootX = t.readInt(), this._rootY = t.readInt(), this._width = t.readInt(), this._length = t.readInt(), this._invert = t.readBoolean();
  }
  get furniId() {
    return this._furniId;
  }
  get on() {
    return this._on;
  }
  get rootX() {
    return this._rootX;
  }
  get rootY() {
    return this._rootY;
  }
  get width() {
    return this._width;
  }
  get length() {
    return this._length;
  }
  get invert() {
    return this._invert;
  }
}
class r4 {
  flush() {
    return this._roomIndex = -1, this._groupId = -1, this._status = 0, this._groupName = null, !0;
  }
  parse(t) {
    return t ? (this._roomIndex = t.readInt(), this._groupId = t.readInt(), this._status = t.readInt(), this._groupName = t.readString(), !0) : !1;
  }
  get roomIndex() {
    return this._roomIndex;
  }
  get groupId() {
    return this._groupId;
  }
  get status() {
    return this._status;
  }
  get groupName() {
    return this._groupName;
  }
}
class n4 {
  constructor(t, e, s) {
    this._id = 0, this._state = 0, this._id = t, this._state = e, this._data = s;
  }
  get id() {
    return this._id;
  }
  get state() {
    return this._state;
  }
  get data() {
    return this._data;
  }
}
class a4 {
  flush() {
    return this._areaData = null, !0;
  }
  parse(t) {
    return t ? (this._areaData = new i4(t), !0) : !1;
  }
  get areaData() {
    return this._areaData;
  }
}
class o4 {
  flush() {
    return this._code = 0, !0;
  }
  parse(t) {
    return t ? (this._code = t.readInt(), !0) : !1;
  }
  get count() {
    return this._code;
  }
}
class h4 {
  flush() {
    return this._itemId = 0, this._value = 0, !0;
  }
  parse(t) {
    return t ? (this._itemId = t.readInt(), this._value = t.readInt(), !0) : !1;
  }
  get itemId() {
    return this._itemId;
  }
  get value() {
    return this._value;
  }
}
class u4 {
  flush() {
    return this._isWallItem = !1, this._furniTypeName = null, this._buyout = !1, this._priceInCredits = -1, this._priceInActivityPoints = -1, this._activityPointType = -1, !0;
  }
  parse(t) {
    return t ? (this._isWallItem = t.readBoolean(), this._furniTypeName = t.readString(), this._buyout = t.readBoolean(), this._priceInCredits = t.readInt(), this._priceInActivityPoints = t.readInt(), this._activityPointType = t.readInt(), !0) : !1;
  }
  get isWallItem() {
    return this._isWallItem;
  }
  get furniTypeName() {
    return this._furniTypeName;
  }
  get buyout() {
    return this._buyout;
  }
  get priceInCredits() {
    return this._priceInCredits;
  }
  get priceInActivityPoints() {
    return this._priceInActivityPoints;
  }
  get activityPointType() {
    return this._activityPointType;
  }
}
class l4 {
  flush() {
    return this._aliases = /* @__PURE__ */ new Map(), !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; )
      this._aliases.set(t.readString(), t.readString()), e--;
    return !0;
  }
  get aliases() {
    return this._aliases;
  }
}
class Tn {
  flush() {
    return this._itemId = 0, this._data = null, !0;
  }
  parse(t) {
    return t ? (this._itemId = parseInt(t.readString()), this._data = Tn.parseObjectData(t), !0) : !1;
  }
  static parseObjectData(t) {
    if (!t) return null;
    const e = tn.getData(t.readInt());
    return e ? (e.parseWrapper(t), e) : null;
  }
  get furnitureId() {
    return this._itemId;
  }
  get objectData() {
    return this._data;
  }
}
class c4 {
  flush() {
    return this._furniId = -1, this._height = 0, !0;
  }
  parse(t) {
    return t ? (this._furniId = t.readInt(), this._height = t.readInt() / 100, !0) : !1;
  }
  get furniId() {
    return this._furniId;
  }
  get height() {
    return this._height;
  }
}
class _4 {
  flush() {
    return this._objectId = 0, this._guildId = 0, this._guildName = null, this._guildHomeRoomId = 0, this._userIsMember = !1, this._guildHasReadableForum = !1, !0;
  }
  parse(t) {
    return t ? (this._objectId = t.readInt(), this._guildId = t.readInt(), this._guildName = t.readString(), this._guildHomeRoomId = t.readInt(), this._userIsMember = t.readBoolean(), this._guildHasReadableForum = t.readBoolean(), !0) : !1;
  }
  get objectId() {
    return this._objectId;
  }
  get guildId() {
    return this._guildId;
  }
  get guildName() {
    return this._guildName;
  }
  get guildHomeRoomId() {
    return this._guildHomeRoomId;
  }
  get userIsMember() {
    return this._userIsMember;
  }
  get guildHasReadableForum() {
    return this._guildHasReadableForum;
  }
}
class d4 {
  flush() {
    return this._itemId = 0, this._data = "", !0;
  }
  parse(t) {
    return t ? (this._itemId = parseInt(t.readString()), this._data = t.readString(), !0) : !1;
  }
  get furnitureId() {
    return this._itemId;
  }
  get data() {
    return this._data;
  }
}
class f4 {
  get furniId() {
    return this._furniId;
  }
  flush() {
    return this._furniId = -1, !0;
  }
  parse(t) {
    return this._furniId = t.readInt(), !0;
  }
}
class g4 {
  get furniId() {
    return this._furniId;
  }
  flush() {
    return this._furniId = -1, !0;
  }
  parse(t) {
    return this._furniId = t.readInt(), !0;
  }
}
class p4 {
  get furniId() {
    return this._furniId;
  }
  get start() {
    return this._start;
  }
  flush() {
    return this._furniId = -1, this._start = !1, !0;
  }
  parse(t) {
    return this._furniId = t.readInt(), this._start = t.readBoolean(), !0;
  }
}
class m4 {
  flush() {
    return this._itemId = 0, this._state = 0, !0;
  }
  parse(t) {
    return t ? (this._itemId = t.readInt(), this._state = t.readInt(), !0) : !1;
  }
  get itemId() {
    return this._itemId;
  }
  get state() {
    return this._state;
  }
}
class E4 {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._reason = t.readInt(), !0) : !1;
  }
  get reason() {
    return this._reason;
  }
}
class T4 {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._expiryTime = t.readInt(), !0) : !1;
  }
  get expiryTime() {
    return this._expiryTime;
  }
}
const Gs = class Gs {
  flush() {
    return this._rented = !1, this._renterId = -1, this._renterName = null, this._canRent = !1, this._canRentErrorCode = -1, this._timeRemaining = -1, this._price = -1, !0;
  }
  parse(t) {
    return t ? (this._rented = t.readBoolean(), this._canRentErrorCode = t.readInt(), this._canRent = this._canRentErrorCode === 0, this._renterId = t.readInt(), this._renterName = t.readString(), this._timeRemaining = t.readInt(), this._price = t.readInt(), this._rented || (this._renterId = -1, this._renterName = ""), !0) : !1;
  }
  get rented() {
    return this._rented;
  }
  get renterId() {
    return this._renterId;
  }
  get renterName() {
    return this._renterName;
  }
  get canRent() {
    return this._canRent;
  }
  get price() {
    return this._price;
  }
  get timeRemaining() {
    return this._timeRemaining;
  }
  get canRentErrorCode() {
    return this._canRentErrorCode;
  }
};
Gs.SPACE_ALREADY_RENTED = 100, Gs.SPACE_EXTEND_NOT_RENTED = 101, Gs.SPACE_EXTEND_NOT_RENTED_BY_YOU = 102, Gs.CAN_RENT_ONLY_ONE_SPACE = 103, Gs.NOT_ENOUGH_CREDITS = 200, Gs.NOT_ENOUGH_PIXELS = 201, Gs.CANT_RENT_NO_PERMISSION = 202, Gs.CANT_RENT_NO_HABBO_CLUB = 203, Gs.CANT_RENT = 300, Gs.CANT_RENT_GENERIC = 400;
let Kp = Gs;
class I4 {
  flush() {
    return this._itemId = -1, this._location = "", !0;
  }
  parse(t) {
    return t ? (this._itemId = t.readInt(), this._location = t.readString(), !0) : !1;
  }
  get itemId() {
    return this._itemId;
  }
  get location() {
    return this._location;
  }
}
class S4 {
  constructor(t, e, s, r) {
    this.id = t, this.type = e, this.color = s, this.brightness = r;
  }
}
class A4 {
  constructor() {
    this._selectedPresetId = 0, this._presets = [];
  }
  flush() {
    return this._presets = [], !0;
  }
  parse(t) {
    const e = t.readInt();
    this._selectedPresetId = t.readInt();
    for (let s = 0; s < e; s++) {
      const r = t.readInt(), n = t.readInt(), a = parseInt(t.readString().substr(1), 16), o = t.readInt();
      this._presets.push(new S4(r, n, a, o));
    }
    return !0;
  }
  getPreset(t) {
    return t < 0 || t >= this.presetCount ? null : this._presets[t];
  }
  get presetCount() {
    return this._presets.length;
  }
  get selectedPresetId() {
    return this._selectedPresetId;
  }
}
class R4 {
  flush() {
    return this._roomId = -1, this._roomName = null, this._messageCount = -1, !0;
  }
  parse(t) {
    return t ? (this._roomId = t.readInt(), this._roomName = t.readString(), this._messageCount = t.readInt(), !0) : !1;
  }
  get roomId() {
    return this._roomId;
  }
  get roomName() {
    return this._roomName;
  }
  get messageCount() {
    return this._messageCount;
  }
}
class O4 {
  flush() {
    return this._email = null, this._isVerified = !1, this._allowChange = !1, this._furniId = -1, this._requestedByUser = !1, !0;
  }
  parse(t) {
    return t ? (this._email = t.readString(), this._isVerified = t.readBoolean(), this._allowChange = t.readBoolean(), this._furniId = t.readInt(), this._requestedByUser = t.readBoolean(), !0) : !1;
  }
  get email() {
    return this._email;
  }
  get isVerified() {
    return this._isVerified;
  }
  get allowChange() {
    return this._allowChange;
  }
  get furniId() {
    return this._furniId;
  }
  get requestedByUser() {
    return this._requestedByUser;
  }
}
class sI {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this.flush(), this.parse(t);
  }
  flush() {
    return this._itemId = 0, this._spriteId = 0, this._spriteName = null, this._x = 0, this._y = 0, this._direction = 0, this._z = 0, this._stackHeight = 0, this._extra = 0, this._data = null, this._state = 0, this._expires = 0, this._usagePolicy = 0, this._userId = 0, this._username = null, !0;
  }
  parse(t) {
    return t ? (this._itemId = t.readInt(), this._spriteId = t.readInt(), this._x = t.readInt(), this._y = t.readInt(), this._direction = t.readInt() % 8 * 45, this._z = parseFloat(t.readString()), this._stackHeight = parseFloat(t.readString()), this._extra = t.readInt(), this._data = Tn.parseObjectData(t), this._state = parseFloat(this._data && this._data.getLegacyString()) || 0, this._expires = t.readInt(), this._usagePolicy = t.readInt(), this._userId = t.readInt(), this._username = null, this._spriteId < 0 && (this._spriteName = t.readString()), !0) : !1;
  }
  get itemId() {
    return this._itemId;
  }
  get spriteId() {
    return this._spriteId;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  get direction() {
    return this._direction;
  }
  get z() {
    return isNaN(this._z) ? 0 : this._z;
  }
  get stackHeight() {
    return isNaN(this._stackHeight) ? 0 : this._stackHeight;
  }
  get extra() {
    return this._extra;
  }
  get data() {
    return this._data;
  }
  get state() {
    return this._state;
  }
  get expires() {
    return this._expires;
  }
  get usagePolicy() {
    return this._usagePolicy;
  }
  get userId() {
    return this._userId;
  }
  get username() {
    return this._username;
  }
  set username(t) {
    this._username = t;
  }
  get spriteName() {
    return this._spriteName;
  }
  set spriteName(t) {
    this._spriteName = t;
  }
}
class y4 {
  flush() {
    return this._item = null, !0;
  }
  parse(t) {
    return t ? (this._item = new sI(t), this._item.username = t.readString(), !0) : !1;
  }
  get item() {
    return this._item;
  }
}
class v4 {
  flush() {
    return this._owners = /* @__PURE__ */ new Map(), this._items = [], !0;
  }
  parse(t) {
    if (!t || !this.parseOwners(t)) return !1;
    let e = t.readInt();
    for (; e > 0; ) {
      const s = new sI(t);
      if (!s) continue;
      const r = this._owners.get(s.userId);
      r && (s.username = r), this._items.push(s), e--;
    }
    return !0;
  }
  parseOwners(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; )
      this._owners.set(t.readInt(), t.readString()), e--;
    return !0;
  }
  get owners() {
    return this._owners;
  }
  get items() {
    return this._items;
  }
}
class C4 {
  flush() {
    return this._itemId = 0, this._isExpired = !0, this._userId = 0, this._delay = 0, !0;
  }
  parse(t) {
    return t ? (this._itemId = parseInt(t.readString()), this._isExpired = t.readBoolean(), this._userId = t.readInt(), this._delay = t.readInt(), !0) : !1;
  }
  get itemId() {
    return this._itemId;
  }
  get isExpired() {
    return this._isExpired;
  }
  get userId() {
    return this._userId;
  }
  get delay() {
    return this._delay;
  }
}
class x4 {
  flush() {
    return this._item = null, !0;
  }
  parse(t) {
    return t ? (this._item = new sI(t), !0) : !1;
  }
  get item() {
    return this._item;
  }
}
class iI {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this.flush(), this.parse(t);
  }
  flush() {
    return this._itemId = 0, this._spriteId = 0, this._location = null, this._stuffData = null, this._state = 0, this._secondsToExpiration = 0, this._usagePolicy = -1, this._userId = 0, this._username = null, this._width = 0, this._height = 0, this._localX = 0, this._localY = 0, this._y = 0, this._z = 0, this._direction = null, this._isOldFormat = !1, !0;
  }
  parse(t) {
    if (!t) return !1;
    this._itemId = parseInt(t.readString()), this._spriteId = t.readInt(), this._location = t.readString(), this._stuffData = t.readString(), this._secondsToExpiration = t.readInt(), this._usagePolicy = t.readInt(), this._userId = t.readInt(), this._username = null;
    const e = parseFloat(this._stuffData);
    if (isNaN(e) || (this._state = Math.trunc(e)), this._location.indexOf(":") === 0) {
      this._isOldFormat = !1;
      let s = this._location.split(" ");
      if (s.length >= 3) {
        let r = s[0], n = s[1];
        const a = s[2];
        if (r.length > 3 && n.length > 2 && (r = r.substr(3), n = n.substr(2), s = r.split(","), s.length >= 2)) {
          const o = parseInt(s[0]), h = parseInt(s[1]);
          if (s = n.split(","), s.length >= 2) {
            const u = parseInt(s[0]), c = parseInt(s[1]);
            this._width = o, this._height = h, this._localX = u, this._localY = c, this._direction = a;
          }
        }
      }
    } else
      this._isOldFormat = !0;
    return !0;
  }
  get itemId() {
    return this._itemId;
  }
  get spriteId() {
    return this._spriteId;
  }
  get wallPosition() {
    return this._location;
  }
  get stuffData() {
    return this._stuffData;
  }
  get state() {
    return this._state;
  }
  get secondsToExpiration() {
    return this._secondsToExpiration;
  }
  get usagePolicy() {
    return this._usagePolicy;
  }
  get userId() {
    return this._userId;
  }
  get username() {
    return this._username;
  }
  set username(t) {
    this._username = t;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get localX() {
    return this._localX;
  }
  get localY() {
    return this._localY;
  }
  get direction() {
    return this._direction;
  }
  get isOldFormat() {
    return this._isOldFormat;
  }
}
class M4 {
  flush() {
    return this._item = null, !0;
  }
  parse(t) {
    return t ? (this._item = new iI(t), this._item.username = t.readString(), !0) : !1;
  }
  get item() {
    return this._item;
  }
}
class b4 {
  flush() {
    return this._owners = /* @__PURE__ */ new Map(), this._items = [], !0;
  }
  parse(t) {
    if (!t || !this.parseOwners(t)) return !1;
    let e = t.readInt();
    for (; e > 0; ) {
      const s = new iI(t);
      if (!s) continue;
      const r = this._owners.get(s.userId);
      r && (s.username = r), this._items.push(s), e--;
    }
    return !0;
  }
  parseOwners(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; )
      this._owners.set(t.readInt(), t.readString()), e--;
    return !0;
  }
  get owners() {
    return this._owners;
  }
  get items() {
    return this._items;
  }
}
class P4 {
  flush() {
    return this._itemId = 0, this._userId = 0, !0;
  }
  parse(t) {
    return t ? (this._itemId = parseInt(t.readString()), this._userId = t.readInt(), !0) : !1;
  }
  get itemId() {
    return this._itemId;
  }
  get userId() {
    return this._userId;
  }
}
class N4 {
  flush() {
    return this._item = null, !0;
  }
  parse(t) {
    return t ? (this._item = new iI(t), !0) : !1;
  }
  get item() {
    return this._item;
  }
}
class U4 {
  parse(t) {
    return this._furniId = t.readInt(), this._commandId = t.readInt(), !0;
  }
  flush() {
    return this._furniId = -1, this._commandId = -1, !0;
  }
  get furniId() {
    return this._furniId;
  }
  get commandId() {
    return this._commandId;
  }
}
class D4 {
  constructor(t, e, s) {
    this._video = t, this._title = e, this._description = s;
  }
  get video() {
    return this._video;
  }
  get title() {
    return this._title;
  }
  get description() {
    return this._description;
  }
}
class L4 {
  flush() {
    return this._furniId = -1, this._playlists = null, this._selectedPlaylistId = null, !0;
  }
  parse(t) {
    this._furniId = t.readInt();
    const e = t.readInt();
    this._playlists = [];
    for (let s = 0; s < e; s++)
      this._playlists.push(new D4(t.readString(), t.readString(), t.readString()));
    return this._selectedPlaylistId = t.readString(), !0;
  }
  get furniId() {
    return this._furniId;
  }
  get playlists() {
    return this._playlists;
  }
  get selectedPlaylistId() {
    return this._selectedPlaylistId;
  }
}
class F4 {
  flush() {
    return !0;
  }
  parse(t) {
    return this._furniId = t.readInt(), this._videoId = t.readString(), this._startAtSeconds = t.readInt(), this._endAtSeconds = t.readInt(), this._state = t.readInt(), !0;
  }
  get furniId() {
    return this._furniId;
  }
  get videoId() {
    return this._videoId;
  }
  get state() {
    return this._state;
  }
  get startAtSeconds() {
    return this._startAtSeconds;
  }
  get endAtSeconds() {
    return this._endAtSeconds;
  }
}
class w4 {
  flush() {
    return this._objects = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; ) {
      const s = t.readInt(), r = Tn.parseObjectData(t), n = parseFloat(r.getLegacyString());
      this._objects.push(new n4(s, n, r)), e--;
    }
    return !0;
  }
  get objects() {
    return this._objects;
  }
}
class G4 {
  flush() {
    return this._rollerId = 0, this._itemsRolling = [], this._unitRolling = null, !0;
  }
  parse(t) {
    if (!t) return !1;
    const e = t.readInt(), s = t.readInt(), r = t.readInt(), n = t.readInt();
    let a = t.readInt();
    for (; a > 0; ) {
      const l = t.readInt(), _ = parseFloat(t.readString()), d = parseFloat(t.readString()), f = new fr(l, new v(e, s, _), new v(r, n, d));
      this._itemsRolling.push(f), a--;
    }
    if (this._rollerId = t.readInt(), !t.bytesAvailable) return !0;
    const o = t.readInt(), h = t.readInt(), u = parseFloat(t.readString()), c = parseFloat(t.readString());
    switch (o) {
      case 0:
        break;
      case 1:
        this._unitRolling = new fr(h, new v(e, s, u), new v(r, n, c), fr.MOVE);
        break;
      case 2:
        this._unitRolling = new fr(h, new v(e, s, u), new v(r, n, c), fr.SLIDE);
        break;
    }
    return !0;
  }
  get rollerId() {
    return this._rollerId;
  }
  get itemsRolling() {
    return this._itemsRolling;
  }
  get unitRolling() {
    return this._unitRolling;
  }
}
const Kh = class Kh {
  flush() {
    return this._model = null, this._width = 0, this._height = 0, this._wallHeight = -1, this._heightMap = [], this._scale = 64, this._model = null, !0;
  }
  parse(t) {
    if (!t) return !1;
    const e = t.readBoolean(), s = t.readInt(), r = t.readString();
    return this.parseExplicitly(r, s, e);
  }
  parseModel(t, e, s = !0) {
    return this.parseExplicitly(t, e, s);
  }
  parseExplicitly(t, e, s = !0) {
    this._scale = s ? 32 : 64, this._wallHeight = e, this._model = t;
    const r = this._model.split("\r"), n = r.length;
    let a = 0, o = 0;
    for (; o < n; ) {
      const h = r[o];
      h.length > a && (a = h.length), o++;
    }
    for (this._heightMap = [], o = 0; o < n; ) {
      const h = [];
      let u = 0;
      for (; u < a; )
        h.push(Kh.TILE_BLOCKED), u++;
      this._heightMap.push(h), o++;
    }
    for (this._width = a, this._height = n, o = 0; o < n; ) {
      const h = this._heightMap[o], u = r[o];
      if (u.length > 0) {
        let c = 0;
        for (; c < u.length; ) {
          const l = u.charAt(c);
          let _ = Kh.TILE_BLOCKED;
          l !== "x" && l !== "X" && (_ = parseInt(l, 36)), h[c] = _, c++;
        }
      }
      o++;
    }
    return !0;
  }
  getHeight(t, e) {
    if (t < 0 || t >= this._width || e < 0 || e >= this._height) return -110;
    const s = this._heightMap[e];
    if (s === void 0) return -110;
    const r = s[t];
    return r === void 0 ? -110 : r;
  }
  get model() {
    return this._model;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get heightMap() {
    return this._heightMap;
  }
  get wallHeight() {
    return this._wallHeight;
  }
  get scale() {
    return this._scale;
  }
};
Kh.TILE_BLOCKED = -110;
let Tc = Kh;
class B4 {
  flush() {
    return this._x = 0, this._y = 0, this._direction = 0, !0;
  }
  parse(t) {
    return t ? (this._x = t.readInt(), this._y = t.readInt(), this._direction = t.readInt(), !0) : !1;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  get direction() {
    return this._direction;
  }
}
class cn {
  static decodeTileHeight(t) {
    return t < 0 ? -1 : (t & 16383) / 256;
  }
  static decodeIsStackingBlocked(t) {
    return !!(t & 16384);
  }
  static decodeIsRoomTile(t) {
    return t >= 0;
  }
  getTileHeight(t, e) {
    return t < 0 || t >= this._width || e < 0 || e >= this._height ? -1 : cn.decodeTileHeight(this._heights[e * this._width + t]);
  }
  getStackingBlocked(t, e) {
    return t < 0 || t >= this._width || e < 0 || e >= this._height ? !0 : cn.decodeIsStackingBlocked(this._heights[e * this._width + t]);
  }
  isRoomTile(t, e) {
    return t < 0 || t >= this._width || e < 0 || e >= this._height ? !1 : cn.decodeIsRoomTile(this._heights[e * this._width + t]);
  }
  flush() {
    return this._width = 0, this._height = 0, this._heights = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._width = t.readInt();
    const e = t.readInt();
    this._height = e / this._width;
    let s = 0;
    for (; s < e; )
      this._heights[s] = t.readShort(), s++;
    return !0;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get heights() {
    return this._heights;
  }
}
class k4 {
  flush() {
    return this._wrapper = null, this._count = 0, this._x = 0, this._y = 0, this._value = 0, !0;
  }
  tileHeight() {
    return cn.decodeTileHeight(this._value);
  }
  isStackingBlocked() {
    return cn.decodeIsStackingBlocked(this._value);
  }
  isRoomTile() {
    return cn.decodeIsRoomTile(this._value);
  }
  next() {
    return this._count ? (this._count--, this._x = this._wrapper.readByte(), this._y = this._wrapper.readByte(), this._value = this._wrapper.readShort(), !0) : !1;
  }
  parse(t) {
    return t ? (this._wrapper = t, this._count = t.readByte(), !0) : !1;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  get height() {
    return this._value;
  }
}
class z4 {
  flush() {
    return this._blockedTilesMap = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; ) {
      const s = t.readInt(), r = t.readInt();
      this._blockedTilesMap[r] || (this._blockedTilesMap[r] = []), this._blockedTilesMap[r][s] = !0, e--;
    }
    return !0;
  }
  get blockedTilesMap() {
    return this._blockedTilesMap;
  }
}
class V4 {
  flush() {
    return this._floorType = null, this._wallType = null, this._landscapeType = null, this._landscapeAnimation = null, !0;
  }
  parse(t) {
    if (!t) return !1;
    const e = t.readString(), s = t.readString();
    switch (e) {
      case "floor":
        this._floorType = s;
        break;
      case "wallpaper":
        this._wallType = s;
        break;
      case "landscape":
        this._landscapeType = s;
        break;
      case "landscapeanim":
        this._landscapeAnimation = s;
        break;
    }
    return !0;
  }
  get floorType() {
    return this._floorType;
  }
  get wallType() {
    return this._wallType;
  }
  get landscapeType() {
    return this._landscapeType;
  }
  get landscapeAnimation() {
    return this._landscapeAnimation;
  }
}
class H4 {
  flush() {
    return this._name = null, this._roomId = 0, !0;
  }
  parse(t) {
    return t ? (this._name = t.readString(), this._roomId = t.readInt(), !0) : !1;
  }
  get name() {
    return this._name;
  }
  get roomId() {
    return this._roomId;
  }
}
class Y4 {
  flush() {
    return this._hideWalls = !1, this._thicknessWall = 0, this._thicknessFloor = 0, !0;
  }
  parse(t) {
    if (!t) return !1;
    this._hideWalls = t.readBoolean();
    let e = t.readInt(), s = t.readInt();
    return e = e < -2 ? -2 : e > 1 ? 1 : e, s = s < -2 ? -2 : s > 1 ? 1 : s, this._thicknessWall = Math.pow(2, e), this._thicknessFloor = Math.pow(2, s), !0;
  }
  get hideWalls() {
    return this._hideWalls;
  }
  get thicknessWall() {
    return this._thicknessWall;
  }
  get thicknessFloor() {
    return this._thicknessFloor;
  }
}
class W4 {
  flush() {
    return this._resultData = null, this._otherResultData = null, !0;
  }
  parse(t) {
    return t ? (this._resultData = new hA(t), this._otherResultData = new hA(t), !0) : !1;
  }
  get resultData() {
    return this._resultData;
  }
  get otherResultData() {
    return this._otherResultData;
  }
}
class j4 {
  flush() {
    return this._petId = -1, this._roomIndex = -1, this._gainedExperience = 0, !0;
  }
  parse(t) {
    return t ? (this._petId = t.readInt(), this._roomIndex = t.readInt(), this._gainedExperience = t.readInt(), !0) : !1;
  }
  get petId() {
    return this._petId;
  }
  get roomIndex() {
    return this._roomIndex;
  }
  get gainedExperience() {
    return this._gainedExperience;
  }
}
class X4 {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._roomIndex = t.readInt(), this._petId = t.readInt(), this._figureData = new nI(t), this._hasSaddle = t.readBoolean(), this._isRiding = t.readBoolean(), !0) : !1;
  }
  get roomIndex() {
    return this._roomIndex;
  }
  get petId() {
    return this._petId;
  }
  get figureData() {
    return this._figureData;
  }
  get hasSaddle() {
    return this._hasSaddle;
  }
  get isRiding() {
    return this._isRiding;
  }
}
class K4 {
  flush() {
    return this._id = -1, this._skillThresholds = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._id = t.readInt(), this._name = t.readString(), this._level = t.readInt(), this._maximumLevel = t.readInt(), this._experience = t.readInt(), this._levelExperienceGoal = t.readInt(), this._energy = t.readInt(), this._maximumEnergy = t.readInt(), this._happyness = t.readInt(), this._maximumHappyness = t.readInt(), this._respect = t.readInt(), this._ownerId = t.readInt(), this._age = t.readInt(), this._ownerName = t.readString(), this._rarityLevel = t.readInt(), this._saddle = t.readBoolean(), this._rider = t.readBoolean();
    let e = t.readInt();
    for (; e > 0; )
      this._skillThresholds.push(t.readInt()), e--;
    return this._skillThresholds.sort(), this._publiclyRideable = t.readInt(), this._breedable = t.readBoolean(), this._fullyGrown = t.readBoolean(), this._dead = t.readBoolean(), this._unknownRarity = t.readInt(), this._maximumTimeToLive = t.readInt(), this._remainingTimeToLive = t.readInt(), this._remainingGrowTime = t.readInt(), this._publiclyBreedable = t.readBoolean(), !0;
  }
  get id() {
    return this._id;
  }
  get name() {
    return this._name;
  }
  get level() {
    return this._level;
  }
  get maximumLevel() {
    return this._maximumLevel;
  }
  get experience() {
    return this._experience;
  }
  get energy() {
    return this._energy;
  }
  get happyness() {
    return this._happyness;
  }
  get levelExperienceGoal() {
    return this._levelExperienceGoal;
  }
  get maximumEnergy() {
    return this._maximumEnergy;
  }
  get maximumHappyness() {
    return this._maximumHappyness;
  }
  get respect() {
    return this._respect;
  }
  get ownerId() {
    return this._ownerId;
  }
  get ownerName() {
    return this._ownerName;
  }
  get age() {
    return this._age;
  }
  get rarityLevel() {
    return this._rarityLevel;
  }
  get saddle() {
    return this._saddle;
  }
  get rider() {
    return this._rider;
  }
  get breedable() {
    return this._breedable;
  }
  get fullyGrown() {
    return this._fullyGrown;
  }
  get dead() {
    return this._dead;
  }
  get maximumTimeToLive() {
    return this._maximumTimeToLive;
  }
  get remainingTimeToLive() {
    return this._remainingTimeToLive;
  }
  get remainingGrowTime() {
    return this._remainingGrowTime;
  }
  get skillTresholds() {
    return this._skillThresholds;
  }
  get publiclyRideable() {
    return this._publiclyRideable;
  }
  get unknownRarity() {
    return this._unknownRarity;
  }
  get publiclyBreedable() {
    return this._publiclyBreedable;
  }
}
class q4 {
  flush() {
    return this._roomIndex = -1, this._petId = -1, this._canBreed = !1, this._canHarvest = !1, this._canRevive = !1, this._hasBreedingPermission = !1, !0;
  }
  parse(t) {
    return t ? (this._roomIndex = t.readInt(), this._petId = t.readInt(), this._canBreed = t.readBoolean(), this._canHarvest = t.readBoolean(), this._canRevive = t.readBoolean(), this._hasBreedingPermission = t.readBoolean(), !0) : !1;
  }
  get roomIndex() {
    return this._roomIndex;
  }
  get petId() {
    return this._petId;
  }
  get canBreed() {
    return this._canBreed;
  }
  get canHarvest() {
    return this._canHarvest;
  }
  get canRevive() {
    return this._canRevive;
  }
  get hasBreedingPermission() {
    return this._hasBreedingPermission;
  }
}
class $4 {
  flush() {
    return this._isPlaying = !1, !0;
  }
  parse(t) {
    return t ? (this._isPlaying = t.readBoolean(), !0) : !1;
  }
  get isPlaying() {
    return this._isPlaying;
  }
}
class Z4 {
  flush() {
    return !0;
  }
  parse(t) {
    return !0;
  }
}
class Q4 {
  flush() {
    return this._seconds = 0, !0;
  }
  parse(t) {
    return t ? (this._seconds = t.readInt(), !0) : !1;
  }
  get seconds() {
    return this._seconds;
  }
}
class J4 {
  flush() {
    return this._seconds = 0, !0;
  }
  parse(t) {
    return t ? (this._seconds = t.readInt(), !0) : !1;
  }
  get seconds() {
    return this._seconds;
  }
}
class rI {
  flush() {
    return this._roomIndex = null, this._message = null, this._gesture = 0, this._bubble = 0, this._urls = [], this._messageLength = 0, !0;
  }
  parse(t) {
    return t ? (this._roomIndex = t.readInt(), this._message = t.readString(), this._gesture = t.readInt(), this._bubble = t.readInt(), this.parseUrls(t), this._messageLength = t.readInt(), !0) : !1;
  }
  parseUrls(t) {
    if (!t) return !1;
    this._urls = [];
    let e = t.readInt();
    for (; e > 0; )
      this._urls.push(t.readString()), e--;
    return !0;
  }
  get roomIndex() {
    return this._roomIndex;
  }
  get message() {
    return this._message;
  }
  get gesture() {
    return this._gesture;
  }
  get bubble() {
    return this._bubble;
  }
  get urls() {
    return this._urls;
  }
  get messageLength() {
    return this._messageLength;
  }
}
class tV {
  flush() {
    return this._unitId = null, this._isTyping = !1, !0;
  }
  parse(t) {
    return t ? (this._unitId = t.readInt(), this._isTyping = t.readInt() === 1, !0) : !1;
  }
  get unitId() {
    return this._unitId;
  }
  get isTyping() {
    return this._isTyping;
  }
}
class eV {
  flush() {
    return this._unitId = null, this._danceId = 0, !0;
  }
  parse(t) {
    return t ? (this._unitId = t.readInt(), this._danceId = t.readInt(), !0) : !1;
  }
  get unitId() {
    return this._unitId;
  }
  get danceId() {
    return this._danceId;
  }
}
class sV {
  flush() {
    return this._unitId = null, this._effectId = 0, this._delay = 0, !0;
  }
  parse(t) {
    return t ? (this._unitId = t.readInt(), this._effectId = t.readInt(), this._delay = t.readInt(), !0) : !1;
  }
  get unitId() {
    return this._unitId;
  }
  get effectId() {
    return this._effectId;
  }
  get delay() {
    return this._delay;
  }
}
class iV {
  flush() {
    return this._unitId = null, this._expression = 0, !0;
  }
  parse(t) {
    return t ? (this._unitId = t.readInt(), this._expression = t.readInt(), !0) : !1;
  }
  get unitId() {
    return this._unitId;
  }
  get expression() {
    return this._expression;
  }
}
class rV {
  flush() {
    return this._unitId = null, this._handId = 0, !0;
  }
  parse(t) {
    return t ? (this._unitId = t.readInt(), this._handId = t.readInt(), !0) : !1;
  }
  get unitId() {
    return this._unitId;
  }
  get handId() {
    return this._handId;
  }
}
class nV {
  flush() {
    return this._giverUserId = -1, this._handItemType = -1, !0;
  }
  parse(t) {
    return t ? (this._giverUserId = t.readInt(), this._handItemType = t.readInt(), !0) : !1;
  }
  get giverUserId() {
    return this._giverUserId;
  }
  get handItemType() {
    return this._handItemType;
  }
}
class aV {
  flush() {
    return this._unitId = null, this._isIdle = !1, !0;
  }
  parse(t) {
    return t ? (this._unitId = t.readInt(), this._isIdle = t.readBoolean(), !0) : !1;
  }
  get unitId() {
    return this._unitId;
  }
  get isIdle() {
    return this._isIdle;
  }
}
class oV {
  flush() {
    return this._unitId = null, this._figure = null, this._gender = "M", this._motto = null, this._achievementScore = 0, !0;
  }
  parse(t) {
    return t ? (this._unitId = t.readInt(), this._figure = t.readString(), this._gender = t.readString().toLocaleUpperCase(), this._motto = t.readString(), this._achievementScore = t.readInt(), !0) : !1;
  }
  get unitId() {
    return this._unitId;
  }
  get figure() {
    return this._figure;
  }
  get gender() {
    return this._gender;
  }
  get motto() {
    return this._motto;
  }
  get achievementScore() {
    return this._achievementScore;
  }
}
class hV {
  flush() {
    return this._unitId = null, this._value = 0, !0;
  }
  parse(t) {
    return t ? (this._unitId = t.readInt(), this._value = t.readInt(), !0) : !1;
  }
  get unitId() {
    return this._unitId;
  }
  get value() {
    return this._value;
  }
}
const td = class td {
  constructor(t) {
    this._roomIndex = 0, this._x = 0, this._y = 0, this._z = 0, this._dir = 0, this._name = "", this._userType = 0, this._sex = "", this._figure = "", this._custom = "", this._activityPoints = 0, this._webID = 0, this._groupID = 0, this._groupStatus = 0, this._groupName = "", this._subType = "", this._ownerId = 0, this._ownerName = "", this._rarityLevel = 0, this._hasSaddle = !1, this._isRiding = !1, this._canBreed = !1, this._canHarvest = !1, this._canRevive = !1, this._hasBreedingPermission = !1, this._petLevel = 0, this._petPosture = "", this._botSkills = [], this._isModerator = !1, this._isReadOnly = !1, this._roomIndex = t;
  }
  setReadOnly() {
    this._isReadOnly = !0;
  }
  get roomIndex() {
    return this._roomIndex;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._isReadOnly || (this._x = t);
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._isReadOnly || (this._y = t);
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._isReadOnly || (this._z = t);
  }
  get dir() {
    return this._dir;
  }
  set dir(t) {
    this._isReadOnly || (this._dir = t);
  }
  get name() {
    return this._name;
  }
  set name(t) {
    this._isReadOnly || (this._name = t);
  }
  get userType() {
    return this._userType;
  }
  set userType(t) {
    this._isReadOnly || (this._userType = t);
  }
  get sex() {
    return this._sex;
  }
  set sex(t) {
    this._isReadOnly || (this._sex = t);
  }
  get figure() {
    return this._figure;
  }
  set figure(t) {
    this._isReadOnly || (this._figure = t);
  }
  get custom() {
    return this._custom;
  }
  set custom(t) {
    this._isReadOnly || (this._custom = t);
  }
  get activityPoints() {
    return this._activityPoints;
  }
  set activityPoints(t) {
    this._isReadOnly || (this._activityPoints = t);
  }
  get webID() {
    return this._webID;
  }
  set webID(t) {
    this._isReadOnly || (this._webID = t);
  }
  get groupID() {
    return this._groupID;
  }
  set groupID(t) {
    this._isReadOnly || (this._groupID = t);
  }
  get groupName() {
    return this._groupName;
  }
  set groupName(t) {
    this._isReadOnly || (this._groupName = t);
  }
  get groupStatus() {
    return this._groupStatus;
  }
  set groupStatus(t) {
    this._isReadOnly || (this._groupStatus = t);
  }
  get subType() {
    return this._subType;
  }
  set subType(t) {
    this._isReadOnly || (this._subType = t);
  }
  get ownerId() {
    return this._ownerId;
  }
  set ownerId(t) {
    this._isReadOnly || (this._ownerId = t);
  }
  get ownerName() {
    return this._ownerName;
  }
  set ownerName(t) {
    this._isReadOnly || (this._ownerName = t);
  }
  get rarityLevel() {
    return this._rarityLevel;
  }
  set rarityLevel(t) {
    this._isReadOnly || (this._rarityLevel = t);
  }
  get hasSaddle() {
    return this._hasSaddle;
  }
  set hasSaddle(t) {
    this._isReadOnly || (this._hasSaddle = t);
  }
  get isRiding() {
    return this._isRiding;
  }
  set isRiding(t) {
    this._isReadOnly || (this._isRiding = t);
  }
  get canBreed() {
    return this._canBreed;
  }
  set canBreed(t) {
    this._isReadOnly || (this._canBreed = t);
  }
  get canHarvest() {
    return this._canHarvest;
  }
  set canHarvest(t) {
    this._isReadOnly || (this._canHarvest = t);
  }
  get canRevive() {
    return this._canRevive;
  }
  set canRevive(t) {
    this._isReadOnly || (this._canRevive = t);
  }
  get hasBreedingPermission() {
    return this._hasBreedingPermission;
  }
  set hasBreedingPermission(t) {
    this._isReadOnly || (this._hasBreedingPermission = t);
  }
  get petLevel() {
    return this._petLevel;
  }
  set petLevel(t) {
    this._isReadOnly || (this._petLevel = t);
  }
  get petPosture() {
    return this._petPosture;
  }
  set petPosture(t) {
    this._isReadOnly || (this._petPosture = t);
  }
  get botSkills() {
    return this._botSkills;
  }
  set botSkills(t) {
    this._botSkills = t;
  }
  get isModerator() {
    return this._isModerator;
  }
  set isModerator(t) {
    this._isReadOnly || (this._isModerator = t);
  }
};
td.M = "M", td.F = "F";
let Ka = td;
class uV {
  flush() {
    return this._users = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._users = [];
    const e = t.readInt();
    let s = 0;
    for (; s < e; ) {
      const r = t.readInt(), n = t.readString(), a = t.readString();
      let o = t.readString();
      const h = t.readInt(), u = t.readInt(), c = t.readInt(), l = parseFloat(t.readString()), _ = t.readInt(), d = t.readInt(), f = new Ka(h);
      if (f.dir = _, f.name = n, f.custom = a, f.x = u, f.y = c, f.z = l, this._users.push(f), d === 1) {
        f.webID = r, f.userType = pr.USER, f.sex = this.resolveSex(t.readString()), f.groupID = t.readInt(), f.groupStatus = t.readInt(), f.groupName = t.readString();
        const p = t.readString();
        p !== "" && (o = this.convertSwimFigure(p, o, f.sex)), f.figure = o, f.activityPoints = t.readInt(), f.isModerator = t.readBoolean();
      } else if (d === 2)
        f.userType = pr.PET, f.figure = o, f.webID = r, f.subType = t.readInt().toString(), f.ownerId = t.readInt(), f.ownerName = t.readString(), f.rarityLevel = t.readInt(), f.hasSaddle = t.readBoolean(), f.isRiding = t.readBoolean(), f.canBreed = t.readBoolean(), f.canHarvest = t.readBoolean(), f.canRevive = t.readBoolean(), f.hasBreedingPermission = t.readBoolean(), f.petLevel = t.readInt(), f.petPosture = t.readString();
      else if (d === 3)
        f.userType = pr.BOT, f.webID = h * -1, o.indexOf("/") === -1 ? f.figure = o : f.figure = "hr-100-.hd-180-1.ch-876-66.lg-270-94.sh-300-64", f.sex = Ka.M;
      else if (d === 4) {
        f.userType = pr.RENTABLE_BOT, f.webID = r, f.sex = this.resolveSex(t.readString()), f.figure = o, f.ownerId = t.readInt(), f.ownerName = t.readString();
        const p = t.readInt();
        if (p) {
          const g = [];
          let m = 0;
          for (; m < p; )
            g.push(t.readShort()), m++;
          f.botSkills = g;
        }
      }
      s++;
    }
    return !0;
  }
  resolveSex(t) {
    return t.substr(0, 1).toLowerCase() === "f" ? Ka.F : Ka.M;
  }
  convertSwimFigure(t, e, s) {
    const r = e.split(".");
    let n = 1, a = 1, o = 1;
    const h = 1e4;
    let u = 0;
    for (; u < r.length; ) {
      const d = r[u].split("-");
      d.length > 2 && d[0] === "hd" && (n = parseInt(d[2])), u++;
    }
    const c = ["238,238,238", "250,56,49", "253,146,160", "42,199,210", "53,51,44", "239,255,146", "198,255,152", "255,146,90", "157,89,126", "182,243,255", "109,255,51", "51,120,201", "255,182,49", "223,161,233", "249,251,50", "202,175,143", "197,198,197", "71,98,61", "138,131,97", "255,140,51", "84,198,39", "30,108,153", "152,79,136", "119,200,255", "255,192,142", "60,75,135", "124,44,71", "215,255,227", "143,63,28", "255,99,147", "31,155,121", "253,255,51"], l = t.split("=");
    if (l.length > 1) {
      const _ = l[1].split("/");
      _[0];
      const d = _[1];
      s === "F" ? o = 10010 : o = 10011;
      const f = c.indexOf(d);
      a = h + f + 1;
    }
    return e + (".bds-10001-" + n + ".ss-" + o + "-" + a);
  }
  get users() {
    return this._users;
  }
}
class lV {
  flush() {
    return this._unitId = null, !0;
  }
  parse(t) {
    return t ? (this._unitId = parseInt(t.readString()), !0) : !1;
  }
  get unitId() {
    return this._unitId;
  }
}
class cV {
  constructor(t, e) {
    this._action = t, this._value = e;
  }
  get action() {
    return this._action;
  }
  get value() {
    return this._value;
  }
}
class _V {
  constructor(t, e, s, r, n, a, o, h = 0, u = 0, c = 0, l, _, d) {
    this._id = t, this._x = e, this._y = s, this._z = r, this._height = n, this._headDirection = a, this._direction = o, this._targetX = h, this._targetY = u, this._targetZ = c, this._didMove = l, this._canStandUp = _, this._actions = d || [];
  }
  get id() {
    return this._id;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  get z() {
    return this._z;
  }
  get height() {
    return this._height;
  }
  get headDirection() {
    return this._headDirection;
  }
  get direction() {
    return this._direction;
  }
  get targetX() {
    return this._targetX;
  }
  get targetY() {
    return this._targetY;
  }
  get targetZ() {
    return this._targetZ;
  }
  get didMove() {
    return this._didMove;
  }
  get canStandUp() {
    return this._canStandUp;
  }
  get actions() {
    return this._actions;
  }
}
class dV {
  flush() {
    return this._statuses = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; ) {
      const s = this.parseStatus(t);
      if (!s) {
        e--;
        continue;
      }
      this._statuses.push(s), e--;
    }
    return !0;
  }
  parseStatus(t) {
    if (!t) return null;
    const e = t.readInt(), s = t.readInt(), r = t.readInt(), n = parseFloat(t.readString()), a = t.readInt() % 8 * 45, o = t.readInt() % 8 * 45, h = t.readString();
    let u = 0, c = 0, l = 0, _ = 0, d = !1, f = !1;
    if (h) {
      const p = h.split("/"), g = [];
      for (const m of p) {
        const O = m.split(" ");
        if (O[0] !== "") {
          if (O.length >= 2)
            switch (O[0]) {
              case "mv": {
                const y = O[1].split(",");
                y.length >= 3 && (u = parseInt(y[0]), c = parseInt(y[1]), l = parseFloat(y[2]), f = !0);
                break;
              }
              case "sit": {
                const y = parseFloat(O[1]);
                O.length >= 3 && (d = O[2] === "1"), _ = y;
                break;
              }
              case "lay": {
                const y = parseFloat(O[1]);
                _ = Math.abs(y);
                break;
              }
            }
          g.push(new cV(O[0], O[1]));
        }
      }
      this._statuses.push(new _V(e, s, r, n, _, a, o, u, c, l, f, d, g));
    }
  }
  get statuses() {
    return this._statuses;
  }
}
const po = class po {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this.flush(), this.parse(t);
  }
  flush() {
    return this._rentable = !1, this._itemId = 0, this._furniType = null, this._ref = 0, this._spriteId = 0, this._category = 0, this._stuffData = null, this._isGroupable = !1, this._isRecyclable = !1, this._tradable = !1, this._sellable = !1, this._secondsToExpiration = 0, this._extra = 0, this._flatId = 0, this._isWallItem = !1, this._hasRentPeriodStarted = !1, this._expirationTimeStamp = 0, this._slotId = "", this._songId = -1, !0;
  }
  parse(t) {
    return t ? (this._itemId = t.readInt(), this._furniType = t.readString(), this._ref = t.readInt(), this._spriteId = t.readInt(), this._category = t.readInt(), this._stuffData = Tn.parseObjectData(t), this._isRecyclable = t.readBoolean(), this._tradable = t.readBoolean(), this._isGroupable = t.readBoolean(), this._sellable = t.readBoolean(), this._secondsToExpiration = t.readInt(), this._expirationTimeStamp = 0, this.secondsToExpiration > -1 ? this._rentable = !0 : (this._rentable = !1, this._secondsToExpiration = -1), this._hasRentPeriodStarted = t.readBoolean(), this._flatId = t.readInt(), this._isWallItem = this._furniType === po.WALL_ITEM, this._furniType === po.FLOOR_ITEM && (this._slotId = t.readString(), this._extra = t.readInt()), !0) : !1;
  }
  get itemId() {
    return this._itemId;
  }
  get furniType() {
    return this._furniType;
  }
  get ref() {
    return this._ref;
  }
  get spriteId() {
    return this._spriteId;
  }
  get category() {
    return this._category;
  }
  get stuffData() {
    return this._stuffData;
  }
  get isGroupable() {
    return this._isGroupable;
  }
  get isRecycleable() {
    return this._isRecyclable;
  }
  get tradable() {
    return this._tradable;
  }
  get sellable() {
    return this._sellable;
  }
  get secondsToExpiration() {
    return this._secondsToExpiration;
  }
  get flatId() {
    return this._flatId;
  }
  get slotId() {
    return this._slotId;
  }
  get songId() {
    return this._songId;
  }
  get extra() {
    return this._extra;
  }
  get rentable() {
    return this._rentable;
  }
  get isWallItem() {
    return this._isWallItem;
  }
  get hasRentPeriodStarted() {
    return this._hasRentPeriodStarted;
  }
  get expirationTimeStamp() {
    return this._expirationTimeStamp;
  }
  get creationDay() {
    return 0;
  }
  get creationMonth() {
    return 0;
  }
  get creationYear() {
    return 0;
  }
  get isExternalImageFurni() {
    return this._furniType.indexOf("external_image") !== -1;
  }
};
po.WALL_ITEM = "I", po.FLOOR_ITEM = "S";
let Ic = po;
class fV {
  flush() {
    return this._items = [], !0;
  }
  parse(t) {
    return t ? (this._items.push(new Ic(t)), !0) : !1;
  }
  get items() {
    return this._items;
  }
}
class gV {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class pV {
  flush() {
    return this._totalFragments = 0, this._fragmentNumber = 0, this._fragment = /* @__PURE__ */ new Map(), !0;
  }
  parse(t) {
    if (!t) return !1;
    this._totalFragments = t.readInt(), this._fragmentNumber = t.readInt();
    let e = t.readInt();
    for (; e > 0; ) {
      const s = new Ic(t);
      s && this._fragment.set(s.itemId, s), e--;
    }
    return !0;
  }
  get totalFragments() {
    return this._totalFragments;
  }
  get fragmentNumber() {
    return this._fragmentNumber;
  }
  get fragment() {
    return this._fragment;
  }
}
class mV {
  flush() {
    return this._itemId = 0, !0;
  }
  parse(t) {
    return t ? (this._itemId = t.readInt(), !0) : !1;
  }
  get itemId() {
    return this._itemId;
  }
}
class EV {
  flush() {
    return this._itemId = 0, this._itemsLeft = 0, !0;
  }
  parse(t) {
    return t ? (this._itemId = t.readInt(), this._itemsLeft = t.readInt(), !0) : !1;
  }
  get itemId() {
    return this._itemId;
  }
  get itemsLeft() {
    return this._itemsLeft;
  }
}
class TV {
  flush() {
    return this._itemType = "", this._classId = 0, this._productCode = "", !0;
  }
  parse(t) {
    return t ? (this._itemType = t.readString(), this._classId = t.readInt(), this._productCode = t.readString(), this._placedItemId = t.readInt(), this._placedItemType = t.readString(), this._placedInRoom = t.readBoolean(), this._petFigureString = t.readString(), !0) : !1;
  }
  get itemType() {
    return this._itemType;
  }
  get classId() {
    return this._classId;
  }
  get productCode() {
    return this._productCode;
  }
  get placedItemId() {
    return this._placedItemId;
  }
  get placedItemType() {
    return this._placedItemType;
  }
  get placedInRoom() {
    return this._placedInRoom;
  }
  get petFigureString() {
    return this._petFigureString;
  }
}
class IV {
  flush() {
    this._nestId = 0, this._pet1 && (this._pet1.dispose(), this._pet1 = null), this._pet2 && (this._pet2.dispose(), this._pet2 = null);
    for (const t of this._rarityCategories) t && t.dispose();
    return this._rarityCategories = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._nestId = t.readInt(), this._pet1 = new oA(t), this._pet2 = new oA(t);
    let e = t.readInt();
    for (; e > 0; )
      this._rarityCategories.push(new v1(t)), e--;
    return this._resultPetType = t.readInt(), !0;
  }
  get nestId() {
    return this._nestId;
  }
  get pet1() {
    return this._pet1;
  }
  get pet2() {
    return this._pet2;
  }
  get rarityCategories() {
    return this._rarityCategories;
  }
  get resultPetType() {
    return this._resultPetType;
  }
}
class SV {
  flush() {
    return this._breedingNestStuffId = 0, this._result = 0, !0;
  }
  parse(t) {
    return t ? (this._breedingNestStuffId = t.readInt(), this._result = t.readInt(), !0) : !1;
  }
  get breedingNestStuffId() {
    return this._breedingNestStuffId;
  }
  get result() {
    return this._result;
  }
}
const VI = class VI {
  flush() {
    return !0;
  }
  parse(t) {
    return this._reason = t.readInt(), !0;
  }
  get reason() {
    return this._reason;
  }
};
VI.PET_TOO_TIRED_TO_BREED = 6;
let qp = VI;
class AV {
  flush() {
    return this._petId = -1, this._rarityCategory = -1, !0;
  }
  parse(t) {
    return this._petId = t.readInt(), this._rarityCategory = t.readInt(), !0;
  }
  get rarityCategory() {
    return this._rarityCategory;
  }
  get petId() {
    return this._petId;
  }
}
class nI {
  constructor(t) {
    this._typeId = t.readInt(), this._paletteId = t.readInt(), this._color = t.readString(), this._breedId = t.readInt(), this._customParts = [], this._customPartCount = t.readInt();
    let e = 0;
    for (; e < this._customPartCount; )
      this._customParts.push(new ey(t.readInt(), t.readInt(), t.readInt())), e++;
  }
  get typeId() {
    return this._typeId;
  }
  get paletteId() {
    return this._paletteId;
  }
  get color() {
    return this._color;
  }
  get breedId() {
    return this._breedId;
  }
  get figuredata() {
    let t = this.typeId + " " + this.paletteId + " " + this.color;
    t = t + (" " + this.customPartCount);
    for (const e of this.customParts) t = t + (" " + e.layerId + " " + e.partId + " " + e.paletteId);
    return t;
  }
  get customParts() {
    return this._customParts;
  }
  get customPartCount() {
    return this._customPartCount;
  }
}
class Kd {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this._id = t.readInt(), this._name = t.readString(), this._figureData = new nI(t), this._level = t.readInt();
  }
  get id() {
    return this._id;
  }
  get name() {
    return this._name;
  }
  get typeId() {
    return this._figureData.typeId;
  }
  get paletteId() {
    return this._figureData.paletteId;
  }
  get color() {
    return this._figureData.color;
  }
  get breedId() {
    return this._figureData.breedId;
  }
  get customPartCount() {
    return this._figureData.customPartCount;
  }
  get figureString() {
    return this._figureData.figuredata;
  }
  get figureData() {
    return this._figureData;
  }
  get level() {
    return this._level;
  }
}
class RV {
  flush() {
    return this._pet = null, this._boughtAsGift = !1, !0;
  }
  parse(t) {
    return this._pet = new Kd(t), this._boughtAsGift = t.readBoolean(), !0;
  }
  get pet() {
    return this._pet;
  }
  get boughtAsGift() {
    return this._boughtAsGift;
  }
}
const qh = class qh {
  flush() {
    return this._state = 0, this._ownPetId = 0, this._otherPetId = 0, !0;
  }
  parse(t) {
    return t ? (this._state = t.readInt(), this._ownPetId = t.readInt(), this._otherPetId = t.readInt(), !0) : !1;
  }
  get state() {
    return this._state;
  }
  get ownPetId() {
    return this._ownPetId;
  }
  get otherPetId() {
    return this._otherPetId;
  }
};
qh.STATE_CANCEL = 1, qh.STATE_ACCEPT = 2, qh.STATE_REQUEST = 3;
let $p = qh;
class OV {
  flush() {
    return this._fragment = null, !0;
  }
  parse(t) {
    this._totalFragments = t.readInt(), this._fragmentNumber = t.readInt();
    let e = t.readInt();
    for (this._fragment = /* @__PURE__ */ new Map(); e > 0; ) {
      const s = new Kd(t);
      this._fragment.set(s.id, s), e--;
    }
    return !0;
  }
  get totalFragments() {
    return this._totalFragments;
  }
  get fragmentNumber() {
    return this._fragmentNumber;
  }
  get fragment() {
    return this._fragment;
  }
}
class yV {
  flush() {
    return this._boughtAsGift = !1, this._pet = null, !0;
  }
  parse(t) {
    return this._boughtAsGift = t.readBoolean(), this._pet = new Kd(t), !0;
  }
  get boughtAsGift() {
    return this._boughtAsGift;
  }
  get pet() {
    return this._pet;
  }
}
class vV {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._petId = t.readInt(), !0) : !1;
  }
  get petId() {
    return this._petId;
  }
}
class ent {
  parse(t) {
    return t ? (this._balance = parseFloat(t.readString()), !0) : !1;
  }
  flush() {
    return !0;
  }
  get balance() {
    return this._balance;
  }
}
class CV {
  constructor(t) {
    this._itemId = t.readInt(), this._furniType = t.readString().toUpperCase(), this._ref = t.readInt(), this._spriteId = t.readInt(), this._category = t.readInt(), this._isGroupable = t.readBoolean(), this._stuffData = Tn.parseObjectData(t), this._secondsToExpiration = -1, this._expirationTimeStamp = Nt(), this._hasRentPeriodStarted = !1, this._creationDay = t.readInt(), this._creationMonth = t.readInt(), this._creationYear = t.readInt(), this._extra = this.furniType === "S" ? t.readInt() : -1, this._flatId = -1, this._rentable = !1, this._isWallItem = this._furniType === "I";
  }
  get itemId() {
    return this._itemId;
  }
  get furniType() {
    return this._furniType;
  }
  get ref() {
    return this._ref;
  }
  get spriteId() {
    return this._spriteId;
  }
  get category() {
    return this._category;
  }
  get stuffData() {
    return this._stuffData;
  }
  get extra() {
    return this._extra;
  }
  get secondsToExpiration() {
    return this._secondsToExpiration;
  }
  get creationDay() {
    return this._creationDay;
  }
  get creationMonth() {
    return this._creationMonth;
  }
  get creationYear() {
    return this._creationYear;
  }
  get isGroupable() {
    return this._isGroupable;
  }
  get songId() {
    return this._extra;
  }
  get flatId() {
    return this._flatId;
  }
  get rentable() {
    return this._rentable;
  }
  get isWallItem() {
    return this._isWallItem;
  }
  get hasRentPeriodStarted() {
    return this._hasRentPeriodStarted;
  }
  get expirationTimeStamp() {
    return this._expirationTimeStamp;
  }
  get isRecycleable() {
    return !0;
  }
  get tradable() {
    return !0;
  }
  get sellable() {
    return !0;
  }
  get slotId() {
    return null;
  }
  get isExternalImageFurni() {
    return this._furniType.indexOf("external_image") !== -1;
  }
}
class xV {
  flush() {
    return this._userID = -1, this._userAccepts = !1, !0;
  }
  parse(t) {
    return t ? (this._userID = t.readInt(), this._userAccepts = t.readInt() > 0, !0) : !1;
  }
  get userID() {
    return this._userID;
  }
  get userAccepts() {
    return this._userAccepts;
  }
}
const HI = class HI {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._userId = t.readInt(), this._reason = t.readInt(), !0) : !1;
  }
  get userID() {
    return this._userId;
  }
  get reason() {
    return this._reason;
  }
};
HI.ERROR_WHILE_COMMIT = 1;
let Zp = HI;
class MV {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class bV {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class PV {
  flush() {
    return this._firstUserID = -1, this._firstUserItemArray = null, this._firstUserNumItems = 0, this._firstUserNumCredits = 0, this._secondUserID = -1, this._secondUserItemArray = null, this._secondUserNumItems = 0, this._secondUserNumCredits = 0, !0;
  }
  parse(t) {
    return !t || (this._firstUserID = t.readInt(), this._firstUserItemArray = [], !this.parseItems(t, this._firstUserItemArray)) || (this._firstUserNumItems = t.readInt(), this._firstUserNumCredits = t.readInt(), this._secondUserID = t.readInt(), this._secondUserItemArray = [], !this.parseItems(t, this._secondUserItemArray)) ? !1 : (this._secondUserNumItems = t.readInt(), this._secondUserNumCredits = t.readInt(), !0);
  }
  parseItems(t, e) {
    let s = t.readInt();
    for (; s > 0; )
      e.push(new CV(t)), s--;
    return !0;
  }
  get firstUserID() {
    return this._firstUserID;
  }
  get firstUserItemArray() {
    return this._firstUserItemArray;
  }
  get firstUserNumItems() {
    return this._firstUserNumItems;
  }
  get firstUserNumCredits() {
    return this._firstUserNumCredits;
  }
  get secondUserID() {
    return this._secondUserID;
  }
  get secondUserItemArray() {
    return this._secondUserItemArray;
  }
  get secondUserNumItems() {
    return this._secondUserNumItems;
  }
  get secondUserNumCredits() {
    return this._secondUserNumCredits;
  }
}
class NV {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class UV {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
const ed = class ed {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._reason = t.readInt(), this._otherUserName = t.readString(), !0) : !1;
  }
  get reason() {
    return this._reason;
  }
  get otherUserName() {
    return this._otherUserName;
  }
};
ed.REASON_YOU_ARE_ALREADY_TRADING = 7, ed.REASON_OTHER_USER_ALREADY_TRADING = 8;
let Qp = ed;
class DV {
  flush() {
    return this._userId = -1, this._userCanTrade = !1, this._otherUserId = -1, this._otherUserCanTrade = !1, !0;
  }
  parse(t) {
    return t ? (this._userId = t.readInt(), this._userCanTrade = t.readInt() === 1, this._otherUserId = t.readInt(), this._otherUserCanTrade = t.readInt() === 1, !0) : !1;
  }
  get userID() {
    return this._userId;
  }
  get userCanTrade() {
    return this._userCanTrade;
  }
  get otherUserID() {
    return this._otherUserId;
  }
  get otherUserCanTrade() {
    return this._otherUserCanTrade;
  }
}
class LV {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class FV {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class wV {
  flush() {
    return this._respect = 0, this._petOwnerId = 0, this._petData = null, !0;
  }
  parse(t) {
    return t ? (this._respect = t.readInt(), this._petOwnerId = t.readInt(), this._petData = new Kd(t), !0) : !1;
  }
  get respect() {
    return this._respect;
  }
  get petOwnerId() {
    return this._petOwnerId;
  }
  get petData() {
    return this._petData;
  }
  get isTreat() {
    return this._petData.typeId === Eu.MONSTERPLANT;
  }
}
class GV {
  flush() {
    return this._petId = 0, this._userId = 0, this._supplementType = 0, !0;
  }
  parse(t) {
    return t ? (this._petId = t.readInt(), this._userId = t.readInt(), this._supplementType = t.readInt(), !0) : !1;
  }
  get petId() {
    return this._petId;
  }
  get userId() {
    return this._userId;
  }
  get supplementType() {
    return this._supplementType;
  }
}
const Xn = class Xn {
};
Xn.WATER = 0, Xn.LIGHT = 1, Xn.REVIVE = 2, Xn.REBREED_FERTILIZER = 3, Xn.SPEED_FERTILIZER = 4;
let xh = Xn;
class BV {
  flush() {
    return this._userId = 0, this._respectsReceived = 0, !0;
  }
  parse(t) {
    return t ? (this._userId = t.readInt(), this._respectsReceived = t.readInt(), !0) : !1;
  }
  get userId() {
    return this._userId;
  }
  get respectsReceived() {
    return this._respectsReceived;
  }
}
class kV {
  constructor(t, e, s) {
    this._hasControllers = !1, this._roomId = t, this._roomName = e, this._hasControllers = s;
  }
  get roomId() {
    return this._roomId;
  }
  get roomName() {
    return this._roomName;
  }
  get hasControllers() {
    return this._hasControllers;
  }
}
class zV {
  constructor(t) {
    this._currentHcStreak = t.readInt(), this._firstSubscriptionDate = t.readString(), this._kickbackPercentage = t.readDouble(), this._totalCreditsMissed = t.readInt(), this._totalCreditsRewarded = t.readInt(), this._totalCreditsSpent = t.readInt(), this._creditRewardForStreakBonus = t.readInt(), this._creditRewardForMonthlySpent = t.readInt(), this._timeUntilPayday = t.readInt();
  }
  get currentHcStreak() {
    return this._currentHcStreak;
  }
  get firstSubscriptionDate() {
    return this._firstSubscriptionDate;
  }
  get kickbackPercentage() {
    return this._kickbackPercentage;
  }
  get totalCreditsMissed() {
    return this._totalCreditsMissed;
  }
  get totalCreditsRewarded() {
    return this._totalCreditsRewarded;
  }
  get totalCreditsSpent() {
    return this._totalCreditsSpent;
  }
  get creditRewardForStreakBonus() {
    return this._creditRewardForStreakBonus;
  }
  get creditRewardForMonthlySpent() {
    return this._creditRewardForMonthlySpent;
  }
  get timeUntilPayday() {
    return this._timeUntilPayday;
  }
}
class VV {
  flush() {
    return this._data = null, !0;
  }
  parse(t) {
    return this._data = new zV(t), !0;
  }
  get data() {
    return this._data;
  }
}
class HV {
  flush() {
    return this._looks = /* @__PURE__ */ new Map(), !0;
  }
  parse(t) {
    if (!t) return !1;
    t.readInt();
    let e = t.readInt();
    for (; e > 0; ) {
      const s = t.readInt(), r = t.readString(), n = t.readString();
      this._looks.set(s, [r, n]), e--;
    }
    return !0;
  }
  get looks() {
    return this._looks;
  }
}
class YV {
  flush() {
    return this._result = -1, !0;
  }
  parse(t) {
    return t ? (this._result = t.readInt(), !0) : !1;
  }
  get result() {
    return this._result;
  }
}
class WV {
  flush() {
    return this._isVip = !1, this._rooms = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._isVip = t.readBoolean();
    let e = t.readInt();
    for (; e > 0; )
      this._rooms.push(new kV(t.readInt(), t.readString(), t.readBoolean())), e--;
    return !0;
  }
  get isVip() {
    return this._isVip;
  }
  get rooms() {
    return this._rooms;
  }
}
class jV {
  flush() {
    return this._pageId = -1, this._data = null, !0;
  }
  parse(t) {
    return t ? (this._pageId = t.readInt(), this._data = new Xd(t), !0) : !1;
  }
  get pageId() {
    return this._pageId;
  }
  get data() {
    return this._data;
  }
}
class XV {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this.flush(), this.parse(t);
  }
  flush() {
    return this._type = -1, this._breedId = -1, this._paletteId = -1, this._sellable = !1, this._rare = !1, !0;
  }
  parse(t) {
    return t ? (this._type = t.readInt(), this._breedId = t.readInt(), this._paletteId = t.readInt(), this._sellable = t.readBoolean(), this._rare = t.readBoolean(), !0) : !1;
  }
  get type() {
    return this._type;
  }
  get breedId() {
    return this._breedId;
  }
  get paletteId() {
    return this._paletteId;
  }
  get sellable() {
    return this._sellable;
  }
  get rare() {
    return this._rare;
  }
}
class KV {
  flush() {
    return this._productCode = "", this._palettes = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._productCode = t.readString();
    let e = t.readInt();
    for (; e > 0; )
      this._palettes.push(new XV(t)), e--;
    return !0;
  }
  get productCode() {
    return this._productCode;
  }
  get palettes() {
    return this._palettes;
  }
}
class qV {
  constructor(t) {
    this._trackingState = t.readInt(), this._id = t.readInt(), this._identifier = t.readString(), this._productCode = t.readString(), this._priceInCredits = t.readInt(), this._priceInActivityPoints = t.readInt(), this._activityPointType = t.readInt(), this._purchaseLimit = t.readInt();
    const e = t.readInt();
    this._expirationTime = e > 0 ? e * 1e3 + Date.now() : 0, this._title = t.readString(), this._description = t.readString(), this._imageUrl = t.readString(), this._iconImageUrl = t.readString(), this._type = t.readInt(), this._subProductCodes = [];
    let s = t.readInt();
    for (; s > 0; )
      this._subProductCodes.push(t.readString()), s--;
    return this;
  }
  populate(t) {
    t && (this._id = t.id, this._identifier = t.identifier, this._type = t.type, this._title = t.title, this._description = t.description, this._imageUrl = t.imageUrl, this._iconImageUrl = t.iconImageUrl, this._productCode = t.productCode, this._purchaseLimit = t.purchaseLimit, this._expirationTime = t.expirationTime, this._priceInCredits = t.priceInCredits, this._priceInActivityPoints = t.priceInActivityPoints, this._activityPointType = t.activityPointType, this._subProductCodes = t.subProductCodes, this._trackingState = t.trackingState);
  }
  purchase(t) {
    this._purchaseLimit = this._purchaseLimit - t;
  }
  get id() {
    return this._id;
  }
  get identifier() {
    return this._identifier;
  }
  get type() {
    return this._type;
  }
  get title() {
    return this._title;
  }
  get description() {
    return this._description;
  }
  get imageUrl() {
    return this._imageUrl;
  }
  get iconImageUrl() {
    return this._iconImageUrl;
  }
  get productCode() {
    return this._productCode;
  }
  get purchaseLimit() {
    return this._purchaseLimit;
  }
  get expirationTime() {
    return this._expirationTime;
  }
  get priceInCredits() {
    return this._priceInCredits;
  }
  get priceInActivityPoints() {
    return this._priceInActivityPoints;
  }
  get activityPointType() {
    return this._activityPointType;
  }
  get subProductCodes() {
    return this._subProductCodes;
  }
  get trackingState() {
    return this._trackingState;
  }
}
class $V {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class ZV {
  flush() {
    return this._data = null, !0;
  }
  parse(t) {
    return t ? (this._data = new qV(t), !0) : !1;
  }
  get data() {
    return this._data;
  }
}
class QV {
  constructor() {
    this._errorCode = "";
  }
  flush() {
    return this._errorCode = "", !0;
  }
  parse(t) {
    return t ? (this._errorCode = t.readString(), !0) : !1;
  }
  get errorCode() {
    return this._errorCode;
  }
}
class JV {
  constructor() {
    this._productName = "", this._productDescription = "";
  }
  flush() {
    return this._productDescription = "", this._productName = "", !0;
  }
  parse(t) {
    return t ? (this._productDescription = t.readString(), this._productName = t.readString(), !0) : !1;
  }
  get productName() {
    return this._productName;
  }
  get productDescription() {
    return this._productDescription;
  }
}
class t5 {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
const nr = class nr {
  flush() {
    return this._goalId = 0, this._goalCode = null, this._result = 0, this._requiredFurnis = null, this._missingFurnis = null, !0;
  }
  parse(t) {
    this._goalId = t.readInt(), this._goalCode = t.readString(), this._result = t.readInt(), this._requiredFurnis = [];
    let e = t.readInt();
    for (; e > 0; )
      this._requiredFurnis.push(t.readString()), e--;
    for (e = t.readInt(); e > 0; )
      this._missingFurnis[t.readString()] = "", e--;
    return !0;
  }
  get goalId() {
    return this._goalId;
  }
  get goalCode() {
    return this._goalCode;
  }
  get result() {
    return this._result;
  }
  get requiredFurnis() {
    return this._requiredFurnis;
  }
  isMissing(t) {
    return !!this._missingFurnis[t];
  }
};
nr.SUBMITTED = 0, nr.ASK_FOR_SUBMIT = 1, nr.ASK_FOR_CONFIRM = 2, nr.PREREQUISITES_NOT_MET = 3, nr.ROOM_DOOR_NOT_OPEN = 4, nr.ROOM_TOO_OLD = 5, nr.ASK_FOR_ACCEPT_RULES = 6;
let Jp = nr;
const $h = class $h {
};
$h.ALLOWED = 0, $h.REQUIRED_PERK_MISSING = 1, $h.REQUIRED_BADGE_MISSING = 2;
let tm = $h;
class e5 {
  flush() {
    return this._goalId = 0, this._goalCode = null, this._resultCode = 0, this._votesRemaining = 0, !0;
  }
  parse(t) {
    return this._goalId = t.readInt(), this._goalCode = t.readString(), this._resultCode = t.readInt(), this._votesRemaining = t.readInt(), !0;
  }
  get goalId() {
    return this._goalId;
  }
  get goalCode() {
    return this._goalCode;
  }
  get isVotingAllowedForUser() {
    return this._resultCode === tm.ALLOWED;
  }
  get votesRemaining() {
    return this._votesRemaining;
  }
  get resultCode() {
    return this._resultCode;
  }
}
class s5 {
  flush() {
    return this._schedulingStr = null, this._code = null, !0;
  }
  parse(t) {
    return this._schedulingStr = t.readString(), this._code = t.readString(), !0;
  }
  get schedulingStr() {
    return this._schedulingStr;
  }
  get code() {
    return this._code;
  }
}
class i5 {
  flush() {
    return this._isPartOf = !1, this._targetId = 0, !0;
  }
  parse(t) {
    return this._isPartOf = t.readBoolean(), this._targetId = t.readInt(), !0;
  }
  get isPartOf() {
    return this._isPartOf;
  }
  get targetId() {
    return this._targetId;
  }
}
class r5 {
  flush() {
    return !0;
  }
  parse(t) {
    return !0;
  }
}
class n5 {
  flush() {
    return this._timeStr = null, this._secondsUntil = 0, !0;
  }
  parse(t) {
    return this._timeStr = t.readString(), this._secondsUntil = t.readInt(), !0;
  }
  get timeStr() {
    return this._timeStr;
  }
  get secondsUntil() {
    return this._secondsUntil;
  }
}
class Dv {
  constructor(t) {
    this._recipeName = t.readString(), this._itemName = t.readString();
  }
  get recipeName() {
    return this._recipeName;
  }
  get itemName() {
    return this._itemName;
  }
}
class a5 {
  constructor() {
    this._recipes = [], this._ingredients = [];
  }
  flush() {
    return this._recipes = [], this._ingredients = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    const e = t.readInt();
    for (let r = 0; r < e; r++)
      this._recipes.push(new Dv(t));
    const s = t.readInt();
    for (let r = 0; r < s; r++)
      this._ingredients.push(t.readString());
    return !0;
  }
  get recipes() {
    return this._recipes;
  }
  get ingredients() {
    return this._ingredients;
  }
  isActive() {
    return this._recipes.length > 0 || this._ingredients.length > 0;
  }
}
class o5 {
  constructor(t) {
    this._count = t.readInt(), this._itemName = t.readString();
  }
  get count() {
    return this._count;
  }
  get itemName() {
    return this._itemName;
  }
}
class h5 {
  constructor() {
    this._ingredients = [];
  }
  parse(t) {
    if (!t) return !1;
    const e = t.readInt();
    for (let s = 0; s < e; s++)
      this._ingredients.push(new o5(t));
    return !0;
  }
  flush() {
    return this._ingredients = [], !0;
  }
  get ingredients() {
    return this._ingredients;
  }
}
class u5 {
  parse(t) {
    return t ? (this._count = t.readInt(), this._hasRecipes = t.readBoolean(), !0) : !1;
  }
  flush() {
    return this._count = 0, this._hasRecipes = !1, !0;
  }
  get count() {
    return this._count;
  }
  get hasRecipes() {
    return this._hasRecipes;
  }
}
class l5 {
  parse(t) {
    return t ? (this._success = t.readBoolean(), this._success && (this._result = new Dv(t)), !0) : !1;
  }
  flush() {
    return this._success = !1, !0;
  }
  get success() {
    return this._success;
  }
  get result() {
    return this._result;
  }
}
class c5 {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class _5 {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this._senderId = t.readInt(), this._errorCode = t.readInt();
  }
  get senderId() {
    return this._senderId;
  }
  get errorCode() {
    return this._errorCode;
  }
}
class d5 {
  flush() {
    return this._failuers = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; )
      this._failuers.push(new _5(t)), e--;
    return !0;
  }
  get failures() {
    return this._failuers;
  }
}
class f5 {
  flush() {
    return this._success = !1, !0;
  }
  parse(t) {
    return t ? (this._success = t.readBoolean(), !0) : !1;
  }
  get success() {
    return this._success;
  }
}
class g5 {
  flush() {
    return this._errorCode = 0, !0;
  }
  parse(t) {
    return t ? (this._errorCode = t.readInt(), !0) : !1;
  }
  get errorCode() {
    return this._errorCode;
  }
}
class Lv {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this._id = t.readInt(), this._name = t.readString();
  }
  get id() {
    return this._id;
  }
  get name() {
    return this._name;
  }
}
class em {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this._id = t.readInt(), this._name = t.readString(), this._gender = t.readInt(), this._online = t.readBoolean(), this._followingAllowed = t.readBoolean(), this._figure = t.readString(), this._categoryId = t.readInt(), this._motto = t.readString(), this._realName = t.readString(), this._lastAccess = t.readString(), this._persistedMessageUser = t.readBoolean(), this._vipMember = t.readBoolean(), this._pocketHabboUser = t.readBoolean(), this._relationshipStatus = t.readShort();
  }
  get id() {
    return this._id;
  }
  get name() {
    return this._name;
  }
  get gender() {
    return this._gender;
  }
  get online() {
    return this._online;
  }
  get followingAllowed() {
    return this._followingAllowed;
  }
  get figure() {
    return this._figure;
  }
  get categoryId() {
    return this._categoryId;
  }
  get motto() {
    return this._motto;
  }
  get lastAccess() {
    return this._lastAccess;
  }
  get realName() {
    return this._realName;
  }
  get persistedMessageUser() {
    return this._persistedMessageUser;
  }
  get vipMember() {
    return this._vipMember;
  }
  get pocketHabboUser() {
    return this._pocketHabboUser;
  }
  get relationshipStatus() {
    return this._relationshipStatus;
  }
}
class p5 {
  flush() {
    return this._totalFragments = 0, this._fragmentNumber = 0, this._fragment = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._totalFragments = t.readInt(), this._fragmentNumber = t.readInt();
    let e = t.readInt();
    for (; e > 0; )
      this._fragment.push(new em(t)), e--;
    return !0;
  }
  get totalFragments() {
    return this._totalFragments;
  }
  get fragmentNumber() {
    return this._fragmentNumber;
  }
  get fragment() {
    return this._fragment;
  }
}
class m5 {
  flush() {
    return this._categories = [], this._removedFriendIds = [], this._addedFriends = [], this._updatedFriends = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; )
      this._categories.push(new Lv(t)), e--;
    let s = t.readInt();
    for (; s > 0; ) {
      const r = t.readInt();
      r === -1 ? this._removedFriendIds.push(t.readInt()) : r === 0 ? this._updatedFriends.push(new em(t)) : r === 1 && this._addedFriends.push(new em(t)), s--;
    }
    return !0;
  }
  get categories() {
    return this._categories;
  }
  get removedFriendIds() {
    return this._removedFriendIds;
  }
  get addedFriends() {
    return this._addedFriends;
  }
  get updatedFriends() {
    return this._updatedFriends;
  }
}
class E5 {
  flush() {
    return this._typeCode = -1, this._avatarId = 0, this._message = null, !0;
  }
  parse(t) {
    return t ? (this._typeCode = t.readInt(), this._avatarId = t.readInt(), this._message = t.readString(), !0) : !1;
  }
  get typeCode() {
    return this._typeCode;
  }
  get avatarId() {
    return this._avatarId;
  }
  get message() {
    return this._message;
  }
}
class Fv {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this._requestId = t.readInt(), this._requesterName = t.readString(), this._figureString = t.readString(), this._requesterUserId = this._requestId;
  }
  get requestId() {
    return this._requestId;
  }
  get requesterName() {
    return this._requesterName;
  }
  get requesterUserId() {
    return this._requesterUserId;
  }
  get figureString() {
    return this._figureString;
  }
}
class T5 {
  flush() {
    return this._totalRequests = 0, this._requests = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._totalRequests = t.readInt();
    let e = t.readInt();
    for (; e > 0; )
      this._requests.push(new Fv(t)), e--;
    return !0;
  }
  get totalRequests() {
    return this._totalRequests;
  }
  get requests() {
    return this._requests;
  }
}
class ER {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this._avatarId = t.readInt(), this._avatarName = t.readString(), this._avatarMotto = t.readString(), this._isAvatarOnline = t.readBoolean(), this._canFollow = t.readBoolean(), this._lastOnlineData = t.readString(), this._avatarGender = t.readInt(), this._avatarFigure = t.readString(), this._realName = t.readString();
  }
  get avatarId() {
    return this._avatarId;
  }
  get avatarName() {
    return this._avatarName;
  }
  get avatarMotto() {
    return this._avatarMotto;
  }
  get isAvatarOnline() {
    return this._isAvatarOnline;
  }
  get canFollow() {
    return this._canFollow;
  }
  get avatarGender() {
    return this._avatarGender;
  }
  get avatarFigure() {
    return this._avatarFigure;
  }
  get lastOnlineData() {
    return this._lastOnlineData;
  }
  get realName() {
    return this._realName;
  }
}
class I5 {
  flush() {
    return this._friends = [], this._others = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; )
      this._friends.push(new ER(t)), e--;
    let s = t.readInt();
    for (; s > 0; )
      this._others.push(new ER(t)), s--;
    return !0;
  }
  get friends() {
    return this._friends;
  }
  get others() {
    return this._others;
  }
}
class S5 {
  flush() {
    return this._errorCode = 0, this._userId = 0, this._message = null, !0;
  }
  parse(t) {
    return t ? (this._errorCode = t.readInt(), this._userId = t.readInt(), this._message = t.readString(), !0) : !1;
  }
  get errorCode() {
    return this._errorCode;
  }
  get userId() {
    return this._userId;
  }
  get message() {
    return this._message;
  }
}
class A5 {
  flush() {
    return this._clientMessageId = 0, this._errorCode = 0, !0;
  }
  parse(t) {
    return t ? (this._clientMessageId = t.readInt(), this._errorCode = t.readInt(), !0) : !1;
  }
  get clientMessageId() {
    return this._clientMessageId;
  }
  get errorCode() {
    return this._errorCode;
  }
}
class R5 {
  flush() {
    return this._userFriendLimit = 0, this._normalFriendLimit = 0, this._extendedFriendLimit = 0, this._categories = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._userFriendLimit = t.readInt(), this._normalFriendLimit = t.readInt(), this._extendedFriendLimit = t.readInt();
    let e = t.readInt();
    for (; e > 0; )
      this._categories.push(new Lv(t)), e--;
    return !0;
  }
  get userFriendLimit() {
    return this._userFriendLimit;
  }
  get normalFriendLimit() {
    return this._normalFriendLimit;
  }
  get extendedFriendLimit() {
    return this._extendedFriendLimit;
  }
  get categories() {
    return this._categories;
  }
}
class O5 {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class y5 {
  flush() {
    return this._count = 0, !0;
  }
  parse(t) {
    return t ? (this._count = t.readInt(), !0) : !1;
  }
  get count() {
    return this._count;
  }
}
class v5 {
  flush() {
    return this._senderId = 0, this._messageText = null, this._secondsSinceSent = 0, this._extraData = null, !0;
  }
  parse(t) {
    return t ? (this._senderId = t.readInt(), this._messageText = t.readString(), this._secondsSinceSent = t.readInt(), t.bytesAvailable && (this._extraData = t.readString()), !0) : !1;
  }
  get senderId() {
    return this._senderId;
  }
  get messageText() {
    return this._messageText;
  }
  get secondsSinceSent() {
    return this._secondsSinceSent;
  }
  get extraData() {
    return this._extraData;
  }
}
class C5 {
  flush() {
    return this._request = null, !0;
  }
  parse(t) {
    return t ? (this._request = new Fv(t), !0) : !1;
  }
  get request() {
    return this._request;
  }
}
class x5 {
  flush() {
    return this._errorCode = 0, this._failedRecipients = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._errorCode = t.readInt();
    let e = t.readInt();
    for (; e > 0; )
      this._failedRecipients.push(t.readInt()), e--;
    return !0;
  }
  get errorCode() {
    return this._errorCode;
  }
  get failedRecipients() {
    return this._failedRecipients;
  }
}
class M5 {
  flush() {
    return this._senderId = 0, this._messageText = null, !0;
  }
  parse(t) {
    return t ? (this._senderId = t.readInt(), this._messageText = t.readString(), !0) : !1;
  }
  get senderId() {
    return this._senderId;
  }
  get messageText() {
    return this._messageText;
  }
}
class b5 {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._gameTypeId = t.readInt(), this._freeGamesLeft = t.readInt(), this._gamesPlayedTotal = t.readInt(), !0) : !1;
  }
  get gameTypeId() {
    return this._gameTypeId;
  }
  get freeGamesLeft() {
    return this._freeGamesLeft;
  }
  get gamesPlayedTotal() {
    return this._gamesPlayedTotal;
  }
  get hasUnlimitedGames() {
    return this._freeGamesLeft == -1;
  }
}
const mo = class mo {
  flush() {
    return this._status = -1, this._blockLength = -1, this._gamesPlayed = -1, this._freeGamesLeft = -1, !0;
  }
  parse(t) {
    return t ? (this._status = t.readInt(), this._blockLength = t.readInt(), this._gamesPlayed = t.readInt(), this._freeGamesLeft = t.readInt(), !0) : !1;
  }
  get status() {
    return this._status;
  }
  get blockLength() {
    return this._blockLength;
  }
  get gamesPlayed() {
    return this._gamesPlayed;
  }
  get freeGamesLeft() {
    return this._freeGamesLeft;
  }
  get hasUnlimitedGames() {
    return this._freeGamesLeft == -1;
  }
};
mo.STATUS_OK = 0, mo.STATUS_FAILED_REASON_UNKNOWN = 1, mo.STATUS_FAILED_REASON_GAME_DIRECTORY_IS_NOT_AVAILABLE = 2, mo.STATUS_FAILED_REASON_HOTEL_IS_CLOSED = 3;
let sm = mo;
class P5 {
  flush() {
    return this._position = -1, !0;
  }
  parse(t) {
    return t ? (this._position = t.readInt(), !0) : !1;
  }
  get position() {
    return this._position;
  }
}
const Ci = class Ci {
  flush() {
    return this._reason = -1, !0;
  }
  parse(t) {
    return t ? (this._reason = t.readInt(), !0) : !1;
  }
  get reason() {
    return this._reason;
  }
};
Ci.KICKED = 1, Ci.DUPLICATE_MACHINEID = 2, Ci.INVITATION_REQUIRED = 3, Ci.NO_SPACE_IN_TEAM = 4, Ci.TEAM_NOT_FOUND = 5, Ci.USER_HAS_ACTIVE_INSTANCE = 6, Ci.USER_HAS_PENDING_INSTANCE_REQUEST = 7, Ci.USER_HAS_NO_FREE_GAMES_LEFT = 8;
let im = Ci;
const sd = class sd {
  flush() {
    return this._reason = -1, !0;
  }
  parse(t) {
    return t ? (this._reason = t.readInt(), !0) : !1;
  }
  get reason() {
    return this._reason;
  }
};
sd.NOT_ENOUGH_PLAYERS = 1, sd.GAME_HAS_NO_OWNER = 2;
let rm = sd;
class N5 {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class U5 {
  flush() {
    return this._userId = -1, !0;
  }
  parse(t) {
    return t ? (this._userId = t.readInt(), !0) : !1;
  }
  get userId() {
    return this._userId;
  }
}
class D5 {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._stuffCode = t.readString(), this._badgeCode = t.readString(), !0) : !1;
  }
  get stuffCode() {
    return this._stuffCode;
  }
  get badgeCode() {
    return this._badgeCode;
  }
}
class L5 {
  flush() {
    return this._stuffId = -1, this._achievementId = 0, this._requiredLevelBadgeCode = "", this._userProgress = 0, this._totalProgress = 0, this._endTime = 0, !0;
  }
  parse(t) {
    return t ? (this._stuffId = t.readInt(), this._achievementId = t.readInt(), this._requiredLevelBadgeCode = t.readString(), this._userProgress = t.readInt(), this._totalProgress = t.readInt(), this._endTime = t.readInt(), !0) : !1;
  }
  get stuffId() {
    return this._stuffId;
  }
  get achievementId() {
    return this._achievementId;
  }
  get requiredLevelBadgeCode() {
    return this._requiredLevelBadgeCode;
  }
  get userProgress() {
    return this._userProgress;
  }
  get totalProgress() {
    return this._totalProgress;
  }
  get endTime() {
    return this._endTime;
  }
}
class F5 {
  flush() {
    return !0;
  }
  parse(t) {
    if (!t) return !1;
    this._stuffId = t.readInt();
    const e = t.readInt();
    let s = 0;
    for (; s < e; )
      this._achievements.push(new Yp(t)), s++;
    return this._endTime = t.readInt(), !0;
  }
  get stuffId() {
    return this._stuffId;
  }
  get achievements() {
    return this._achievements;
  }
  get endTime() {
    return this._endTime;
  }
}
class w5 {
  constructor(t, e, s, r) {
    this._gameTypeId = t, this._achievementId = e, this._achievementName = s, this._levels = r;
  }
  get gameTypeId() {
    return this._gameTypeId;
  }
  get achievementId() {
    return this._achievementId;
  }
  get achievementName() {
    return this._achievementName;
  }
  get levels() {
    return this._levels;
  }
}
class G5 {
  flush() {
    return !0;
  }
  parse(t) {
    if (!t) return !1;
    this._achievements = [];
    const e = t.readInt();
    let s = 0;
    for (; s < e; ) {
      const r = t.readInt(), n = t.readInt();
      let a = 0;
      for (; a < n; ) {
        const o = t.readInt(), h = t.readString(), u = t.readInt();
        this._achievements.push(new w5(r, o, h, u)), a++;
      }
      s++;
    }
    return !0;
  }
  get achievements() {
    return this._achievements;
  }
}
class B5 {
  constructor(t, e, s, r, n, a) {
    this._gameId = t, this._gameNameId = e, this._bgColor = s, this._textColor = r, this._assetUrl = n, this._supportUrl = a;
  }
  get gameId() {
    return this._gameId;
  }
  get gameNameId() {
    return this._gameNameId;
  }
  get bgColor() {
    return this._bgColor;
  }
  get textColor() {
    return this._textColor;
  }
  get assetUrl() {
    return this._assetUrl;
  }
  get supportUrl() {
    return this._supportUrl;
  }
}
class k5 {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._gameTypeId = t.readInt(), this._inviterId = t.readInt(), !0) : !1;
  }
  get gameTypeId() {
    return this._gameTypeId;
  }
  get inviterId() {
    return this._inviterId;
  }
}
class z5 {
  flush() {
    return !0;
  }
  parse(t) {
    if (!t) return !1;
    this._games = [];
    const e = t.readInt();
    for (let s = 0; s < e; s++) {
      const r = t.readInt(), n = t.readString(), a = t.readString();
      let o = parseInt(a, 16);
      o = o | 4278190080;
      const h = t.readString();
      let u = parseInt(h, 16);
      u = u | 4278190080;
      const c = t.readString(), l = t.readString();
      this._games.push(new B5(r, n, o, u, c, l));
    }
    return !0;
  }
  get games() {
    return this._games;
  }
}
const Eo = class Eo {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._gameTypeId = t.readInt(), this._status = t.readInt(), !0) : !1;
  }
  get gameTypeId() {
    return this._gameTypeId;
  }
  get isOk() {
    return this._status == Eo.OK;
  }
  get isInMaintenance() {
    return this._status == Eo.MAINTENANCE;
  }
};
Eo.OK = 0, Eo.MAINTENANCE = 1;
let nm = Eo;
class V5 {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._gameTypeId = t.readInt(), !0) : !1;
  }
  get gameTypeId() {
    return this._gameTypeId;
  }
}
const YI = class YI {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._gameTypeId = t.readInt(), this._reason = t.readInt(), !0) : !1;
  }
  get gameTypeId() {
    return this._gameTypeId;
  }
  get reason() {
    return this._reason;
  }
};
YI.DUPLICATE_MACHINEID = 1;
let am = YI;
class H5 {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._gameTypeId = t.readInt(), !0) : !1;
  }
  get gameTypeId() {
    return this._gameTypeId;
  }
}
class Y5 {
  flush() {
    return !0;
  }
  parse(t) {
    if (!t) return !1;
    this._gameTypeId = t.readInt(), this._gameClientId = t.readString(), this._url = t.readString(), this._quality = t.readString(), this._scaleMode = t.readString(), this._frameRate = t.readInt(), this._minMajorVersion = t.readInt(), this._minMinorVersion = t.readInt(), this._params = /* @__PURE__ */ new Map();
    const e = t.readInt();
    let s = 0;
    for (; s < e; )
      this._params.set(t.readString(), t.readString()), s++;
    return !0;
  }
  get gameTypeId() {
    return this._gameTypeId;
  }
  get url() {
    return this._url;
  }
  get quality() {
    return this._quality;
  }
  get scaleMode() {
    return this._scaleMode;
  }
  get frameRate() {
    return this._frameRate;
  }
  get minMajorVersion() {
    return this._minMajorVersion;
  }
  get minMinorVersion() {
    return this._minMinorVersion;
  }
  get params() {
    return this._params;
  }
  get gameClientId() {
    return this._gameClientId;
  }
}
class W5 {
  flush() {
    return this._gameTypeId = 0, this._url = null, this._gameClientId = null, !0;
  }
  parse(t) {
    return t ? (this._gameTypeId = t.readInt(), this._gameClientId = t.readString(), this._url = t.readString(), !0) : !1;
  }
  get gameTypeId() {
    return this._gameTypeId;
  }
  get url() {
    return this._url;
  }
  get gameClientId() {
    return this._gameClientId;
  }
}
class j5 {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._gameTypeId = t.readInt(), this._gameClientId = t.readString(), !0) : !1;
  }
  get gameTypeId() {
    return this._gameTypeId;
  }
  get gameClientId() {
    return this._gameClientId;
  }
}
class X5 {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class qd {
  flush() {
    return this._year = -1, this._week = -1, this._maxOffset = -1, this._currentOffset = -1, this._minutesUntilReset = -1, !0;
  }
  parse(t) {
    return t ? (this._year = t.readInt(), this._week = t.readInt(), this._maxOffset = t.readInt(), this._currentOffset = t.readInt(), this._minutesUntilReset = t.readInt(), !0) : !1;
  }
  get year() {
    return this._year;
  }
  get week() {
    return this._week;
  }
  get maxOffset() {
    return this._maxOffset;
  }
  get currentOffset() {
    return this._currentOffset;
  }
  get minutesUntilReset() {
    return this._minutesUntilReset;
  }
}
class K5 {
  constructor(t) {
    this._name = t.readString(), this._figure = t.readString(), this._gender = t.readString(), this._rank = t.readInt(), this._score = t.readInt();
  }
  get name() {
    return this._name;
  }
  get figure() {
    return this._figure;
  }
  get gender() {
    return this._gender;
  }
  get rank() {
    return this._rank;
  }
  get score() {
    return this._score;
  }
}
class snt {
  constructor(t) {
    this._userId = t.readInt(), this._score = t.readInt(), this._rank = t.readInt(), this._name = t.readString(), this._figure = t.readString(), this._gender = t.readString();
  }
  get userId() {
    return this._userId;
  }
  get score() {
    return this._score;
  }
  get rank() {
    return this._rank;
  }
  get figure() {
    return this._figure;
  }
  get gender() {
    return this._gender;
  }
  get name() {
    return this._name;
  }
}
class q5 {
  flush() {
    return this._gameTypeId = -1, this._products = [], this._minutesUntilNextWeek = 0, this._rewardingOn = !0, !0;
  }
  parse(t) {
    if (!t) return !1;
    this._gameTypeId = t.readInt();
    let e = t.readInt();
    for (; e > 0; )
      this._products.push(new jd(t)), e--;
    return this._minutesUntilNextWeek = t.readInt(), this._rewardingOn = t.readBoolean(), !0;
  }
  get gameTypeId() {
    return this._gameTypeId;
  }
  get products() {
    return this._products;
  }
  get minutesUntilNextWeek() {
    return this._minutesUntilNextWeek;
  }
  get rewardingOn() {
    return this._rewardingOn;
  }
}
class $5 {
  flush() {
    return this._gameTypeId = -1, this._winners = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._gameTypeId = t.readInt();
    let e = t.readInt();
    for (; e > 0; )
      this._winners.push(new K5(t)), e--;
    return !0;
  }
  get gameTypeId() {
    return this._gameTypeId;
  }
  get winners() {
    return this._winners;
  }
}
class Z5 {
  flush() {
    return this._errorCode = 0, !0;
  }
  parse(t) {
    return t ? (this._errorCode = t.readInt(), !0) : !1;
  }
  get errorCode() {
    return this._errorCode;
  }
}
class Q5 {
  flush() {
    return this._phoneStatusCode = -1, this._millisecondsToAllowProcessReset = -1, !0;
  }
  parse(t) {
    return t ? (this._phoneStatusCode = t.readInt(), this._collectionStatusCode = t.readInt(), this._millisecondsToAllowProcessReset = t.readInt(), !0) : !1;
  }
  get phoneStatusCode() {
    return this._phoneStatusCode;
  }
  get collectionStatusCode() {
    return this._collectionStatusCode;
  }
  get millisecondsToAllowProcessReset() {
    return this._millisecondsToAllowProcessReset;
  }
}
class J5 {
  flush() {
    return this._resultCode = -1, !0;
  }
  parse(t) {
    return t ? (this._resultCode = t.readInt(), this._millisToAllowProcessReset = t.readInt(), !0) : !1;
  }
  get resultCode() {
    return this._resultCode;
  }
  get millisToAllowProcessReset() {
    return this._millisToAllowProcessReset;
  }
}
class tH {
  flush() {
    return this._resultCode = -1, this._millisecondsToAllowProcessReset = -1, !0;
  }
  parse(t) {
    return t ? (this._resultCode = t.readInt(), this._millisecondsToAllowProcessReset = t.readInt(), !0) : !1;
  }
  get resultCode() {
    return this._resultCode;
  }
  get millisToAllowProcessReset() {
    return this._millisecondsToAllowProcessReset;
  }
}
class eH {
  flush() {
    return this._bases = /* @__PURE__ */ new Map(), this._symbols = /* @__PURE__ */ new Map(), this._partColors = /* @__PURE__ */ new Map(), this._colorsA = /* @__PURE__ */ new Map(), this._colorsB = /* @__PURE__ */ new Map(), !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; ) {
      const o = t.readInt(), h = t.readString(), u = t.readString();
      this._bases.set(o, [h, u]), e--;
    }
    let s = t.readInt();
    for (; s > 0; ) {
      const o = t.readInt(), h = t.readString(), u = t.readString();
      this._symbols.set(o, [h, u]), s--;
    }
    let r = t.readInt();
    for (; r > 0; ) {
      const o = t.readInt(), h = t.readString();
      this._partColors.set(o, h), r--;
    }
    let n = t.readInt();
    for (; n > 0; ) {
      const o = t.readInt(), h = t.readString();
      this._colorsA.set(o, h), n--;
    }
    let a = t.readInt();
    for (; a > 0; ) {
      const o = t.readInt(), h = t.readString();
      this._colorsB.set(o, h), a--;
    }
    return !0;
  }
  get bases() {
    return this._bases;
  }
  get symbols() {
    return this._symbols;
  }
  get partColors() {
    return this._partColors;
  }
  get colorsA() {
    return this._colorsA;
  }
  get colorsB() {
    return this._colorsB;
  }
}
class sH {
  flush() {
    return this._groupCost = 0, this._availableRooms = /* @__PURE__ */ new Map(), !0;
  }
  parse(t) {
    if (!t) return !1;
    this._groupCost = t.readInt();
    let e = t.readInt();
    for (; e > 0; ) {
      const s = t.readInt(), r = t.readString();
      t.readBoolean(), this._availableRooms.set(s, r), e--;
    }
    return !0;
  }
  get groupCost() {
    return this._groupCost;
  }
  get availableRooms() {
    return this._availableRooms;
  }
}
class iH {
  flush() {
    return this._userId = 0, this._furnitureCount = 0, !0;
  }
  parse(t) {
    return t ? (this._userId = t.readInt(), this._furnitureCount = t.readInt(), !0) : !1;
  }
  get userId() {
    return this._userId;
  }
  get furnitureCount() {
    return this._furnitureCount;
  }
}
class rH {
  flush() {
    return this._id = 0, this._type = 0, this._title = null, this._description = null, this._badge = null, this._roomId = 0, this._roomName = null, this._membershipType = 0, this._membersCount = 0, this._isFavorite = !1, this._createdAt = null, this._isOwner = !1, this._isAdmin = !1, this._ownerName = null, this._flag = !1, this._canMembersDecorate = !1, this._pendingRequestsCount = 0, !0;
  }
  parse(t) {
    return t ? (this._id = t.readInt(), t.readBoolean(), this._type = t.readInt(), this._title = t.readString(), this._description = t.readString(), this._badge = t.readString(), this._roomId = t.readInt(), this._roomName = t.readString(), this._membershipType = t.readInt(), this._membersCount = t.readInt(), this._isFavorite = t.readBoolean(), this._createdAt = t.readString(), this._isOwner = t.readBoolean(), this._isAdmin = t.readBoolean(), this._ownerName = t.readString(), this._flag = t.readBoolean(), this._canMembersDecorate = t.readBoolean(), this._pendingRequestsCount = t.readInt(), !0) : !1;
  }
  get id() {
    return this._id;
  }
  get type() {
    return this._type;
  }
  get title() {
    return this._title;
  }
  get description() {
    return this._description;
  }
  get badge() {
    return this._badge;
  }
  get roomId() {
    return this._roomId;
  }
  get roomName() {
    return this._roomName;
  }
  get membershipType() {
    return this._membershipType;
  }
  get membersCount() {
    return this._membersCount;
  }
  get isFavorite() {
    return this._isFavorite;
  }
  get createdAt() {
    return this._createdAt;
  }
  get isOwner() {
    return this._isOwner;
  }
  get isAdmin() {
    return this._isAdmin;
  }
  get ownerName() {
    return this._ownerName;
  }
  get flag() {
    return this._flag;
  }
  get canMembersDecorate() {
    return this._canMembersDecorate;
  }
  get pendingRequestsCount() {
    return this._pendingRequestsCount;
  }
}
class nH {
  constructor(t) {
    this.isBase = t, this.key = 0, this.color = 0, this.position = 4;
  }
  get code() {
    return this.key === 0 ? null : (this.isBase ? "b" : "s") + (this.key < 100 ? "0" : "") + (this.key < 10 ? "0" : "") + this.key + (this.color < 10 ? "0" : "") + this.color + this.position;
  }
}
const Kn = class Kn {
};
Kn.OWNER = 0, Kn.ADMIN = 1, Kn.MEMBER = 2, Kn.REQUESTED = 3, Kn.DELETED = 4;
let TR = Kn;
class aH {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this.flush(), this.parse(t);
  }
  flush() {
    return this._rank = -1, this._id = 0, this._name = null, this._figure = null, this._joinedAt = null, !0;
  }
  parse(t) {
    return t ? (this._rank = t.readInt(), this._id = t.readInt(), this._name = t.readString(), this._figure = t.readString(), this._joinedAt = t.readString(), !0) : !1;
  }
  get id() {
    return this._id;
  }
  get name() {
    return this._name;
  }
  get figure() {
    return this._figure;
  }
  get rank() {
    return this._rank;
  }
  get joinedAt() {
    return this._joinedAt;
  }
}
class oH {
  flush() {
    return this._groupId = 0, this._groupTitle = null, this._roomId = 0, this._badge = null, this._totalMembersCount = 0, this._result = [], this._admin = !1, this._pageSize = 0, this._pageIndex = 0, this._level = 0, this._query = null, !0;
  }
  parse(t) {
    if (!t) return !1;
    this._groupId = t.readInt(), this._groupTitle = t.readString(), this._roomId = t.readInt(), this._badge = t.readString(), this._totalMembersCount = t.readInt();
    let e = t.readInt();
    for (; e > 0; )
      this._result.push(new aH(t)), e--;
    return this._admin = t.readBoolean(), this._pageSize = t.readInt(), this._pageIndex = t.readInt(), this._level = t.readInt(), this._query = t.readString(), !0;
  }
  get groupId() {
    return this._groupId;
  }
  get groupTitle() {
    return this._groupTitle;
  }
  get roomId() {
    return this._roomId;
  }
  get badge() {
    return this._badge;
  }
  get totalMembersCount() {
    return this._totalMembersCount;
  }
  get result() {
    return this._result;
  }
  get admin() {
    return this._admin;
  }
  get pageSize() {
    return this._pageSize;
  }
  get pageIndex() {
    return this._pageIndex;
  }
  get level() {
    return this._level;
  }
  get query() {
    return this._query;
  }
}
class hH {
  flush() {
    return this._roomId = 0, this._groupId = 0, !0;
  }
  parse(t) {
    return t ? (this._roomId = t.readInt(), this._groupId = t.readInt(), !0) : !1;
  }
  get roomId() {
    return this._roomId;
  }
  get guildId() {
    return this._groupId;
  }
}
class uH {
  flush() {
    return this._roomId = 0, this._roomName = null, this._id = 0, this._title = null, this._description = null, this._colorA = 0, this._colorB = 0, this._state = 0, this._canMembersDecorate = !1, this._badgeParts = /* @__PURE__ */ new Map(), this._badgeCode = null, this._membersCount = 0, !0;
  }
  parse(t) {
    if (!t) return !1;
    t.readInt() === 1 && (this._roomId = t.readInt(), this._roomName = t.readString(), t.readBoolean()), t.readBoolean(), this._id = t.readInt(), this._title = t.readString(), this._description = t.readString(), t.readInt(), this._colorA = t.readInt(), this._colorB = t.readInt(), this._state = t.readInt(), this._canMembersDecorate = t.readInt() === 0, t.readBoolean(), t.readString();
    const s = t.readInt();
    for (let r = 0; r < s; r++) {
      const n = new nH(r === 0);
      n.key = t.readInt(), n.color = t.readInt(), n.position = t.readInt(), n.key === 0 && (n.position = 4), this._badgeParts.set(r, n);
    }
    return this._badgeCode = t.readString(), this._membersCount = t.readInt(), !0;
  }
  get roomId() {
    return this._roomId;
  }
  get roomName() {
    return this._roomName;
  }
  get id() {
    return this._id;
  }
  get title() {
    return this._title;
  }
  get description() {
    return this._description;
  }
  get colorA() {
    return this._colorA;
  }
  get colorB() {
    return this._colorB;
  }
  get state() {
    return this._state;
  }
  get canMembersDecorate() {
    return this._canMembersDecorate;
  }
  get badgeParts() {
    return this._badgeParts;
  }
  get badgeCode() {
    return this._badgeCode;
  }
  get membersCount() {
    return this._membersCount;
  }
}
class lH {
  flush() {
    return !0;
  }
  parse(t) {
    return this._groupId = t.readInt(), !0;
  }
  get groupId() {
    return this._groupId;
  }
}
class Uu {
  static parse(t) {
    return this.fillFromMessage(new Uu(), t);
  }
  static fillFromMessage(t, e) {
    return t._groupId = e.readInt(), t._name = e.readString(), t._description = e.readString(), t._icon = e.readString(), t._totalThreads = e.readInt(), t._leaderboardScore = e.readInt(), t._totalMessages = e.readInt(), t._unreadMessages = e.readInt(), t._lastMessageId = e.readInt(), t._lastMessageAuthorId = e.readInt(), t._lastMessageAuthorName = e.readString(), t._lastMessageTimeAsSecondsAgo = e.readInt(), t;
  }
  get groupId() {
    return this._groupId;
  }
  get name() {
    return this._name;
  }
  get description() {
    return this._description;
  }
  get icon() {
    return this._icon;
  }
  get totalThreads() {
    return this._totalThreads;
  }
  get leaderboardScore() {
    return this._leaderboardScore;
  }
  get totalMessages() {
    return this._totalMessages;
  }
  get unreadMessages() {
    return this._unreadMessages;
  }
  get lastMessageId() {
    return this._lastMessageId;
  }
  get lastMessageAuthorId() {
    return this._lastMessageAuthorId;
  }
  get lastMessageAuthorName() {
    return this._lastMessageAuthorName;
  }
  get lastMessageTimeAsSecondsAgo() {
    return this._lastMessageTimeAsSecondsAgo;
  }
  updateFrom(t) {
    this._totalThreads = t._totalThreads, this._totalMessages = t._totalMessages, this._unreadMessages = t._unreadMessages, this._lastMessageAuthorId = t._lastMessageAuthorId, this._lastMessageAuthorName = t._lastMessageAuthorName, this._lastMessageId = t._lastMessageId, this._lastMessageTimeAsSecondsAgo = t._lastMessageTimeAsSecondsAgo;
  }
  get lastReadMessageId() {
    return this._totalMessages - this._unreadMessages;
  }
  set lastReadMessageId(t) {
    this._unreadMessages = this._totalMessages - t, this._unreadMessages < 0 && (this._unreadMessages = 0);
  }
  addNewThread(t) {
    this._lastMessageAuthorId = t.lastUserId, this._lastMessageAuthorName = t.lastUserName, this._lastMessageId = t.lastMessageId, this._lastMessageTimeAsSecondsAgo = t.lastCommentTime, this._totalThreads++, this._totalMessages++, this._unreadMessages = 0;
  }
}
class aI extends Uu {
  static parse(t) {
    const e = new aI();
    return Uu.fillFromMessage(e, t), e._readPermissions = t.readInt(), e._postMessagePermissions = t.readInt(), e._postThreadPermissions = t.readInt(), e._moderatePermissions = t.readInt(), e._readPermissionError = t.readString(), e._postMessagePermissionError = t.readString(), e._postThreadPermissionError = t.readString(), e._moderatePermissionError = t.readString(), e._reportPermissionError = t.readString(), e._canChangeSettings = t.readBoolean(), e._isStaff = t.readBoolean(), e;
  }
  get readPermissions() {
    return this._readPermissions;
  }
  get postMessagePermissions() {
    return this._postMessagePermissions;
  }
  get postThreadPermissions() {
    return this._postThreadPermissions;
  }
  get moderatePermissions() {
    return this._moderatePermissions;
  }
  get hasReadPermissionError() {
    return this._readPermissionError.length === 0;
  }
  get canReport() {
    return !0;
  }
  get hasPostMessagePermissionError() {
    return this._postMessagePermissionError.length === 0;
  }
  get hasPostThreadPermissionError() {
    return this._postThreadPermissionError.length === 0;
  }
  get hasModeratePermissionError() {
    return this._moderatePermissionError.length === 0;
  }
  get canChangeSettings() {
    return this._canChangeSettings;
  }
  get isStaf() {
    return this._isStaff;
  }
  get readPermissionError() {
    return this._readPermissionError;
  }
  get postMessagePermissionError() {
    return this._postMessagePermissionError;
  }
  get postThreadPermissionError() {
    return this._postThreadPermissionError;
  }
  get moderatePermissionError() {
    return this._moderatePermissionError;
  }
  get reportPermissionError() {
    return this._reportPermissionError;
  }
}
class cH {
  flush() {
    return this._extendedForumData = null, !0;
  }
  parse(t) {
    return t ? (this._extendedForumData = aI.parse(t), !0) : !1;
  }
  get extendedForumData() {
    return this._extendedForumData;
  }
}
class _H {
  flush() {
    return this._listCode = -1, this._totalAmount = 0, this._startIndex = -1, this._amount = 0, this._forums = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._listCode = t.readInt(), this._totalAmount = t.readInt(), this._startIndex = t.readInt(), this._amount = t.readInt(), this._forums = [];
    let e = 0;
    for (; e < this._amount; )
      this._forums.push(Uu.parse(t)), e++;
    return !0;
  }
  get listCode() {
    return this._listCode;
  }
  get totalAmount() {
    return this._totalAmount;
  }
  get startIndex() {
    return this._startIndex;
  }
  get amount() {
    return this._amount;
  }
  get forums() {
    return this._forums;
  }
}
class ju {
  static parse(t) {
    const e = new ju();
    return e._threadId = t.readInt(), e._authorId = t.readInt(), e._authorName = t.readString(), e._header = t.readString(), e._isPinned = t.readBoolean(), e._isLocked = t.readBoolean(), e._creationTimeAsSecondsAgo = t.readInt(), e._totalMessages = t.readInt(), e._unreadMessagesCount = t.readInt(), e._lastMessageId = t.readInt(), e._lastUserId = t.readInt(), e._lastUserName = t.readString(), e._lastCommentTime = t.readInt(), e._state = t.readByte(), e._adminId = t.readInt(), e._adminName = t.readString(), e._adminOperationTimeAsSecondsAgo = t.readInt(), e;
  }
  get adminOperationTimeAsSecondsAgo() {
    return this._adminOperationTimeAsSecondsAgo;
  }
  set adminOperationTimeAsSecondsAgo(t) {
    this._adminOperationTimeAsSecondsAgo = t;
  }
  get lastCommentTime() {
    return this._lastCommentTime;
  }
  set lastCommentTime(t) {
    this._lastCommentTime = t;
  }
  get threadId() {
    return this._threadId;
  }
  set threadId(t) {
    this._threadId = t;
  }
  get authorId() {
    return this._authorId;
  }
  set authorId(t) {
    this._authorId = t;
  }
  get authorName() {
    return this._authorName;
  }
  set authorName(t) {
    this._authorName = t;
  }
  get creationTimeAsSecondsAgo() {
    return this._creationTimeAsSecondsAgo;
  }
  set creationTimeAsSecondsAgo(t) {
    this._creationTimeAsSecondsAgo = t;
  }
  get header() {
    return this._header;
  }
  set header(t) {
    this._header = t;
  }
  get lastMessageId() {
    return this._lastMessageId;
  }
  set lastMessageId(t) {
    this._lastMessageId = t;
  }
  get lastUserId() {
    return this._lastUserId;
  }
  set lastUserId(t) {
    this._lastUserId = t;
  }
  get lastUserName() {
    return this._lastUserName;
  }
  set lastUserName(t) {
    this._lastUserName = t;
  }
  get totalMessages() {
    return this._totalMessages;
  }
  set totalMessages(t) {
    this._totalMessages = t;
  }
  get unreadMessagesCount() {
    return this._unreadMessagesCount;
  }
  set unreadMessagesCount(t) {
    this._unreadMessagesCount = t;
  }
  get state() {
    return this._state;
  }
  set state(t) {
    this._state = t;
  }
  get adminId() {
    return this._adminId;
  }
  set adminId(t) {
    this._adminId = t;
  }
  get adminName() {
    return this._adminName;
  }
  set adminName(t) {
    this._adminName = t;
  }
  get isPinned() {
    return this._isPinned;
  }
  set isPinned(t) {
    this._isPinned = t;
  }
  get isLocked() {
    return this._isLocked;
  }
  set isLocked(t) {
    this._isLocked = t;
  }
}
class dH {
  flush() {
    return this._groupId = -1, this._startIndex = -1, this._amount = 0, this._threads = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._groupId = t.readInt(), this._startIndex = t.readInt(), this._amount = t.readInt(), this._threads = [];
    let e = 0;
    for (; e < this._amount; )
      this._threads.push(ju.parse(t)), e++;
    return !0;
  }
  get groupId() {
    return this._groupId;
  }
  get startIndex() {
    return this._startIndex;
  }
  get amount() {
    return this._amount;
  }
  get threads() {
    return this._threads;
  }
}
class Xu {
  static parse(t) {
    const e = new Xu();
    return e._messageId = t.readInt(), e._messageIndex = t.readInt(), e._authorId = t.readInt(), e._authorName = t.readString(), e._authorFigure = t.readString(), e._creationTime = t.readInt(), e._messageText = t.readString(), e._state = t.readByte(), e._adminId = t.readInt(), e._adminName = t.readString(), e._adminOperationTimeAsSeccondsAgo = t.readInt(), e._authorPostCount = t.readInt(), e;
  }
  get state() {
    return this._state;
  }
  set state(t) {
    this._state = t;
  }
  get adminId() {
    return this._adminId;
  }
  set adminId(t) {
    this._adminId = t;
  }
  get adminName() {
    return this._adminName;
  }
  set adminName(t) {
    this._adminName = t;
  }
  get adminOperationTimeAsSeccondsAgo() {
    return this._adminOperationTimeAsSeccondsAgo;
  }
  set adminOperationTimeAsSeccondsAgo(t) {
    this._adminOperationTimeAsSeccondsAgo = t;
  }
  get messageId() {
    return this._messageId;
  }
  set messageId(t) {
    this._messageId = t;
  }
  get creationTime() {
    return this._creationTime;
  }
  set creationTime(t) {
    this._creationTime = t;
  }
  get authorName() {
    return this._authorName;
  }
  set authorName(t) {
    this._authorName = t;
  }
  get authorFigure() {
    return this._authorFigure;
  }
  set authorFigure(t) {
    this._authorFigure = t;
  }
  get threadId() {
    return this._threadId;
  }
  set threadId(t) {
    this._threadId = t;
  }
  get messageIndex() {
    return this._messageIndex;
  }
  set messageIndex(t) {
    this._messageIndex = t;
  }
  set groupID(t) {
    this._groupId = t;
  }
  get groupId() {
    return this._groupId;
  }
  get authorId() {
    return this._authorId;
  }
  set authorId(t) {
    this._authorId = t;
  }
  get messageText() {
    return this._messageText;
  }
  set messageText(t) {
    this._messageText = t;
  }
  get authorPostCount() {
    return this._authorPostCount;
  }
  set authorPostCount(t) {
    this._authorPostCount = t;
  }
}
class fH {
  flush() {
    return this._groupId = -1, this._threadId = -1, this._message = null, !0;
  }
  parse(t) {
    return t ? (this._groupId = t.readInt(), this._threadId = t.readInt(), this._message = Xu.parse(t), !0) : !1;
  }
  get groupId() {
    return this._groupId;
  }
  get threadId() {
    return this._threadId;
  }
  get message() {
    return this._message;
  }
}
class gH {
  flush() {
    return this._groupId = -1, this._thread = null, !0;
  }
  parse(t) {
    return t ? (this._groupId = t.readInt(), this._thread = ju.parse(t), !0) : !1;
  }
  get groupId() {
    return this._groupId;
  }
  get thread() {
    return this._thread;
  }
}
class pH {
  flush() {
    return this._groupId = -1, this._threadId = -1, this._startIndex = -1, this._amount = 0, this._messages = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._groupId = t.readInt(), this._threadId = t.readInt(), this._startIndex = t.readInt(), this._amount = t.readInt(), this._messages = [];
    let e = 0;
    for (; e < this._amount; ) {
      const s = Xu.parse(t);
      s.groupID = this._groupId, s.threadId = this._threadId, this._messages.push(s), e++;
    }
    return !0;
  }
  get groupId() {
    return this._groupId;
  }
  get threadId() {
    return this._threadId;
  }
  get startIndex() {
    return this._startIndex;
  }
  get amount() {
    return this._amount;
  }
  get messages() {
    return this._messages;
  }
}
class mH {
  flush() {
    return this._count = 0, !0;
  }
  parse(t) {
    return t ? (this._count = t.readInt(), !0) : !1;
  }
  get count() {
    return this._count;
  }
}
class EH {
  flush() {
    return this._groupId = -1, this._threadId = -1, this._message = null, !0;
  }
  parse(t) {
    return t ? (this._groupId = t.readInt(), this._threadId = t.readInt(), this._message = Xu.parse(t), !0) : !1;
  }
  get groupId() {
    return this._groupId;
  }
  get threadId() {
    return this._threadId;
  }
  get message() {
    return this._message;
  }
}
class TH {
  flush() {
    return this._groupId = -1, this._thread = null, !0;
  }
  parse(t) {
    return t ? (this._groupId = t.readInt(), this._thread = ju.parse(t), !0) : !1;
  }
  get groupId() {
    return this._groupId;
  }
  get thread() {
    return this._thread;
  }
}
class IH {
  constructor() {
    this._encryptedPublicKey = null, this._serverClientEncryption = !1;
  }
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._encryptedPublicKey = t.readString(), t.bytesAvailable && (this._serverClientEncryption = t.readBoolean()), !0) : !1;
  }
  get encryptedPublicKey() {
    return this._encryptedPublicKey;
  }
  get serverClientEncryption() {
    return this._serverClientEncryption;
  }
}
class SH {
  flush() {
    return this._reason = -1, !0;
  }
  parse(t) {
    return t ? (this._reason = 0, t.bytesAvailable && (this._reason = t.readInt()), !0) : !1;
  }
  get reason() {
    return this._reason;
  }
}
class AH {
  flush() {
    return this._accounts && (this._accounts = /* @__PURE__ */ new Map()), !0;
  }
  parse(t) {
    if (!t) return !1;
    this._accounts = /* @__PURE__ */ new Map();
    let e = t.readInt();
    for (; e > 0; )
      this._accounts.set(t.readInt(), t.readString()), e--;
    return !0;
  }
  get accounts() {
    return this._accounts;
  }
}
class RH {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._encryptedPrime = t.readString(), this._encryptedGenerator = t.readString(), !0) : !1;
  }
  get encryptedPrime() {
    return this._encryptedPrime;
  }
  get encryptedGenerator() {
    return this._encryptedGenerator;
  }
}
class OH {
  flush() {
    return this._noobnessLevel = 0, !0;
  }
  parse(t) {
    return t ? (this._noobnessLevel = t.readInt(), !0) : !1;
  }
  get noobnessLevel() {
    return this._noobnessLevel;
  }
}
class yH {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._infoUrl = t.readString(), !0) : !1;
  }
  get infoUrl() {
    return this._infoUrl;
  }
}
class vH {
  flush() {
    return !0;
  }
  parse(t) {
    return !0;
  }
}
class CH {
  flush() {
    return this._calls = [], !0;
  }
  parse(t) {
    this._calls = [];
    const e = t.readInt();
    for (let s = 0; s < e; s++) {
      const r = t.readString(), n = t.readString(), a = t.readString();
      this._calls.push({ callId: r, timeStamp: n, message: a });
    }
    return !0;
  }
  get pendingCalls() {
    return this._calls;
  }
  get count() {
    return this._calls.length;
  }
}
class xH {
  flush() {
    return this._message = null, !0;
  }
  parse(t) {
    return this._message = t.readString(), !0;
  }
  get message() {
    return this._message;
  }
}
class MH {
  flush() {
    return this._resultType = 0, this._messageText = null, !0;
  }
  parse(t) {
    return t ? (this._resultType = t.readInt(), this._messageText = t.readString(), !0) : !1;
  }
  get resultType() {
    return this._resultType;
  }
  get messageText() {
    return this._messageText;
  }
}
class bH {
  flush() {
    return !0;
  }
  parse(t) {
    return !0;
  }
}
class PH {
  flush() {
    return this._acceptanceTimeout = -1, !0;
  }
  parse(t) {
    return this._acceptanceTimeout = t.readInt(), !0;
  }
  get acceptanceTimeout() {
    return this._acceptanceTimeout;
  }
}
class NH {
  flush() {
    return this._winningVoteCode = -1, this._ownVoteCode = -1, this._finalStatus = null, !0;
  }
  parse(t) {
    this._finalStatus = [], this._winningVoteCode = t.readInt(), this._ownVoteCode = t.readInt();
    const e = t.readInt();
    for (let s = 0; s < e; s++)
      this._finalStatus.push(t.readInt());
    return !0;
  }
  get winningVoteCode() {
    return this._winningVoteCode;
  }
  get ownVoteCode() {
    return this._ownVoteCode;
  }
  get finalStatus() {
    return this._finalStatus;
  }
}
class UH {
  flush() {
    return !0;
  }
  parse(t) {
    return this._votingTimeout = t.readInt(), this._chatRecord = t.readString(), !0;
  }
  get votingTimeout() {
    return this._votingTimeout;
  }
  get chatRecord() {
    return this._chatRecord;
  }
}
const Hr = class Hr {
  flush() {
    return this._status = null, !0;
  }
  parse(t) {
    this._status = [];
    const e = t.readInt();
    for (let s = 0; s < e; s++)
      this._status.push(t.readInt());
    return !0;
  }
  get status() {
    return this._status;
  }
};
Hr.AWAITING_VOTE = 0, Hr.VOTED_OK = 1, Hr.VOTED_BAD = 2, Hr.VOTED_VERY_BAD = 3, Hr.NO_VOTE = 4, Hr.FINDING_NEW_VOTER = 5;
let om = Hr;
class DH {
  flush() {
    return this._onDuty = !1, this._guidesOnDuty = 0, this._helpersOnDuty = 0, this._guardiansOnDuty = 0, !0;
  }
  parse(t) {
    return t ? (this._onDuty = t.readBoolean(), this._guidesOnDuty = t.readInt(), this._helpersOnDuty = t.readInt(), this._guardiansOnDuty = t.readInt(), !0) : !1;
  }
  get onDuty() {
    return this._onDuty;
  }
  get guidesOnDuty() {
    return this._guidesOnDuty;
  }
  get helpersOnDuty() {
    return this._helpersOnDuty;
  }
  get guardiansOnDuty() {
    return this._guardiansOnDuty;
  }
}
class LH {
  constructor(t, e, s, r, n, a, o) {
    this._type = t, this._secondsAgo = e, this._isGuide = s, this._otherPartyName = r, this._otherPartyFigure = n, this._description = a, this._roomName = o;
  }
  get type() {
    return this._type;
  }
  set type(t) {
    this._type = t;
  }
  get secondsAgo() {
    return this._secondsAgo;
  }
  set secondsAgo(t) {
    this._secondsAgo = t;
  }
  get isGuide() {
    return this._isGuide;
  }
  set isGuide(t) {
    this._isGuide = t;
  }
  get otherPartyName() {
    return this._otherPartyName;
  }
  set otherPartyName(t) {
    this._otherPartyName = t;
  }
  get otherPartyFigure() {
    return this._otherPartyFigure;
  }
  set otherPartyFigure(t) {
    this._otherPartyFigure = t;
  }
  get description() {
    return this._description;
  }
  set description(t) {
    this._description = t;
  }
  get roomName() {
    return this._roomName;
  }
  set roomName(t) {
    this._roomName = t;
  }
}
const To = class To {
  flush() {
    return this._statusCode = 0, this._pendingTicket = null, !0;
  }
  parse(t) {
    return t ? (this._statusCode = t.readInt(), this._pendingTicket = new LH(
      t.readInt(),
      t.readInt(),
      t.readBoolean(),
      t.readString(),
      t.readString(),
      t.readString(),
      t.readString()
    ), !0) : !1;
  }
  get statusCode() {
    return this._statusCode;
  }
  get pendingTicket() {
    return this._pendingTicket;
  }
};
To.GUIDE_REPORTING_STATUS_OK = 0, To.GUIDE_REPORTING_STATUS_PENDING_TICKET = 1, To.GUIDE_REPORTING_STATUS_ABUSIVE = 2, To.GUIDE_REPORTING_STATUS_REPORTING_TOO_QUICKLY = 3;
let hm = To;
class FH {
  flush() {
    return this._asGuide = !1, this._helpRequestType = 0, this._helpRequestDescription = null, this._roleSpecificWaitTime = 0, !0;
  }
  parse(t) {
    return t ? (this._asGuide = t.readBoolean(), this._helpRequestType = t.readInt(), this._helpRequestDescription = t.readString(), this._roleSpecificWaitTime = t.readInt(), !0) : !1;
  }
  get asGuide() {
    return this._asGuide;
  }
  get helpRequestType() {
    return this._helpRequestType;
  }
  get helpRequestDescription() {
    return this._helpRequestDescription;
  }
  get roleSpecificWaitTime() {
    return this._roleSpecificWaitTime;
  }
}
class wH {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class GH {
  flush() {
    return this._endReason = 0, !0;
  }
  parse(t) {
    return t ? (this._endReason = t.readInt(), !0) : !1;
  }
  get endReason() {
    return this._endReason;
  }
}
const qn = class qn {
  flush() {
    return this._errorCode = 0, !0;
  }
  parse(t) {
    return t ? (this._errorCode = t.readInt(), !0) : !1;
  }
  get errorCode() {
    return this._errorCode;
  }
};
qn.ERROR_GENERIC = 0, qn.ERROR_GUIDES_REJECT = 1, qn.ERROR_NOT_ENOUGH_GUIDES = 2, qn.ERROR_NOT_ENOUGH_VOTES = 3, qn.ERROR_NO_CHATLOG_FOUND = 4;
let um = qn;
class BH {
  flush() {
    return this._roomId = 0, this._roomName = null, !0;
  }
  parse(t) {
    return t ? (this._roomId = t.readInt(), this._roomName = t.readString(), !0) : !1;
  }
  get roomId() {
    return this._roomId;
  }
  get roomName() {
    return this._roomName;
  }
}
class kH {
  flush() {
    return this._chatMessage = null, this._senderId = 0, !0;
  }
  parse(t) {
    return t ? (this._chatMessage = t.readString(), this._senderId = t.readInt(), !0) : !1;
  }
  get chatMessage() {
    return this._chatMessage;
  }
  get senderId() {
    return this._senderId;
  }
}
class zH {
  flush() {
    return this._isTyping = !1, !0;
  }
  parse(t) {
    return t ? (this._isTyping = t.readBoolean(), !0) : !1;
  }
  get isTyping() {
    return this._isTyping;
  }
}
class VH {
  flush() {
    return this._requesterRoomId = 0, !0;
  }
  parse(t) {
    return t ? (this._requesterRoomId = t.readInt(), !0) : !1;
  }
  get requesterRoomId() {
    return this._requesterRoomId;
  }
}
class HH {
  flush() {
    return this._requesterUserId = 0, this._requesterName = null, this._requesterFigure = null, this._guideUserId = 0, this._guideName = null, this._guideFigure = null, !0;
  }
  parse(t) {
    return t ? (this._requesterUserId = t.readInt(), this._requesterName = t.readString(), this._requesterFigure = t.readString(), this._guideUserId = t.readInt(), this._guideName = t.readString(), this._guideFigure = t.readString(), !0) : !1;
  }
  get requesterUserId() {
    return this._requesterUserId;
  }
  get requesterName() {
    return this._requesterName;
  }
  get requesterFigure() {
    return this._requesterFigure;
  }
  get guideUserId() {
    return this._guideUserId;
  }
  get guideName() {
    return this._guideName;
  }
  get guideFigure() {
    return this._guideFigure;
  }
}
const Io = class Io {
  flush() {
    return this._result = 0, !0;
  }
  parse(t) {
    return t ? (this._result = t.readInt(), !0) : !1;
  }
  get result() {
    return this._result;
  }
};
Io.CREATION_RESULT_OK = 0, Io.CREATION_RESULT_UNABLE_TO_REPORT = 1, Io.CREATION_RESULT_NO_CHATLOG_FOUND = 2, Io.CREATION_RESULT_BULLY_ALREADY_REPORTED = 3;
let lm = Io;
const Zh = class Zh {
  flush() {
    return this._resolution = 0, !0;
  }
  parse(t) {
    return t ? (this._resolution = t.readInt(), !0) : !1;
  }
  get resolution() {
    return this._resolution;
  }
};
Zh.RESOLUTION_GUARDIANS_TOOK_ACTION = 0, Zh.RESOLUTION_FORWARDED_TO_MODERATORS = 1, Zh.RESOLUTION_REPORTER_IS_ABUSIVE = 2;
let cm = Zh;
class YH {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class WH {
  flush() {
    return this._closeReason = 0, this._messageText = "", !0;
  }
  parse(t) {
    return t ? (this._closeReason = t.readInt(), this._messageText = t.readString(), !0) : !1;
  }
  get closeReason() {
    return this._closeReason;
  }
  get messageText() {
    return this._messageText;
  }
}
class jH {
  flush() {
    return this._quizCode = null, this._questionIds = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._quizCode = t.readString();
    const e = t.readInt();
    this._questionIds = [];
    for (let s = 0; s < e; s++) this._questionIds.push(t.readInt());
    return !0;
  }
  get quizCode() {
    return this._quizCode;
  }
  get questionIds() {
    return this._questionIds;
  }
}
class XH {
  flush() {
    return this._quizCode = null, this._questionIdsForWrongAnswers = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._quizCode = t.readString();
    const e = t.readInt();
    this._questionIdsForWrongAnswers = [];
    for (let s = 0; s < e; s++) this._questionIdsForWrongAnswers.push(t.readInt());
    return !0;
  }
  get quizCode() {
    return this._quizCode;
  }
  get questionIdsForWrongAnswers() {
    return this._questionIdsForWrongAnswers;
  }
}
const Qh = class Qh {
  constructor(t) {
    this._id = t.readInt(), this._title = t.readString(), this._bodyText = t.readString(), this._buttonText = t.readString(), this._linkType = t.readInt(), this._linkContent = t.readString(), this._imageUrl = t.readString();
  }
  get id() {
    return this._id;
  }
  get title() {
    return this._title;
  }
  get bodyText() {
    return this._bodyText;
  }
  get buttonText() {
    return this._buttonText;
  }
  get linkType() {
    return this._linkType;
  }
  get linkContent() {
    return this._linkContent;
  }
  get imageUrl() {
    return this._imageUrl;
  }
};
Qh.LINK_TYPE_URL = 0, Qh.LINK_TYPE_INTERNAL = 1, Qh.LINK_TYPE_NO_LINK = 2;
let _m = Qh;
class KH {
  flush() {
    return this._articles = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    const e = t.readInt();
    for (let s = 0; s < e; s++)
      this._articles.push(new _m(t));
    return !0;
  }
  get articles() {
    return this._articles;
  }
}
class qH {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._acknowledged = t.readBoolean(), !0) : !1;
  }
  get acknowledged() {
    return this._acknowledged;
  }
}
class $H {
  flush() {
    return this._newOfferId = -1, this._newPrice = 0, this._requestedOfferId = -1, !0;
  }
  parse(t) {
    return t ? (this._result = t.readInt(), this._newOfferId = t.readInt(), this._newPrice = t.readInt(), this._requestedOfferId = t.readInt(), !0) : !1;
  }
  get result() {
    return this._result;
  }
  get offerId() {
    return this._newOfferId;
  }
  get newPrice() {
    return this._newPrice;
  }
  get requestedOfferId() {
    return this._requestedOfferId;
  }
}
class ZH {
  flush() {
    return this._offerId = 0, this._success = !1, !0;
  }
  parse(t) {
    return t ? (this._offerId = t.readInt(), this._success = t.readBoolean(), !0) : !1;
  }
  get offerId() {
    return this._offerId;
  }
  get success() {
    return this._success;
  }
}
class QH {
  flush() {
    return this._tokenCount = 0, this._result = 0, !0;
  }
  parse(t) {
    return t ? (this._result = t.readInt(), this._tokenCount = t.readInt(), !0) : !1;
  }
  get tokenCount() {
    return this._tokenCount;
  }
  get resultCode() {
    return this._result;
  }
}
class JH {
  flush() {
    return this._enabled = !1, this._commission = 0, this._credits = 0, this._advertisements = 0, this._maximumPrice = 0, this._minimumPrice = 0, this._offerTime = 0, this._displayTime = 0, !0;
  }
  parse(t) {
    return t ? (this._enabled = t.readBoolean(), this._commission = t.readInt(), this._credits = t.readInt(), this._advertisements = t.readInt(), this._minimumPrice = t.readInt(), this._maximumPrice = t.readInt(), this._offerTime = t.readInt(), this._displayTime = t.readInt(), !0) : !1;
  }
  get enabled() {
    return this._enabled;
  }
  get commission() {
    return this._commission;
  }
  get credits() {
    return this._credits;
  }
  get advertisements() {
    return this._advertisements;
  }
  get minimumPrice() {
    return this._minimumPrice;
  }
  get maximumPrice() {
    return this._maximumPrice;
  }
  get offerTime() {
    return this._offerTime;
  }
  get displayTime() {
    return this._displayTime;
  }
}
class tY {
  flush() {
    return this._result = 0, !0;
  }
  parse(t) {
    return t ? (this._result = t.readInt(), !0) : !1;
  }
  get result() {
    return this._result;
  }
}
class eY {
  flush() {
    return this._averagePrice = 0, this._currentOfferCount = 0, this._historyLength = 0, this._dayOffsets = [], this._averagePrices = [], this._soldAmounts = [], this._furniTypeId = 0, this._furniCategoryId = 0, !0;
  }
  parse(t) {
    if (!t) return !1;
    this._averagePrice = t.readInt(), this._currentOfferCount = t.readInt(), this._historyLength = t.readInt();
    let e = t.readInt();
    for (; e > 0; )
      this._dayOffsets.push(t.readInt()), this._averagePrices.push(t.readInt()), this._soldAmounts.push(t.readInt()), e--;
    return this._furniCategoryId = t.readInt(), this._furniTypeId = t.readInt(), !0;
  }
  get averagePrice() {
    return this._averagePrice;
  }
  get offerCount() {
    return this._currentOfferCount;
  }
  get historyLength() {
    return this._historyLength;
  }
  get dayOffsets() {
    return this._dayOffsets;
  }
  get averagePrices() {
    return this._averagePrices;
  }
  get soldAmounts() {
    return this._soldAmounts;
  }
  get furniTypeId() {
    return this._furniTypeId;
  }
  get furniCategoryId() {
    return this._furniCategoryId;
  }
}
class wv {
  constructor(t, e, s, r, n, a, o, h, u, c = -1) {
    this._timeLeftMinutes = -1, this._offerId = t, this._furniId = e, this._furniType = s, this._extraData = r, this._stuffData = n, this._price = a, this._status = o, this._timeLeftMinutes = h, this._averagePrice = u, this._offerCount = c;
  }
  get offerId() {
    return this._offerId;
  }
  get furniId() {
    return this._furniId;
  }
  get furniType() {
    return this._furniType;
  }
  get extraData() {
    return this._extraData;
  }
  get stuffData() {
    return this._stuffData;
  }
  get price() {
    return this._price;
  }
  get status() {
    return this._status;
  }
  get timeLeftMinutes() {
    return this._timeLeftMinutes;
  }
  get averagePrice() {
    return this._averagePrice;
  }
  get offerCount() {
    return this._offerCount;
  }
  get isUniqueLimitedItem() {
    return this.stuffData != null && this.stuffData.uniqueSeries > 0;
  }
}
const id = class id {
  constructor(t, e, s, r, n, a, o, h, u = -1) {
    this._timeLeftMinutes = -1, this._offerId = t, this._furniId = e, this._furniType = s, this._extraData = r, this._stuffData = n, this._price = a, this._status = o, this._averagePrice = h, this._offerCount = u;
  }
  get offerId() {
    return this._offerId;
  }
  set offerId(t) {
    this._offerId = t;
  }
  get furniId() {
    return this._furniId;
  }
  get furniType() {
    return this._furniType;
  }
  get extraData() {
    return this._extraData;
  }
  get stuffData() {
    return this._stuffData;
  }
  get price() {
    return this._price;
  }
  set price(t) {
    this._price = t;
  }
  get averagePrice() {
    return this._averagePrice;
  }
  get image() {
    return this._image;
  }
  set image(t) {
    this._image = t;
  }
  get imageCallback() {
    return this._imageCallback;
  }
  set imageCallback(t) {
    this._imageCallback = t;
  }
  get status() {
    return this._status;
  }
  get timeLeftMinutes() {
    return this._timeLeftMinutes;
  }
  set timeLeftMinutes(t) {
    this._timeLeftMinutes = t;
  }
  get offerCount() {
    return this._offerCount;
  }
  set offerCount(t) {
    this._offerCount = t;
  }
  get isUniqueLimitedItem() {
    return this.stuffData && this.stuffData.uniqueSeries > 0;
  }
};
id.TYPE_LANDSCAPE = 1, id.TYPE_FLOOR = 2;
let IR = id;
const ar = class ar {
  constructor() {
    this.MAX_LIST_LENGTH = 500;
  }
  flush() {
    return this._offers = [], this._totalItemsFound = 0, !0;
  }
  parse(t) {
    if (!t) return !1;
    const e = t.readInt();
    let s = 0;
    for (; s < e; ) {
      const r = t.readInt(), n = t.readInt();
      let a = t.readInt(), o = -1, h = "", u = null;
      a === ar.FURNITYPE_STUFF ? (o = t.readInt(), u = Tn.parseObjectData(t)) : a === ar.FURNITYPE_WALL ? (o = t.readInt(), h = t.readString()) : a == ar.FAKE_FURNITYPE_UNIQUE && (o = t.readInt(), u = tn.getData(ns.FORMAT_KEY), u.uniqueNumber = t.readInt(), u.uniqueSeries = t.readInt(), a = ar.FURNITYPE_STUFF);
      const c = t.readInt(), l = t.readInt(), _ = t.readInt(), d = t.readInt(), f = new wv(r, o, a, h, u, c, n, l, _, d);
      s < this.MAX_LIST_LENGTH && this._offers.push(f), s++;
    }
    return this._totalItemsFound = t.readInt(), !0;
  }
  get offers() {
    return this._offers;
  }
  get totalItemsFound() {
    return this._totalItemsFound;
  }
};
ar.FURNITYPE_STUFF = 1, ar.FURNITYPE_WALL = 2, ar.FAKE_FURNITYPE_UNIQUE = 3;
let dm = ar;
const rd = class rd {
  flush() {
    return this._offers = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._offers = [], this._creditsWaiting = t.readInt();
    const e = t.readInt();
    for (let s = 0; s < e; s++) {
      const r = t.readInt(), n = t.readInt();
      let a = t.readInt(), o, h, u;
      a == 1 ? (o = t.readInt(), u = this.getStuffData(t)) : a == 2 ? (o = t.readInt(), h = t.readString()) : a == 3 && (o = t.readInt(), u = tn.getData(ns.FORMAT_KEY), u.uniqueNumber = t.readInt(), u.uniqueSeries = t.readInt(), a = 1);
      const c = t.readInt(), l = t.readInt(), _ = t.readInt(), d = new wv(r, o, a, h, u, c, n, l, _);
      s < rd.MAX_LIST_LENGTH && this._offers.push(d);
    }
    return !0;
  }
  get offers() {
    return this._offers;
  }
  get creditsWaiting() {
    return this._creditsWaiting;
  }
  getStuffData(t) {
    const e = t.readInt(), s = tn.getData(e);
    return s.parseWrapper(t), s;
  }
};
rd.MAX_LIST_LENGTH = 500;
let fm = rd;
class sY {
  constructor(t, e, s, r, n) {
    this._timestamp = t, this._habboId = e, this._username = s, this._message = r, this._hasHighlighting = n;
  }
  get timestamp() {
    return this._timestamp;
  }
  get userId() {
    return this._habboId;
  }
  get userName() {
    return this._username;
  }
  get message() {
    return this._message;
  }
  get hasHighlighting() {
    return this._hasHighlighting;
  }
}
const or = class or {
  constructor(t) {
    this._context = /* @__PURE__ */ new Map(), this._chatlog = [], this._recordType = t.readByte();
    const e = t.readShort();
    for (let r = 0; r < e; r++) {
      const n = t.readString(), a = t.readByte();
      switch (a) {
        case 0:
          this._context.set(n, t.readBoolean());
          break;
        case 1:
          this._context.set(n, t.readInt());
          break;
        case 2:
          this._context.set(n, t.readString());
          break;
        default:
          throw new Error("Unknown data type " + a);
      }
    }
    const s = t.readShort();
    for (let r = 0; r < s; r++) {
      const n = t.readString(), a = t.readInt(), o = t.readString(), h = t.readString(), u = t.readBoolean();
      this._chatlog.push(new sY(n, a, o, h, u));
    }
  }
  get recordType() {
    return this._recordType;
  }
  get context() {
    return this._context;
  }
  get chatlog() {
    return this._chatlog;
  }
  get roomId() {
    return this.getInt("roomId");
  }
  get roomName() {
    return this._context.get("roomName");
  }
  get groupId() {
    return this.getInt("groupId");
  }
  get threadId() {
    return this.getInt("threadId");
  }
  get messageId() {
    return this.getInt("messageId");
  }
  getInt(t) {
    const e = this._context.get(t);
    return e || 0;
  }
};
or.TYPE_SIMPLE = 0, or.TYPE_ROOM_CHAT = 1, or.TYPE_IM_SESSION = 2, or.TYPE_DISCUSSION_THREAD = 3, or.TYPE_DISCUSSION_MESSAGE = 4, or.TYPE_SELFIE = 5, or.TYPE_PHOTO = 6;
let Du = or;
class iY {
  constructor(t) {
    this._issueId = t.readInt(), this._callerUserId = t.readInt(), this._reportedUserId = t.readInt(), this._chatRecordId = t.readInt(), this._chatRecord = new Du(t);
  }
  get issueId() {
    return this._issueId;
  }
  get callerUserId() {
    return this._callerUserId;
  }
  get reportedUserId() {
    return this._reportedUserId;
  }
  get chatRecordId() {
    return this._chatRecordId;
  }
  get chatRecord() {
    return this._chatRecord;
  }
}
class rY {
  flush() {
    return this._data = null, !0;
  }
  parse(t) {
    return t ? (this._data = new iY(t), !0) : !1;
  }
  get data() {
    return this._data;
  }
}
class nY {
  flush() {
    return !0;
  }
  parse(t) {
    return this._issueId = parseInt(t.readString()), !0;
  }
  get issueId() {
    return this._issueId;
  }
}
const Jh = class Jh {
  constructor(t, e, s, r, n, a, o, h, u, c, l, _, d, f, p, g) {
    this._disposed = !1, this._issueId = t, this._state = e, this._categoryId = s, this._reportedCategoryId = r, this._issueAgeInMilliseconds = n, this._priority = a, this._groupingId = o, this._reporterUserId = h, this._reporterUserName = u, this._reportedUserId = c, this._reportedUserName = l, this._pickerUserId = _, this._pickerUserName = d, this._message = f, this._chatRecordId = p, this._patterns = g, this._creationTimeInMilliseconds = 0;
  }
  get issueId() {
    return this._issueId;
  }
  get state() {
    return this._state;
  }
  get categoryId() {
    return this._categoryId;
  }
  get reportedCategoryId() {
    return this._reportedCategoryId;
  }
  get issueAgeInMilliseconds() {
    return this._issueAgeInMilliseconds;
  }
  get priority() {
    return this._priority;
  }
  get groupingId() {
    return this._groupingId;
  }
  get reporterUserId() {
    return this._reporterUserId;
  }
  get reporterUserName() {
    return this._reporterUserName;
  }
  get reportedUserId() {
    return this._reportedUserId;
  }
  get reportedUserName() {
    return this._reportedUserName;
  }
  get pickerUserId() {
    return this._pickerUserId;
  }
  get pickerUserName() {
    return this._pickerUserName;
  }
  get message() {
    return this._message;
  }
  get chatRecordId() {
    return this._chatRecordId;
  }
  get patterns() {
    return this._patterns;
  }
  dispose() {
    if (!this.disposed) {
      for (const t of this._patterns)
        t.dispose();
      this._patterns = [], this._disposed = !0;
    }
  }
  get disposed() {
    return this._disposed;
  }
  getOpenTime(t) {
    const s = (this._issueAgeInMilliseconds + t - this._creationTimeInMilliseconds) / 1e3 / 60, r = s % 60, n = s / 60, a = (r < 10 ? "0" : "") + r;
    return (n < 10 ? "0" : "") + n + ":" + a;
  }
};
Jh.STATE_OPEN = 1, Jh.STATE_PICKED = 2, Jh.STATE_CLOSED = 3;
let Sc = Jh;
class aY {
  constructor(t) {
    this._disposed = !1, this._pattern = t.readString(), this._startIndex = t.readInt(), this._endIndex = t.readInt();
  }
  dispose() {
    this._disposed = !0, this._pattern = "", this._startIndex = -1, this._endIndex = -1;
  }
  get disposed() {
    return this._disposed;
  }
  get pattern() {
    return this._pattern;
  }
  get startIndex() {
    return this._startIndex;
  }
  get endIndex() {
    return this._endIndex;
  }
}
class Gv {
  get issueData() {
    return this._issueData;
  }
  flush() {
    return this._issueData = null, !0;
  }
  parse(t) {
    const e = t.readInt(), s = t.readInt(), r = t.readInt(), n = t.readInt(), a = t.readInt(), o = t.readInt(), h = t.readInt(), u = t.readInt(), c = t.readString(), l = t.readInt(), _ = t.readString(), d = t.readInt(), f = t.readString(), p = t.readString(), g = t.readInt(), m = t.readInt(), O = [];
    for (let y = 0; y < m; y++)
      O.push(new aY(t));
    return this._issueData = new Sc(
      e,
      s,
      r,
      n,
      a,
      o,
      h,
      u,
      c,
      l,
      _,
      d,
      f,
      p,
      g,
      O
    ), !0;
  }
}
class oY {
  flush() {
    return this._issues = null, !0;
  }
  parse(t) {
    this._issues = [];
    const e = t.readInt();
    for (let s = 0; s < e; s++) {
      const r = t.readInt(), n = t.readInt(), a = t.readString(), o = new Sc(r, 0, 0, 0, 0, 0, 0, 0, null, 0, null, n, a, null, 0, []);
      this._issues.push(o);
    }
    return this._retryEnabled = t.readBoolean(), this._retryCount = t.readInt(), !0;
  }
  get issues() {
    return this._issues;
  }
  get retryEnabled() {
    return this._retryEnabled;
  }
  get retryCount() {
    return this._retryCount;
  }
}
class hY {
  flush() {
    return this._message = "", this._url = null, !0;
  }
  parse(t) {
    return t ? (this._message = t.readString(), this._url = t.readString(), !0) : !1;
  }
  get message() {
    return this._message;
  }
  get url() {
    return this._url;
  }
}
class uY {
  flush() {
    return this._userId = -1, this._success = !1, !0;
  }
  parse(t) {
    return this._userId = t.readInt(), this._success = t.readBoolean(), !0;
  }
  get userId() {
    return this._userId;
  }
  get success() {
    return this._success;
  }
}
class lY {
  constructor(t) {
    this._disposed = !1;
    const e = new Gv();
    this._issues = [], this._messageTemplates = [], this._roomMessageTemplates = [];
    let s = t.readInt(), r = 0;
    for (; r < s; )
      e.parse(t) && this._issues.push(e.issueData), r++;
    for (s = t.readInt(), r = 0; r < s; )
      this._messageTemplates.push(t.readString()), r++;
    for (s = t.readInt(), r = 0; r < s; )
      t.readString(), r++;
    for (this._cfhPermission = t.readBoolean(), this._chatlogsPermission = t.readBoolean(), this._alertPermission = t.readBoolean(), this._kickPermission = t.readBoolean(), this._banPermission = t.readBoolean(), this._roomAlertPermission = t.readBoolean(), this._roomKickPermission = t.readBoolean(), s = t.readInt(), r = 0; r < s; )
      this._roomMessageTemplates.push(t.readString()), r++;
  }
  dispose() {
    this._disposed || (this._disposed = !0, this._messageTemplates = null, this._roomMessageTemplates = null, this._issues = null);
  }
  get disposed() {
    return this._disposed;
  }
  get messageTemplates() {
    return this._messageTemplates;
  }
  get roomMessageTemplates() {
    return this._roomMessageTemplates;
  }
  get issues() {
    return this._issues;
  }
  get cfhPermission() {
    return this._cfhPermission;
  }
  get chatlogsPermission() {
    return this._chatlogsPermission;
  }
  get alertPermission() {
    return this._alertPermission;
  }
  get kickPermission() {
    return this._kickPermission;
  }
  get banPermission() {
    return this._banPermission;
  }
  get roomAlertPermission() {
    return this._roomAlertPermission;
  }
  get roomKickPermission() {
    return this._roomKickPermission;
  }
}
class cY {
  constructor() {
    this._data = null;
  }
  flush() {
    return this._data = null, !0;
  }
  parse(t) {
    return this._data = new lY(t), !0;
  }
  get data() {
    return this._data;
  }
}
class _Y {
  flush() {
    return this._message = "", this._url = "", !0;
  }
  parse(t) {
    return t ? (this._message = t.readString(), this._url = t.readString(), !0) : !1;
  }
  get message() {
    return this._message;
  }
  get url() {
    return this._url;
  }
}
class dY {
  constructor(t) {
    if (this._tags = [], this._exists = t.readBoolean(), !this.exists)
      return;
    this._name = t.readString(), this._desc = t.readString();
    const e = t.readInt();
    for (let s = 0; s < e; s++)
      this._tags.push(t.readString());
  }
  get name() {
    return this._name;
  }
  get desc() {
    return this._desc;
  }
  get tags() {
    return this._tags;
  }
  get exists() {
    return this._exists;
  }
  get disposed() {
    return this._disposed;
  }
  dispose() {
    this._disposed || (this._disposed = !0, this._tags = null);
  }
}
class fY {
  constructor(t) {
    this._flatId = t.readInt(), this._userCount = t.readInt(), this._ownerInRoom = t.readBoolean(), this._ownerId = t.readInt(), this._ownerName = t.readString(), this._room = new dY(t);
  }
  get flatId() {
    return this._flatId;
  }
  get userCount() {
    return this._userCount;
  }
  get ownerInRoom() {
    return this._ownerInRoom;
  }
  get ownerId() {
    return this._ownerId;
  }
  get ownerName() {
    return this._ownerName;
  }
  get room() {
    return this._room;
  }
  get disposed() {
    return this._disposed;
  }
  dispose() {
    this._disposed || (this._disposed = !0, this._room != null && (this._room.dispose(), this._room = null));
  }
}
class gY {
  flush() {
    return this._data = null, !0;
  }
  parse(t) {
    return t ? (this._data = new fY(t), !0) : !1;
  }
  get data() {
    return this._data;
  }
}
class pY {
  flush() {
    return this._windowX = 0, this._windowY = 0, this._windowWidth = 0, this._windowHeight = 0, !0;
  }
  parse(t) {
    return this._windowX = t.readInt(), this._windowY = t.readInt(), this._windowWidth = t.readInt(), this._windowHeight = t.readInt(), !0;
  }
  get windowX() {
    return this._windowX;
  }
  get windowY() {
    return this._windowY;
  }
  get windowWidth() {
    return this._windowWidth;
  }
  get windowHeight() {
    return this._windowHeight;
  }
}
class mY {
  constructor(t) {
    this._lastSanctionTime = "", this._sanctionAgeHours = 0, this._userId = t.readInt(), this._userName = t.readString(), this._figure = t.readString(), this._registrationAgeInMinutes = t.readInt(), this._minutesSinceLastLogin = t.readInt(), this._online = t.readBoolean(), this._cfhCount = t.readInt(), this._abusiveCfhCount = t.readInt(), this._cautionCount = t.readInt(), this._banCount = t.readInt(), this._tradingLockCount = t.readInt(), this._tradingExpiryDate = t.readString(), this._lastPurchaseDate = t.readString(), this._identityId = t.readInt(), this._identityRelatedBanCount = t.readInt(), this._primaryEmailAddress = t.readString(), this._userClassification = t.readString(), t.bytesAvailable && (this._lastSanctionTime = t.readString(), this._sanctionAgeHours = t.readInt());
  }
  get userId() {
    return this._userId;
  }
  get userName() {
    return this._userName;
  }
  get figure() {
    return this._figure;
  }
  get registrationAgeInMinutes() {
    return this._registrationAgeInMinutes;
  }
  get minutesSinceLastLogin() {
    return this._minutesSinceLastLogin;
  }
  get online() {
    return this._online;
  }
  get cfhCount() {
    return this._cfhCount;
  }
  get abusiveCfhCount() {
    return this._abusiveCfhCount;
  }
  get cautionCount() {
    return this._cautionCount;
  }
  get banCount() {
    return this._banCount;
  }
  get tradingLockCount() {
    return this._tradingLockCount;
  }
  get tradingExpiryDate() {
    return this._tradingExpiryDate;
  }
  get lastPurchaseDate() {
    return this._lastPurchaseDate;
  }
  get identityId() {
    return this._identityId;
  }
  get identityRelatedBanCount() {
    return this._identityRelatedBanCount;
  }
  get primaryEmailAddress() {
    return this._primaryEmailAddress;
  }
  get userClassification() {
    return this._userClassification;
  }
  get lastSanctionTime() {
    return this._lastSanctionTime;
  }
  get sanctionAgeHours() {
    return this._sanctionAgeHours;
  }
}
class EY {
  flush() {
    return this._data = null, !0;
  }
  parse(t) {
    return t ? (this._data = new mY(t), !0) : !1;
  }
  get data() {
    return this._data;
  }
}
class TY {
  flush() {
    return this._data = null, !0;
  }
  parse(t) {
    return t ? (this._data = new Du(t), !0) : !1;
  }
  get data() {
    return this._data;
  }
}
class IY {
  constructor(t) {
    this._roomId = t.readInt(), this._roomName = t.readString(), this._enterHour = t.readInt(), this._enterMinute = t.readInt();
  }
  get roomId() {
    return this._roomId;
  }
  get roomName() {
    return this._roomName;
  }
  get enterHour() {
    return this._enterHour;
  }
  get enterMinute() {
    return this._enterMinute;
  }
}
class SY {
  constructor(t) {
    this._rooms = [], this._userId = t.readInt(), this._userName = t.readString();
    const e = t.readInt();
    let s = 0;
    for (; s < e; )
      this._rooms.push(new IY(t)), s++;
  }
  get userId() {
    return this._userId;
  }
  get userName() {
    return this._userName;
  }
  get rooms() {
    return this._rooms;
  }
}
class AY {
  flush() {
    return !0;
  }
  parse(t) {
    return this._data = new SY(t), !0;
  }
  get data() {
    return this._data;
  }
}
class RY {
  flush() {
    return this._message = "", !0;
  }
  parse(t) {
    return t ? (this._message = t.readString(), !0) : !1;
  }
  get message() {
    return this._message;
  }
}
class OY {
  constructor(t) {
    this._roomChatlogs = [], this._userId = t.readInt(), this._username = t.readString();
    const e = t.readInt();
    for (let s = 0; s < e; s++)
      this._roomChatlogs.push(new Du(t));
  }
  get userId() {
    return this._userId;
  }
  get username() {
    return this._username;
  }
  get roomChatlogs() {
    return this._roomChatlogs;
  }
}
class yY {
  flush() {
    return this._data = null, !0;
  }
  parse(t) {
    return t ? (this._data = new OY(t), !0) : !1;
  }
  get data() {
    return this._data;
  }
}
class vY {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class CY {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._contentType = t.readString(), this._classId = t.readInt(), !0) : !1;
  }
  get contentType() {
    return this._contentType;
  }
  get classId() {
    return this._classId;
  }
}
class xY {
  flush() {
    return this._boxColor = null, this._keyColor = null, !0;
  }
  parse(t) {
    return t ? (this._boxColor = t.readString(), this._keyColor = t.readString(), !0) : !1;
  }
  get boxColor() {
    return this._boxColor;
  }
  get keyColor() {
    return this._keyColor;
  }
}
class MY {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class bY {
  flush() {
    return this._canCreate = !1, this._errorCode = 0, !0;
  }
  parse(t) {
    return t ? (this._canCreate = t.readBoolean(), this._errorCode = t.readInt(), !0) : !1;
  }
  get canCreate() {
    return this._canCreate;
  }
  get errorCode() {
    return this._errorCode;
  }
}
const nd = class nd {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._resultCode = t.readInt(), this._roomLimit = t.readInt(), !0) : !1;
  }
  get resultCode() {
    return this._resultCode;
  }
  get roomLimit() {
    return this._roomLimit;
  }
};
nd.CREATION_ALLOWED = 0, nd.ROOM_LIMIT_REACHED = 1;
let gm = nd;
class PY {
  constructor(t) {
    this._categoryToCurrentUserCountMap = /* @__PURE__ */ new Map(), this._categoryToMaxUserCountMap = /* @__PURE__ */ new Map();
    const e = t.readInt();
    for (let s = 0; s < e; s++) {
      const r = t.readInt(), n = t.readInt(), a = t.readInt();
      this._categoryToCurrentUserCountMap.set(r, n), this._categoryToMaxUserCountMap.set(r, a);
    }
  }
  get categoryToCurrentUserCountMap() {
    return this._categoryToCurrentUserCountMap;
  }
  get categoryToMaxUserCountMap() {
    return this._categoryToMaxUserCountMap;
  }
}
class NY {
  constructor(t, e = 0, s = 0) {
    this._goalId = e, this._pageIndex = s, t && (this._goalId = t.readInt(), this._pageIndex = t.readInt(), this._pageCount = t.readInt());
  }
  get goalId() {
    return this._goalId;
  }
  get pageIndex() {
    return this._pageIndex;
  }
  get pageCount() {
    return this._pageCount;
  }
}
const hr = class hr {
  constructor(t) {
    this._index = t.readInt(), this._popupCaption = t.readString(), this._popupDesc = t.readString(), this._showDetails = t.readInt() == 1, this._picText = t.readString(), this._picRef = t.readString(), this._folderId = t.readInt(), this._userCount = t.readInt(), this._type = t.readInt(), this._type == hr.TYPE_TAG ? this._tag = t.readString() : this._type == hr.TYPE_GUEST_ROOM ? this._guestRoomData = new Wo(t) : this._open = t.readBoolean();
  }
  dispose() {
    this._disposed || (this._disposed = !0, this._guestRoomData != null && (this._guestRoomData.flush(), this._guestRoomData = null));
  }
  get disposed() {
    return this._disposed;
  }
  get type() {
    return this._type;
  }
  get index() {
    return this._index;
  }
  get popupCaption() {
    return this._popupCaption;
  }
  get popupDesc() {
    return this._popupDesc;
  }
  get showDetails() {
    return this._showDetails;
  }
  get picText() {
    return this._picText;
  }
  get picRef() {
    return this._picRef;
  }
  get folderId() {
    return this._folderId;
  }
  get tag() {
    return this._tag;
  }
  get userCount() {
    return this._userCount;
  }
  get guestRoomData() {
    return this._guestRoomData;
  }
  get open() {
    return this._open;
  }
  toggleOpen() {
    this._open = !this._open;
  }
  get maxUsers() {
    return this.type == hr.TYPE_TAG ? 0 : this.type == hr.TYPE_GUEST_ROOM ? this._guestRoomData.maxUserCount : 0;
  }
};
hr.TYPE_TAG = 1, hr.TYPE_GUEST_ROOM = 2, hr.TYPE_FOLDER = 4;
let pm = hr;
class UY {
  constructor(t) {
    this._rooms = [], this._searchType = t.readInt(), this._searchParam = t.readString();
    const e = t.readInt();
    for (let r = 0; r < e; r++)
      this._rooms.push(new Wo(t));
    t.readBoolean() && (this._ad = new pm(t));
  }
  dispose() {
    if (!this._disposed) {
      if (this._disposed = !0, this._rooms != null)
        for (const t of this._rooms)
          t.flush();
      this._ad != null && (this._ad.dispose(), this._ad = null), this._rooms = null;
    }
  }
  get disposed() {
    return this._disposed;
  }
  get searchType() {
    return this._searchType;
  }
  get searchParam() {
    return this._searchParam;
  }
  get rooms() {
    return this._rooms;
  }
  get ad() {
    return this._ad;
  }
}
class Bv {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this.flush(), this.parse(t);
  }
  flush() {
    return this._id = -1, this._code = null, this._filter = null, this._localization = null, !0;
  }
  parse(t) {
    return t ? (this._id = t.readInt(), this._code = t.readString(), this._filter = t.readString(), this._localization = t.readString(), !0) : !1;
  }
  get id() {
    return this._id;
  }
  get code() {
    return this._code;
  }
  get filter() {
    return this._filter;
  }
  get localization() {
    return this._localization;
  }
}
class DY {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this.flush(), this.parse(t);
  }
  flush() {
    return this._code = null, this._data = null, this._action = -1, this._closed = !1, this._mode = -1, this._rooms = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._code = t.readString(), this._data = t.readString(), this._action = t.readInt(), this._closed = t.readBoolean(), this._mode = t.readInt();
    let e = t.readInt();
    for (; e > 0; )
      this._rooms.push(new Wo(t)), e--;
    return !0;
  }
  get code() {
    return this._code;
  }
  get data() {
    return this._data;
  }
  get action() {
    return this._action;
  }
  get closed() {
    return this._closed;
  }
  get mode() {
    return this._mode;
  }
  get rooms() {
    return this._rooms;
  }
}
class LY {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this.flush(), this.parse(t);
  }
  flush() {
    return this._code = null, this._data = null, this._results = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._code = t.readString(), this._data = t.readString();
    let e = t.readInt();
    for (; e > 0; )
      this._results.push(new DY(t)), e--;
    return !0;
  }
  get code() {
    return this._code;
  }
  get data() {
    return this._data;
  }
  get results() {
    return this._results;
  }
}
class FY {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this.flush(), this.parse(t);
  }
  flush() {
    return this._code = null, this._savedSearches = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._code = t.readString();
    let e = t.readInt();
    for (; e > 0; )
      this._savedSearches.push(new Bv(t)), e--;
    return !0;
  }
  get code() {
    return this._code;
  }
  get savedSearches() {
    return this._savedSearches;
  }
}
class wY {
  constructor(t) {
    this._adId = t.readInt(), this._ownerAvatarId = t.readInt(), this._ownerAvatarName = t.readString(), this._flatId = t.readInt(), this._eventType = t.readInt(), this._eventName = t.readString(), this._eventDescription = t.readString();
    const e = t.readInt(), s = t.readInt(), r = /* @__PURE__ */ new Date();
    let n = r.getTime();
    const a = e * 60 * 1e3;
    n = n - a;
    const o = new Date(n);
    this._creationTime = o.getDate() + "-" + o.getMonth() + "-" + o.getFullYear() + " " + o.getHours() + ":" + o.getMinutes();
    let h = r.getTime();
    const u = s * 60 * 1e3;
    h = h + u, this._expirationDate = new Date(h), this._categoryId = t.readInt();
  }
  dispose() {
    this._disposed || (this._disposed = !0);
  }
  get disposed() {
    return this._disposed;
  }
  get adId() {
    return this._adId;
  }
  get ownerAvatarId() {
    return this._ownerAvatarId;
  }
  get ownerAvatarName() {
    return this._ownerAvatarName;
  }
  get flatId() {
    return this._flatId;
  }
  get categoryId() {
    return this._categoryId;
  }
  get eventType() {
    return this._eventType;
  }
  get eventName() {
    return this._eventName;
  }
  get eventDescription() {
    return this._eventDescription;
  }
  get creationTime() {
    return this._creationTime;
  }
  get expirationDate() {
    return this._expirationDate;
  }
}
class GY {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._data = new PY(t), !0) : !1;
  }
  get data() {
    return this._data;
  }
}
class BY {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._data = new NY(t), !0) : !1;
  }
  get data() {
    return this._data;
  }
}
class kY {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._globalId = t.readString(), this._convertedId = t.readInt(), !0) : !1;
  }
  get globalId() {
    return this._globalId;
  }
  get convertedId() {
    return this._convertedId;
  }
}
class zY {
  flush() {
    return this._userName = null, !0;
  }
  parse(t) {
    return t ? (this._userName = t.readString(), !0) : !1;
  }
  get userName() {
    return this._userName;
  }
}
class VY {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._flatId = t.readInt(), this._added = t.readBoolean(), !0) : !1;
  }
  get flatId() {
    return this._flatId;
  }
  get added() {
    return this._added;
  }
}
class HY {
  flush() {
    return !0;
  }
  parse(t) {
    if (!t) return !1;
    this._favouriteRoomIds = [], this._limit = t.readInt();
    const e = t.readInt();
    for (let s = 0; s < e; s++)
      this._favouriteRoomIds.push(t.readInt());
    return !0;
  }
  get limit() {
    return this._limit;
  }
  get favoriteRoomIds() {
    return this._favouriteRoomIds;
  }
}
class YY {
  flush() {
    return this._userName = null, !0;
  }
  parse(t) {
    return t ? (this._userName = t.readString(), !0) : !1;
  }
  get userName() {
    return this._userName;
  }
}
class WY {
  flush() {
    return this._roomId = -1, this._roomName = null, !0;
  }
  parse(t) {
    return t ? (this._roomId = t.readInt(), this._roomName = t.readString(), !0) : !1;
  }
  get roomId() {
    return this._roomId;
  }
  get roomName() {
    return this._roomName;
  }
}
class jY {
  flush() {
    return this._roomEnter = !1, this._roomForward = !1, this._data = null, this._staffPick = !1, this._isGroupMember = !1, this._moderation = null, this._chat = null, !0;
  }
  parse(t) {
    return t ? (this._roomEnter = t.readBoolean(), this._data = new Wo(t), this._roomForward = t.readBoolean(), this._staffPick = t.readBoolean(), this._isGroupMember = t.readBoolean(), this.data.allInRoomMuted = t.readBoolean(), this._moderation = new Ec(t), this.data.canMute = t.readBoolean(), this._chat = new Nu(t), !0) : !1;
  }
  get roomEnter() {
    return this._roomEnter;
  }
  get roomForward() {
    return this._roomForward;
  }
  get data() {
    return this._data;
  }
  get staffPick() {
    return this._staffPick;
  }
  get isGroupMember() {
    return this._isGroupMember;
  }
  get moderation() {
    return this._moderation;
  }
  get chat() {
    return this._chat;
  }
}
class XY {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._data = new UY(t), !0) : !1;
  }
  get data() {
    return this._data;
  }
}
class KY {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this.flush(), this.parse(t);
  }
  flush() {
    return this._id = -1, this._name = null, this._visible = !1, this._automatic = !1, this._automaticCategoryKey = null, this._globalCategoryKey = null, this._staffOnly = !1, !0;
  }
  parse(t) {
    return t ? (this._id = t.readInt(), this._name = t.readString(), this._visible = t.readBoolean(), this._automatic = t.readBoolean(), this._automaticCategoryKey = t.readString(), this._globalCategoryKey = t.readString(), this._staffOnly = t.readBoolean(), !0) : !1;
  }
  get id() {
    return this._id;
  }
  get name() {
    return this._name;
  }
  get visible() {
    return this._visible;
  }
  get automatic() {
    return this._automatic;
  }
  get automaticCategoryKey() {
    return this._automaticCategoryKey;
  }
  get globalCategoryKey() {
    return this._globalCategoryKey;
  }
  get staffOnly() {
    return this._staffOnly;
  }
}
class qY {
  flush() {
    return this._categories = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; )
      this._categories.push(t.readString()), e--;
    return !0;
  }
  get categories() {
    return this._categories;
  }
}
class $Y {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this.flush(), this.parse(t);
  }
  flush() {
    return this._id = -1, this._name = null, this._visible = !1, !0;
  }
  parse(t) {
    return t ? (this._id = t.readInt(), this._name = t.readString(), this._visible = t.readBoolean(), !0) : !1;
  }
  get id() {
    return this._id;
  }
  get name() {
    return this._name;
  }
  get visible() {
    return this._visible;
  }
}
class ZY {
  flush() {
    return this._homeRoomId = -1, this._roomIdToEnter = -1, !0;
  }
  parse(t) {
    return t ? (this._homeRoomId = t.readInt(), this._roomIdToEnter = t.readInt(), !0) : !1;
  }
  get homeRoomId() {
    return this._homeRoomId;
  }
  get roomIdToEnter() {
    return this._roomIdToEnter;
  }
}
class QY {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this.flush(), this.parse(t);
  }
  flush() {
    return this._roomId = -1, this._areaId = -1, this._image = null, this._caption = null, !0;
  }
  parse(t) {
    return t ? (this._roomId = t.readInt(), this._areaId = t.readInt(), this._image = t.readString(), this._caption = t.readString(), !0) : !1;
  }
  get roomId() {
    return this._roomId;
  }
  get areaId() {
    return this._areaId;
  }
  get image() {
    return this._image;
  }
  get caption() {
    return this._caption;
  }
}
class JY {
  flush() {
    return this._rooms = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; )
      this._rooms.push(new QY(t)), e--;
    return !0;
  }
  get rooms() {
    return this._rooms;
  }
}
class tW {
  flush() {
    return this._topLevelContexts = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; )
      this._topLevelContexts.push(new FY(t)), e--;
    return !0;
  }
  get topLevelContexts() {
    return this._topLevelContexts;
  }
}
class eW {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class sW {
  flush() {
    return this._searches = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; )
      this._searches.push(new Bv(t)), e--;
    return !0;
  }
  get searches() {
    return this._searches;
  }
}
class iW {
  flush() {
    return this._result = null, !0;
  }
  parse(t) {
    return t ? (this._result = new LY(t), !0) : !1;
  }
  get result() {
    return this._result;
  }
}
class rW {
  flush() {
    return this._windowX = 0, this._windowY = 0, this._windowWidth = 0, this._windowHeight = 0, this._leftPanelHidden = !1, this._resultsMode = 0, !0;
  }
  parse(t) {
    return t ? (this._windowX = t.readInt(), this._windowY = t.readInt(), this._windowWidth = t.readInt(), this._windowHeight = t.readInt(), this._leftPanelHidden = t.readBoolean(), this._resultsMode = t.readInt(), !0) : !1;
  }
  get windowX() {
    return this._windowX;
  }
  get windowY() {
    return this._windowY;
  }
  get windowWidth() {
    return this._windowWidth;
  }
  get windowHeight() {
    return this._windowHeight;
  }
  get leftPanelHidden() {
    return this._leftPanelHidden;
  }
  get resultsMode() {
    return this._resultsMode;
  }
}
class nW {
  constructor(t) {
    this._tagName = t.readString(), this._userCount = t.readInt();
  }
  get tagName() {
    return this._tagName;
  }
  get userCount() {
    return this._userCount;
  }
}
class aW {
  constructor(t) {
    if (!t) throw new Error("invalid_wrapper");
    this.flush(), this.parse(t);
  }
  flush() {
    return this._tags = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._tags = [];
    const e = t.readInt();
    let s = 0;
    for (; s < e; )
      this._tags.push(new nW(t)), s++;
    return !0;
  }
  get tags() {
    return this._tags;
  }
}
class oW {
  flush() {
    return this._data = null, !0;
  }
  parse(t) {
    return t ? (this._data = new aW(t), !0) : !1;
  }
  get data() {
    return this._data;
  }
}
class hW {
  flush() {
    return !0;
  }
  parse(t) {
    return !0;
  }
}
class uW {
  flush() {
    return !0;
  }
  parse(t) {
    return this._data = new wY(t), !0;
  }
  get data() {
    return this._data;
  }
}
class lW {
  flush() {
    return this._words = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; )
      this._words.push(t.readString()), e--;
    return !0;
  }
  get words() {
    return this._words;
  }
}
class cW {
  flush() {
    return this._roomId = 0, !0;
  }
  parse(t) {
    return t ? (this._roomId = t.readInt(), !0) : !1;
  }
  get roomId() {
    return this._roomId;
  }
}
class _W {
  flush() {
    return !0;
  }
  parse(t) {
    return this._flatId = t.readInt(), this._resultCode = t.readInt(), !0;
  }
  get flatId() {
    return this._flatId;
  }
  get resultCode() {
    return this._resultCode;
  }
}
class dW {
  flush() {
    return this._categories = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; )
      this._categories.push(new $Y(t)), e--;
    return !0;
  }
  get categories() {
    return this._categories;
  }
}
class fW {
  flush() {
    return this._categories = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; )
      this._categories.push(new KY(t)), e--;
    return !0;
  }
  get categories() {
    return this._categories;
  }
}
class gW {
  constructor(t) {
    this._badgeCode = "", this._removedBadgeCode = "", this._type = t.readInt(), this._level = t.readInt(), this._badgeId = t.readInt(), this._badgeCode = t.readString(), this._points = t.readInt(), this._levelRewardPoints = t.readInt(), this._levelRewardPointType = t.readInt(), this._bonusPoints = t.readInt(), this._achievementID = t.readInt(), this._removedBadgeCode = t.readString(), this._category = t.readString(), this._showDialogToUser = t.readBoolean();
  }
  get type() {
    return this._type;
  }
  get level() {
    return this._level;
  }
  get points() {
    return this._points;
  }
  get levelRewardPoints() {
    return this._levelRewardPoints;
  }
  get levelRewardPointType() {
    return this._levelRewardPointType;
  }
  get bonusPoints() {
    return this._bonusPoints;
  }
  get badgeId() {
    return this._badgeId;
  }
  get badgeCode() {
    return this._badgeCode;
  }
  get removedBadgeCode() {
    return this._removedBadgeCode;
  }
  get achievementID() {
    return this._achievementID;
  }
  get category() {
    return this._category;
  }
  get showDialogToUser() {
    return this._showDialogToUser;
  }
}
class pW {
  flush() {
    return this._data = null, !0;
  }
  parse(t) {
    return t ? (this._data = new gW(t), !0) : !1;
  }
  get data() {
    return this._data;
  }
}
class mW {
  flush() {
    return this._amount = 0, this._amountChanged = 0, this._type = -1, !0;
  }
  parse(t) {
    return t ? (this._amount = t.readInt(), this._amountChanged = t.readInt(), this._type = t.readInt(), !0) : !1;
  }
  get amount() {
    return this._amount;
  }
  get amountChanged() {
    return this._amountChanged;
  }
  get type() {
    return this._type;
  }
}
class EW {
  flush() {
    return this._errorCode = -1, !0;
  }
  parse(t) {
    return t ? (this._errorCode = t.readInt(), !0) : !1;
  }
  get errorCode() {
    return this._errorCode;
  }
}
class TW {
  flush() {
    return this._numGifts = 0, !0;
  }
  parse(t) {
    return t ? (this._numGifts = t.readInt(), !0) : !1;
  }
  get numGifts() {
    return this._numGifts;
  }
}
class IW {
  flush() {
    return this._errorCode = 0, this._messageId = 0, this._timestamp = null, !0;
  }
  parse(t) {
    return t ? (this._messageId = t.readInt(), this._errorCode = t.readInt(), this._timestamp = t.readString(), !0) : !1;
  }
  get errorCode() {
    return this._errorCode;
  }
  get messageId() {
    return this._messageId;
  }
  get timestamp() {
    return this._timestamp;
  }
}
class SW {
  flush() {
    return this._key = null, !0;
  }
  parse(t) {
    return t ? (this._key = t.readString(), !0) : !1;
  }
  get key() {
    return this._key;
  }
}
class AW {
  flush() {
    return this._message = null, !0;
  }
  parse(t) {
    return t ? (this._message = t.readString(), !0) : !1;
  }
  get message() {
    return this._message;
  }
}
class RW {
  flush() {
    return this._minutes = null, !0;
  }
  parse(t) {
    return t ? (this._minutes = t.readInt(), !0) : !1;
  }
  get minutes() {
    return this._minutes;
  }
}
class OW {
  flush() {
    return this._enabled = !1, !0;
  }
  parse(t) {
    return t ? (this._enabled = t.readBoolean(), !0) : !1;
  }
  get enabled() {
    return this._enabled;
  }
}
class yW {
  flush() {
    return this._messages = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; )
      this._messages.push(t.readString()), e--;
    return !0;
  }
  get messages() {
    return this._messages;
  }
}
class vW {
  flush() {
    return this._type = null, this._parameters = /* @__PURE__ */ new Map(), !0;
  }
  parse(t) {
    if (!t) return !1;
    this._type = t.readString();
    let e = t.readInt();
    for (; e > 0; )
      this._parameters.set(t.readString(), t.readString()), e--;
    return !0;
  }
  get type() {
    return this._type;
  }
  get parameters() {
    return this._parameters;
  }
}
class CW {
  flush() {
    return this._contentType = null, this._classId = 0, this._name = null, this._description = null, !0;
  }
  parse(t) {
    return t ? (this._contentType = t.readString(), this._classId = t.readInt(), this._name = t.readString(), this._description = t.readString(), !0) : !1;
  }
  get contentType() {
    return this._contentType;
  }
  get classId() {
    return this._classId;
  }
  get name() {
    return this._name;
  }
  get description() {
    return this._description;
  }
}
class xW {
  flush() {
    return this._petId = -1, this._petName = null, this._level = 0, this._figureData = null, !0;
  }
  parse(t) {
    return t ? (this._petId = t.readInt(), this._petName = t.readString(), this._level = t.readInt(), this._figureData = new nI(t), !0) : !1;
  }
  get petId() {
    return this._petId;
  }
  get petName() {
    return this._petName;
  }
  get level() {
    return this._level;
  }
  get figureData() {
    return this._figureData;
  }
}
class MW {
  flush() {
    return this._errorCode = -1, !0;
  }
  parse(t) {
    return t ? (this._errorCode = t.readInt(), !0) : !1;
  }
  get errorCode() {
    return this._errorCode;
  }
}
class bW {
  flush() {
    return !0;
  }
  parse(t) {
    return !0;
  }
}
class PW {
  flush() {
    return this._alertMessage = null, !0;
  }
  parse(t) {
    return t ? (this._alertMessage = t.readString(), t.bytesAvailable && (this._titleMessage = t.readString()), !0) : !1;
  }
  get alertMessage() {
    return this._alertMessage;
  }
  get titleMessage() {
    return this._titleMessage;
  }
}
class NW {
  flush() {
    return this._items = new be(), !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = t.readInt();
    for (; e > 0; ) {
      const s = t.readInt();
      let r = t.readInt();
      const n = [];
      for (; r > 0; )
        n.push(t.readInt()), r--;
      this._items.add(s, n), e--;
    }
    return !0;
  }
  getItemsByCategory(t) {
    return this._items.getValue(t);
  }
  get categories() {
    return this._items.getKeys();
  }
}
class UW {
  constructor(t) {
    this._itemName = t.readString(), this._extraInfo = t.readString(), this._extraInfo == "" && (this._extraInfo = null);
  }
  get itemName() {
    return this._itemName;
  }
  get extraInfo() {
    return this._extraInfo;
  }
}
class DW {
  constructor(t) {
    this._thumbnailUrl = t.readString(), this._thumbnailUrl == "" && (this._thumbnailUrl = null), this._productOfferList = [];
    const e = t.readInt();
    let s = 0;
    for (; s < e; )
      this._productOfferList.push(new UW(t)), s++;
  }
  get productOfferList() {
    return this._productOfferList;
  }
  get thumbnailUrl() {
    return this._thumbnailUrl;
  }
}
class LW extends A {
  constructor(t) {
    super(t, GW);
  }
  getParser() {
    return this.parser;
  }
}
class FW {
  constructor(t) {
    this._dayIndex = t.readInt(), this._stepIndex = t.readInt(), this._options = [];
    const e = t.readInt();
    let s = 0;
    for (; s < e; )
      this._options.push(new DW(t)), s++;
  }
  get dayIndex() {
    return this._dayIndex;
  }
  get stepIndex() {
    return this._stepIndex;
  }
  get options() {
    return this._options;
  }
}
class wW extends A {
  constructor(t) {
    super(t, BW);
  }
  getParser() {
    return this.parser;
  }
}
class GW {
  flush() {
    return !0;
  }
  parse(t) {
    if (!t) return !1;
    const e = t.readInt();
    this._giftOptions = [];
    let s = 0;
    for (; s < e; )
      this._giftOptions.push(new FW(t)), s++;
    return !0;
  }
  get giftOptions() {
    return this._giftOptions;
  }
}
class BW {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class kW {
  constructor(t, e, s) {
    this._code = t, this._errorMessage = e, this._isAllowed = s;
  }
  get code() {
    return this._code;
  }
  get errorMessage() {
    return this._errorMessage;
  }
  get isAllowed() {
    return this._isAllowed;
  }
}
const ls = class ls {
};
ls.USE_GUIDE_TOOL = "USE_GUIDE_TOOL", ls.GIVE_GUIDE_TOUR = "GIVE_GUIDE_TOUR", ls.JUDGE_CHAT_REVIEWS = "JUDGE_CHAT_REVIEWS", ls.VOTE_IN_COMPETITIONS = "VOTE_IN_COMPETITIONS", ls.CALL_ON_HELPERS = "CALL_ON_HELPERS", ls.CITIZEN = "CITIZEN", ls.TRADE = "TRADE", ls.HEIGHTMAP_EDITOR_BETA = "HEIGHTMAP_EDITOR_BETA", ls.BUILDER_AT_WORK = "BUILDER_AT_WORK", ls.NAVIGATOR_ROOM_THUMBNAIL_CAMERA = "NAVIGATOR_ROOM_THUMBNAIL_CAMERA", ls.CAMERA = "CAMERA", ls.MOUSE_ZOOM = "MOUSE_ZOOM";
let SR = ls;
class zW {
  flush() {
    return this._perks = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    this._perks = [];
    const e = t.readInt();
    for (let s = 0; s < e; s++) this._perks.push(new kW(
      t.readString(),
      t.readString(),
      t.readBoolean()
    ));
    return !0;
  }
  isAllowed(t) {
    let e = !1;
    for (const s of this._perks)
      if (s.code === t) {
        e = s.isAllowed;
        break;
      }
    return e;
  }
  get perks() {
    return this._perks;
  }
}
class VW {
  flush() {
    return this._objectId = -1, this._figureData = null, !0;
  }
  parse(t) {
    return this._objectId = t.readInt(), t.bytesAvailable && (this._figureData = new $l(t.readString())), !0;
  }
  get objectId() {
    return this._objectId;
  }
  get figureData() {
    return this._figureData;
  }
}
class HW {
  flush() {
    return this._objectId = 0, this._nameValidationStatus = 0, this._nameValidationInfo = null, !0;
  }
  parse(t) {
    return this._objectId = t.readInt(), this._nameValidationStatus = t.readInt(), this._nameValidationInfo = t.readString(), !0;
  }
  get objectId() {
    return this._objectId;
  }
  get nameValidationStatus() {
    return this._nameValidationStatus;
  }
  get nameValidationInfo() {
    return this._nameValidationInfo;
  }
}
class YW {
  flush() {
    return this._roomIndex = -1, this._petId = -1, this._level = -1, !0;
  }
  parse(t) {
    return this._roomIndex = t.readInt(), this._petId = t.readInt(), this._level = t.readInt(), !0;
  }
  get roomIndex() {
    return this._roomIndex;
  }
  get petId() {
    return this._petId;
  }
  get level() {
    return this._level;
  }
}
class WW {
  flush() {
    return this._currentAge = -1, this._requiredAge = -1, !0;
  }
  parse(t) {
    return this._currentAge = t.readInt(), this._requiredAge = t.readInt(), !0;
  }
  get currentAge() {
    return this._currentAge;
  }
  get requiredAge() {
    return this._requiredAge;
  }
}
class jW {
  flush() {
    return this._petId = -1, this._commands = [], this._enabledCommands = [], !0;
  }
  parse(t) {
    this._petId = t.readInt();
    let e = t.readInt();
    for (; e > 0; )
      this._commands.push(t.readInt()), e--;
    let s = t.readInt();
    for (; s > 0; )
      this._enabledCommands.push(t.readInt()), s--;
    return !0;
  }
  get petId() {
    return this._petId;
  }
  get commands() {
    return this._commands;
  }
  get enabledCommands() {
    return this._enabledCommands;
  }
}
class XW {
  constructor(t, e, s) {
    this._value = t, this._choiceText = e, this._choiceType = s;
  }
  get value() {
    return this._value;
  }
  set value(t) {
    this._value = t;
  }
  get choiceText() {
    return this._choiceText;
  }
  set choiceText(t) {
    this._choiceText = t;
  }
  get choiceType() {
    return this._choiceType;
  }
  set choiceType(t) {
    this._choiceType = t;
  }
}
class KW {
  constructor() {
    this._children = [], this._questionChoices = [];
  }
  get questionId() {
    return this._questionId;
  }
  set questionId(t) {
    this._questionId = t;
  }
  get questionType() {
    return this._questionType;
  }
  set questionType(t) {
    this._questionType = t;
  }
  get sortOrder() {
    return this._sortOrder;
  }
  set sortOrder(t) {
    this._sortOrder = t;
  }
  get questionText() {
    return this._questionText;
  }
  set questionText(t) {
    this._questionText = t;
  }
  get questionCategory() {
    return this._questionCategory;
  }
  set questionCategory(t) {
    this._questionCategory = t;
  }
  get questionAnswerType() {
    return this._questionAnswerType;
  }
  set questionAnswerType(t) {
    this._questionAnswerType = t;
  }
  get questionAnswerCount() {
    return this._questionAnswerCount;
  }
  set questionAnswerCount(t) {
    this._questionAnswerCount = t;
  }
  get children() {
    return this._children;
  }
  set children(t) {
    this._children = t;
  }
  get questionChoices() {
    return this._questionChoices;
  }
  set questionChoices(t) {
    this._questionChoices = t;
  }
}
class qW {
  constructor() {
    this._id = -1, this._startMessage = "", this._endMessage = "", this._numQuestions = 0, this._questionArray = [], this._npsPoll = !1;
  }
  flush() {
    return this._id = -1, this._startMessage = "", this._endMessage = "", this._numQuestions = 0, this._questionArray = [], !0;
  }
  parse(t) {
    this._id = t.readInt(), this._startMessage = t.readString(), this._endMessage = t.readString(), this._numQuestions = t.readInt();
    for (let e = 0; e < this._numQuestions; e++) {
      const s = this.parsePollQuestion(t), r = t.readInt();
      for (let n = 0; n < r; n++)
        s.children.push(this.parsePollQuestion(t));
      this._questionArray.push(s);
    }
    return this._npsPoll = t.readBoolean(), !0;
  }
  parsePollQuestion(t) {
    const e = new KW();
    if (e.questionId = t.readInt(), e.sortOrder = t.readInt(), e.questionType = t.readInt(), e.questionText = t.readString(), e.questionCategory = t.readInt(), e.questionAnswerType = t.readInt(), e.questionAnswerCount = t.readInt(), e.questionType == 1 || e.questionType == 2)
      for (let s = 0; s < e.questionAnswerCount; s++)
        e.questionChoices.push(new XW(t.readString(), t.readString(), t.readInt()));
    return e;
  }
  get id() {
    return this._id;
  }
  get startMessage() {
    return this._startMessage;
  }
  get endMessage() {
    return this._endMessage;
  }
  get numQuestions() {
    return this._numQuestions;
  }
  get questionArray() {
    return this._questionArray;
  }
  get npsPoll() {
    return this._npsPoll;
  }
}
class $W {
  flush() {
    throw !0;
  }
  parse(t) {
    return !0;
  }
}
class ZW {
  constructor() {
    this._id = -1, this._type = "", this._headline = "", this._summary = "";
  }
  flush() {
    return this._id = -1, this._type = "", this._summary = "", !0;
  }
  parse(t) {
    return this._id = t.readInt(), this._type = t.readString(), this._headline = t.readString(), this._summary = t.readString(), !0;
  }
  get id() {
    return this._id;
  }
  get type() {
    return this._type;
  }
  get headline() {
    return this._headline;
  }
  get summary() {
    return this._summary;
  }
}
class QW {
  flush() {
    return this._userId = -1, this._value = "", this._answerCounts = null, !0;
  }
  parse(t) {
    this._userId = t.readInt(), this._value = t.readString(), this._answerCounts = /* @__PURE__ */ new Map();
    const e = t.readInt();
    for (let s = 0; s < e; s++) {
      const r = t.readString(), n = t.readInt();
      this._answerCounts.set(r, n);
    }
    return !0;
  }
  get userId() {
    return this._userId;
  }
  get value() {
    return this._value;
  }
  get answerCounts() {
    return this._answerCounts;
  }
}
class JW {
  flush() {
    return this._questionId = -1, this._answerCounts = null, !0;
  }
  parse(t) {
    this._questionId = t.readInt(), this._answerCounts = /* @__PURE__ */ new Map();
    const e = t.readInt();
    for (let s = 0; s < e; s++) {
      const r = t.readString(), n = t.readInt();
      this._answerCounts.set(r, n);
    }
    return !0;
  }
  get questionId() {
    return this._questionId;
  }
  get answerCounts() {
    return this._answerCounts;
  }
}
class tj {
  constructor() {
    this._pollType = null, this._pollId = -1, this._questionId = -1, this._duration = -1, this._question = null;
  }
  flush() {
    return this._pollType = null, this._pollId = -1, this._questionId = -1, this._duration = -1, this._question = null, !0;
  }
  parse(t) {
    this._pollType = t.readString(), this._pollId = t.readInt(), this._questionId = t.readInt(), this._duration = t.readInt();
    const e = t.readInt(), s = t.readInt(), r = t.readInt(), n = t.readString();
    if (this._question = { id: e, number: s, type: r, content: n }, this._question.type == 1 || this._question.type == 2) {
      this._question.selection_min = t.readInt();
      const a = t.readInt();
      this._question.selections = [], this._question.selection_values = [], this._question.selection_count = a, this._question.selection_max = a;
      for (let o = 0; o < a; o++)
        this._question.selection_values.push(t.readString()), this._question.selections.push(t.readString());
    }
    return !0;
  }
  get pollType() {
    return this._pollType;
  }
  get pollId() {
    return this._pollId;
  }
  get questionId() {
    return this._questionId;
  }
  get duration() {
    return this._duration;
  }
  get question() {
    return this._question;
  }
}
class ej {
  flush() {
    return this._question = null, this._choices = [], this._SafeStr_7651 = [], this._SafeStr_7654 = -1, !0;
  }
  parse(t) {
    this._question = t.readString(), this._choices = [], this._SafeStr_7651 = [];
    let e = t.readInt();
    for (; e > 0; )
      this._choices.push(t.readString()), this._SafeStr_7651.push(t.readInt()), e--;
    return this._SafeStr_7654 = t.readInt(), !0;
  }
  get question() {
    return this._question;
  }
  get choices() {
    return this._choices;
  }
  get SafeStr_7651() {
    return this._SafeStr_7651;
  }
  get SafeStr_7654() {
    return this._SafeStr_7654;
  }
}
class sj {
  flush() {
    return this._question = null, this._choices = [], !0;
  }
  parse(t) {
    this._question = t.readString(), this._choices = [];
    const e = t.readInt();
    let s = 0;
    for (; s < e; )
      this._choices.push(t.readString()), s++;
    return !0;
  }
  get question() {
    return this._question;
  }
  get choices() {
    return this._choices.slice();
  }
}
class ij {
  constructor(t) {
    this._rewardUserLimits = [], this._hasGoalExpired = t.readBoolean(), this._personalContributionScore = t.readInt(), this._personalContributionRank = t.readInt(), this._communityTotalScore = t.readInt(), this._communityHighestAchievedLevel = t.readInt(), this._scoreRemainingUntilNextLevel = t.readInt(), this._percentCompletionTowardsNextLevel = t.readInt(), this._goalCode = t.readString(), this._timeRemainingInSeconds = t.readInt();
    const e = t.readInt();
    for (let s = 0; s < e; s++)
      this._rewardUserLimits.push(t.readInt());
  }
  dispose() {
    this._rewardUserLimits = null;
  }
  get disposed() {
    return this._rewardUserLimits == null;
  }
  get hasGoalExpired() {
    return this._hasGoalExpired;
  }
  get personalContributionScore() {
    return this._personalContributionScore;
  }
  get personalContributionRank() {
    return this._personalContributionRank;
  }
  get communityTotalScore() {
    return this._communityTotalScore;
  }
  get communityHighestAchievedLevel() {
    return this._communityHighestAchievedLevel;
  }
  get scoreRemainingUntilNextLevel() {
    return this._scoreRemainingUntilNextLevel;
  }
  get percentCompletionTowardsNextLevel() {
    return this._percentCompletionTowardsNextLevel;
  }
  get timeRemainingInSeconds() {
    return this._timeRemainingInSeconds;
  }
  get rewardUserLimits() {
    return this._rewardUserLimits;
  }
  get goalCode() {
    return this._goalCode;
  }
}
class rj {
  constructor(t) {
    this._communityGoalId = t.readInt(), this._communityGoalCode = t.readString(), this._userRank = t.readInt(), this._rewardCode = t.readString(), this._badge = t.readBoolean(), this._localizedName = t.readString();
  }
  get communityGoalId() {
    return this._communityGoalId;
  }
  get communityGoalCode() {
    return this._communityGoalCode;
  }
  get userRank() {
    return this._userRank;
  }
  get rewardCode() {
    return this._rewardCode;
  }
  get badge() {
    return this._badge;
  }
  get localizedName() {
    return this._localizedName;
  }
}
class nj {
  flush() {
    return this._prizes = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    const e = t.readInt();
    for (let s = 0; s < e; s++)
      this._prizes.push(new rj(t));
    return !0;
  }
  get prizes() {
    return this._prizes;
  }
}
class aj {
  constructor(t) {
    this._userId = t.readInt(), this._userName = t.readString(), this._figure = t.readString(), this._rank = t.readInt(), this._currentScore = t.readInt();
  }
  get userId() {
    return this._userId;
  }
  get userName() {
    return this._userName;
  }
  get figure() {
    return this._figure;
  }
  get rank() {
    return this._rank;
  }
  get currentScore() {
    return this._currentScore;
  }
}
class oj {
  constructor(t) {
    this._hof = [], this._goalCode = t.readString();
    const e = t.readInt();
    for (let s = 0; s < e; s++)
      this._hof.push(new aj(t));
  }
  dispose() {
    this._hof = null;
  }
  get disposed() {
    return this._hof == null;
  }
  get hof() {
    return this._hof;
  }
  get goalCode() {
    return this._goalCode;
  }
}
class hj {
  flush() {
    return this._data = null, !0;
  }
  parse(t) {
    return t ? (this._data = new oj(t), !0) : !1;
  }
  get data() {
    return this._data;
  }
}
class uj {
  flush() {
    return this._data = null, !0;
  }
  parse(t) {
    return t ? (this._data = new ij(t), !0) : !1;
  }
  get data() {
    return this._data;
  }
}
class lj {
  flush() {
    return this._state = -1, this._userCount = -1, this._userCountGoal = -1, !0;
  }
  parse(t) {
    return t ? (this._state = t.readInt(), this._userCount = t.readInt(), this._userCountGoal = t.readInt(), !0) : !1;
  }
  get state() {
    return this._state;
  }
  get userCount() {
    return this._userCount;
  }
  get userCountGoal() {
    return this._userCountGoal;
  }
}
class cj {
  flush() {
    return this._imageUri = "", !0;
  }
  parse(t) {
    return t ? (this._imageUri = t.readString(), !0) : !1;
  }
  get imageUri() {
    return this._imageUri;
  }
}
class _j {
  flush() {
    return !0;
  }
  parse(t) {
    return t ? (this._expired = t.readBoolean(), !0) : !1;
  }
  get expired() {
    return this._expired;
  }
}
class Ca {
  constructor(t) {
    this._receiveTime = /* @__PURE__ */ new Date(), this._campaignCode = t.readString(), this._completedQuestsInCampaign = t.readInt(), this._questCountInCampaign = t.readInt(), this._activityPointType = t.readInt(), this._id = t.readInt(), this._accepted = t.readBoolean(), this._type = t.readString(), this._imageVersion = t.readString(), this._rewardCurrencyAmount = t.readInt(), this._localizationCode = t.readString(), this._completedSteps = t.readInt(), this._totalSteps = t.readInt(), this._sortOrder = t.readInt(), this._catalogPageName = t.readString(), this._chainCode = t.readString(), this._easy = t.readBoolean();
  }
  static getCampaignLocalizationKeyForCode(t) {
    return "quests." + t;
  }
  get campaignCode() {
    return this._campaignCode;
  }
  get localizationCode() {
    return this._localizationCode;
  }
  get completedQuestsInCampaign() {
    return this._completedQuestsInCampaign;
  }
  get questCountInCampaign() {
    return this._questCountInCampaign;
  }
  get activityPointType() {
    return this._activityPointType;
  }
  set accepted(t) {
    this._accepted = t;
  }
  get accepted() {
    return this._accepted;
  }
  set id(t) {
    this._id = t;
  }
  get id() {
    return this._id;
  }
  get type() {
    return this._type;
  }
  get imageVersion() {
    return this._imageVersion;
  }
  get rewardCurrencyAmount() {
    return this._rewardCurrencyAmount;
  }
  get completedSteps() {
    return this._completedSteps;
  }
  get totalSteps() {
    return this._totalSteps;
  }
  get isCompleted() {
    return this._completedSteps == this._totalSteps;
  }
  set waitPeriodSeconds(t) {
    this._waitPeriodSeconds = t;
  }
  get waitPeriodSeconds() {
    if (this._waitPeriodSeconds < 1)
      return 0;
    const e = (/* @__PURE__ */ new Date()).getTime() - this._receiveTime.getTime();
    return Math.max(0, this._waitPeriodSeconds - Math.floor(e / 1e3));
  }
  getCampaignLocalizationKey() {
    return Ca.getCampaignLocalizationKeyForCode(this.campaignCode);
  }
  getQuestLocalizationKey() {
    return this.getCampaignLocalizationKey() + "." + this._localizationCode;
  }
  get completedCampaign() {
    return this._id < 1;
  }
  get lastQuestInCampaign() {
    return this._completedQuestsInCampaign >= this._questCountInCampaign;
  }
  get receiveTime() {
    return this._receiveTime;
  }
  get sortOrder() {
    return this._sortOrder;
  }
  get catalogPageName() {
    return this._catalogPageName;
  }
  get chainCode() {
    return this._chainCode;
  }
  get easy() {
    return this._easy;
  }
}
class dj {
  flush() {
    return this._questData = null, !0;
  }
  parse(t) {
    return t ? (this._questData = new Ca(t), this._showDialog = t.readBoolean(), !0) : !1;
  }
  get questData() {
    return this._questData;
  }
  get showDialog() {
    return this._showDialog;
  }
}
class fj {
  flush() {
    return this._quest = null, !0;
  }
  parse(t) {
    return t ? (t.readBoolean() && (this._quest = new Ca(t), this._easyQuestCount = t.readInt(), this._hardQuestCount = t.readInt()), !0) : !1;
  }
  get quest() {
    return this._quest;
  }
  get easyQuestCount() {
    return this._easyQuestCount;
  }
  get hardQuestCount() {
    return this._hardQuestCount;
  }
}
class gj {
  flush() {
    return this._quest = null, !0;
  }
  parse(t) {
    return t ? (this._quest = new Ca(t), !0) : !1;
  }
  get quest() {
    return this._quest;
  }
}
class pj {
  flush() {
    return this._quests = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    const e = t.readInt();
    for (let s = 0; s < e; s++)
      this._quests.push(new Ca(t));
    return this._openWindow = t.readBoolean(), !0;
  }
  get quests() {
    return this._quests;
  }
  get openWindow() {
    return this._openWindow;
  }
}
class mj {
  flush() {
    return this._quests = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    const e = t.readInt();
    for (let s = 0; s < e; s++)
      this._quests.push(new Ca(t));
    return !0;
  }
  get quests() {
    return this._quests;
  }
}
class Ej {
  flush() {
    return this._recyclerFinishedStatus = -1, this._prizeId = 0, !0;
  }
  parse(t) {
    return t ? (this._recyclerFinishedStatus = t.readInt(), this._prizeId = t.readInt(), !0) : !1;
  }
  get recyclerFinishedStatus() {
    return this._recyclerFinishedStatus;
  }
  get prizeId() {
    return this._prizeId;
  }
}
class Tj {
  flush() {
    return this._recyclerStatus = -1, this._recyclerTimeoutSeconds = 0, !0;
  }
  parse(t) {
    return t ? (this._recyclerStatus = t.readInt(), this._recyclerTimeoutSeconds = t.readInt(), !0) : !1;
  }
  get recyclerStatus() {
    return this._recyclerStatus;
  }
  get recyclerTimeoutSeconds() {
    return this._recyclerTimeoutSeconds;
  }
}
class oI {
  constructor(t) {
    this._stuffIds = [], this._intParams = [], this._stuffTypeSelectionEnabled = t.readBoolean(), this._furniLimit = t.readInt();
    let e = t.readInt();
    for (; e > 0; )
      this._stuffIds.push(t.readInt()), e--;
    for (this._stuffTypeId = t.readInt(), this._id = t.readInt(), this._stringParam = t.readString(), e = t.readInt(); e > 0; )
      this._intParams.push(t.readInt()), e--;
    this._stuffTypeSelectionCode = t.readInt();
  }
  getBoolean(t) {
    return this._intParams[t] === 1;
  }
  get stuffTypeSelectionEnabled() {
    return this._stuffTypeSelectionEnabled;
  }
  get stuffTypeSelectionCode() {
    return this._stuffTypeSelectionCode;
  }
  set stuffTypeSelectionCode(t) {
    this._stuffTypeSelectionCode = t;
  }
  get maximumItemSelectionCount() {
    return this._furniLimit;
  }
  get selectedItems() {
    return this._stuffIds;
  }
  get id() {
    return this._id;
  }
  get stringData() {
    return this._stringParam;
  }
  get intData() {
    return this._intParams;
  }
  get code() {
    return 0;
  }
  get spriteId() {
    return this._stuffTypeId;
  }
}
class Ij extends oI {
  constructor(t) {
    super(t), this._type = t.readInt();
  }
  get type() {
    return this._type;
  }
  get code() {
    return this._type;
  }
}
class Sj extends oI {
  constructor(t) {
    super(t), this._conflictingActions = [], this._triggerConf = t.readInt();
    let e = t.readInt();
    for (; e > 0; )
      this._conflictingActions.push(t.readInt()), e--;
  }
  get code() {
    return this._triggerConf;
  }
  get conflictingActions() {
    return this._conflictingActions;
  }
}
class Aj extends oI {
  constructor(t) {
    super(t), this._conflictingTriggers = [], this._type = t.readInt(), this._delayInPulses = t.readInt();
    let e = t.readInt();
    for (; e > 0; )
      this._conflictingTriggers.push(t.readInt()), e--;
  }
  get type() {
    return this._type;
  }
  get code() {
    return this._type;
  }
  get delayInPulses() {
    return this._delayInPulses;
  }
  get conflictingTriggers() {
    return this._conflictingTriggers;
  }
}
class Rj {
  flush() {
    return this._definition = null, !0;
  }
  parse(t) {
    return t ? (this._definition = new Aj(t), !0) : !1;
  }
  get definition() {
    return this._definition;
  }
}
class Oj {
  flush() {
    return this._definition = null, !0;
  }
  parse(t) {
    return t ? (this._definition = new Ij(t), !0) : !1;
  }
  get definition() {
    return this._definition;
  }
}
class yj {
  flush() {
    return this._definition = null, !0;
  }
  parse(t) {
    return t ? (this._definition = new Sj(t), !0) : !1;
  }
  get definition() {
    return this._definition;
  }
}
class vj {
  flush() {
    return this._stuffId = 0, !0;
  }
  parse(t) {
    return t ? (this._stuffId = t.readInt(), !0) : !1;
  }
  get stuffId() {
    return this._stuffId;
  }
}
class Cj {
  flush() {
    return this._reason = 0, !0;
  }
  parse(t) {
    return t ? (this._reason = t.readInt(), !0) : !1;
  }
  get reason() {
    return this._reason;
  }
}
class xj {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class Mj {
  flush() {
    return this._info = null, !0;
  }
  parse(t) {
    return t ? (this._info = t.readString(), !0) : !1;
  }
  get info() {
    return this._info;
  }
}
class bj {
  flush() {
    return !0;
  }
  parse(t) {
    return !!t;
  }
}
class Pj {
  flush() {
    return !0;
  }
  parse(t) {
    return !0;
  }
}
class Nj {
  constructor() {
    this._songDisks = new be();
  }
  flush() {
    return this._songDisks.reset(), this._maxLength = 0, !0;
  }
  parse(t) {
    this._maxLength = t.readInt();
    const e = t.readInt();
    for (let s = 0; s < e; s++)
      this._songDisks.add(t.readInt(), t.readInt());
    return !0;
  }
  get songDisks() {
    return this._songDisks;
  }
  get maxLength() {
    return this._maxLength;
  }
}
class Uj {
  flush() {
    return this._currentSongId = -1, this._currentPosition = -1, this._nextSongId = -1, this._nextPosition = -1, this._syncCount = -1, !0;
  }
  parse(t) {
    return this._currentSongId = t.readInt(), this._currentPosition = t.readInt(), this._nextSongId = t.readInt(), this._nextPosition = t.readInt(), this._syncCount = t.readInt(), !0;
  }
  get currentSongId() {
    return this._currentSongId;
  }
  get currentPosition() {
    return this._currentPosition;
  }
  get nextSongId() {
    return this._nextSongId;
  }
  get nextPosition() {
    return this._nextPosition;
  }
  get syncCount() {
    return this._syncCount;
  }
}
class Dj {
  flush() {
    return this._songId = 0, this._officialSongId = "", !0;
  }
  parse(t) {
    return this._officialSongId = t.readString(), this._songId = t.readInt(), !0;
  }
  get songId() {
    return this._songId;
  }
  get officialSongId() {
    return this._officialSongId;
  }
}
class hI {
  constructor(t, e, s, r) {
    this._startPlayHead = 0, this._id = t, this._length = e, this._name = s, this._creator = r;
  }
  get id() {
    return this._id;
  }
  get length() {
    return this._length;
  }
  get name() {
    return this._name;
  }
  get creator() {
    return this._creator;
  }
  get startPlayHeadPos() {
    return this._startPlayHead;
  }
  set startPlayHeadPos(t) {
    this._startPlayHead = t;
  }
}
class Lj {
  flush() {
    return this._synchronizationCount = -1, this._playlist = [], !0;
  }
  parse(t) {
    this._synchronizationCount = t.readInt();
    const e = t.readInt();
    for (let s = 0; s < e; s++)
      this._playlist.push(new hI(
        t.readInt(),
        t.readInt(),
        t.readString(),
        t.readString()
      ));
    return !0;
  }
  get synchronizationCount() {
    return this._synchronizationCount;
  }
  get playList() {
    return this._playlist;
  }
}
class Fj {
  flush() {
    return this._entry = null, !0;
  }
  parse(t) {
    return this._entry = new hI(t.readInt(), t.readInt(), t.readString(), t.readString()), !0;
  }
  get entry() {
    return this._entry;
  }
}
class wj extends hI {
  constructor(t, e, s, r, n) {
    super(t, e, s, r), this._data = "", this._data = n;
  }
  get data() {
    return this._data;
  }
}
class Gj {
  flush() {
    return this._songs = [], !0;
  }
  parse(t) {
    const e = t.readInt();
    for (let s = 0; s < e; s++) {
      const r = t.readInt();
      t.readString();
      const n = t.readString(), a = t.readString(), o = t.readInt(), h = t.readString(), u = new wj(r, o, n, h, a);
      this._songs.push(u);
    }
    return !0;
  }
  get songs() {
    return this._songs;
  }
}
class Bj {
  constructor() {
    this._songDiskInventory = new be();
  }
  flush() {
    return this._songDiskInventory.reset(), !0;
  }
  parse(t) {
    const e = t.readInt();
    for (let s = 0; s < e; s++)
      this._songDiskInventory.add(t.readInt(), t.readInt());
    return !0;
  }
  getDiskId(t) {
    return t >= 0 && t < this._songDiskInventory.length ? this._songDiskInventory.getKey(t) : -1;
  }
  getSongId(t) {
    return t >= 0 && t < this._songDiskInventory.length ? this._songDiskInventory.getWithIndex(t) : -1;
  }
  get songDiskCount() {
    return this._songDiskInventory.length;
  }
}
class kj {
  constructor(t) {
    this._perkId = t.readInt();
  }
  get perkId() {
    return this._perkId;
  }
}
class kv {
  constructor(t, e) {
    this._productCode = t, this._vipDays = e;
  }
  get productCode() {
    return this._productCode;
  }
  get vipDays() {
    return this._vipDays;
  }
}
class zj {
  flush() {
    return this._talentTrackName = null, this._level = -1, this._rewardPerks = [], this._rewardProducts = [], !0;
  }
  parse(t) {
    if (!t) return !1;
    let e = 0;
    this._talentTrackName = t.readString(), this._level = t.readInt();
    const s = t.readInt();
    for (; e < s; )
      this._rewardPerks.push(new kj(t)), e++;
    const r = t.readInt();
    if (e < r)
      for (let n = 0; n < r; n++) {
        const a = t.readString(), o = t.readInt();
        this._rewardProducts.push(new kv(a, o)), e++;
      }
    return !0;
  }
  get talentTrackName() {
    return this._talentTrackName;
  }
  get level() {
    return this._level;
  }
  get rewardPerks() {
    return this._rewardPerks;
  }
  get rewardProducts() {
    return this._rewardProducts;
  }
}
class Vj {
  constructor(t, e, s, r, n) {
    this._level = t, this._state = e, this._tasks = s, this._rewardPerks = r, this._rewardProducts = n;
  }
  get level() {
    return this._level;
  }
  get state() {
    return this._state;
  }
  get tasks() {
    return this._tasks;
  }
  get perks() {
    return this._rewardPerks;
  }
  get items() {
    return this._rewardProducts;
  }
}
class Hj {
  flush() {
    return this._talentTrackName = null, this._level = -1, this._maxLevel = -1, !0;
  }
  parse(t) {
    return t ? (this._talentTrackName = t.readString(), this._level = t.readInt(), this._maxLevel = t.readInt(), !0) : !1;
  }
  get talentTrackName() {
    return this._talentTrackName;
  }
  get level() {
    return this._level;
  }
  get maxLevel() {
    return this._maxLevel;
  }
}
class Yj {
  constructor(t, e, s, r, n, a) {
    this._id = t, this._requiredLevel = e, this._badgeCode = s, this._state = r, this._currentScore = n, this._totalScore = a;
  }
  get id() {
    return this._id;
  }
  get requiredLevel() {
    return this._requiredLevel;
  }
  get badgeCode() {
    return this._badgeCode;
  }
  get state() {
    return this._state;
  }
  get currentScore() {
    return this._currentScore;
  }
  get totalScore() {
    return this._totalScore;
  }
}
class Wj {
  flush() {
    return this._type = null, this._levels = null, !0;
  }
  parse(t) {
    if (!t) return !1;
    this._type = t.readString(), this._levels = [];
    const e = t.readInt();
    for (let s = 0; s < e; s++) {
      const r = t.readInt(), n = t.readInt(), a = [], o = t.readInt();
      for (let _ = 0; _ < o; _++) {
        const d = t.readInt(), f = t.readInt(), p = t.readString(), g = t.readInt(), m = t.readInt(), O = t.readInt();
        a.push(new Yj(d, f, p, g, m, O));
      }
      const h = [], u = t.readInt();
      for (let _ = 0; _ < u; _++) h.push(t.readString());
      const c = [], l = t.readInt();
      for (let _ = 0; _ < l; _++) {
        const d = t.readString(), f = t.readInt();
        c.push(new kv(d, f));
      }
      this._levels.push(new Vj(r, n, a, h, c));
    }
    return !0;
  }
  get type() {
    return this._type;
  }
  get levels() {
    return this._levels;
  }
}
class jj {
  flush() {
    return this._classifiedUsersNames && (this._classifiedUsersNames = /* @__PURE__ */ new Map()), this._classifiedUsersClass && (this._classifiedUsersClass = /* @__PURE__ */ new Map()), !0;
  }
  parse(t) {
    if (!t) return !1;
    let e, s, r, n = t.readInt();
    for (this._classifiedUsersNames = /* @__PURE__ */ new Map(), this._classifiedUsersClass = /* @__PURE__ */ new Map(); n > 0; )
      e = t.readInt(), s = t.readString(), r = t.readString(), this._classifiedUsersNames.set(e, s), this._classifiedUsersClass.set(e, r), n--;
    return !0;
  }
  get classifiedUsernameMap() {
    return this._classifiedUsersNames;
  }
  get classifiedUserTypeMap() {
    return this._classifiedUsersClass;
  }
}
class Xj extends A {
  constructor(t) {
    super(t, FB);
  }
  getParser() {
    return this.parser;
  }
}
class Kj extends A {
  constructor(t) {
    super(t, wB);
  }
  getParser() {
    return this.parser;
  }
}
class zv extends A {
  constructor(t) {
    super(t, GB);
  }
  getParser() {
    return this.parser;
  }
}
class qj extends A {
  constructor(t) {
    super(t, BB);
  }
  getParser() {
    return this.parser;
  }
}
class $j extends A {
  constructor(t) {
    super(t, kB);
  }
  getParser() {
    return this.parser;
  }
}
class Zj extends A {
  constructor(t) {
    super(t, zB);
  }
  getParser() {
    return this.parser;
  }
}
class Qj extends A {
  constructor(t) {
    super(t, VB);
  }
  getParser() {
    return this.parser;
  }
}
class Jj extends A {
  constructor(t) {
    super(t, HB);
  }
  getParser() {
    return this.parser;
  }
}
const xi = class xi extends A {
  constructor(t) {
    super(t, YB);
  }
  getParser() {
    return this.parser;
  }
};
xi.NAME_OK = 0, xi.ERROR_NAME_REQUIRED = 1, xi.ERROR_NAME_TOO_SHORT = 2, xi.ERROR_NAME_TOO_LONG = 3, xi.ERROR_NAME_NOT_VALID = 4, xi.ERROR_NAME_IN_USE = 5, xi.ERROR_NAME_CHANGE_NOT_ALLOWED = 6, xi.ERROR_MERGE_HOTEL_DOWN = 7;
let Lu = xi;
class t6 extends A {
  constructor(t) {
    super(t, WB);
  }
  getParser() {
    return this.parser;
  }
}
class Vv extends A {
  constructor(t) {
    super(t, jB);
  }
  getParser() {
    return this.parser;
  }
}
class e6 extends A {
  constructor(t) {
    super(t, KB);
  }
  getParser() {
    return this.parser;
  }
}
class s6 extends A {
  constructor(t) {
    super(t, qB);
  }
  getParser() {
    return this.parser;
  }
}
class i6 extends A {
  constructor(t) {
    super(t, $B);
  }
  getParser() {
    return this.parser;
  }
}
class r6 extends A {
  constructor(t) {
    super(t, ZB);
  }
  getParser() {
    return this.parser;
  }
}
class n6 extends A {
  constructor(t) {
    super(t, QB);
  }
  getParser() {
    return this.parser;
  }
}
class a6 extends A {
  constructor(t) {
    super(t, sk);
  }
  getParser() {
    return this.parser;
  }
}
class o6 extends A {
  constructor(t) {
    super(t, ik);
  }
  getParser() {
    return this.parser;
  }
}
class h6 extends A {
  constructor(t) {
    super(t, rk);
  }
  getParser() {
    return this.parser;
  }
}
class u6 extends A {
  constructor(t) {
    super(t, nk);
  }
  getParser() {
    return this.parser;
  }
}
class l6 extends A {
  constructor(t) {
    super(t, ak);
  }
  getParser() {
    return this.parser;
  }
}
class c6 extends A {
  constructor(t) {
    super(t, ok);
  }
  getParser() {
    return this.parser;
  }
}
class _6 extends A {
  constructor(t) {
    super(t, hk);
  }
  getParser() {
    return this.parser;
  }
}
class d6 extends A {
  constructor(t) {
    super(t, uk);
  }
  getParser() {
    return this.parser;
  }
}
class f6 extends A {
  constructor(t) {
    super(t, lk);
  }
  getParser() {
    return this.parser;
  }
}
class g6 extends A {
  constructor(t) {
    super(t, ck);
  }
  getParser() {
    return this.parser;
  }
}
class p6 extends A {
  constructor(t) {
    super(t, _k);
  }
  getParser() {
    return this.parser;
  }
}
class m6 extends A {
  constructor(t) {
    super(t, dk);
  }
  getParser() {
    return this.parser;
  }
}
class E6 extends A {
  constructor(t) {
    super(t, fk);
  }
  getParser() {
    return this.parser;
  }
}
class T6 extends A {
  constructor(t) {
    super(t, gk);
  }
  getParser() {
    return this.parser;
  }
}
class I6 extends A {
  constructor(t) {
    super(t, pk);
  }
  getParser() {
    return this.parser;
  }
}
class S6 extends A {
  constructor(t) {
    super(t, Ek);
  }
  getParser() {
    return this.parser;
  }
}
class A6 extends A {
  constructor(t) {
    super(t, Sk);
  }
  getParser() {
    return this.parser;
  }
}
class R6 extends A {
  constructor(t) {
    super(t, Ak);
  }
  getParser() {
    return this.parser;
  }
}
class O6 extends A {
  constructor(t) {
    super(t, Tk);
  }
  getParser() {
    return this.parser;
  }
}
class y6 extends A {
  constructor(t) {
    super(t, Rk);
  }
  getParser() {
    return this.parser;
  }
}
class v6 extends A {
  constructor(t) {
    super(t, Ok);
  }
  getParser() {
    return this.parser;
  }
}
class C6 extends A {
  constructor(t) {
    super(t, vk);
  }
  getParser() {
    return this.parser;
  }
}
class x6 extends A {
  constructor(t) {
    super(t, Ck);
  }
  getParser() {
    return this.parser;
  }
}
class M6 extends A {
  constructor(t) {
    super(t, Mk);
  }
  getParser() {
    return this.parser;
  }
}
class b6 extends A {
  constructor(t) {
    super(t, Pk);
  }
  getParser() {
    return this.parser;
  }
}
class P6 extends A {
  constructor(t) {
    super(t, Nk);
  }
  getParser() {
    return this.parser;
  }
}
class N6 extends A {
  constructor(t) {
    super(t, Uk);
  }
  getParser() {
    return this.parser;
  }
}
class U6 extends A {
  constructor(t) {
    super(t, Dk);
  }
  getParser() {
    return this.parser;
  }
}
class D6 extends A {
  constructor(t) {
    super(t, Lk);
  }
  getParser() {
    return this.parser;
  }
}
class L6 extends A {
  constructor(t) {
    super(t, Fk);
  }
  getParser() {
    return this.parser;
  }
}
class F6 extends A {
  constructor(t) {
    super(t, wk);
  }
  getParser() {
    return this.parser;
  }
}
class w6 extends A {
  constructor(t) {
    super(t, Gk);
  }
  getParser() {
    return this.parser;
  }
}
class G6 extends A {
  constructor(t) {
    super(t, Bk);
  }
  getParser() {
    return this.parser;
  }
}
class B6 extends A {
  constructor(t) {
    super(t, kk);
  }
  getParser() {
    return this.parser;
  }
}
class k6 extends A {
  constructor(t) {
    super(t, zk);
  }
  getParser() {
    return this.parser;
  }
}
class z6 extends A {
  constructor(t) {
    super(t, Vk);
  }
  getParser() {
    return this.parser;
  }
}
class V6 extends A {
  constructor(t) {
    super(t, Yk);
  }
  getParser() {
    return this.parser;
  }
}
class H6 extends A {
  constructor(t) {
    super(t, WV);
  }
  getParser() {
    return this.parser;
  }
}
class Y6 extends A {
  constructor(t) {
    super(t, jV);
  }
  getParser() {
    return this.parser;
  }
}
class W6 extends A {
  constructor(t) {
    super(t, KV);
  }
  getParser() {
    return this.parser;
  }
}
class j6 extends A {
  constructor(t) {
    super(t, ZV);
  }
  getParser() {
    return this.parser;
  }
}
class X6 extends A {
  constructor(t) {
    super(t, $V);
  }
  getParser() {
    return this.parser;
  }
}
class K6 extends A {
  constructor(t) {
    super(t, QV);
  }
  getParser() {
    return this.parser;
  }
}
class q6 extends A {
  constructor(t) {
    super(t, JV);
  }
  getParser() {
    return this.parser;
  }
}
class Hv extends A {
  constructor(t) {
    super(t, t5);
  }
  getParser() {
    return this.parser;
  }
}
class $6 extends A {
  constructor(t) {
    super(t, Jp);
  }
  getParser() {
    return this.parser;
  }
}
class Z6 extends A {
  constructor(t) {
    super(t, e5);
  }
  getParser() {
    return this.parser;
  }
}
class Q6 extends A {
  constructor(t) {
    super(t, s5);
  }
  getParser() {
    return this.parser;
  }
}
class J6 extends A {
  constructor(t) {
    super(t, i5);
  }
  getParser() {
    return this.parser;
  }
}
class t8 extends A {
  constructor(t) {
    super(t, r5);
  }
  getParser() {
    return this.parser;
  }
}
class e8 extends A {
  constructor(t) {
    super(t, n5);
  }
  getParser() {
    return this.parser;
  }
}
class s8 extends A {
  constructor(t) {
    super(t, a5);
  }
  getParser() {
    return this.parser;
  }
}
class i8 extends A {
  constructor(t) {
    super(t, h5);
  }
  getParser() {
    return this.parser;
  }
}
class r8 extends A {
  constructor(t) {
    super(t, u5);
  }
  getParser() {
    return this.parser;
  }
}
class n8 extends A {
  constructor(t) {
    super(t, l5);
  }
  getParser() {
    return this.parser;
  }
}
class mm extends A {
  constructor(t) {
    super(t, c5);
  }
  getParser() {
    return this.parser;
  }
}
class a8 extends A {
  constructor(t) {
    super(t, d5);
  }
  getParser() {
    return this.parser;
  }
}
class o8 extends A {
  constructor(t) {
    super(t, f5);
  }
  getParser() {
    return this.parser;
  }
}
class h8 extends A {
  constructor(t) {
    super(t, g5);
  }
  getParser() {
    return this.parser;
  }
}
class u8 extends A {
  constructor(t) {
    super(t, p5);
  }
  getParser() {
    return this.parser;
  }
}
class l8 extends A {
  constructor(t) {
    super(t, m5);
  }
  getParser() {
    return this.parser;
  }
}
class c8 extends A {
  constructor(t) {
    super(t, E5);
  }
  getParser() {
    return this.parser;
  }
}
class _8 extends A {
  constructor(t) {
    super(t, T5);
  }
  getParser() {
    return this.parser;
  }
}
class d8 extends A {
  constructor(t) {
    super(t, I5);
  }
  getParser() {
    return this.parser;
  }
}
class f8 extends A {
  constructor(t) {
    super(t, S5);
  }
  getParser() {
    return this.parser;
  }
}
class g8 extends A {
  constructor(t) {
    super(t, A5);
  }
  getParser() {
    return this.parser;
  }
}
class p8 extends A {
  constructor(t) {
    super(t, R5);
  }
  getParser() {
    return this.parser;
  }
}
class m8 extends A {
  constructor(t) {
    super(t, O5);
  }
  getParser() {
    return this.parser;
  }
}
class E8 extends A {
  constructor(t) {
    super(t, y5);
  }
  getParser() {
    return this.parser;
  }
}
class T8 extends A {
  constructor(t) {
    super(t, v5);
  }
  getParser() {
    return this.parser;
  }
}
class Yv extends A {
  constructor(t) {
    super(t, C5);
  }
  getParser() {
    return this.parser;
  }
}
class I8 extends A {
  constructor(t) {
    super(t, x5);
  }
  getParser() {
    return this.parser;
  }
}
class S8 extends A {
  constructor(t) {
    super(t, M5);
  }
  getParser() {
    return this.parser;
  }
}
class A8 extends A {
  constructor(t) {
    super(t, b5);
  }
  getParser() {
    return this.parser;
  }
}
class R8 extends A {
  constructor(t) {
    super(t, sm);
  }
  getParser() {
    return this.parser;
  }
}
class O8 extends A {
  constructor(t) {
    super(t, P5);
  }
  getParser() {
    return this.parser;
  }
}
class y8 extends A {
  constructor(t) {
    super(t, im);
  }
  getParser() {
    return this.parser;
  }
}
class v8 extends A {
  constructor(t) {
    super(t, rm);
  }
  getParser() {
    return this.parser;
  }
}
class C8 extends A {
  constructor(t) {
    super(t, N5);
  }
  getParser() {
    return this.parser;
  }
}
class x8 extends A {
  constructor(t) {
    super(t, U5);
  }
  getParser() {
    return this.parser;
  }
}
class M8 extends A {
  constructor(t) {
    super(t, D5);
  }
  getParser() {
    return this.parser;
  }
}
class b8 extends A {
  constructor(t) {
    super(t, L5);
  }
  getParser() {
    return this.parser;
  }
}
class P8 extends A {
  constructor(t) {
    super(t, F5);
  }
  getParser() {
    return this.parser;
  }
}
class N8 extends A {
  constructor(t) {
    super(t, G5);
  }
  getParser() {
    return this.parser;
  }
}
class U8 extends A {
  constructor(t) {
    super(t, k5);
  }
  getParser() {
    return this.parser;
  }
}
class D8 extends A {
  constructor(t) {
    super(t, z5);
  }
  getParser() {
    return this.parser;
  }
}
class L8 extends A {
  constructor(t) {
    super(t, nm);
  }
  getParser() {
    return this.parser;
  }
}
class F8 extends A {
  constructor(t) {
    super(t, V5);
  }
  getParser() {
    return this.parser;
  }
}
class w8 extends A {
  constructor(t) {
    super(t, am);
  }
  getParser() {
    return this.parser;
  }
}
class G8 extends A {
  constructor(t) {
    super(t, H5);
  }
  getParser() {
    return this.parser;
  }
}
class B8 extends A {
  constructor(t) {
    super(t, Y5);
  }
  getParser() {
    return this.parser;
  }
}
class k8 extends A {
  constructor(t) {
    super(t, W5);
  }
  getParser() {
    return this.parser;
  }
}
class z8 extends A {
  constructor(t) {
    super(t, j5);
  }
  getParser() {
    return this.parser;
  }
}
class V8 extends A {
  constructor(t) {
    super(t, X5);
  }
  getParser() {
    return this.parser;
  }
}
class H8 extends A {
  constructor(t) {
    super(t, qd);
  }
  getParser() {
    return this.parser;
  }
}
class Y8 extends A {
  constructor(t) {
    super(t, qd);
  }
  getParser() {
    return this.parser;
  }
}
class W8 extends A {
  constructor(t) {
    super(t, qd);
  }
  getParser() {
    return this.parser;
  }
}
class j8 extends A {
  constructor(t) {
    super(t, qd);
  }
  getParser() {
    return this.parser;
  }
}
class X8 extends A {
  constructor(t) {
    super(t, q5);
  }
  getParser() {
    return this.parser;
  }
}
class K8 extends A {
  constructor(t) {
    super(t, $5);
  }
  getParser() {
    return this.parser;
  }
}
class Em extends A {
  constructor(t) {
    super(t, Z5);
  }
  getParser() {
    return this.parser;
  }
}
class q8 extends A {
  constructor(t) {
    super(t, Q5);
  }
  getParser() {
    return this.parser;
  }
}
class $8 extends A {
  constructor(t) {
    super(t, J5);
  }
  getParser() {
    return this.parser;
  }
}
class Z8 extends A {
  constructor(t) {
    super(t, tH);
  }
  getParser() {
    return this.parser;
  }
}
class Wv extends A {
  constructor(t) {
    super(t, eH);
  }
  getParser() {
    return this.parser;
  }
}
class Q8 extends A {
  constructor(t) {
    super(t, sH);
  }
  getParser() {
    return this.parser;
  }
}
class J8 extends A {
  constructor(t) {
    super(t, iH);
  }
  getParser() {
    return this.parser;
  }
}
class tX extends A {
  constructor(t) {
    super(t, rH);
  }
  getParser() {
    return this.parser;
  }
}
class eX extends A {
  constructor(t) {
    super(t, oH);
  }
  getParser() {
    return this.parser;
  }
}
class sX extends A {
  constructor(t) {
    super(t, hH);
  }
  getParser() {
    return this.parser;
  }
}
class iX extends A {
  constructor(t) {
    super(t, uH);
  }
  getParser() {
    return this.parser;
  }
}
class rX extends A {
  constructor(t) {
    super(t, lH);
  }
  getParser() {
    return this.parser;
  }
}
class nX extends A {
  constructor(t) {
    super(t, cH);
  }
  getParser() {
    return this.parser;
  }
}
class aX extends A {
  constructor(t) {
    super(t, _H);
  }
  getParser() {
    return this.parser;
  }
}
class oX extends A {
  constructor(t) {
    super(t, dH);
  }
  getParser() {
    return this.parser;
  }
}
class hX extends A {
  constructor(t) {
    super(t, fH);
  }
  getParser() {
    return this.parser;
  }
}
class uX extends A {
  constructor(t) {
    super(t, gH);
  }
  getParser() {
    return this.parser;
  }
}
class lX extends A {
  constructor(t) {
    super(t, pH);
  }
  getParser() {
    return this.parser;
  }
}
class cX extends A {
  constructor(t) {
    super(t, mH);
  }
  getParser() {
    return this.parser;
  }
}
class _X extends A {
  constructor(t) {
    super(t, EH);
  }
  getParser() {
    return this.parser;
  }
}
class dX extends A {
  constructor(t) {
    super(t, TH);
  }
  getParser() {
    return this.parser;
  }
}
class fX extends A {
  constructor(t) {
    super(t, IH);
  }
  getParser() {
    return this.parser;
  }
}
const Et = class Et {
};
Et.LOGOUT = 0, Et.JUST_BANNED = 1, Et.CONCURRENT_LOGIN = 2, Et.CONNECTION_LOST_TO_PEER = 3, Et.AVATAR_IDENTITY_CHANGE = 4, Et.REMOVE_FURNITURE_TOOL = 5, Et.STILL_BANNED = 10, Et.DUAL_LOGIN_BY_USERID = 11, Et.HOTEL_CLOSED = 12, Et.DUAL_LOGIN_BY_IP = 13, Et.PEER_CONNECTION_MISSING = 16, Et.NO_LOGIN_PERMISSION = 17, Et.DUPLICATE_CONNECTION = 18, Et.HOTEL_CLOSING = 19, Et.INCORRECT_PASSWORD = 20, Et.INVALID_LOGIN_TICKET = 22, Et.VERSION_CHECK_URL = 23, Et.VERSION_CHECK_PROPERTY = 24, Et.VERSION_CHECK_MACHINE_ID = 25, Et.NO_MESSENGER_SESSION = 26, Et.USER_NOT_FOUND = 27, Et.CRYPTO_NOT_INITIALIZED = 28, Et.DEV_CRYPTO_NOT_ALLOWED = 29, Et.DUPLICATE_UUID_DETECTED = 100, Et.OLD_SESSION_IN_PROXY = 101, Et.PUBLIC_KEY_NOT_NUMERIC = 102, Et.PUBLIC_KEY_TOO_SHORT = 103, Et.SOCKET_READ_GENERIC = 104, Et.SOCKET_READ_FIRST_BYTE = 105, Et.SOCKET_READ_LENGTH = 106, Et.SOCKET_READ_BODY = 107, Et.SOCKET_READ_POLICY = 108, Et.SOCKET_IO_EXCEPTION = 109, Et.SOCKET_WRONG_CRYPTO = 110, Et.PROXY_RUNTIME_EXCEPTION = 111, Et.IDLE_CONNECTION = 112, Et.PONG_TIMEOUT = 113, Et.IDLE_CONNECTION_NOT_AUTH = 114, Et.IDLE_CONNECTION_NO_USER_ID = 115, Et.WRITE_CLOSED_CHANNEL = 116, Et.SOCKET_WRITE_EXCEPTION_1 = 117, Et.SOCKET_WRITE_EXCEPTION_2 = 118, Et.SOCKET_WRITE_EXCEPTION_3 = 119;
let qa = Et;
class gX extends A {
  constructor(t) {
    super(t, SH);
  }
  getParser() {
    return this.parser;
  }
  get reasonString() {
    switch (this.getParser().reason) {
      case qa.JUST_BANNED:
      case qa.STILL_BANNED:
        return "banned";
      case qa.CONCURRENT_LOGIN:
        return "concurrentlogin";
      case qa.INCORRECT_PASSWORD:
        return "incorrectpassword";
      default:
        return "logout";
    }
  }
}
class pX extends A {
  constructor(t) {
    super(t, AH);
  }
  getParser() {
    return this.parser;
  }
}
class mX extends A {
  constructor(t) {
    super(t, RH);
  }
  getParser() {
    return this.parser;
  }
}
class jv extends A {
  constructor(t) {
    super(t, OH);
  }
  getParser() {
    return this.parser;
  }
}
class EX extends A {
  constructor(t) {
    super(t, yH);
  }
  getParser() {
    return this.parser;
  }
}
class TX extends A {
  constructor(t) {
    super(t, vH);
  }
  getParser() {
    return this.parser;
  }
}
class IX extends A {
  constructor(t) {
    super(t, CH);
  }
  getParser() {
    return this.parser;
  }
}
class SX extends A {
  constructor(t) {
    super(t, xH);
  }
  getParser() {
    return this.parser;
  }
}
class AX extends A {
  constructor(t) {
    super(t, MH);
  }
  getParser() {
    return this.parser;
  }
}
class RX extends A {
  constructor(t) {
    super(t, bH);
  }
  getParser() {
    return this.parser;
  }
}
class OX extends A {
  constructor(t) {
    super(t, PH);
  }
  getParser() {
    return this.parser;
  }
}
class yX extends A {
  constructor(t) {
    super(t, NH);
  }
  getParser() {
    return this.parser;
  }
}
class vX extends A {
  constructor(t) {
    super(t, UH);
  }
  getParser() {
    return this.parser;
  }
}
class CX extends A {
  constructor(t) {
    super(t, om);
  }
  getParser() {
    return this.parser;
  }
}
class xX extends A {
  constructor(t) {
    super(t, DH);
  }
  getParser() {
    return this.parser;
  }
}
class MX extends A {
  constructor(t) {
    super(t, hm);
  }
  getParser() {
    return this.parser;
  }
}
class bX extends A {
  constructor(t) {
    super(t, FH);
  }
  getParser() {
    return this.parser;
  }
}
class PX extends A {
  constructor(t) {
    super(t, wH);
  }
  getParser() {
    return this.parser;
  }
}
class Xv extends A {
  constructor(t) {
    super(t, GH);
  }
  getParser() {
    return this.parser;
  }
}
class Kv extends A {
  constructor(t) {
    super(t, um);
  }
  getParser() {
    return this.parser;
  }
}
class NX extends A {
  constructor(t) {
    super(t, BH);
  }
  getParser() {
    return this.parser;
  }
}
class UX extends A {
  constructor(t) {
    super(t, kH);
  }
  getParser() {
    return this.parser;
  }
}
class DX extends A {
  constructor(t) {
    super(t, zH);
  }
  getParser() {
    return this.parser;
  }
}
class LX extends A {
  constructor(t) {
    super(t, VH);
  }
  getParser() {
    return this.parser;
  }
}
class qv extends A {
  constructor(t) {
    super(t, HH);
  }
  getParser() {
    return this.parser;
  }
}
class FX extends A {
  constructor(t) {
    super(t, lm);
  }
  getParser() {
    return this.parser;
  }
}
class wX extends A {
  constructor(t) {
    super(t, cm);
  }
  getParser() {
    return this.parser;
  }
}
class GX extends A {
  constructor(t) {
    super(t, YH);
  }
  getParser() {
    return this.parser;
  }
}
class BX extends A {
  constructor(t) {
    super(t, WH);
  }
  getParser() {
    return this.parser;
  }
}
class kX extends A {
  constructor(t) {
    super(t, jH);
  }
  getParser() {
    return this.parser;
  }
}
class zX extends A {
  constructor(t) {
    super(t, XH);
  }
  getParser() {
    return this.parser;
  }
}
class VX extends A {
  constructor(t) {
    super(t, fz);
  }
  getParser() {
    return this.parser;
  }
}
class HX extends A {
  constructor(t) {
    super(t, gz);
  }
  getParser() {
    return this.parser;
  }
}
class YX extends A {
  constructor(t) {
    super(t, pz);
  }
  getParser() {
    return this.parser;
  }
}
class WX extends A {
  constructor(t) {
    super(t, Ez);
  }
  getParser() {
    return this.parser;
  }
}
class jX extends A {
  constructor(t) {
    super(t, Tz);
  }
  getParser() {
    return this.parser;
  }
}
class XX extends A {
  constructor(t) {
    super(t, Iz);
  }
  getParser() {
    return this.parser;
  }
}
class KX extends A {
  constructor(t) {
    super(t, Sz);
  }
  getParser() {
    return this.parser;
  }
}
class qX extends A {
  constructor(t) {
    super(t, Az);
  }
  getParser() {
    return this.parser;
  }
}
class $v extends A {
  constructor(t) {
    super(t, Oz);
  }
  getParser() {
    return this.parser;
  }
}
class $X extends A {
  constructor(t) {
    super(t, yz);
  }
  getParser() {
    return this.parser;
  }
}
class ZX extends A {
  constructor(t) {
    super(t, vz);
  }
  getParser() {
    return this.parser;
  }
}
class QX extends A {
  constructor(t) {
    super(t, Cz);
  }
  getParser() {
    return this.parser;
  }
}
class JX extends A {
  constructor(t) {
    super(t, xz);
  }
  getParser() {
    return this.parser;
  }
}
class int extends A {
  constructor(t) {
    super(t, Mz);
  }
  getParser() {
    return this.parser;
  }
}
class rnt extends A {
  constructor(t) {
    super(t, bz);
  }
  getParser() {
    return this.parser;
  }
}
class tK extends A {
  constructor(t) {
    super(t, fV);
  }
  getParser() {
    return this.parser;
  }
}
class eK extends A {
  constructor(t) {
    super(t, pV);
  }
  getParser() {
    return this.parser;
  }
}
class sK extends A {
  constructor(t) {
    super(t, gV);
  }
  getParser() {
    return this.parser;
  }
}
class iK extends A {
  constructor(t) {
    super(t, mV);
  }
  getParser() {
    return this.parser;
  }
}
class rK extends A {
  constructor(t) {
    super(t, EV);
  }
  getParser() {
    return this.parser;
  }
}
class Zv extends A {
  constructor(t) {
    super(t, TV);
  }
  getParser() {
    return this.parser;
  }
}
class nK extends A {
  constructor(t) {
    super(t, IV);
  }
  getParser() {
    return this.parser;
  }
}
class aK extends A {
  constructor(t) {
    super(t, SV);
  }
  getParser() {
    return this.parser;
  }
}
class nnt extends A {
  constructor(t) {
    super(t, qp);
  }
  getParser() {
    return this.parser;
  }
}
class oK extends A {
  constructor(t) {
    super(t, AV);
  }
  getParser() {
    return this.parser;
  }
}
class hK extends A {
  constructor(t) {
    super(t, RV);
  }
  getParser() {
    return this.parser;
  }
}
class uK extends A {
  constructor(t) {
    super(t, OV);
  }
  getParser() {
    return this.parser;
  }
}
class lK extends A {
  constructor(t) {
    super(t, yV);
  }
  getParser() {
    return this.parser;
  }
}
class cK extends A {
  constructor(t) {
    super(t, vV);
  }
  getParser() {
    return this.parser;
  }
}
class _K extends A {
  constructor(t) {
    super(t, xV);
  }
  get userID() {
    return this.getParser().userID;
  }
  get userAccepts() {
    return this.getParser().userAccepts;
  }
  getParser() {
    return this.parser;
  }
}
class dK extends A {
  constructor(t) {
    super(t, Zp);
  }
  get userID() {
    return this.getParser().userID;
  }
  getParser() {
    return this.parser;
  }
}
class fK extends A {
  constructor(t) {
    super(t, MV);
  }
  getParser() {
    return this.parser;
  }
}
class gK extends A {
  constructor(t) {
    super(t, bV);
  }
  getParser() {
    return this.parser;
  }
}
class pK extends A {
  constructor(t) {
    super(t, PV);
  }
  get firstUserID() {
    return this.getParser().firstUserID;
  }
  get secondUserID() {
    return this.getParser().secondUserID;
  }
  get firstUserNumItems() {
    return this.getParser().firstUserNumItems;
  }
  get secondUserNumItems() {
    return this.getParser().secondUserNumItems;
  }
  get firstUserNumCredits() {
    return this.getParser().firstUserNumCredits;
  }
  get secondUserNumCredits() {
    return this.getParser().secondUserNumCredits;
  }
  get firstUserItemArray() {
    return this.getParser().firstUserItemArray;
  }
  get secondUserItemArray() {
    return this.getParser().secondUserItemArray;
  }
  getParser() {
    return this.parser;
  }
}
class mK extends A {
  constructor(t) {
    super(t, NV);
  }
  getParser() {
    return this.parser;
  }
}
class EK extends A {
  constructor(t) {
    super(t, UV);
  }
  getParser() {
    return this.parser;
  }
}
class TK extends A {
  constructor(t) {
    super(t, DV);
  }
  get userID() {
    return this.getParser().userID;
  }
  get userCanTrade() {
    return this.getParser().userCanTrade;
  }
  get otherUserID() {
    return this.getParser().otherUserID;
  }
  get otherUserCanTrade() {
    return this.getParser().otherUserCanTrade;
  }
  getParser() {
    return this.parser;
  }
}
class IK extends A {
  constructor(t) {
    super(t, Qp);
  }
  getParser() {
    return this.parser;
  }
}
class SK extends A {
  constructor(t) {
    super(t, LV);
  }
  getParser() {
    return this.parser;
  }
}
class AK extends A {
  constructor(t) {
    super(t, FV);
  }
  getParser() {
    return this.parser;
  }
}
class RK extends A {
  constructor(t) {
    super(t, KH);
  }
  getParser() {
    return this.parser;
  }
}
class OK extends A {
  constructor(t) {
    super(t, qH);
  }
  getParser() {
    return this.parser;
  }
}
class yK extends A {
  constructor(t) {
    super(t, $H);
  }
  getParser() {
    return this.parser;
  }
}
class vK extends A {
  constructor(t) {
    super(t, ZH);
  }
  getParser() {
    return this.parser;
  }
}
class CK extends A {
  constructor(t) {
    super(t, QH);
  }
  getParser() {
    return this.parser;
  }
}
class xK extends A {
  constructor(t) {
    super(t, JH);
  }
  getParser() {
    return this.parser;
  }
}
class MK extends A {
  constructor(t) {
    super(t, eY);
  }
  getParser() {
    return this.parser;
  }
}
class bK extends A {
  constructor(t) {
    super(t, tY);
  }
  getParser() {
    return this.parser;
  }
}
class PK extends A {
  constructor(t) {
    super(t, dm);
  }
  getParser() {
    return this.parser;
  }
}
class NK extends A {
  constructor(t) {
    super(t, fm);
  }
  getParser() {
    return this.parser;
  }
}
class UK extends A {
  constructor(t) {
    super(t, rY);
  }
  getParser() {
    return this.parser;
  }
}
class DK extends A {
  constructor(t) {
    super(t, nY);
  }
  getParser() {
    return this.parser;
  }
}
class LK extends A {
  constructor(t) {
    super(t, Gv);
  }
  getParser() {
    return this.parser;
  }
}
class FK extends A {
  constructor(t) {
    super(t, oY);
  }
  getParser() {
    return this.parser;
  }
}
class wK extends A {
  constructor(t) {
    super(t, uY);
  }
  getParser() {
    return this.parser;
  }
}
class GK extends A {
  constructor(t) {
    super(t, hY);
  }
  getParser() {
    return this.parser;
  }
}
class BK extends A {
  constructor(t) {
    super(t, cY);
  }
  getParser() {
    return this.parser;
  }
}
class kK extends A {
  constructor(t) {
    super(t, _Y);
  }
  getParser() {
    return this.parser;
  }
}
class zK extends A {
  constructor(t) {
    super(t, gY);
  }
  getParser() {
    return this.parser;
  }
}
class VK extends A {
  constructor(t) {
    super(t, pY);
  }
  getParser() {
    return this.parser;
  }
}
class HK extends A {
  constructor(t) {
    super(t, EY);
  }
  getParser() {
    return this.parser;
  }
}
class YK extends A {
  constructor(t) {
    super(t, TY);
  }
  getParser() {
    return this.parser;
  }
}
class WK extends A {
  constructor(t) {
    super(t, AY);
  }
  getParser() {
    return this.parser;
  }
}
class jK extends A {
  constructor(t) {
    super(t, RY);
  }
  getParser() {
    return this.parser;
  }
}
class XK extends A {
  constructor(t) {
    super(t, yY);
  }
  getParser() {
    return this.parser;
  }
}
class KK extends A {
  constructor(t) {
    super(t, vY);
  }
  getParser() {
    return this.parser;
  }
}
class qK extends A {
  constructor(t) {
    super(t, CY);
  }
  getParser() {
    return this.parser;
  }
}
class Qv extends A {
  constructor(t) {
    super(t, xY);
  }
  getParser() {
    return this.parser;
  }
}
class $K extends A {
  constructor(t) {
    super(t, MY);
  }
  getParser() {
    return this.parser;
  }
}
class ZK extends A {
  constructor(t) {
    super(t, gm);
  }
  getParser() {
    return this.parser;
  }
}
class QK extends A {
  constructor(t) {
    super(t, bY);
  }
  getParser() {
    return this.parser;
  }
}
class JK extends A {
  constructor(t) {
    super(t, GY);
  }
  getParser() {
    return this.parser;
  }
}
class t7 extends A {
  constructor(t) {
    super(t, BY);
  }
  getParser() {
    return this.parser;
  }
}
class e7 extends A {
  constructor(t) {
    super(t, kY);
  }
  getParser() {
    return this.parser;
  }
}
class Jv extends A {
  constructor(t) {
    super(t, zY);
  }
  getParser() {
    return this.parser;
  }
  get userName() {
    return this.getParser().userName;
  }
}
class s7 extends A {
  constructor(t) {
    super(t, VY);
  }
  getParser() {
    return this.parser;
  }
}
class i7 extends A {
  constructor(t) {
    super(t, HY);
  }
  getParser() {
    return this.parser;
  }
}
class Tm extends A {
  constructor(t) {
    super(t, YY);
  }
  getParser() {
    return this.parser;
  }
}
class r7 extends A {
  constructor(t) {
    super(t, WY);
  }
  getParser() {
    return this.parser;
  }
}
class Im extends A {
  constructor(t) {
    super(t, jY);
  }
  getParser() {
    return this.parser;
  }
}
class n7 extends A {
  constructor(t) {
    super(t, XY);
  }
  getParser() {
    return this.parser;
  }
}
class a7 extends A {
  constructor(t) {
    super(t, qY);
  }
  getParser() {
    return this.parser;
  }
}
class o7 extends A {
  constructor(t) {
    super(t, ZY);
  }
  getParser() {
    return this.parser;
  }
}
class h7 extends A {
  constructor(t) {
    super(t, JY);
  }
  getParser() {
    return this.parser;
  }
}
class u7 extends A {
  constructor(t) {
    super(t, tW);
  }
  getParser() {
    return this.parser;
  }
}
class l7 extends A {
  constructor(t) {
    super(t, eW);
  }
  getParser() {
    return this.parser;
  }
}
class c7 extends A {
  constructor(t) {
    super(t, sW);
  }
  getParser() {
    return this.parser;
  }
}
class _7 extends A {
  constructor(t) {
    super(t, iW);
  }
  getParser() {
    return this.parser;
  }
}
class d7 extends A {
  constructor(t) {
    super(t, rW);
  }
  getParser() {
    return this.parser;
  }
}
class AR extends A {
  constructor(t) {
    super(t, oW);
  }
  getParser() {
    return this.parser;
  }
}
class f7 extends A {
  constructor(t) {
    super(t, hW);
  }
  getParser() {
    return this.parser;
  }
}
class g7 extends A {
  constructor(t) {
    super(t, uW);
  }
  getParser() {
    return this.parser;
  }
}
class p7 extends A {
  constructor(t) {
    super(t, lW);
  }
  getParser() {
    return this.parser;
  }
}
class m7 extends A {
  constructor(t) {
    super(t, cW);
  }
  getParser() {
    return this.parser;
  }
}
class E7 extends A {
  constructor(t) {
    super(t, _W);
  }
  getParser() {
    return this.parser;
  }
}
class T7 extends A {
  constructor(t) {
    super(t, dW);
  }
  getParser() {
    return this.parser;
  }
}
class I7 extends A {
  constructor(t) {
    super(t, fW);
  }
  getParser() {
    return this.parser;
  }
}
class S7 extends A {
  constructor(t) {
    super(t, pW);
  }
  getParser() {
    return this.parser;
  }
}
class A7 extends A {
  constructor(t) {
    super(t, mW);
  }
  getParser() {
    return this.parser;
  }
}
class tC extends A {
  constructor(t) {
    super(t, EW);
  }
  getParser() {
    return this.parser;
  }
}
class R7 extends A {
  constructor(t) {
    super(t, TW);
  }
  getParser() {
    return this.parser;
  }
}
class O7 extends A {
  constructor(t) {
    super(t, IW);
  }
  getParser() {
    return this.parser;
  }
}
class y7 extends A {
  constructor(t) {
    super(t, SW);
  }
  getParser() {
    return this.parser;
  }
}
class v7 extends A {
  constructor(t) {
    super(t, AW);
  }
  getParser() {
    return this.parser;
  }
}
class ant extends A {
  constructor(t) {
    super(t, RW);
  }
  getParser() {
    return this.parser;
  }
}
class C7 extends A {
  constructor(t) {
    super(t, OW);
  }
  getParser() {
    return this.parser;
  }
}
class x7 extends A {
  constructor(t) {
    super(t, yW);
  }
  getParser() {
    return this.parser;
  }
}
class M7 extends A {
  constructor(t) {
    super(t, vW);
  }
  getParser() {
    return this.parser;
  }
}
class b7 extends A {
  constructor(t) {
    super(t, CW);
  }
  getParser() {
    return this.parser;
  }
}
class P7 extends A {
  constructor(t) {
    super(t, xW);
  }
  getParser() {
    return this.parser;
  }
}
class eC extends A {
  constructor(t) {
    super(t, MW);
  }
  getParser() {
    return this.parser;
  }
}
class N7 extends A {
  constructor(t) {
    super(t, bW);
  }
  getParser() {
    return this.parser;
  }
}
class U7 extends A {
  constructor(t) {
    super(t, PW);
  }
  getParser() {
    return this.parser;
  }
}
class D7 extends A {
  constructor(t) {
    super(t, NW);
  }
  getParser() {
    return this.parser;
  }
}
class L7 extends A {
  constructor(t) {
    super(t, zW);
  }
  getParser() {
    return this.parser;
  }
}
class F7 extends A {
  constructor(t) {
    super(t, $p);
  }
  getParser() {
    return this.parser;
  }
}
class sC extends A {
  constructor(t) {
    super(t, VW);
  }
  getParser() {
    return this.parser;
  }
}
class iC extends A {
  constructor(t) {
    super(t, HW);
  }
  getParser() {
    return this.parser;
  }
}
class rC extends A {
  constructor(t) {
    super(t, YW);
  }
  getParser() {
    return this.parser;
  }
}
class nC extends A {
  constructor(t) {
    super(t, WW);
  }
  getParser() {
    return this.parser;
  }
}
class w7 extends A {
  constructor(t) {
    super(t, jW);
  }
  getParser() {
    return this.parser;
  }
}
class aC extends A {
  constructor(t) {
    super(t, qW);
  }
  getParser() {
    return this.parser;
  }
}
class oC extends A {
  constructor(t) {
    super(t, $W);
  }
  getParser() {
    return this.parser;
  }
}
class hC extends A {
  constructor(t) {
    super(t, ZW);
  }
  getParser() {
    return this.parser;
  }
}
class uC extends A {
  constructor(t) {
    super(t, QW);
  }
  getParser() {
    return this.parser;
  }
}
class lC extends A {
  constructor(t) {
    super(t, tj);
  }
  getParser() {
    return this.parser;
  }
}
class cC extends A {
  constructor(t) {
    super(t, JW);
  }
  getParser() {
    return this.parser;
  }
}
class _C extends A {
  constructor(t) {
    super(t, ej);
  }
  getParser() {
    return this.parser;
  }
}
class dC extends A {
  constructor(t) {
    super(t, sj);
  }
  getParser() {
    return this.parser;
  }
}
class G7 extends A {
  constructor(t) {
    super(t, nj);
  }
  getParser() {
    return this.parser;
  }
}
class B7 extends A {
  constructor(t) {
    super(t, hj);
  }
  getParser() {
    return this.parser;
  }
}
class k7 extends A {
  constructor(t) {
    super(t, uj);
  }
  getParser() {
    return this.parser;
  }
}
class z7 extends A {
  constructor(t) {
    super(t, lj);
  }
  getParser() {
    return this.parser;
  }
}
class V7 extends A {
  constructor(t) {
    super(t, cj);
  }
  getParser() {
    return this.parser;
  }
}
class H7 extends A {
  constructor(t) {
    super(t, _j);
  }
  getParser() {
    return this.parser;
  }
}
class Y7 extends A {
  constructor(t) {
    super(t, dj);
  }
  getParser() {
    return this.parser;
  }
}
class W7 extends A {
  constructor(t) {
    super(t, fj);
  }
  getParser() {
    return this.parser;
  }
}
class j7 extends A {
  constructor(t) {
    super(t, gj);
  }
  getParser() {
    return this.parser;
  }
}
class X7 extends A {
  constructor(t) {
    super(t, pj);
  }
  getParser() {
    return this.parser;
  }
}
class K7 extends A {
  constructor(t) {
    super(t, mj);
  }
  getParser() {
    return this.parser;
  }
}
const ad = class ad extends A {
  constructor(t) {
    super(t, Ej);
  }
  getParser() {
    return this.parser;
  }
};
ad.FINISHED_OK = 1, ad.FINISHED_FAIL = 2;
let Sm = ad;
const tu = class tu extends A {
  constructor(t) {
    super(t, Tj);
  }
  getParser() {
    return this.parser;
  }
};
tu.SYSTEM_STATUS_ENABLED = 1, tu.SYSTEM_STATUS_DISABLED = 2, tu.SYSTEM_STATUS_TIMEOUT = 3;
let Am = tu;
class Rm extends A {
  constructor(t) {
    super(t, Pz);
  }
  getParser() {
    return this.parser;
  }
}
class Om extends A {
  constructor(t) {
    super(t, Nz);
  }
  getParser() {
    return this.parser;
  }
}
class ym extends A {
  constructor(t) {
    super(t, Dz);
  }
  getParser() {
    return this.parser;
  }
}
class vm extends A {
  constructor(t) {
    super(t, Uz);
  }
  getParser() {
    return this.parser;
  }
}
class q7 extends A {
  constructor(t) {
    super(t, Wp);
  }
  getParser() {
    return this.parser;
  }
}
class Cm extends A {
  constructor(t) {
    super(t, Lz);
  }
  getParser() {
    return this.parser;
  }
}
class $7 extends A {
  constructor(t) {
    super(t, Fz);
  }
  getParser() {
    return this.parser;
  }
}
class Z7 extends A {
  constructor(t) {
    super(t, wz);
  }
  getParser() {
    return this.parser;
  }
}
class Q7 extends A {
  constructor(t) {
    super(t, Gz);
  }
  getParser() {
    return this.parser;
  }
}
class J7 extends A {
  constructor(t) {
    super(t, kz);
  }
  getParser() {
    return this.parser;
  }
}
class t9 extends A {
  constructor(t) {
    super(t, t4);
  }
  getParser() {
    return this.parser;
  }
}
class e9 extends A {
  constructor(t) {
    super(t, e4);
  }
  getParser() {
    return this.parser;
  }
}
class s9 extends A {
  constructor(t) {
    super(t, s4);
  }
  getParser() {
    return this.parser;
  }
}
class fC extends A {
  constructor(t) {
    super(t, r4);
  }
  getParser() {
    return this.parser;
  }
}
class xm extends A {
  constructor(t) {
    super(t, w4);
  }
  getParser() {
    return this.parser;
  }
}
class Mm extends A {
  constructor(t) {
    super(t, G4);
  }
  getParser() {
    return this.parser;
  }
}
class bm extends A {
  constructor(t) {
    super(t, a4);
  }
  getParser() {
    return this.parser;
  }
}
class i9 extends A {
  constructor(t) {
    super(t, o4);
  }
  getParser() {
    return this.parser;
  }
}
class Pm extends A {
  constructor(t) {
    super(t, h4);
  }
  getParser() {
    return this.parser;
  }
}
class r9 extends A {
  constructor(t) {
    super(t, u4);
  }
  getParser() {
    return this.parser;
  }
}
class Nm extends A {
  constructor(t) {
    super(t, l4);
  }
  getParser() {
    return this.parser;
  }
}
class Um extends A {
  constructor(t) {
    super(t, Tn);
  }
  getParser() {
    return this.parser;
  }
}
class n9 extends A {
  constructor(t) {
    super(t, c4);
  }
  getParser() {
    return this.parser;
  }
}
class a9 extends A {
  constructor(t) {
    super(t, _4);
  }
  getParser() {
    return this.parser;
  }
}
class Dm extends A {
  constructor(t) {
    super(t, d4);
  }
  getParser() {
    return this.parser;
  }
}
class o9 extends A {
  constructor(t) {
    super(t, f4);
  }
  getParser() {
    return this.parser;
  }
}
class h9 extends A {
  constructor(t) {
    super(t, g4);
  }
  getParser() {
    return this.parser;
  }
}
class u9 extends A {
  constructor(t) {
    super(t, p4);
  }
  getParser() {
    return this.parser;
  }
}
class Lm extends A {
  constructor(t) {
    super(t, m4);
  }
  getParser() {
    return this.parser;
  }
}
class l9 extends A {
  constructor(t) {
    super(t, E4);
  }
  getParser() {
    return this.parser;
  }
}
class c9 extends A {
  constructor(t) {
    super(t, T4);
  }
  getParser() {
    return this.parser;
  }
}
class _9 extends A {
  constructor(t) {
    super(t, Kp);
  }
  getParser() {
    return this.parser;
  }
}
class d9 extends A {
  constructor(t) {
    super(t, I4);
  }
  getParser() {
    return this.parser;
  }
}
class gC extends A {
  constructor(t) {
    super(t, A4);
  }
  getParser() {
    return this.parser;
  }
}
class f9 extends A {
  constructor(t) {
    super(t, R4);
  }
  getParser() {
    return this.parser;
  }
}
class g9 extends A {
  constructor(t) {
    super(t, O4);
  }
  getParser() {
    return this.parser;
  }
}
class Fm extends A {
  constructor(t) {
    super(t, y4);
  }
  getParser() {
    return this.parser;
  }
}
class wm extends A {
  constructor(t) {
    super(t, v4);
  }
  getParser() {
    return this.parser;
  }
}
class Gm extends A {
  constructor(t) {
    super(t, C4);
  }
  getParser() {
    return this.parser;
  }
}
class Bm extends A {
  constructor(t) {
    super(t, x4);
  }
  getParser() {
    return this.parser;
  }
}
class km extends A {
  constructor(t) {
    super(t, M4);
  }
  getParser() {
    return this.parser;
  }
}
class zm extends A {
  constructor(t) {
    super(t, b4);
  }
  getParser() {
    return this.parser;
  }
}
class Vm extends A {
  constructor(t) {
    super(t, P4);
  }
  getParser() {
    return this.parser;
  }
}
class Hm extends A {
  constructor(t) {
    super(t, N4);
  }
  getParser() {
    return this.parser;
  }
}
class p9 extends A {
  constructor(t) {
    super(t, U4);
  }
  getParser() {
    return this.parser;
  }
}
class m9 extends A {
  constructor(t) {
    super(t, L4);
  }
  getParser() {
    return this.parser;
  }
}
class E9 extends A {
  constructor(t) {
    super(t, F4);
  }
  getParser() {
    return this.parser;
  }
}
class Ym extends A {
  constructor(t) {
    super(t, Tc);
  }
  getParser() {
    return this.parser;
  }
}
class Wm extends A {
  constructor(t) {
    super(t, B4);
  }
  getParser() {
    return this.parser;
  }
}
class jm extends A {
  constructor(t) {
    super(t, cn);
  }
  getParser() {
    return this.parser;
  }
}
class Xm extends A {
  constructor(t) {
    super(t, k4);
  }
  getParser() {
    return this.parser;
  }
}
class T9 extends A {
  constructor(t) {
    super(t, z4);
  }
  getParser() {
    return this.parser;
  }
}
class Km extends A {
  constructor(t) {
    super(t, V4);
  }
  getParser() {
    return this.parser;
  }
}
class jo extends A {
  constructor(t) {
    super(t, H4);
  }
  getParser() {
    return this.parser;
  }
}
class qm extends A {
  constructor(t) {
    super(t, Y4);
  }
  getParser() {
    return this.parser;
  }
}
class pC extends A {
  constructor(t) {
    super(t, W4);
  }
  getParser() {
    return this.parser;
  }
}
class mC extends A {
  constructor(t) {
    super(t, j4);
  }
  getParser() {
    return this.parser;
  }
}
class Ac extends A {
  constructor(t) {
    super(t, X4);
  }
  getParser() {
    return this.parser;
  }
}
class EC extends A {
  constructor(t) {
    super(t, K4);
  }
  getParser() {
    return this.parser;
  }
}
class TC extends A {
  constructor(t) {
    super(t, q4);
  }
  getParser() {
    return this.parser;
  }
}
class IC extends A {
  constructor(t) {
    super(t, $4);
  }
  getParser() {
    return this.parser;
  }
}
class SC extends A {
  constructor(t) {
    super(t, Z4);
  }
  getParser() {
    return this.parser;
  }
}
class AC extends A {
  constructor(t) {
    super(t, Q4);
  }
  getParser() {
    return this.parser;
  }
}
class RC extends A {
  constructor(t) {
    super(t, J4);
  }
  getParser() {
    return this.parser;
  }
}
class uI extends A {
  constructor(t) {
    super(t, rI);
  }
  getParser() {
    return this.parser;
  }
}
class Rc extends A {
  constructor(t) {
    super(t, rI);
  }
  getParser() {
    return this.parser;
  }
}
class Oc extends A {
  constructor(t) {
    super(t, rI);
  }
  getParser() {
    return this.parser;
  }
}
class $m extends A {
  constructor(t) {
    super(t, tV);
  }
  getParser() {
    return this.parser;
  }
}
class yc extends A {
  constructor(t) {
    super(t, eV);
  }
  getParser() {
    return this.parser;
  }
}
class Zm extends A {
  constructor(t) {
    super(t, sV);
  }
  getParser() {
    return this.parser;
  }
}
class vc extends A {
  constructor(t) {
    super(t, uV);
  }
  getParser() {
    return this.parser;
  }
}
class Qm extends A {
  constructor(t) {
    super(t, iV);
  }
  getParser() {
    return this.parser;
  }
}
class Jm extends A {
  constructor(t) {
    super(t, rV);
  }
  getParser() {
    return this.parser;
  }
}
class OC extends A {
  constructor(t) {
    super(t, nV);
  }
  getParser() {
    return this.parser;
  }
}
class tE extends A {
  constructor(t) {
    super(t, aV);
  }
  getParser() {
    return this.parser;
  }
}
class Cc extends A {
  constructor(t) {
    super(t, oV);
  }
  getParser() {
    return this.parser;
  }
}
class eE extends A {
  constructor(t) {
    super(t, hV);
  }
  getParser() {
    return this.parser;
  }
}
class xc extends A {
  constructor(t) {
    super(t, lV);
  }
  getParser() {
    return this.parser;
  }
}
class sE extends A {
  constructor(t) {
    super(t, dV);
  }
  getParser() {
    return this.parser;
  }
}
class I9 extends A {
  constructor(t) {
    super(t, Rj);
  }
  getParser() {
    return this.parser;
  }
}
class S9 extends A {
  constructor(t) {
    super(t, Oj);
  }
  getParser() {
    return this.parser;
  }
}
class A9 extends A {
  constructor(t) {
    super(t, yj);
  }
  getParser() {
    return this.parser;
  }
}
class R9 extends A {
  constructor(t) {
    super(t, vj);
  }
  getParser() {
    return this.parser;
  }
}
const od = class od extends A {
  constructor(t) {
    super(t, Cj);
  }
  getParser() {
    return this.parser;
  }
};
od.PRODUCT_DONATED_CODE = 6, od.BADGE_DONATED_CODE = 7;
let iE = od;
class O9 extends A {
  constructor(t) {
    super(t, xj);
  }
  getParser() {
    return this.parser;
  }
}
class y9 extends A {
  constructor(t) {
    super(t, Mj);
  }
  getParser() {
    return this.parser;
  }
}
class v9 extends A {
  constructor(t) {
    super(t, Vz);
  }
  getParser() {
    return this.parser;
  }
}
class C9 extends A {
  constructor(t) {
    super(t, Yz);
  }
  getParser() {
    return this.parser;
  }
}
class x9 extends A {
  constructor(t) {
    super(t, Wz);
  }
  getParser() {
    return this.parser;
  }
}
class M9 extends A {
  constructor(t) {
    super(t, jz);
  }
  getParser() {
    return this.parser;
  }
}
class b9 extends A {
  constructor(t) {
    super(t, Xz);
  }
  getParser() {
    return this.parser;
  }
}
class P9 extends A {
  constructor(t) {
    super(t, Kz);
  }
  getParser() {
    return this.parser;
  }
}
class N9 extends A {
  constructor(t) {
    super(t, qz);
  }
  getParser() {
    return this.parser;
  }
}
class U9 extends A {
  constructor(t) {
    super(t, $z);
  }
  getParser() {
    return this.parser;
  }
}
class D9 extends A {
  constructor(t) {
    super(t, Zz);
  }
  getParser() {
    return this.parser;
  }
}
class L9 extends A {
  constructor(t) {
    super(t, Xp);
  }
  getParser() {
    return this.parser;
  }
}
class F9 extends A {
  constructor(t) {
    super(t, Qz);
  }
  getParser() {
    return this.parser;
  }
}
class w9 extends A {
  constructor(t) {
    super(t, Jz);
  }
  getParser() {
    return this.parser;
  }
}
class yC extends A {
  constructor(t) {
    super(t, bj);
  }
  getParser() {
    return this.parser;
  }
}
class vC extends A {
  constructor(t) {
    super(t, Pj);
  }
  getParser() {
    return this.parser;
  }
}
class CC extends A {
  constructor(t) {
    super(t, Nj);
  }
  getParser() {
    return this.parser;
  }
}
class xC extends A {
  constructor(t) {
    super(t, Uj);
  }
  getParser() {
    return this.parser;
  }
}
class G9 extends A {
  constructor(t) {
    super(t, Dj);
  }
  getParser() {
    return this.parser;
  }
}
class B9 extends A {
  constructor(t) {
    super(t, Lj);
  }
  getParser() {
    return this.parser;
  }
}
class k9 extends A {
  constructor(t) {
    super(t, Fj);
  }
  getParser() {
    return this.parser;
  }
}
class MC extends A {
  constructor(t) {
    super(t, Gj);
  }
  getParser() {
    return this.parser;
  }
}
class bC extends A {
  constructor(t) {
    super(t, Bj);
  }
  getParser() {
    return this.parser;
  }
}
class z9 extends A {
  constructor(t) {
    super(t, zj);
  }
  getParser() {
    return this.parser;
  }
}
class V9 extends A {
  constructor(t) {
    super(t, Hj);
  }
  getParser() {
    return this.parser;
  }
}
class H9 extends A {
  constructor(t) {
    super(t, Wj);
  }
  getParser() {
    return this.parser;
  }
}
class PC extends A {
  constructor(t) {
    super(t, Wk);
  }
  getParser() {
    return this.parser;
  }
}
class NC extends A {
  constructor(t) {
    super(t, pc);
  }
  getParser() {
    return this.parser;
  }
}
class Y9 extends A {
  constructor(t) {
    super(t, jk);
  }
  getParser() {
    return this.parser;
  }
}
class W9 extends A {
  constructor(t) {
    super(t, kp);
  }
  getParser() {
    return this.parser;
  }
}
class j9 extends A {
  constructor(t) {
    super(t, Kk);
  }
  getParser() {
    return this.parser;
  }
}
class UC extends A {
  constructor(t) {
    super(t, qk);
  }
  getParser() {
    return this.parser;
  }
}
class Mc extends A {
  constructor(t) {
    super(t, Zk);
  }
  getParser() {
    return this.parser;
  }
}
class lI extends A {
  constructor(t) {
    super(t, Qk);
  }
  getParser() {
    return this.parser;
  }
}
class X9 extends A {
  constructor(t) {
    super(t, Jk);
  }
  getParser() {
    return this.parser;
  }
}
class K9 extends A {
  constructor(t) {
    super(t, tz);
  }
  getParser() {
    return this.parser;
  }
}
class DC extends A {
  constructor(t) {
    super(t, ez);
  }
  getParser() {
    return this.parser;
  }
}
class LC extends A {
  constructor(t) {
    super(t, sz);
  }
  getParser() {
    return this.parser;
  }
}
class q9 extends A {
  constructor(t) {
    super(t, iz);
  }
  getParser() {
    return this.parser;
  }
}
class $9 extends A {
  constructor(t) {
    super(t, rz);
  }
  getParser() {
    return this.parser;
  }
}
class Z9 extends A {
  constructor(t) {
    super(t, nz);
  }
  getParser() {
    return this.parser;
  }
}
class Q9 extends A {
  constructor(t) {
    super(t, zp);
  }
  getParser() {
    return this.parser;
  }
}
class J9 extends A {
  constructor(t) {
    super(t, az);
  }
  getParser() {
    return this.parser;
  }
}
class tq extends A {
  constructor(t) {
    super(t, oz);
  }
  getParser() {
    return this.parser;
  }
}
class FC extends A {
  constructor(t) {
    super(t, hz);
  }
  getParser() {
    return this.parser;
  }
}
class eq extends A {
  constructor(t) {
    super(t, Vp);
  }
  getParser() {
    return this.parser;
  }
}
class wC extends A {
  constructor(t) {
    super(t, uz);
  }
  getParser() {
    return this.parser;
  }
}
class cI extends A {
  constructor(t) {
    super(t, lz);
  }
  getParser() {
    return this.parser;
  }
}
class GC extends A {
  constructor(t) {
    super(t, cz);
  }
  getParser() {
    return this.parser;
  }
}
class sq extends A {
  constructor(t) {
    super(t, _z);
  }
  getParser() {
    return this.parser;
  }
}
class iq extends A {
  constructor(t) {
    super(t, dz);
  }
  getParser() {
    return this.parser;
  }
}
class rq extends A {
  constructor(t) {
    super(t, Hp);
  }
  getParser() {
    return this.parser;
  }
}
const Bs = class Bs {
  constructor(t) {
    this._type = t.readInt(), this._userId = t.readInt(), this._userName = t.readString(), this._figure = t.readString(), this._memberSince = t.readString();
  }
  get userId() {
    return this._userId;
  }
  get userName() {
    return this._userName;
  }
  get admin() {
    return this._type == Bs.TYPE_ADMIN;
  }
  get owner() {
    return this._type == Bs.TYPE_OWNER;
  }
  get pending() {
    return this._type == Bs.TYPE_PENDING;
  }
  get member() {
    return this._type != Bs.TYPE_MEMBER;
  }
  get blocked() {
    return this._type == Bs.TYPE_BLOCKED;
  }
  get figure() {
    return this._figure;
  }
  get memberSince() {
    return this._memberSince;
  }
};
Bs.TYPE_OWNER = 0, Bs.TYPE_ADMIN = 1, Bs.TYPE_PENDING = 2, Bs.TYPE_MEMBER = 3, Bs.TYPE_BLOCKED = 4;
let rE = Bs;
class BC extends A {
  constructor(t) {
    super(t, wV);
  }
  getParser() {
    return this.parser;
  }
}
class kC extends A {
  constructor(t) {
    super(t, GV);
  }
  getParser() {
    return this.parser;
  }
}
class zC extends A {
  constructor(t) {
    super(t, BV);
  }
  getParser() {
    return this.parser;
  }
}
class nq extends A {
  constructor(t) {
    super(t, VV);
  }
  getParser() {
    return this.parser;
  }
}
class aq extends A {
  constructor(t) {
    super(t, HV);
  }
  getParser() {
    return this.parser;
  }
}
class oq extends A {
  constructor(t) {
    super(t, YV);
  }
  getParser() {
    return this.parser;
  }
}
class hq extends A {
  constructor(t) {
    super(t, jj);
  }
  getParser() {
    return this.parser;
  }
}
const T = class T {
};
T.CLICK_FURNI = 6002, T.ACHIEVEMENT_LIST = 219, T.AUTHENTICATION = -1, T.BOT_CONFIGURATION = 1986, T.BOT_PICKUP = 3323, T.BOT_PLACE = 1592, T.BOT_SKILL_SAVE = 2624, T.GET_CLUB_OFFERS = 3285, T.GET_CLUB_GIFT_INFO = 487, T.GET_CATALOG_INDEX = 1195, T.GET_CATALOG_PAGE = 412, T.CATALOG_PURCHASE = 3492, T.CATALOG_PURCHASE_GIFT = 1411, T.GET_PRODUCT_OFFER = 2594, T.CLIENT_LATENCY = 295, T.CLIENT_LATENCY_MEASURE = 96, T.CLIENT_POLICY = 26979, T.CLIENT_PONG = 2596, T.CLIENT_TOOLBAR_TOGGLE = 2313, T.CLIENT_VARIABLES = 1053, T.GET_CURRENT_TIMING_CODE = 2912, T.DESKTOP_NEWS = 1827, T.DESKTOP_VIEW = 105, T.GET_BUNDLE_DISCOUNT_RULESET = 223, T.EVENT_TRACKER = 3457, T.FIND_NEW_FRIENDS = 516, T.FURNITURE_ALIASES = 3898, T.FURNITURE_FLOOR_UPDATE = 248, T.FURNITURE_MULTISTATE = 99, T.FURNITURE_PICKUP = 3456, T.FURNITURE_PLACE = 1258, T.FURNITURE_POSTIT_PLACE = 2248, T.FURNITURE_POSTIT_SAVE_STICKY_POLE = 3283, T.FURNITURE_RANDOMSTATE = 3617, T.FURNITURE_WALL_MULTISTATE = 210, T.FURNITURE_WALL_UPDATE = 168, T.GAMES_INIT = 2914, T.GAMES_LIST = 741, T.ACCEPTGAMEINVITE = 3802, T.GAMEUNLOADEDMESSAGE = 3207, T.GETGAMEACHIEVEMENTSMESSAGE = 2399, T.GETGAMESTATUSMESSAGE = 3171, T.GETUSERGAMEACHIEVEMENTSMESSAGE = 389, T.JOINQUEUEMESSAGE = 1458, T.LEAVEQUEUEMESSAGE = 2384, T.RESETRESOLUTIONACHIEVEMENTMESSAGE = 3144, T.GETWEEKLYGAMEREWARDWINNERS = 1054, T.GAME2GETACCOUNTGAMESTATUSMESSAGE = 11, T.GAME2CHECKGAMEDIRECTORYSTATUSMESSAGE = 3259, T.GAME2EXITGAMEMESSAGE = 1445, T.GAME2GAMECHATMESSAGE = 2502, T.GAME2LOADSTAGEREADYMESSAGE = 2415, T.GAME2PLAYAGAINMESSAGE = 3196, T.GAME2REQUESTFULLSTATUSUPDATEMESSAGE = 1598, T.GAME2GETWEEKLYFRIENDSLEADERBOARD = 1232, T.GAME2GETWEEKLYLEADERBOARD = 2565, T.GET_GIFT_WRAPPING_CONFIG = 418, T.GROUP_ADMIN_ADD = 2894, T.GROUP_ADMIN_REMOVE = 722, T.GROUP_CREATE_OPTIONS = 798, T.GROUP_FAVORITE = 3549, T.GET_FORUM_STATS = 3149, T.GET_FORUM_THREADS = 873, T.GET_FORUMS_LIST = 436, T.GET_FORUM_MESSAGES = 232, T.GET_FORUM_THREAD = 3900, T.GET_UNREAD_FORUMS_COUNT = 2908, T.FORUM_MODERATE_MESSAGE = 286, T.FORUM_MODERATE_THREAD = 1397, T.FORUM_POST_MESSAGE = 3529, T.UPDATE_FORUM_READ_MARKER = 1855, T.UPDATE_FORUM_SETTINGS = 2214, T.FORUM_UPDATE_THREAD = 3045, T.GROUP_INFO = 2991, T.GROUP_DELETE = 1134, T.GROUP_MEMBER_REMOVE_CONFIRM = 3593, T.GROUP_MEMBER_REMOVE = 593, T.GROUP_MEMBERS = 312, T.GROUP_MEMBERSHIPS = 367, T.GROUP_REQUEST = 998, T.GROUP_REQUEST_ACCEPT = 3386, T.GROUP_REQUEST_DECLINE = 1894, T.GROUP_SETTINGS = 1004, T.GROUP_PARTS = 813, T.GROUP_BUY = 230, T.GROUP_SAVE_INFORMATION = 3137, T.GROUP_SAVE_BADGE = 1991, T.GROUP_SAVE_COLORS = 1764, T.GROUP_SAVE_PREFERENCES = 3435, T.GROUP_BADGES = 21, T.GROUP_UNBLOCK_MEMBER = 2864, T.GET_BADGE_POINTS_LIMITS = 1371, T.REQUESTABADGE = 3077, T.GETISBADGEREQUESTFULFILLED = 1364, T.ITEM_CLOTHING_REDEEM = 3374, T.ITEM_COLOR_WHEEL_CLICK = 2144, T.ITEM_DICE_CLICK = 1990, T.ITEM_DICE_CLOSE = 1533, T.ITEM_DIMMER_SAVE = 1648, T.ITEM_DIMMER_SETTINGS = 2813, T.ITEM_DIMMER_TOGGLE = 2296, T.ITEM_EXCHANGE_REDEEM = 3115, T.ITEM_PAINT = 711, T.SET_OBJECT_DATA = 3608, T.ITEM_STACK_HELPER = 3839, T.ITEM_WALL_CLICK = 210, T.ITEM_WALL_UPDATE = 168, T.MARKETPLACE_CONFIG = 2597, T.ACCEPT_FRIEND = 137, T.MESSENGER_CHAT = 3567, T.DECLINE_FRIEND = 2890, T.FOLLOW_FRIEND = 3997, T.MESSENGER_FRIENDS = 1523, T.MESSENGER_INIT = 2781, T.MESSENGER_RELATIONSHIPS = 2138, T.SET_RELATIONSHIP_STATUS = 3768, T.REMOVE_FRIEND = 1689, T.REQUEST_FRIEND = 3157, T.GET_FRIEND_REQUESTS = 2448, T.SEND_ROOM_INVITE = 1276, T.HABBO_SEARCH = 1210, T.FRIEND_LIST_UPDATE = 1419, T.MOD_TOOL_USER_INFO = 3295, T.GET_USER_FLAT_CATS = 3027, T.NAVIGATOR_INIT = 2110, T.NAVIGATOR_SEARCH = 249, T.NAVIGATOR_SEARCH_CLOSE = 1834, T.NAVIGATOR_SEARCH_OPEN = 637, T.NAVIGATOR_SEARCH_SAVE = 2226, T.GET_USER_EVENT_CATS = 1782, T.NAVIGATOR_SETTINGS_SAVE = 3159, T.NAVIGATOR_CATEGORY_LIST_MODE = 1202, T.NAVIGATOR_DELETE_SAVED_SEARCH = 1954, T.PET_INFO = 2934, T.PET_PICKUP = 1581, T.PET_PLACE = 2647, T.PET_RESPECT = 3202, T.PET_RIDE = 1036, T.PET_MOVE = 3449, T.PET_OPEN_PACKAGE = 3698, T.PET_SELECTED = 549, T.PETS_BREED = 1638, T.PET_CANCEL_BREEDING = 2713, T.PET_CONFIRM_BREEDING = 3382, T.GET_PET_TRAINING_PANEL = 2161, T.RECYCLER_PRIZES = 398, T.RECYCLER_STATUS = 1342, T.RECYCLER_ITEMS = 2771, T.RELEASE_VERSION = 4e3, T.CALL_FOR_HELP = 1691, T.ROOM_AMBASSADOR_ALERT = 2996, T.ROOM_BAN_GIVE = 1477, T.ROOM_BAN_LIST = 2267, T.ROOM_BAN_REMOVE = 992, T.ROOM_CREATE = 2752, T.ROOM_DELETE = 532, T.ROOM_DOORBELL = 1644, T.ROOM_ENTER = 2312, T.ROOM_FAVORITE = 3817, T.ROOM_FAVORITE_REMOVE = 309, T.CAN_CREATE_ROOM = 2128, T.CANCEL_ROOM_EVENT = 2725, T.EDIT_ROOM_EVENT = 3991, T.COMPETITION_ROOM_SEARCH = 433, T.FORWARD_TO_RANDOM_PROMOTED_ROOM = 10, T.FORWARD_TO_SOME_ROOM = 1703, T.GET_CATEGORIES_WITH_USER_COUNT = 3782, T.GET_GUEST_ROOM = 2230, T.GET_OFFICIAL_ROOMS = 1229, T.GET_POPULAR_ROOM_TAGS = 826, T.GUILD_BASE_SEARCH = 2930, T.MY_FAVOURITE_ROOMS_SEARCH = 2578, T.MY_FREQUENT_ROOM_HISTORY_SEARCH = 1002, T.MY_FRIENDS_ROOM_SEARCH = 2266, T.MY_GUILD_BASES_SEARCH = 39, T.MY_RECOMMENDED_ROOMS = 2537, T.MY_ROOM_HISTORY_SEARCH = 2264, T.MY_ROOM_RIGHTS_SEARCH = 272, T.MY_ROOMS_SEARCH = 2277, T.POPULAR_ROOMS_SEARCH = 2758, T.ROOM_AD_EVENT_TAB_CLICKED = 2412, T.ROOM_AD_EVENT_TAB_VIEWED = 2668, T.ROOM_AD_SEARCH = 2809, T.ROOM_TEXT_SEARCH = 3943, T.ROOMS_WHERE_MY_FRIENDS_ARE = 1786, T.ROOMS_WITH_HIGHEST_SCORE_SEARCH = 2939, T.SET_ROOM_SESSION_TAGS = 3305, T.UPDATE_ROOM_THUMBNAIL = 2468, T.ROOM_KICK = 1320, T.ROOM_LIKE = 3582, T.ROOM_MODEL = 2300, T.GET_OCCUPIED_TILES = 1687, T.GET_ROOM_ENTRY_TILE = 3559, T.ROOM_MODEL_SAVE = 875, T.ROOM_MUTE = 3637, T.ROOM_MUTE_USER = 3485, T.ROOM_RIGHTS_GIVE = 808, T.ROOM_RIGHTS_LIST = 3385, T.ROOM_RIGHTS_REMOVE = 2064, T.ROOM_RIGHTS_REMOVE_ALL = 2683, T.ROOM_RIGHTS_REMOVE_OWN = 3182, T.ROOM_SETTINGS = 3129, T.ROOM_SETTINGS_SAVE = 1969, T.ROOM_SETTINGS_UPDATE_ROOM_CATEGORY_AND_TRADE = 1265, T.ROOM_STAFF_PICK = 1918, T.ROOM_FILTER_WORDS = 1911, T.ROOM_FILTER_WORDS_MODIFY = 3001, T.MYSTERYBOXWAITINGCANCELEDMESSAGE = 2012, T.MYSTERYBOX_OPEN_TROPHY = 3074, T.SECURITY_MACHINE = 2490, T.SECURITY_TICKET = 2419, T.TRADE = 1481, T.TRADE_ACCEPT = 3863, T.TRADE_CANCEL = 2341, T.TRADE_CLOSE = 2551, T.TRADE_CONFIRM = 2760, T.TRADE_ITEM = 3107, T.TRADE_ITEM_REMOVE = 3845, T.TRADE_ITEMS = 1263, T.TRADE_UNACCEPT = 1444, T.UNIT_ACTION = 2456, T.UNIT_CHAT = 1314, T.UNIT_CHAT_SHOUT = 2085, T.UNIT_CHAT_WHISPER = 1543, T.UNIT_DANCE = 2080, T.UNIT_DROP_HAND_ITEM = 2814, T.UNIT_GIVE_HANDITEM = 2941, T.UNIT_LOOK = 3301, T.UNIT_POSTURE = 2235, T.UNIT_SIGN = 1975, T.UNIT_TYPING = 1597, T.UNIT_TYPING_STOP = 1474, T.UNIT_WALK = 3320, T.USER_BADGES = 2769, T.USER_BADGES_CURRENT = 2091, T.USER_BADGES_CURRENT_UPDATE = 644, T.USER_BOTS = 3848, T.USER_CURRENCY = 273, T.USER_EFFECT_ACTIVATE = 2959, T.USER_EFFECT_ENABLE = 1752, T.USER_FIGURE = 2730, T.USER_FURNITURE = 3150, T.REQUESTFURNIINVENTORYWHENNOTINROOM = 3500, T.USER_HOME_ROOM = 1740, T.USER_INFO = 357, T.USER_MOTTO = 2228, T.USER_IGNORED = 3878, T.USER_PETS = 3095, T.USER_PROFILE = 3265, T.USER_PROFILE_BY_NAME = 2249, T.USER_RESPECT = 2694, T.GET_SOUND_SETTINGS = 2388, T.USER_SETTINGS_CAMERA = 1461, T.USER_SETTINGS_CHAT_STYLE = 1030, T.USER_SETTINGS_INVITES = 1086, T.USER_SETTINGS_OLD_CHAT = 1262, T.USER_SETTINGS_VOLUME = 1367, T.USER_SUBSCRIPTION = 3166, T.GET_WARDROBE = 2742, T.SAVE_WARDROBE_OUTFIT = 800, T.USER_TAGS = 17, T.PEER_USERS_CLASSIFICATION = 1160, T.USER_CLASSIFICATION = 2285, T.VISIT_USER = 2970, T.WIRED_ACTION_SAVE = 2281, T.WIRED_APPLY_SNAPSHOT = 3373, T.WIRED_CONDITION_SAVE = 3203, T.WIRED_OPEN = 768, T.WIRED_TRIGGER_SAVE = 1520, T.GET_ITEM_DATA = 3964, T.ONE_WAY_DOOR_CLICK = 2765, T.REMOVE_WALL_ITEM = 3336, T.SET_ITEM_DATA = 3666, T.CATALOG_REDEEM_VOUCHER = 339, T.ROOM_TONER_APPLY = 2880, T.FRIEND_FURNI_CONFIRM_LOCK = 3775, T.MANNEQUIN_SAVE_NAME = 2850, T.MANNEQUIN_SAVE_LOOK = 2209, T.PRESENT_OPEN_PRESENT = 3558, T.CATALOG_SELECT_VIP_GIFT = 2276, T.USER_IGNORE_ID = 3314, T.USER_IGNORE = 1117, T.USER_UNIGNORE = 2061, T.MODTOOL_REQUEST_ROOM_INFO = 707, T.MODTOOL_CHANGE_ROOM_SETTINGS = 3260, T.MODTOOL_REQUEST_USER_CHATLOG = 1391, T.MODTOOL_REQUEST_ROOM_CHATLOG = 2587, T.MODTOOL_SANCTION_ALERT = 229, T.MODTOOL_SANCTION_BAN = 2766, T.MODTOOL_SANCTION_KICK = 2582, T.MODTOOL_SANCTION_TRADELOCK = 3742, T.MODTOOL_ALERTEVENT = 1840, T.MODTOOL_SANCTION_MUTE = 1945, T.MODTOOL_REQUEST_USER_ROOMS = 3526, T.MODTOOL_ROOM_ALERT = 3842, T.MODTOOL_PREFERENCES = 31, T.CLOSE_ISSUE_DEFAULT_ACTION = 2717, T.CLOSE_ISSUES = 2067, T.DEFAULT_SANCTION = 1681, T.GET_CFH_CHATLOG = 211, T.MODTOOL_SANCTION = 1392, T.PICK_ISSUES = 15, T.RELEASE_ISSUES = 1572, T.CONVERT_GLOBAL_ROOM_ID = 314, T.REQUEST_SELL_ITEM = 848, T.REQUEST_MARKETPLACE_ITEM_STATS = 3288, T.MARKETPLACE_SELL_ITEM = 3447, T.MARKETPLACE_REQUEST_OWN_ITEMS = 2105, T.MARKETPLACE_TAKE_BACK_ITEM = 434, T.MARKETPLACE_REDEEM_CREDITS = 2650, T.MARKETPLACE_REQUEST_OFFERS = 2407, T.MARKETPLACE_BUY_OFFER = 1603, T.MARKETPLACE_BUY_TOKENS = 1866, T.CATALOG_REQUESET_PET_BREEDS = 1756, T.APPROVE_NAME = 2109, T.UNIT_GIVE_HANDITEM_PET = 2768, T.PET_MOUNT = 1036, T.PET_SUPPLEMENT = 749, T.FURNITURE_GROUP_INFO = 2651, T.ACHIEVEMENT_RESOLUTION_OPEN = 359, T.USE_PET_PRODUCT = 1328, T.REMOVE_PET_SADDLE = 186, T.TOGGLE_PET_RIDING = 1472, T.TOGGLE_PET_BREEDING = 3379, T.UNSEEN_RESET_CATEGORY = 3493, T.UNSEEN_RESET_ITEMS = 2343, T.COMMUNITY_GOAL_VOTE_COMPOSER = 3536, T.GET_PROMO_ARTICLES = 1827, T.ACCEPT_QUEST = 3604, T.ACTIVATE_QUEST = 793, T.CANCEL_QUEST = 3133, T.FRIEND_REQUEST_QUEST_COMPLETE = 1148, T.GET_COMMUNITY_GOAL_EARNED_PRIZES = 2688, T.GET_COMMUNITY_GOAL_HALL_OF_FAME = 2167, T.GET_COMMUNITY_GOAL_PROGRESS = 1145, T.GET_CONCURRENT_USERS_GOAL_PROGRESS = 1343, T.GET_CONCURRENT_USERS_REWARD = 3872, T.GET_DAILY_QUEST = 2486, T.GET_QUESTS = 3333, T.GET_SEASONAL_QUESTS_ONLY = 1190, T.OPEN_QUEST_TRACKER = 2750, T.REDEEM_COMMUNITY_GOAL_PRIZE = 90, T.REJECT_QUEST = 2397, T.START_CAMPAIGN = 1697, T.GET_BONUS_RARE_INFO = 957, T.CRAFT = 3591, T.CRAFT_SECRET = 1251, T.GET_CRAFTABLE_PRODUCTS = 633, T.GET_CRAFTING_RECIPE = 1173, T.GET_CRAFTING_RECIPES_AVAILABLE = 3086, T.PHOTO_COMPETITION = 3959, T.PUBLISH_PHOTO = 2068, T.PURCHASE_PHOTO = 2408, T.RENDER_ROOM = 3226, T.RENDER_ROOM_THUMBNAIL = 1982, T.REQUEST_CAMERA_CONFIGURATION = 796, T.ADD_JUKEBOX_DISK = 753, T.GET_JUKEBOX_PLAYLIST = 1435, T.GET_NOW_PLAYING = 1325, T.GET_OFFICIAL_SONG_ID = 3189, T.GET_SONG_INFO = 3082, T.GET_SOUND_MACHINE_PLAYLIST = 3498, T.GET_USER_SONG_DISKS = 2304, T.REMOVE_JUKEBOX_DISK = 3050, T.INTERSTITIAL_SHOWN = 1109, T.GET_INTERSTITIAL = 2519, T.CHANGE_USERNAME = 2977, T.CHECK_USERNAME = 3950, T.OPEN_CAMPAIGN_CALENDAR_DOOR_STAFF = 3889, T.OPEN_CAMPAIGN_CALENDAR_DOOR = 2257, T.BUILDERS_CLUB_PLACE_ROOM_ITEM = 1051, T.BUILDERS_CLUB_PLACE_WALL_ITEM = 462, T.BUILDERS_CLUB_QUERY_FURNI_COUNT = 2529, T.GET_CATALOG_PAGE_EXPIRATION = 742, T.GET_CATALOG_PAGE_WITH_EARLIEST_EXP = 3135, T.GET_DIRECT_CLUB_BUY_AVAILABLE = 801, T.GET_HABBO_BASIC_MEMBERSHIP_EXTEND_OFFER = 603, T.GET_HABBO_CLUB_EXTEND_OFFER = 2462, T.GET_IS_OFFER_GIFTABLE = 1347, T.GET_LIMITED_OFFER_APPEARING_NEXT = 410, T.GET_NEXT_TARGETED_OFFER = 596, T.GET_ROOM_AD_PURCHASE_INFO = 1075, T.GET_SEASONAL_CALENDAR_DAILY_OFFER = 3257, T.GET_TARGETED_OFFER = 2487, T.MARK_CATALOG_NEW_ADDITIONS_PAGE_OPENED = 2150, T.PURCHASE_BASIC_MEMBERSHIP_EXTENSION = 2735, T.PURCHASE_ROOM_AD = 777, T.PURCHASE_TARGETED_OFFER = 1826, T.PURCHASE_VIP_MEMBERSHIP_EXTENSION = 3407, T.ROOM_AD_PURCHASE_INITIATED = 2283, T.SET_TARGETTED_OFFER_STATE = 2041, T.SHOP_TARGETED_OFFER_VIEWED = 3483, T.HELPER_TALENT_TRACK = 196, T.TALENT_TRACK_GET_LEVEL = 2127, T.FORWARD_TO_A_COMPETITION_ROOM = 172, T.FORWARD_TO_A_SUBMITTABLE_ROOM = 1450, T.FORWARD_TO_RANDOM_COMPETITION_ROOM = 865, T.GET_IS_USER_PART_OF_COMPETITION = 2077, T.GET_SECONDS_UNTIL = 271, T.ROOM_COMPETITION_INIT = 1334, T.SUBMIT_ROOM_TO_COMPETITION = 2595, T.VOTE_FOR_ROOM = 143, T.GET_GIFT = 2436, T.RESET_PHONE_NUMBER_STATE = 2741, T.SET_PHONE_NUMBER_VERIFICATION_STATUS = 1379, T.TRY_PHONE_NUMBER = 790, T.VERIFY_CODE = 2721, T.CONTROL_YOUTUBE_DISPLAY_PLAYBACK = 3005, T.GET_YOUTUBE_DISPLAY_STATUS = 336, T.SET_YOUTUBE_DISPLAY_PLAYLIST = 2069, T.GO_TO_FLAT = 685, T.CHANGE_QUEUE = 3093, T.CALL_FOR_HELP_FROM_FORUM_MESSAGE = 1412, T.CALL_FOR_HELP_FROM_FORUM_THREAD = 534, T.CALL_FOR_HELP_FROM_IM = 2950, T.CALL_FOR_HELP_FROM_PHOTO = 2492, T.CALL_FOR_HELP_FROM_SELFIE = 2755, T.CHAT_REVIEW_GUIDE_DECIDES = 3365, T.CHAT_REVIEW_GUIDE_DETACHED = 2501, T.CHAT_REVIEW_GUIDE_VOTE = 3961, T.CHAT_REVIEW_SESSION_CREATE = 3060, T.DELETE_PENDING_CALLS_FOR_HELP = 3605, T.GET_CFH_STATUS = 2746, T.GET_FAQ_CATEGORY = 3445, T.GET_FAQ_TEXT = 1849, T.GET_GUIDE_REPORTING_STATUS = 3786, T.GET_PENDING_CALLS_FOR_HELP = 3267, T.GET_QUIZ_QUESTIONS = 1296, T.GUIDE_SESSION_CREATE = 3338, T.GUIDE_SESSION_FEEDBACK = 477, T.GUIDE_SESSION_GET_REQUESTER_ROOM = 1052, T.GUIDE_SESSION_GUIDE_DECIDES = 1424, T.GUIDE_SESSION_INVITE_REQUESTER = 234, T.GUIDE_SESSION_IS_TYPING = 519, T.GUIDE_SESSION_MESSAGE = 3899, T.GUIDE_SESSION_ON_DUTY_UPDATE = 1922, T.GUIDE_SESSION_REPORT = 3969, T.GUIDE_SESSION_REQUESTER_CANCELS = 291, T.GUIDE_SESSION_RESOLVED = 887, T.POST_QUIZ_ANSWERS = 3720, T.SEARCH_FAQS = 2031, T.POLL_ANSWER = 3505, T.POLL_REJECT = 1773, T.POLL_START = 109, T.POLL_VOTE_COUNTER = 6200, T.DISCONNECT = 2445, T.SCR_GET_KICKBACK_INFO = 869, T.COMPOST_PLANT = 3835, T.HARVEST_PET = 1521, T.SET_CLOTHING_CHANGE_DATA = 924, T.GROUP_UNFAVORITE = 1820, T.NEW_USER_EXPERIENCE_GET_GIFTS = 1822, T.NEW_USER_EXPERIENCE_SCRIPT_PROCEED = 1299, T.HANDSHAKE_INIT_DIFFIE = 3110, T.HANDSHAKE_COMPLETE_DIFFIE = 773, T.WELCOME_OPEN_GIFT = 2638, T.WELCOME_GIFT_CHANGE_EMAIL = 66, T.EMAIL_GET_STATUS = 2557, T.EMAIL_CHANGE = 3965, T.APPROVE_ALL_MEMBERSHIP_REQUESTS = 882, T.RENTABLE_SPACE_CANCEL_RENT = 1667, T.RENTABLE_SPACE_RENT = 2946, T.RENTABLE_SPACE_STATUS = 872, T.TRACKING_PERFORMANCE_LOG = 3230, T.TRACKING_LAG_WARNING_REPORT = 3847, T.ROOM_DIRECTORY_ROOM_NETWORK_OPEN_CONNECTION = 3736, T.RENTABLE_EXTEND_RENT_OR_BUYOUT_STRIP_ITEM = 2115, T.RENTABLE_EXTEND_RENT_OR_BUYOUT_FURNI = 1071, T.RENTABLE_GET_RENT_OR_BUYOUT_OFFER = 2518;
let S = T;
class uq {
  constructor() {
    this._data = [];
  }
  dispose() {
  }
  getMessageArray() {
    return this._data;
  }
}
class lq {
  constructor() {
    this._data = [];
  }
  dispose() {
  }
  getMessageArray() {
    return this._data;
  }
}
class cq {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class _q {
  constructor(t) {
    this._data = [t];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class dq {
  constructor(t) {
    this._data = [t];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class fq {
  constructor(t = 0) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class gq {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class pq {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class mq {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Eq {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class bc {
  constructor(t = "", e = "", s = "", r = -1, n = -1) {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
    this._data = [];
  }
  async assignBitmap(t) {
    const e = await le.generateImageUrl(t);
    if (!e) return;
    const s = e.split(",")[1], r = Uint8Array.from(atob(s), (n) => n.charCodeAt(0));
    this._data.push(r.byteLength, r.buffer);
  }
  assignBase64(t) {
    const e = t.split(",")[1], s = Uint8Array.from(atob(e), (r) => r.charCodeAt(0));
    this._data.push(s.byteLength, s.buffer);
  }
}
class nE extends bc {
  constructor(t = "", e = "", s = "", r = -1, n = -1) {
    super(t, e, s, r, n);
  }
}
class Tq {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Iq {
  constructor(t, e) {
    this._data = [t, e];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class Sq {
  constructor(t, e) {
    this._data = [t, e];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class Aq {
  constructor(t, e, s, r, n, a) {
    this._data = [t, e, s, r, n, a];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class Rq {
  constructor(t, e, s, r) {
    this._data = [t, e, s, r];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class Oq {
  constructor() {
    this._data = [];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class yq {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class vq {
  constructor() {
    this._data = [];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class Cq {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class xq {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Mq {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class bq {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Pq {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
    this._data = null;
  }
}
class Nq {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
    this._data = null;
  }
}
class Uq {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
    this._data = null;
  }
}
class Dq {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Lq {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
    this._data = null;
  }
}
class Fq {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
    this._data = null;
  }
}
class wq {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
    this._data = null;
  }
}
class Gq {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
    this._data = null;
  }
}
class Bq {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
    this._data = null;
  }
}
class kq {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class zq {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
    this._data = null;
  }
}
class Vq {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
    this._data = null;
  }
}
class Hq {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Yq {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Wq {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class jq {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
    this._data = null;
  }
}
class Xq {
  constructor(t, e, s, r, n, a, o, h, u) {
    this._data = [t, e, s, r, n, a, o, h, u];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Kq {
  constructor(t, e, s, r) {
    this._data = [t, e, s, r];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class qq {
  constructor(t, e, s, r, n, a, o) {
    this._data = [t, e, s, r, n, a, o];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class $q {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Zq {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Qq {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Jq {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class t$ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class e$ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class s$ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class i$ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class r$ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class n$ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class a$ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class o$ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class h$ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class u$ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
const So = class So {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
};
So.CONFIRM_LEVEL_NOT_ACCEPTED = 0, So.CONFIRM_LEVEL_NOT_SUBMITTED = 1, So.CONFIRM_LEVEL_NOT_CONFIRMED = 2, So.CONFIRM_LEVEL_COMMIT = 3;
let aE = So;
class l$ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class c$ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class _$ {
  constructor(t, e) {
    this._data = [t, e.length].concat(e);
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class d$ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class f$ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class g$ {
  constructor(t, e) {
    this._data = [t, e.length].concat(e);
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class p$ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class m$ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class E$ {
  constructor(...t) {
    this._data = [t.length, ...t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class T$ {
  constructor(t, ...e) {
    this._data = [t, e.length, ...e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class I$ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class S$ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class A$ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class R$ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class O$ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class y$ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class v$ {
  constructor(...t) {
    this._data = [t.length, ...t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class C$ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class x$ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class M$ {
  constructor(t, e) {
    this._data = [e.length, ...e, t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class b$ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class P$ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class N$ {
  constructor(t = !0) {
    this._data = [t];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class U$ {
  constructor(t) {
    this._data = [t];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class D$ {
  constructor(t) {
    this._data = [t];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class L$ {
  constructor() {
    this._data = [];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class F$ {
  constructor() {
    this._data = [];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class w$ {
  constructor(t) {
    this._data = [t];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class G$ {
  constructor(t) {
    this._data = [t];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class B$ {
  constructor(t, e) {
    this._data = [t, e];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class k$ {
  constructor(t) {
    this._data = [t];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class z$ {
  constructor() {
    this._data = [];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class V$ {
  constructor() {
    this._data = [];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class H$ {
  constructor(t) {
    this._data = [t];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class VC {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Y$ {
  constructor(t) {
    this._data = [t];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class W$ {
  constructor(t) {
    this._data = [t];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class j$ {
  constructor(t) {
    this._data = [t];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class X$ {
  constructor(t) {
    this._data = [t];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class K$ {
  constructor(t, e, s, r, n, a) {
    this._data = [t, e, s, r, n, a];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class q$ {
  constructor(t, e, s, r, n, a) {
    this._data = [t, e, s, r, n, a];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class $$ {
  constructor(t) {
    this._data = [t];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class Z$ {
  constructor(t) {
    this._data = [t];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
const WI = class WI {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
};
WI.NO_ISSUE_ID = -1;
let oE = WI;
class Q$ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
const jI = class jI {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
};
jI.NO_ISSUE_ID = -1;
let hE = jI;
class J$ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class tZ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class eZ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class sZ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class iZ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class rZ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class nZ {
  constructor(t, e, s, r, n, a) {
    this._data = [t, e, s, r, n, a.length, ...a];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class aZ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class oZ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class hZ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class uZ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class lZ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class cZ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class _Z {
  constructor(t, e, s, r) {
    this._data = [t, e, s, r];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class dZ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class fZ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class gZ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class pZ {
  constructor(t, e) {
    this._data = [t, e.length, ...e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class mZ {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class EZ {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class TZ {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class IZ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class SZ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class AZ {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class RZ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class OZ {
  constructor(t, e, s, r) {
    this._data = [t, e, s, r];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class yZ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class vZ {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class CZ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class xZ {
  constructor(t, e, s, r) {
    this._data = [t, e, s, r];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class MZ {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class bZ {
  constructor(t, e, s, r) {
    this._data = [t, e, s, r];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class PZ {
  constructor(...t) {
    this._data = [t.length], t.forEach((e) => {
      this._data.push(e.k), this._data.push(e._arg_2), this._data.push(e._arg_3);
    });
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class ont {
  constructor(t, e, s) {
    this.k = t, this._arg_2 = e, this._arg_3 = s;
  }
}
class NZ {
  constructor(t, e, s, r, n) {
    this._data = [t, e, s, r, n];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class UZ {
  constructor(t, e, s, r) {
    this._data = [t, e, r, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class DZ {
  constructor(t, e, s) {
    if (this._type = t, e.length === s.length) {
      this._data = [];
      for (let r = 0; r < e.length; r++)
        this._data.push(e[r]), this._data.push(s[r]);
    }
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class HC {
  constructor(t, e, s, r) {
    this._data = [`NITRO-${ic.RENDERER_VERSION.replaceAll(".", "-")}`, "HTML5", Mg.HTML5, xg.BROWSER];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class LZ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class FZ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class YC {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class wZ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class WC {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class jC {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class GZ {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class BZ {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class kZ {
  constructor(t, e, s, r, n) {
    this._data = [t, e, s, r, n];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class zZ {
  constructor(t, e, s, r) {
    this._data = [t, e, s, r];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class VZ {
  constructor(t, e, s, r) {
    this._data = [t, e, s, r.length / 2, ...r];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class HZ {
  constructor(t, e, s, r, n) {
    this._data = [t, e, s, r, n];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class YZ {
  constructor(t, e, s, r, n) {
    this._data = [t, e, s, r, n];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class WZ {
  constructor(t, e, s, r, n) {
    this._data = [t, e, s, r, n.length / 2, ...n];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class jZ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class XZ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class KZ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class qZ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class $Z {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class ZZ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class QZ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class JZ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class tQ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class eQ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class sQ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class iQ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class rQ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class nQ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class aQ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class oQ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class hQ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class uQ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class lQ {
  constructor(t, e, s, r) {
    this._data = [t, e, s, r];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class cQ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class _Q {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class dQ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class fQ {
  constructor(t, e) {
    this._data = [t, e.length, ...e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class gQ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class pQ {
  constructor(t) {
    this._data = [t];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class mQ {
  constructor(t) {
    this._data = [t];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class EQ {
  constructor() {
    this._data = [];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class TQ {
  constructor(t) {
    this._data = [t];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class IQ {
  constructor(t) {
    this._data = [t];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class SQ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class AQ {
  constructor() {
    this._badges = [];
  }
  getMessageArray() {
    const t = [];
    for (let e = 1; e <= this._badges.length; e++)
      t.push(e), t.push(this._badges[e - 1]);
    return t;
  }
  dispose() {
  }
  addActivatedBadge(t) {
    this._badges.push(t);
  }
}
class RR {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class RQ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class OQ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class yQ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class vQ {
  constructor(t, e, s, r) {
    this._data = [t, e, s, r];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class OR {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class CQ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class xQ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class MQ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class bQ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class PQ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class NQ {
  constructor(...t) {
    this._data = [t.length, ...t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class UQ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class DQ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class LQ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class FQ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class wQ {
  constructor(t, ...e) {
    this._data = [t, e.length, ...e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class GQ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class BQ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class kQ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
    this._data = null;
  }
}
class zQ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
    this._data = null;
  }
}
class VQ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
    this._data = null;
  }
}
class HQ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class YQ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
    this._data = null;
  }
}
class WQ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
    this._data = null;
  }
}
class jQ {
  constructor(t, e, s, r) {
    this._data = [t, e, s, r];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
    this._data = null;
  }
}
class XQ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
    this._data = null;
  }
}
class KQ {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class qQ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
    this._data = null;
  }
}
class $Q {
  constructor(t, e, s) {
    this._data = [t, e.length, ...e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
const eu = class eu {
  constructor(t, e) {
    this._data = [e, t.length, ...t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
};
eu.RESOLUTION_USELESS = 1, eu.RESOLUTION_ABUSIVE = 2, eu.RESOLUTION_RESOLVED = 3;
let uE = eu;
const hd = class hd {
  constructor(t, e, s, r, n, a = -1) {
    this._data = [t, e, s, r, n], a != hd.NO_ISSUE_ID && this._data.push(a);
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
};
hd.NO_ISSUE_ID = -1;
let yr = hd;
class ZQ {
  constructor(t, e, s, r = -1) {
    this._data = [t, e, s], r != yr.NO_ISSUE_ID && this._data.push(r);
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class QQ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class JQ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class tJ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class eJ {
  constructor(t, e = 0) {
    this._data = [e, t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class sJ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class iJ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class rJ {
  constructor(t, e, s, r = -1) {
    this._data = [t, e, s], r != yr.NO_ISSUE_ID && this._data.push(r);
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class nJ {
  constructor(t, e, s, r) {
    this._data = [t, e, s, r];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
const Ao = class Ao {
  constructor(t, e, s) {
    this._data = [], this._data.push(t), this._data.push(e), this._data.push(s);
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
};
Ao.ACTION_ALERT = 0, Ao.ACTION_KICK = 1, Ao.ACTION_MESSAGE = 3, Ao.ACTION_MESSAGE_AND_SOFT_KICK = 4;
let lE = Ao;
class aJ {
  constructor(t, e, s, r = -1) {
    this._data = [t, e, s], r != yr.NO_ISSUE_ID && this._data.push(r);
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class oJ {
  constructor(t, e, s, r = -1) {
    this._data = [], this._data.push(t), this._data.push(e), this._data.push(""), this._data.push(""), this._data.push(s), r != yr.NO_ISSUE_ID && this._data.push(r);
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class hJ {
  constructor(t, e, s, r = -1) {
    this._data = [t, e, s], r != yr.NO_ISSUE_ID && this._data.push(r);
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class uJ {
  constructor(t, e, s, r) {
    this._data = [t, e, s, r];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class lJ {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class cJ {
  constructor(t, e, s, r, n = -1) {
    this._data = [t, e, s, r], n != yr.NO_ISSUE_ID && this._data.push(n);
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class _J {
  constructor(t, e, s, r) {
    this._data = [t.length, ...t, e, s, r];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class dJ {
  constructor(t) {
    this._data = [t.length, ...t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class fJ {
  constructor(t) {
    this._data = [t];
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class gJ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class pJ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class mJ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class EJ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class TJ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class IJ {
  constructor(t, e, s, r, n, a) {
    this._data = [t, e, s, r, n, a];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class SJ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class AJ {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class RJ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class OJ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class yJ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class vJ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class CJ {
  constructor(t, e, s) {
    this._data = [t, e ? 1 : 0, s ? 1 : 0];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class xJ {
  constructor(t = 0) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class MJ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class bJ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class PJ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class NJ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class UJ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class DJ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class LJ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class FJ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class wJ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class GJ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class BJ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class kJ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class zJ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class VJ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class HJ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class YJ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class WJ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class jJ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class XJ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class KJ {
  constructor(t, e, s, r, n, a) {
    this._data = [t, e, s, r, n, a];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class qJ {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class $J {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class ZJ {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class QJ {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class JJ {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class ttt {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class ett {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class stt {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class itt {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class rtt {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class ntt {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class att {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class ott {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class htt {
  constructor(t, e, s, r) {
    this._data = [t, e, s, r];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class utt {
  constructor(...t) {
    this._data = [t.length * 3], t.forEach((e) => {
      this._data.push(e.dayIndex), this._data.push(e.stepIndex), this._data.push(e.giftIndex);
    });
  }
  dispose() {
    this._data = null;
  }
  getMessageArray() {
    return this._data;
  }
}
class hnt {
  constructor(t, e, s) {
    this._dayIndex = t, this._stepIndex = e, this._giftIndex = s;
  }
  get dayIndex() {
    return this._dayIndex;
  }
  get stepIndex() {
    return this._stepIndex;
  }
  get giftIndex() {
    return this._giftIndex;
  }
}
class XC {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class KC {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class cE {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class qC {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class ltt {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class $C {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class ZC {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class QC {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class JC {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class tx {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class ex {
  constructor(t, e, s) {
    this._data = [t, e, s.length, ...s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class sx {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class ix {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class rx {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class ctt {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class _tt {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class dtt {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class ftt {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class gtt {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class ptt {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class mtt {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Ett {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Ttt {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Itt {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Stt {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Att {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Rtt {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Ott {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class ytt {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class vtt {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Ctt {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class xtt {
  constructor(...t) {
    this._data = [t.length], t.forEach((e) => {
      this._data.push(e.itemId);
    });
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class unt {
  constructor(t) {
    this.itemId = t;
  }
}
class nx {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class ax {
  constructor(t, e = null) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Mtt {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class ox {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class hx {
  constructor(t, e = 0, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class btt {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class ux {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class lx {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class cx {
  constructor(t, e, s = 0) {
    this._data = [t, s, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class _x {
  constructor(...t) {
    this._data = [t.length, ...t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Ptt {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Ntt {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Utt {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Dtt {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Ltt {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Ftt {
  constructor(t, e, s, r, n, a, o, h, u, c, l, _, d, f, p, g, m, O, y, C, b, D, P, F) {
    this._data = [], this._data.push(
      t,
      e,
      s,
      r,
      n,
      a,
      o
    ), this._data.push(u.length, ...u), this._data.push(
      c,
      l,
      _,
      d,
      f,
      p,
      g,
      m,
      O,
      y,
      C,
      b,
      D,
      P,
      F
    );
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class dx {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class fx {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class wtt {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class _E {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class gx {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class px extends gx {
  constructor(t) {
    super(t);
  }
}
class mx {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Ex extends gx {
  constructor(t) {
    super(t);
  }
}
class dE {
  constructor(t, e, s, r) {
    this._data = [t, e, s, r];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Tx {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Ix {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Sx {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Ax {
  constructor(t, e, s = "") {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Rx {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Ox {
  constructor(t, e) {
    this._data = [t, e.size * 2];
    for (const [s, r] of e.entries()) this._data.push(s, r);
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Gtt {
  constructor(t, e, s, r) {
    this._data = [t, e, s, r];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class yx {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class vx {
  constructor(t, e, s, r, n) {
    this._data = [t, e, s, r, n];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Cx {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Btt {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class ktt {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class fE {
  constructor(t, e, s, r) {
    this._data = [t, e, s, r];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class xx {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Mx {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class bx {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Px {
  constructor(t, e, s, r, n, a) {
    this._itemId = t, this._category = e, this._wallLocation = s, this._x = r, this._y = n, this._direction = a;
  }
  getMessageArray() {
    switch (this._category) {
      case L.FLOOR:
        return [`${this._itemId} ${this._x} ${this._y} ${this._direction}`];
      case L.WALL:
        return [`${this._itemId} ${this._wallLocation} `];
      default:
        return [];
    }
  }
  dispose() {
  }
}
class ztt {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Nx {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Vtt {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Ux {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Dx {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Lx {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Htt {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class _I {
  constructor(t, e = 0) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Fx {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class wx {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Ytt {
  constructor(t, e = -100) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Gx {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Wtt {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class jtt {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Xtt {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Bx {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Ktt {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class kx {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class qtt {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class $tt {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Ztt {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Qtt {
  constructor(t, e, s, r) {
    this._data = [t, e, s, r];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class zx {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Jtt {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class tet {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class eet {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class set {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class gE {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class iet {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class ret {
  constructor(t, e, s, r, n, a, o) {
    this._data = [t, e, s, r, n, a, o];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class net {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Vx {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Hx {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class dI {
  constructor(t, e = 0) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Yx {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class aet {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Wx {
  constructor(t, e, s) {
    this._data = [t + " " + e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class jx {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Xx {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Kx {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class qx {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class oet {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class het {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class uet {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class $x {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Zx {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Qx {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Jx {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
const su = class su {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
};
su.STATE_START = 0, su.STATE_CANCEL = 1, su.STATE_ACCEPT = 2;
let pE = su;
class cet {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class _et {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class det {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class fet {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class get {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class pet {
  constructor(t, e, s, r, n, a) {
    this._data = [t, e.length, ...e, s, r.length, ...r, n, a];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class met {
  constructor(t, e, s, r, n) {
    this._data = [t, e.length, ...e, s, r.length, ...r, n];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Eet {
  constructor(t, e, s, r, n) {
    this._data = [t, e.length, ...e, s, r.length, ...r, n];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class lnt {
  get tradeMode() {
    return this._tradeMode;
  }
  set tradeMode(t) {
    this._tradeMode = t;
  }
  get allowPets() {
    return this._allowPets;
  }
  set allowPets(t) {
    this._allowPets = t;
  }
  get allowFoodConsume() {
    return this._allowFoodConsume;
  }
  set allowFoodConsume(t) {
    this._allowFoodConsume = t;
  }
  get allowWalkThrough() {
    return this._allowWalkThrough;
  }
  set allowWalkThrough(t) {
    this._allowWalkThrough = t;
  }
  get hideWalls() {
    return this._hideWalls;
  }
  set hideWalls(t) {
    this._hideWalls = t;
  }
  get wallThickness() {
    return this._wallThickness;
  }
  set wallThickness(t) {
    this._wallThickness = t;
  }
  get floorThickness() {
    return this._floorThickness;
  }
  set floorThickness(t) {
    this._floorThickness = t;
  }
  get roomId() {
    return this._roomId;
  }
  set roomId(t) {
    this._roomId = t;
  }
  get name() {
    return this._name;
  }
  set name(t) {
    this._name = t;
  }
  get description() {
    return this._description;
  }
  set description(t) {
    this._description = t;
  }
  get doorMode() {
    return this._doorMode;
  }
  set doorMode(t) {
    this._doorMode = t;
  }
  get password() {
    return this._password;
  }
  set password(t) {
    this._password = t;
  }
  get categoryId() {
    return this._categoryId;
  }
  set categoryId(t) {
    this._categoryId = t;
  }
  get maximumVisitors() {
    return this._maximumVisitors;
  }
  set maximumVisitors(t) {
    this._maximumVisitors = t;
  }
  get tags() {
    return this._tags;
  }
  set tags(t) {
    this._tags = t;
  }
  get whoCanMute() {
    return this._whoCanMute;
  }
  set whoCanMute(t) {
    this._whoCanMute = t;
  }
  get whoCanKick() {
    return this._whoCanKick;
  }
  set whoCanKick(t) {
    this._whoCanKick = t;
  }
  get whoCanBan() {
    return this._whoCanBan;
  }
  set whoCanBan(t) {
    this._whoCanBan = t;
  }
  get chatMode() {
    return this._chatMode;
  }
  set chatMode(t) {
    this._chatMode = t;
  }
  get chatBubbleSize() {
    return this._chatBubbleSize;
  }
  set chatBubbleSize(t) {
    this._chatBubbleSize = t;
  }
  get chatScrollUpFrequency() {
    return this._chatScrollUpFrequency;
  }
  set chatScrollUpFrequency(t) {
    this._chatScrollUpFrequency = t;
  }
  get chatFullHearRange() {
    return this._chatFullHearRange;
  }
  set chatFullHearRange(t) {
    this._chatFullHearRange = t;
  }
  get chatFloodSensitivity() {
    return this._chatFloodSensitivity;
  }
  set chatFloodSensitivity(t) {
    this._chatFloodSensitivity = t;
  }
  get allowNavigatorDynCats() {
    return this._allowNavigatorDynCats;
  }
  set allowNavigatorDynCats(t) {
    this._allowNavigatorDynCats = t;
  }
}
class Tet {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Iet {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class tM {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class eM {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Aet {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class sM {
  constructor(...t) {
    this._data = [t.length].concat(t);
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Ret {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Oet {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class iM {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class yet {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class vet {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Cet {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class xet {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Met {
  constructor(t, e, s, r, n, a, o, h, u, c, l) {
    this._data = [t, e, s, r, n, a, o, h, u, c, l];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class bet {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Pet {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Net {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Uet {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class rM {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class nM {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class aM {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class oM {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class hM {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class uM {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Det {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class lM {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Let {
  constructor(t, e = !0) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Fet {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class wet {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class cM {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Get {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Bet {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class ket {
  constructor() {
    this._data = [];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class zet {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Vet {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Het {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Yet {
  constructor(t, e, s) {
    this._data = [t, e, s];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Wet {
  constructor(t, e) {
    this._data = [t, e];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class _M {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class jet {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class dM {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class fM {
  constructor(t) {
    this._data = [t];
  }
  getMessageArray() {
    return this._data;
  }
  dispose() {
  }
}
class Xet {
  constructor() {
    this._events = /* @__PURE__ */ new Map(), this._composers = /* @__PURE__ */ new Map(), this.registerEvents(), this.registerComposers();
  }
  registerEvents() {
    this._events.set(R.INTERSTITIAL_MESSAGE, Xj), this._events.set(R.ROOM_AD_ERROR, Kj), this._events.set(R.AVAILABILITY_STATUS, zv), this._events.set(R.AVAILABILITY_TIME, qj), this._events.set(R.HOTEL_CLOSED_AND_OPENS, $j), this._events.set(R.HOTEL_CLOSES_AND_OPENS_AT, Zj), this._events.set(R.HOTEL_WILL_CLOSE_MINUTES, Qj), this._events.set(R.HOTEL_MAINTENANCE, Jj), this._events.set(R.USER_CHANGE_NAME, Lu), this._events.set(R.CHECK_USER_NAME, t6), this._events.set(R.USER_FIGURE, Vv), this._events.set(R.USER_OUTFITS, e6), this._events.set(R.ADD_BOT_TO_INVENTORY, s6), this._events.set(R.USER_BOTS, i6), this._events.set(R.BOT_RECEIVED, r6), this._events.set(R.REMOVE_BOT_FROM_INVENTORY, n6), this._events.set(R.CFH_SANCTION, a6), this._events.set(R.CFH_TOPICS, o6), this._events.set(R.CFH_SANCTION_STATUS, h6), this._events.set(R.CAMERA_PUBLISH_STATUS, u6), this._events.set(R.CAMERA_PURCHASE_OK, l6), this._events.set(R.CAMERA_STORAGE_URL, _6), this._events.set(R.COMPETITION_STATUS, d6), this._events.set(R.INIT_CAMERA, f6), this._events.set(R.THUMBNAIL_STATUS, g6), this._events.set(R.CAMERA_SNAPSHOT, c6), this._events.set(R.CAMPAIGN_CALENDAR_DATA, p6), this._events.set(R.CAMPAIGN_CALENDAR_DOOR_OPENED, m6), this._events.set(R.BONUS_RARE_INFO, E6), this._events.set(R.BUILDERS_CLUB_FURNI_COUNT, T6), this._events.set(R.BUILDERS_CLUB_SUBSCRIPTION, I6), this._events.set(R.BUNDLE_DISCOUNT_RULESET, S6), this._events.set(R.CATALOG_PAGE_EXPIRATION, A6), this._events.set(R.CATALOG_PAGE, R6), this._events.set(R.CATALOG_PAGE_LIST, O6), this._events.set(R.CATALOG_EARLIEST_EXPIRY, y6), this._events.set(R.CATALOG_PUBLISHED, v6), this._events.set(R.CLUB_GIFT_INFO, C6), this._events.set(R.CLUB_GIFT_SELECTED, x6), this._events.set(R.DIRECT_SMS_CLUB_BUY, M6), this._events.set(R.GIFT_RECEIVER_NOT_FOUND, P6), this._events.set(R.GIFT_WRAPPER_CONFIG, N6), this._events.set(R.CLUB_EXTENDED_OFFER, U6), this._events.set(R.CLUB_OFFERS, D6), this._events.set(R.IS_OFFER_GIFTABLE, L6), this._events.set(R.LIMITED_SOLD_OUT, F6), this._events.set(R.LIMITED_OFFER_APPEARING_NEXT, w6), this._events.set(R.NOT_ENOUGH_BALANCE, G6), this._events.set(R.PRODUCT_OFFER, B6), this._events.set(R.CATALOG_PURCHASE_ERROR, k6), this._events.set(R.CATALOG_PURCHASE_NOT_ALLOWED, z6), this._events.set(R.CATALOG_PURCHASE_OK, V6), this._events.set(R.ROOM_AD_PURCHASE, H6), this._events.set(R.SEASONAL_CALENDAR_OFFER, Y6), this._events.set(R.CATALOG_RECEIVE_PET_BREEDS, W6), this._events.set(R.TARGET_OFFER, j6), this._events.set(R.TARGET_OFFER_NOT_FOUND, X6), this._events.set(R.REDEEM_VOUCHER_ERROR, K6), this._events.set(R.REDEEM_VOUCHER_OK, q6), this._events.set(R.CLIENT_PING, Hv), this._events.set(R.COMPETITION_ENTRY_SUBMIT, $6), this._events.set(R.COMPETITION_VOTING_INFO, Z6), this._events.set(R.COMPETITION_TIMING_CODE, Q6), this._events.set(R.COMPETITION_USER_PART_OF, J6), this._events.set(R.COMPETITION_NO_OWNED_ROOMS, t8), this._events.set(R.COMPETITION_SECONDS_UNTIL, e8), this._events.set(R.CRAFTABLE_PRODUCTS, s8), this._events.set(R.CRAFTING_RECIPE, i8), this._events.set(R.CRAFTING_RECIPES_AVAILABLE, r8), this._events.set(R.CRAFTING_RESULT, n8), this._events.set(R.DESKTOP_VIEW, mm), this._events.set(R.MESSENGER_ACCEPT_FRIENDS, a8), this._events.set(R.MESSENGER_FIND_FRIENDS, o8), this._events.set(R.MESSENGER_FOLLOW_FAILED, h8), this._events.set(R.MESSENGER_FRIENDS, u8), this._events.set(R.MESSENGER_UPDATE, l8), this._events.set(R.MESSENGER_FRIEND_NOTIFICATION, c8), this._events.set(R.MESSENGER_REQUESTS, _8), this._events.set(R.MESSENGER_SEARCH, d8), this._events.set(R.MESSENGER_INSTANCE_MESSAGE_ERROR, f8), this._events.set(R.MESSENGER_MESSAGE_ERROR, g8), this._events.set(R.MESSENGER_INIT, p8), this._events.set(R.MESSENGER_MINIMAIL_NEW, m8), this._events.set(R.MESSENGER_MINIMAIL_COUNT, E8), this._events.set(R.MESSENGER_CHAT, T8), this._events.set(R.MESSENGER_REQUEST, Yv), this._events.set(R.MESSENGER_INVITE_ERROR, I8), this._events.set(R.MESSENGER_INVITE, S8), this._events.set(R.ACHIEVEMENTRESOLUTIONCOMPLETED, M8), this._events.set(R.ACHIEVEMENTRESOLUTIONPROGRESS, b8), this._events.set(R.ACHIEVEMENTRESOLUTIONS, P8), this._events.set(R.LOAD_GAME_URL, k8), this._events.set(R.LOADGAME, B8), this._events.set(R.UNLOADGAME, z8), this._events.set(R.GAME_CENTER_GAME_LIST, D8), this._events.set(R.GAMESTATUSMESSAGE, L8), this._events.set(R.GAME_CENTER_ACHIEVEMENTS, V8), this._events.set(R.GAME_CENTER_STATUS, A8), this._events.set(R.GAME_CENTER_IN_ARENA_QUEUE, O8), this._events.set(R.GAME_CENTER_STOP_COUNTER, C8), this._events.set(R.GAME_CENTER_USER_LEFT_GAME, x8), this._events.set(R.GAME_CENTER_DIRECTORY_STATUS, R8), this._events.set(R.GAME_CENTER_STARTING_GAME_FAILED, v8), this._events.set(R.GAME_CENTER_JOINING_FAILED, y8), this._events.set(R.GAMEACHIEVEMENTS, N8), this._events.set(R.GAMEINVITE, U8), this._events.set(R.JOINEDQUEUEMESSAGE, F8), this._events.set(R.JOININGQUEUEFAILED, w8), this._events.set(R.LEFTQUEUE, G8), this._events.set(R.WEEKLY_GAME_REWARD, X8), this._events.set(R.WEEKLY_GAME_REWARD_WINNERS, K8), this._events.set(R.WEEKLY_COMPETITIVE_LEADERBOARD, j8), this._events.set(R.WEEKLY_COMPETITIVE_FRIENDS_LEADERBOARD, W8), this._events.set(R.WEEKLY_GAME2_FRIENDS_LEADERBOARD, H8), this._events.set(R.WEEKLY_GAME2_LEADERBOARD, Y8), this._events.set(R.GROUP_INFO, tX), this._events.set(R.GROUP_MEMBER_REMOVE_CONFIRM, J8), this._events.set(R.GROUP_MEMBERS, eX), this._events.set(R.GROUP_CREATE_OPTIONS, Q8), this._events.set(R.GROUP_BADGE_PARTS, Wv), this._events.set(R.GROUP_SETTINGS, iX), this._events.set(R.GROUP_PURCHASED, sX), this._events.set(R.GROUP_BADGES, FC), this._events.set(R.GROUP_DEACTIVATE, rX), this._events.set(R.GROUP_MEMBERSHIP_REQUESTED, Z9), this._events.set(R.GROUP_DETAILS_CHANGED, $9), this._events.set(R.GROUP_HABBO_JOIN_FAILED, eq), this._events.set(R.GROUP_FORUM_DATA, nX), this._events.set(R.GROUP_FORUM_LIST, aX), this._events.set(R.GROUP_FORUM_THREADS, oX), this._events.set(R.GROUP_FORUM_POST, hX), this._events.set(R.GROUP_FORUM_POST_THREAD, uX), this._events.set(R.GROUP_FORUM_THREAD_MESSAGES, lX), this._events.set(R.GROUP_FORUM_UNREAD_COUNT, cX), this._events.set(R.GROUP_FORUM_UPDATE_MESSAGE, _X), this._events.set(R.GROUP_FORUM_UPDATE_THREAD, dX), this._events.set(R.CFH_DISABLED_NOTIFY, EX), this._events.set(R.CFH_PENDING_CALLS_DELETED, TX), this._events.set(R.CFH_PENDING_CALLS, IX), this._events.set(R.CFH_REPLY, SX), this._events.set(R.CFH_RESULT_MESSAGE, AX), this._events.set(R.GUIDE_ON_DUTY_STATUS, xX), this._events.set(R.GUIDE_SESSION_ATTACHED, bX), this._events.set(R.GUIDE_SESSION_DETACHED, PX), this._events.set(R.GUIDE_SESSION_ENDED, Xv), this._events.set(R.GUIDE_SESSION_ERROR, Kv), this._events.set(R.GUIDE_SESSION_INVITED_TO_GUIDE_ROOM, NX), this._events.set(R.GUIDE_SESSION_MESSAGE, UX), this._events.set(R.GUIDE_SESSION_PARTNER_IS_TYPING, DX), this._events.set(R.GUIDE_SESSION_REQUESTER_ROOM, LX), this._events.set(R.GUIDE_SESSION_STARTED, qv), this._events.set(R.GUIDE_TICKET_CREATION_RESULT, FX), this._events.set(R.GUIDE_TICKET_RESOLUTION, wX), this._events.set(R.GUIDE_REPORTING_STATUS, MX), this._events.set(R.HOTEL_MERGE_NAME_CHANGE, GX), this._events.set(R.ISSUE_CLOSE_NOTIFICATION, BX), this._events.set(R.QUIZ_DATA, kX), this._events.set(R.QUIZ_RESULTS, zX), this._events.set(R.CHAT_REVIEW_SESSION_DETACHED, RX), this._events.set(R.CHAT_REVIEW_SESSION_OFFERED_TO_GUIDE, OX), this._events.set(R.CHAT_REVIEW_SESSION_RESULTS, yX), this._events.set(R.CHAT_REVIEW_SESSION_STARTED, vX), this._events.set(R.CHAT_REVIEW_SESSION_VOTING_STATUS, CX), this._events.set(R.ACHIEVEMENT_PROGRESSED, VX), this._events.set(R.ACHIEVEMENT_LIST, HX), this._events.set(R.USER_ACHIEVEMENT_SCORE, YX), this._events.set(R.USER_EFFECT_ACTIVATE, WX), this._events.set(R.USER_EFFECT_LIST_ADD, jX), this._events.set(R.USER_EFFECT_LIST_REMOVE, XX), this._events.set(R.USER_EFFECT_LIST, qX), this._events.set(R.AVATAR_EFFECT_SELECTED, KX), this._events.set(R.USER_BADGES, ZX), this._events.set(R.USER_BADGES_ADD, $X), this._events.set(R.BADGE_POINT_LIMITS, $v), this._events.set(R.BADGE_REQUEST_FULFILLED, QX), this._events.set(R.USER_CLOTHING, JX), this._events.set(R.USER_FURNITURE_ADD, tK), this._events.set(R.USER_FURNITURE, eK), this._events.set(R.USER_FURNITURE_REFRESH, sK), this._events.set(R.USER_FURNITURE_REMOVE, iK), this._events.set(R.USER_FURNITURE_POSTIT_PLACED, rK), this._events.set(R.USER_PETS, uK), this._events.set(R.USER_PET_REMOVE, cK), this._events.set(R.USER_PET_ADD, hK), this._events.set(R.PET_RECEIVED, lK), this._events.set(R.PET_PLACING_ERROR, eC), this._events.set(R.YOUTUBE_CONTROL_VIDEO, p9), this._events.set(R.YOUTUBE_DISPLAY_PLAYLISTS, m9), this._events.set(R.YOUTUBE_DISPLAY_VIDEO, E9), this._events.set(R.TRADE_ACCEPTED, _K), this._events.set(R.TRADE_CLOSED, dK), this._events.set(R.TRADE_COMPLETED, fK), this._events.set(R.TRADE_CONFIRMATION, gK), this._events.set(R.TRADE_LIST_ITEM, pK), this._events.set(R.TRADE_NOT_OPEN, EK), this._events.set(R.TRADE_OPEN_FAILED, IK), this._events.set(R.TRADE_OPEN, TK), this._events.set(R.TRADE_OTHER_NOT_ALLOWED, SK), this._events.set(R.TRADE_YOU_NOT_ALLOWED, AK), this._events.set(R.TRADE_NO_SUCH_ITEM, mK), this._events.set(R.COMMUNITY_GOAL_VOTE_EVENT, OK), this._events.set(R.PROMO_ARTICLES, RK), this._events.set(R.MARKETPLACE_AFTER_ORDER_STATUS, yK), this._events.set(R.MARKETPLACE_CANCEL_SALE, vK), this._events.set(R.MARKETPLACE_SELL_ITEM, CK), this._events.set(R.MARKETPLACE_CONFIG, xK), this._events.set(R.MARKETPLACE_ITEM_STATS, MK), this._events.set(R.MARKETPLACE_ITEM_POSTED, bK), this._events.set(R.MARKETPLACE_ITEMS_SEARCHED, PK), this._events.set(R.MARKETPLACE_OWN_ITEMS, NK), this._events.set(R.USER_BANNED, jK), this._events.set(R.MODERATION_CAUTION, GK), this._events.set(R.MODTOOL_ROOM_INFO, zK), this._events.set(R.MODTOOL_USER_CHATLOG, XK), this._events.set(R.MODTOOL_ROOM_CHATLOG, YK), this._events.set(R.MODERATION_USER_INFO, HK), this._events.set(R.MODERATION_TOOL, BK), this._events.set(R.MODTOOL_VISITED_ROOMS_USER, WK), this._events.set(R.CFH_CHATLOG, UK), this._events.set(R.ISSUE_DELETED, DK), this._events.set(R.ISSUE_INFO, LK), this._events.set(R.ISSUE_PICK_FAILED, FK), this._events.set(R.MODERATOR_ACTION_RESULT, wK), this._events.set(R.MODERATOR_MESSAGE, kK), this._events.set(R.MODERATOR_TOOL_PREFERENCES, VK), this._events.set(R.MYSTERY_BOX_KEYS, Qv), this._events.set(R.GOTMYSTERYBOXPRIZEMESSAGE, qK), this._events.set(R.CANCELMYSTERYBOXWAITMESSAGE, KK), this._events.set(R.SHOWMYSTERYBOXWAITMESSAGE, $K), this._events.set(R.CAN_CREATE_ROOM, ZK), this._events.set(R.CAN_CREATE_ROOM_EVENT, QK), this._events.set(R.CATEGORIES_WITH_VISITOR_COUNT, JK), this._events.set(R.COMPETITION_ROOMS_DATA, t7), this._events.set(R.CONVERTED_ROOM_ID, e7), this._events.set(R.ROOM_DOORBELL, Jv), this._events.set(R.USER_FAVORITE_ROOM, s7), this._events.set(R.USER_FAVORITE_ROOM_COUNT, i7), this._events.set(R.ROOM_DOORBELL_REJECTED, Tm), this._events.set(R.ROOM_CREATED, r7), this._events.set(R.ROOM_INFO, Im), this._events.set(R.GUEST_ROOM_SEARCH_RESULT, n7), this._events.set(R.USER_HOME_ROOM, o7), this._events.set(R.ROOM_EVENT_CANCEL, f7), this._events.set(R.ROOM_EVENT, g7), this._events.set(R.ROOM_INFO_UPDATED, m7), this._events.set(R.THUMBNAIL_UPDATE_RESULT, E7), this._events.set(R.NAVIGATOR_EVENT_CATEGORIES, T7), this._events.set(R.NAVIGATOR_CATEGORIES, I7), this._events.set(R.NAVIGATOR_COLLAPSED, a7), this._events.set(R.NAVIGATOR_LIFTED, h7), this._events.set(R.NAVIGATOR_METADATA, u7), this._events.set(R.NAVIGATOR_OPEN_ROOM_CREATOR, l7), this._events.set(R.NAVIGATOR_SEARCHES, c7), this._events.set(R.NAVIGATOR_SEARCH, _7), this._events.set(R.NAVIGATOR_SETTINGS, d7), this._events.set(R.GENERIC_ALERT, v7), this._events.set(R.MOTD_MESSAGES, x7), this._events.set(R.NOTIFICATION_LIST, M7), this._events.set(R.UNSEEN_ITEMS, D7), this._events.set(R.ACHIEVEMENT_NOTIFICATION, S7), this._events.set(R.INFO_FEED_ENABLE, C7), this._events.set(R.CLUB_GIFT_NOTIFICATION, R7), this._events.set(R.ACTIVITY_POINT_NOTIFICATION, A7), this._events.set(R.BOT_ERROR, tC), this._events.set(R.PET_LEVEL_NOTIFICATION, P7), this._events.set(R.NOTIFICATION_OFFER_REWARD_DELIVERED, b7), this._events.set(R.NOTIFICATION_SIMPLE_ALERT, U7), this._events.set(R.NOTIFICATION_ELEMENT_POINTER, y7), this._events.set(R.USER_PERKS, L7), this._events.set(R.PET_TRAINING_PANEL, w7), this._events.set(R.PET_LEVEL_UPDATE, rC), this._events.set(R.PET_SCRATCH_FAILED, nC), this._events.set(R.PET_OPEN_PACKAGE_REQUESTED, sC), this._events.set(R.PET_OPEN_PACKAGE_RESULT, iC), this._events.set(R.PET_BREEDING_RESULT, pC), this._events.set(R.QUESTION, lC), this._events.set(R.POLL_CONTENTS, aC), this._events.set(R.POLL_ERROR, oC), this._events.set(R.POLL_OFFER, hC), this._events.set(R.POLL_START_ROOM, dC), this._events.set(R.QUESTION_ANSWERED, uC), this._events.set(R.QUESTION_FINISHED, cC), this._events.set(R.POLL_ROOM_RESULT, _C), this._events.set(R.COMMUNITY_GOAL_EARNED_PRIZES, G7), this._events.set(R.COMMUNITY_GOAL_PROGRESS, k7), this._events.set(R.CONCURRENT_USERS_GOAL_PROGRESS, z7), this._events.set(R.QUEST_DAILY, W7), this._events.set(R.QUEST_CANCELLED, H7), this._events.set(R.QUEST_COMPLETED, Y7), this._events.set(R.COMMUNITY_GOAL_HALL_OF_FAME, B7), this._events.set(R.EPIC_POPUP, V7), this._events.set(R.SEASONAL_QUESTS, K7), this._events.set(R.QUESTS, X7), this._events.set(R.QUEST, j7), this._events.set(R.ROOM_ENTER_ERROR, q7), this._events.set(R.ROOM_ENTER, Cm), this._events.set(R.ROOM_FORWARD, $7), this._events.set(R.ROOM_DOORBELL_ACCEPTED, Rm), this._events.set(R.ROOM_RIGHTS_CLEAR, Om), this._events.set(R.ROOM_RIGHTS_OWNER, vm), this._events.set(R.ROOM_RIGHTS, ym), this._events.set(R.BOT_COMMAND_CONFIGURATION, Z7), this._events.set(R.BOT_SKILL_LIST_UPDATE, J7), this._events.set(R.BOT_FORCE_OPEN_CONTEXT_MENU, Q7), this._events.set(R.ROOM_SETTINGS_CHAT, t9), this._events.set(R.ROOM_INFO_OWNER, e9), this._events.set(R.ROOM_SCORE, s9), this._events.set(R.ROOM_ROLLING, Mm), this._events.set(R.FURNITURE_FLOOR_ADD, Fm), this._events.set(R.FURNITURE_FLOOR, wm), this._events.set(R.FURNITURE_FLOOR_REMOVE, Gm), this._events.set(R.FURNITURE_FLOOR_UPDATE, Bm), this._events.set(R.ITEM_WALL_ADD, km), this._events.set(R.ITEM_WALL, zm), this._events.set(R.ITEM_WALL_REMOVE, Vm), this._events.set(R.ITEM_WALL_UPDATE, Hm), this._events.set(R.FURNITURE_ALIASES, Nm), this._events.set(R.FURNITURE_DATA, Um), this._events.set(R.FURNITURE_ITEMDATA, Dm), this._events.set(R.ITEM_STACK_HELPER, n9), this._events.set(R.FURNITURE_STATE, Lm), this._events.set(R.ITEM_DIMMER_SETTINGS, gC), this._events.set(R.FURNITURE_STATE_2, Pm), this._events.set(R.LOVELOCK_FURNI_FINISHED, o9), this._events.set(R.LOVELOCK_FURNI_FRIEND_COMFIRMED, h9), this._events.set(R.LOVELOCK_FURNI_START, u9), this._events.set(R.OBJECTS_DATA_UPDATE, xm), this._events.set(R.FURNITURE_GROUP_CONTEXT_MENU_INFO, a9), this._events.set(R.FURNITURE_POSTIT_STICKY_POLE_OPEN, d9), this._events.set(R.ROOM_SPECTATOR, SC), this._events.set(R.CUSTOM_USER_NOTIFICATION, i9), this._events.set(R.ROOM_MESSAGE_NOTIFICATION, f9), this._events.set(R.ROOM_POPULAR_TAGS_RESULT, AR), this._events.set(R.ROOM_POPULAR_TAGS_RESULT, AR), this._events.set(R.ROOM_RIGHTS_LIST, M9), this._events.set(R.ROOM_RIGHTS_LIST_ADD, C9), this._events.set(R.ROOM_RIGHTS_LIST_REMOVE, x9), this._events.set(R.ROOM_BAN_LIST, v9), this._events.set(R.ROOM_SETTINGS_SAVE_ERROR, L9), this._events.set(R.ROOM_SETTINGS, N9), this._events.set(R.ROOM_SETTINGS_SAVE, D9), this._events.set(R.ROOM_SETTINGS_ERROR, U9), this._events.set(R.SHOW_ENFORCE_ROOM_CATEGORY, F9), this._events.set(R.ROOM_BAN_REMOVE, w9), this._events.set(R.ROOM_MUTED, b9), this._events.set(R.NO_SUCH_FLAT, P9), this._events.set(R.FAVORITE_GROUP_UDPATE, fC), this._events.set(R.ROOM_MODEL_DOOR, Wm), this._events.set(R.ROOM_HEIGHT_MAP, jm), this._events.set(R.ROOM_HEIGHT_MAP_UPDATE, Xm), this._events.set(R.ROOM_MODEL, Ym), this._events.set(R.ROOM_MODEL_NAME, jo), this._events.set(R.ROOM_PAINT, Km), this._events.set(R.ROOM_THICKNESS, qm), this._events.set(R.ROOM_GET_FILTER_WORDS, p7), this._events.set(R.ROOM_MODEL_BLOCKED_TILES, T9), this._events.set(R.PET_FIGURE_UPDATE, Ac), this._events.set(R.PET_INFO, EC), this._events.set(R.PET_STATUS, TC), this._events.set(R.PET_EXPERIENCE, mC), this._events.set(R.PLAYING_GAME, IC), this._events.set(R.UNIT_DANCE, yc), this._events.set(R.UNIT_EFFECT, Zm), this._events.set(R.UNIT, vc), this._events.set(R.UNIT_EXPRESSION, Qm), this._events.set(R.UNIT_HAND_ITEM, Jm), this._events.set(R.UNIT_IDLE, tE), this._events.set(R.UNIT_INFO, Cc), this._events.set(R.UNIT_NUMBER, eE), this._events.set(R.UNIT_REMOVE, xc), this._events.set(R.UNIT_STATUS, sE), this._events.set(R.HAND_ITEM_RECEIVED, OC), this._events.set(R.FLOOD_CONTROL, AC), this._events.set(R.REMAINING_MUTE, RC), this._events.set(R.UNIT_CHAT, uI), this._events.set(R.UNIT_CHAT_SHOUT, Rc), this._events.set(R.UNIT_CHAT_WHISPER, Oc), this._events.set(R.UNIT_TYPING, $m), this._events.set(R.WIRED_ACTION, I9), this._events.set(R.WIRED_CONDITION, S9), this._events.set(R.WIRED_TRIGGER, A9), this._events.set(R.WIRED_OPEN, R9), this._events.set(R.WIRED_REWARD, iE), this._events.set(R.WIRED_SAVE, O9), this._events.set(R.WIRED_ERROR, y9), this._events.set(R.AUTHENTICATED, yC), this._events.set(R.JUKEBOX_PLAYLIST_FULL, vC), this._events.set(R.JUKEBOX_SONG_DISKS, CC), this._events.set(R.NOW_PLAYING, xC), this._events.set(R.OFFICIAL_SONG_ID, G9), this._events.set(R.PLAYLIST, B9), this._events.set(R.PLAYLIST_SONG_ADDED, k9), this._events.set(R.TRAX_SONG_INFO, MC), this._events.set(R.USER_SONG_DISKS_INVENTORY, bC), this._events.set(R.HELPER_TALENT_TRACK, H9), this._events.set(R.TALENT_TRACK_LEVEL, V9), this._events.set(R.TALENT_TRACK_LEVEL_UP, z9), this._events.set(R.IN_CLIENT_LINK, GC), this._events.set(R.USER_IGNORED, wC), this._events.set(R.USER_IGNORED_RESULT, cI), this._events.set(R.USER_RESPECT, zC), this._events.set(R.USER_PERMISSIONS, PC), this._events.set(R.USER_BADGES_CURRENT, UC), this._events.set(R.USER_INFO, Mc), this._events.set(R.UNIT_CHANGE_NAME, lI), this._events.set(R.USER_SETTINGS, K9), this._events.set(R.USER_PROFILE, X9), this._events.set(R.MESSENGER_RELATIONSHIPS, j9), this._events.set(R.GIFT_OPENED, Zv), this._events.set(R.USER_CREDITS, sq), this._events.set(R.USER_CURRENCY, iq), this._events.set(R.USER_SUBSCRIPTION, rq), this._events.set(R.USER_WARDROBE_PAGE, aq), this._events.set(R.USER_CLASSIFICATION, hq), this._events.set(R.GET_USER_TAGS, DC), this._events.set(R.SCR_SEND_KICKBACK_INFO, nq), this._events.set(R.PET_RESPECTED, BC), this._events.set(R.PET_SUPPLEMENT, kC), this._events.set(R.ACCOUNT_SAFETY_LOCK_STATUS_CHANGE, NC), this._events.set(R.GENERIC_ERROR, Em), this._events.set(R.GROUP_LIST, tq), this._events.set(R.CATALOG_APPROVE_NAME_RESULT, Y9), this._events.set(R.CONNECTION_ERROR, O7), this._events.set(R.GUILD_EDIT_FAILED, Q9), this._events.set(R.GUILD_MEMBER_MGMT_FAILED, J9), this._events.set(R.EXTENDED_PROFILE_CHANGED, q9), this._events.set(R.NOOBNESS_LEVEL, jv), this._events.set(R.DISCONNECT_REASON, gX), this._events.set(R.HANDSHAKE_INIT_DIFFIE, mX), this._events.set(R.HANDSHAKE_COMPLETE_DIFFIE, fX), this._events.set(R.HANDSHAKE_IDENTITY_ACCOUNT, pX), this._events.set(R.NEW_USER_EXPERIENCE_GIFT_OFFER, LW), this._events.set(R.NEW_USER_EXPERIENCE_NOT_COMPLETE, wW), this._events.set(R.RESTORE_CLIENT, N7), this._events.set(R.FIREWORK_CHARGE_DATA, b6), this._events.set(R.PHONE_COLLECTION_STATE, q8), this._events.set(R.PHONE_TRY_NUMBER_RESULT, $8), this._events.set(R.PHONE_TRY_VERIFICATION_CODE_RESULT, Z8), this._events.set(R.WELCOME_GIFT_CHANGE_EMAIL_RESULT, oq), this._events.set(R.WELCOME_GIFT_STATUS, g9), this._events.set(R.RENTABLE_SPACE_RENT_OK, c9), this._events.set(R.RENTABLE_SPACE_STATUS, _9), this._events.set(R.RENTABLE_SPACE_RENT_FAILED, l9), this._events.set(R.RECYCLER_STATUS, Am), this._events.set(R.RECYCLER_FINISHED, Sm), this._events.set(R.EMAIL_STATUS, LC), this._events.set(R.CHANGE_EMAIL_RESULT, W9), this._events.set(R.RENTABLE_FURNI_RENT_OR_BUYOUT_OFFER, r9), this._events.set(R.AREA_HIDE, bm);
  }
  registerComposers() {
    this._composers.set(S.CLICK_FURNI, _E), this._composers.set(S.AUTHENTICATION, DZ), this._composers.set(S.INTERSTITIAL_SHOWN, lq), this._composers.set(S.GET_INTERSTITIAL, uq), this._composers.set(S.GET_WARDROBE, fq), this._composers.set(S.SAVE_WARDROBE_OUTFIT, gq), this._composers.set(S.CHANGE_USERNAME, _q), this._composers.set(S.CHECK_USERNAME, dq), this._composers.set(S.REQUEST_CAMERA_CONFIGURATION, Tq), this._composers.set(S.RENDER_ROOM, bc), this._composers.set(S.RENDER_ROOM_THUMBNAIL, nE), this._composers.set(S.PURCHASE_PHOTO, Eq), this._composers.set(S.PUBLISH_PHOTO, mq), this._composers.set(S.PHOTO_COMPETITION, pq), this._composers.set(S.OPEN_CAMPAIGN_CALENDAR_DOOR, Sq), this._composers.set(S.OPEN_CAMPAIGN_CALENDAR_DOOR_STAFF, Iq), this._composers.set(S.BUILDERS_CLUB_PLACE_ROOM_ITEM, Aq), this._composers.set(S.BUILDERS_CLUB_PLACE_WALL_ITEM, Rq), this._composers.set(S.BUILDERS_CLUB_QUERY_FURNI_COUNT, Oq), this._composers.set(S.GET_CATALOG_INDEX, Cq), this._composers.set(S.GET_CATALOG_PAGE, xq), this._composers.set(S.CATALOG_PURCHASE, Kq), this._composers.set(S.CATALOG_PURCHASE_GIFT, Xq), this._composers.set(S.GET_PRODUCT_OFFER, kq), this._composers.set(S.GET_CLUB_OFFERS, Nq), this._composers.set(S.GET_CLUB_GIFT_INFO, Pq), this._composers.set(S.CATALOG_REDEEM_VOUCHER, Qq), this._composers.set(S.GROUP_MEMBERSHIPS, Pet), this._composers.set(S.GET_GIFT_WRAPPING_CONFIG, Dq), this._composers.set(S.CATALOG_SELECT_VIP_GIFT, t$), this._composers.set(S.CATALOG_REQUESET_PET_BREEDS, Hq), this._composers.set(S.GET_BONUS_RARE_INFO, yq), this._composers.set(S.GET_BUNDLE_DISCOUNT_RULESET, vq), this._composers.set(S.GET_CATALOG_PAGE_EXPIRATION, Mq), this._composers.set(S.GET_CATALOG_PAGE_WITH_EARLIEST_EXP, bq), this._composers.set(S.GET_DIRECT_CLUB_BUY_AVAILABLE, Uq), this._composers.set(S.GET_HABBO_BASIC_MEMBERSHIP_EXTEND_OFFER, Lq), this._composers.set(S.GET_HABBO_CLUB_EXTEND_OFFER, Fq), this._composers.set(S.GET_IS_OFFER_GIFTABLE, wq), this._composers.set(S.GET_LIMITED_OFFER_APPEARING_NEXT, Gq), this._composers.set(S.GET_NEXT_TARGETED_OFFER, Bq), this._composers.set(S.GET_ROOM_AD_PURCHASE_INFO, zq), this._composers.set(S.GET_SEASONAL_CALENDAR_DAILY_OFFER, Vq), this._composers.set(S.GET_TARGETED_OFFER, Yq), this._composers.set(S.MARK_CATALOG_NEW_ADDITIONS_PAGE_OPENED, Wq), this._composers.set(S.PURCHASE_BASIC_MEMBERSHIP_EXTENSION, jq), this._composers.set(S.PURCHASE_ROOM_AD, qq), this._composers.set(S.PURCHASE_TARGETED_OFFER, $q), this._composers.set(S.PURCHASE_VIP_MEMBERSHIP_EXTENSION, Zq), this._composers.set(S.ROOM_AD_PURCHASE_INITIATED, Jq), this._composers.set(S.SET_TARGETTED_OFFER_STATE, e$), this._composers.set(S.SHOP_TARGETED_OFFER_VIEWED, s$), this._composers.set(S.FORWARD_TO_A_COMPETITION_ROOM, i$), this._composers.set(S.FORWARD_TO_A_SUBMITTABLE_ROOM, r$), this._composers.set(S.FORWARD_TO_RANDOM_COMPETITION_ROOM, n$), this._composers.set(S.GET_CURRENT_TIMING_CODE, a$), this._composers.set(S.GET_IS_USER_PART_OF_COMPETITION, o$), this._composers.set(S.GET_SECONDS_UNTIL, h$), this._composers.set(S.ROOM_COMPETITION_INIT, u$), this._composers.set(S.SUBMIT_ROOM_TO_COMPETITION, aE), this._composers.set(S.VOTE_FOR_ROOM, l$), this._composers.set(S.CRAFT, c$), this._composers.set(S.CRAFT_SECRET, _$), this._composers.set(S.GET_CRAFTABLE_PRODUCTS, f$), this._composers.set(S.GET_CRAFTING_RECIPE, d$), this._composers.set(S.GET_CRAFTING_RECIPES_AVAILABLE, g$), this._composers.set(S.FRIEND_FURNI_CONFIRM_LOCK, m$), this._composers.set(S.ACCEPT_FRIEND, E$), this._composers.set(S.DECLINE_FRIEND, T$), this._composers.set(S.FIND_NEW_FRIENDS, I$), this._composers.set(S.FOLLOW_FRIEND, S$), this._composers.set(S.FRIEND_LIST_UPDATE, A$), this._composers.set(S.GET_FRIEND_REQUESTS, R$), this._composers.set(S.HABBO_SEARCH, O$), this._composers.set(S.MESSENGER_INIT, y$), this._composers.set(S.REMOVE_FRIEND, v$), this._composers.set(S.REQUEST_FRIEND, C$), this._composers.set(S.MESSENGER_CHAT, x$), this._composers.set(S.SEND_ROOM_INVITE, M$), this._composers.set(S.SET_RELATIONSHIP_STATUS, b$), this._composers.set(S.VISIT_USER, P$), this._composers.set(S.ACHIEVEMENT_RESOLUTION_OPEN, VC), this._composers.set(S.ACCEPTGAMEINVITE, B$), this._composers.set(S.GAMEUNLOADEDMESSAGE, k$), this._composers.set(S.GETGAMEACHIEVEMENTSMESSAGE, z$), this._composers.set(S.GAMES_LIST, V$), this._composers.set(S.GETGAMESTATUSMESSAGE, H$), this._composers.set(S.GETUSERGAMEACHIEVEMENTSMESSAGE, Y$), this._composers.set(S.JOINQUEUEMESSAGE, W$), this._composers.set(S.LEAVEQUEUEMESSAGE, j$), this._composers.set(S.RESETRESOLUTIONACHIEVEMENTMESSAGE, X$), this._composers.set(S.GAMES_INIT, $$), this._composers.set(S.GETWEEKLYGAMEREWARDWINNERS, Z$), this._composers.set(S.GAME2GETACCOUNTGAMESTATUSMESSAGE, w$), this._composers.set(S.GAME2CHECKGAMEDIRECTORYSTATUSMESSAGE, F$), this._composers.set(S.GAME2EXITGAMEMESSAGE, N$), this._composers.set(S.GAME2GAMECHATMESSAGE, U$), this._composers.set(S.GAME2LOADSTAGEREADYMESSAGE, D$), this._composers.set(S.GAME2PLAYAGAINMESSAGE, L$), this._composers.set(S.GAME2REQUESTFULLSTATUSUPDATEMESSAGE, G$), this._composers.set(S.GAME2GETWEEKLYFRIENDSLEADERBOARD, K$), this._composers.set(S.GAME2GETWEEKLYLEADERBOARD, q$), this._composers.set(S.GET_GIFT, oE), this._composers.set(S.RESET_PHONE_NUMBER_STATE, Q$), this._composers.set(S.SET_PHONE_NUMBER_VERIFICATION_STATUS, hE), this._composers.set(S.TRY_PHONE_NUMBER, J$), this._composers.set(S.VERIFY_CODE, tZ), this._composers.set(S.GET_FORUM_STATS, RZ), this._composers.set(S.GET_FORUMS_LIST, AZ), this._composers.set(S.GET_FORUM_MESSAGES, OZ), this._composers.set(S.GET_FORUM_THREAD, yZ), this._composers.set(S.GET_FORUM_THREADS, vZ), this._composers.set(S.GET_UNREAD_FORUMS_COUNT, CZ), this._composers.set(S.FORUM_MODERATE_MESSAGE, xZ), this._composers.set(S.FORUM_MODERATE_THREAD, MZ), this._composers.set(S.FORUM_POST_MESSAGE, bZ), this._composers.set(S.UPDATE_FORUM_READ_MARKER, PZ), this._composers.set(S.UPDATE_FORUM_SETTINGS, NZ), this._composers.set(S.FORUM_UPDATE_THREAD, UZ), this._composers.set(S.CLIENT_PONG, WC), this._composers.set(S.RELEASE_VERSION, HC), this._composers.set(S.SECURITY_TICKET, jC), this._composers.set(S.USER_INFO, YC), this._composers.set(S.DISCONNECT, FZ), this._composers.set(S.SECURITY_MACHINE, GZ), this._composers.set(S.CLIENT_VARIABLES, BZ), this._composers.set(S.HANDSHAKE_INIT_DIFFIE, wZ), this._composers.set(S.HANDSHAKE_COMPLETE_DIFFIE, LZ), this._composers.set(S.CALL_FOR_HELP_FROM_FORUM_MESSAGE, kZ), this._composers.set(S.CALL_FOR_HELP_FROM_FORUM_THREAD, zZ), this._composers.set(S.CALL_FOR_HELP_FROM_IM, VZ), this._composers.set(S.CALL_FOR_HELP_FROM_PHOTO, HZ), this._composers.set(S.CALL_FOR_HELP_FROM_SELFIE, YZ), this._composers.set(S.CALL_FOR_HELP, WZ), this._composers.set(S.CHAT_REVIEW_GUIDE_DECIDES, jZ), this._composers.set(S.CHAT_REVIEW_GUIDE_DETACHED, XZ), this._composers.set(S.CHAT_REVIEW_GUIDE_VOTE, KZ), this._composers.set(S.CHAT_REVIEW_SESSION_CREATE, qZ), this._composers.set(S.DELETE_PENDING_CALLS_FOR_HELP, $Z), this._composers.set(S.GET_CFH_STATUS, ZZ), this._composers.set(S.GET_FAQ_CATEGORY, QZ), this._composers.set(S.GET_FAQ_TEXT, JZ), this._composers.set(S.GET_GUIDE_REPORTING_STATUS, tQ), this._composers.set(S.GET_PENDING_CALLS_FOR_HELP, eQ), this._composers.set(S.GET_QUIZ_QUESTIONS, sQ), this._composers.set(S.GUIDE_SESSION_CREATE, iQ), this._composers.set(S.GUIDE_SESSION_FEEDBACK, rQ), this._composers.set(S.GUIDE_SESSION_GET_REQUESTER_ROOM, nQ), this._composers.set(S.GUIDE_SESSION_GUIDE_DECIDES, aQ), this._composers.set(S.GUIDE_SESSION_INVITE_REQUESTER, oQ), this._composers.set(S.GUIDE_SESSION_IS_TYPING, hQ), this._composers.set(S.GUIDE_SESSION_MESSAGE, uQ), this._composers.set(S.GUIDE_SESSION_ON_DUTY_UPDATE, lQ), this._composers.set(S.GUIDE_SESSION_REPORT, cQ), this._composers.set(S.GUIDE_SESSION_REQUESTER_CANCELS, _Q), this._composers.set(S.GUIDE_SESSION_RESOLVED, dQ), this._composers.set(S.POST_QUIZ_ANSWERS, fQ), this._composers.set(S.SEARCH_FAQS, gQ), this._composers.set(S.DESKTOP_VIEW, p$), this._composers.set(S.GROUP_INFO, lZ), this._composers.set(S.GROUP_REQUEST, cZ), this._composers.set(S.GROUP_MEMBER_REMOVE_CONFIRM, oZ), this._composers.set(S.GROUP_MEMBER_REMOVE, gZ), this._composers.set(S.GROUP_MEMBERS, _Z), this._composers.set(S.GROUP_ADMIN_ADD, sZ), this._composers.set(S.GROUP_ADMIN_REMOVE, iZ), this._composers.set(S.GROUP_REQUEST_ACCEPT, dZ), this._composers.set(S.GROUP_REQUEST_DECLINE, fZ), this._composers.set(S.GROUP_DELETE, hZ), this._composers.set(S.GROUP_CREATE_OPTIONS, aZ), this._composers.set(S.GROUP_PARTS, rZ), this._composers.set(S.GROUP_BUY, nZ), this._composers.set(S.GROUP_SETTINGS, IZ), this._composers.set(S.GROUP_SAVE_BADGE, pZ), this._composers.set(S.GROUP_SAVE_COLORS, mZ), this._composers.set(S.GROUP_SAVE_INFORMATION, EZ), this._composers.set(S.GROUP_SAVE_PREFERENCES, TZ), this._composers.set(S.GROUP_FAVORITE, uZ), this._composers.set(S.GROUP_UNFAVORITE, SZ), this._composers.set(S.GROUP_BADGES, cM), this._composers.set(S.APPROVE_ALL_MEMBERSHIP_REQUESTS, eZ), this._composers.set(S.GROUP_UNBLOCK_MEMBER, Wet), this._composers.set(S.ROOM_FAVORITE, gJ), this._composers.set(S.CAN_CREATE_ROOM, mJ), this._composers.set(S.CANCEL_ROOM_EVENT, pJ), this._composers.set(S.CONVERT_GLOBAL_ROOM_ID, TJ), this._composers.set(S.COMPETITION_ROOM_SEARCH, EJ), this._composers.set(S.ROOM_CREATE, IJ), this._composers.set(S.GET_USER_FLAT_CATS, PJ), this._composers.set(S.GET_USER_EVENT_CATS, bJ), this._composers.set(S.ROOM_FAVORITE_REMOVE, SJ), this._composers.set(S.EDIT_ROOM_EVENT, AJ), this._composers.set(S.FORWARD_TO_RANDOM_PROMOTED_ROOM, RJ), this._composers.set(S.FORWARD_TO_SOME_ROOM, OJ), this._composers.set(S.GET_CATEGORIES_WITH_USER_COUNT, yJ), this._composers.set(S.GET_GUEST_ROOM, CJ), this._composers.set(S.GET_OFFICIAL_ROOMS, xJ), this._composers.set(S.GET_POPULAR_ROOM_TAGS, MJ), this._composers.set(S.GUILD_BASE_SEARCH, NJ), this._composers.set(S.MY_FAVOURITE_ROOMS_SEARCH, UJ), this._composers.set(S.MY_FREQUENT_ROOM_HISTORY_SEARCH, DJ), this._composers.set(S.MY_FRIENDS_ROOM_SEARCH, LJ), this._composers.set(S.MY_GUILD_BASES_SEARCH, FJ), this._composers.set(S.MY_RECOMMENDED_ROOMS, wJ), this._composers.set(S.MY_ROOM_HISTORY_SEARCH, GJ), this._composers.set(S.MY_ROOM_RIGHTS_SEARCH, BJ), this._composers.set(S.MY_ROOMS_SEARCH, kJ), this._composers.set(S.POPULAR_ROOMS_SEARCH, qJ), this._composers.set(S.ROOM_LIKE, $J), this._composers.set(S.ROOM_RIGHTS_REMOVE_OWN, ZJ), this._composers.set(S.ROOM_AD_EVENT_TAB_CLICKED, QJ), this._composers.set(S.ROOM_AD_EVENT_TAB_VIEWED, JJ), this._composers.set(S.ROOM_AD_SEARCH, ttt), this._composers.set(S.ROOM_TEXT_SEARCH, itt), this._composers.set(S.ROOMS_WHERE_MY_FRIENDS_ARE, ett), this._composers.set(S.ROOMS_WITH_HIGHEST_SCORE_SEARCH, stt), this._composers.set(S.SET_ROOM_SESSION_TAGS, rtt), this._composers.set(S.ROOM_STAFF_PICK, ntt), this._composers.set(S.ROOM_FILTER_WORDS, vJ), this._composers.set(S.ROOM_FILTER_WORDS_MODIFY, ott), this._composers.set(S.USER_HOME_ROOM, att), this._composers.set(S.UPDATE_ROOM_THUMBNAIL, htt), this._composers.set(S.NAVIGATOR_INIT, HJ), this._composers.set(S.NAVIGATOR_SEARCH_CLOSE, YJ), this._composers.set(S.NAVIGATOR_SEARCH, WJ), this._composers.set(S.NAVIGATOR_SEARCH_OPEN, jJ), this._composers.set(S.NAVIGATOR_SEARCH_SAVE, XJ), this._composers.set(S.NAVIGATOR_SETTINGS_SAVE, KJ), this._composers.set(S.NAVIGATOR_CATEGORY_LIST_MODE, zJ), this._composers.set(S.NAVIGATOR_DELETE_SAVED_SEARCH, VJ), this._composers.set(S.POLL_ANSWER, ex), this._composers.set(S.POLL_REJECT, sx), this._composers.set(S.POLL_START, ix), this._composers.set(S.POLL_VOTE_COUNTER, rx), this._composers.set(S.USER_EFFECT_ACTIVATE, pQ), this._composers.set(S.USER_EFFECT_ENABLE, mQ), this._composers.set(S.USER_BADGES, SQ), this._composers.set(S.USER_BADGES_CURRENT_UPDATE, AQ), this._composers.set(S.GET_BADGE_POINTS_LIMITS, EQ), this._composers.set(S.REQUESTABADGE, IQ), this._composers.set(S.GETISBADGEREQUESTFULFILLED, TQ), this._composers.set(S.USER_BOTS, RR), this._composers.set(S.USER_FURNITURE, RQ), this._composers.set(S.REQUESTFURNIINVENTORYWHENNOTINROOM, OQ), this._composers.set(S.USER_PETS, OR), this._composers.set(S.TRADE_ACCEPT, CQ), this._composers.set(S.TRADE_CANCEL, xQ), this._composers.set(S.TRADE_CLOSE, MQ), this._composers.set(S.TRADE_CONFIRM, bQ), this._composers.set(S.TRADE_ITEM, PQ), this._composers.set(S.TRADE_ITEMS, NQ), this._composers.set(S.TRADE_ITEM_REMOVE, UQ), this._composers.set(S.TRADE, DQ), this._composers.set(S.TRADE_UNACCEPT, LQ), this._composers.set(S.UNSEEN_RESET_CATEGORY, FQ), this._composers.set(S.UNSEEN_RESET_ITEMS, wQ), this._composers.set(S.ACHIEVEMENT_LIST, cq), this._composers.set(S.PET_MOUNT, cE), this._composers.set(S.PET_RESPECT, qC), this._composers.set(S.PET_SUPPLEMENT, ltt), this._composers.set(S.REMOVE_PET_SADDLE, $C), this._composers.set(S.PET_INFO, ZC), this._composers.set(S.TOGGLE_PET_BREEDING, QC), this._composers.set(S.TOGGLE_PET_RIDING, JC), this._composers.set(S.USE_PET_PRODUCT, tx), this._composers.set(S.GET_PET_TRAINING_PANEL, KC), this._composers.set(S.PET_OPEN_PACKAGE, Bx), this._composers.set(S.PET_SELECTED, cet), this._composers.set(S.PETS_BREED, pE), this._composers.set(S.PET_CANCEL_BREEDING, yQ), this._composers.set(S.PET_CONFIRM_BREEDING, vQ), this._composers.set(S.ROOM_ENTER, ax), this._composers.set(S.ROOM_DOORBELL, nx), this._composers.set(S.GO_TO_FLAT, Hx), this._composers.set(S.CHANGE_QUEUE, Vx), this._composers.set(S.ROOM_AMBASSADOR_ALERT, ox), this._composers.set(S.ROOM_BAN_GIVE, hx), this._composers.set(S.ROOM_BAN_REMOVE, Ptt), this._composers.set(S.ROOM_RIGHTS_GIVE, ux), this._composers.set(S.ROOM_KICK, lx), this._composers.set(S.ROOM_MUTE_USER, cx), this._composers.set(S.ROOM_RIGHTS_REMOVE, _x), this._composers.set(S.ROOM_RIGHTS_REMOVE_ALL, Mtt), this._composers.set(S.ROOM_DELETE, btt), this._composers.set(S.ROOM_SETTINGS, Dtt), this._composers.set(S.ROOM_SETTINGS_SAVE, Ftt), this._composers.set(S.ROOM_RIGHTS_LIST, Ltt), this._composers.set(S.ROOM_BAN_LIST, Utt), this._composers.set(S.ROOM_SETTINGS_UPDATE_ROOM_CATEGORY_AND_TRADE, Tet), this._composers.set(S.BOT_CONFIGURATION, Ntt), this._composers.set(S.GET_ITEM_DATA, mx), this._composers.set(S.REMOVE_WALL_ITEM, Sx), this._composers.set(S.BOT_PLACE, dx), this._composers.set(S.BOT_PICKUP, fx), this._composers.set(S.BOT_SKILL_SAVE, wtt), this._composers.set(S.PET_PLACE, Tx), this._composers.set(S.PET_MOVE, dE), this._composers.set(S.PET_PICKUP, Ix), this._composers.set(S.SET_ITEM_DATA, Rx), this._composers.set(S.SET_OBJECT_DATA, Ox), this._composers.set(S.COMPOST_PLANT, px), this._composers.set(S.HARVEST_PET, Ex), this._composers.set(S.SET_CLOTHING_CHANGE_DATA, Ax), this._composers.set(S.FURNITURE_ALIASES, xx), this._composers.set(S.FURNITURE_GROUP_INFO, Mx), this._composers.set(S.FURNITURE_PICKUP, bx), this._composers.set(S.FURNITURE_PLACE, Px), this._composers.set(S.ITEM_PAINT, ztt), this._composers.set(S.FURNITURE_POSTIT_PLACE, Nx), this._composers.set(S.FURNITURE_POSTIT_SAVE_STICKY_POLE, Gtt), this._composers.set(S.CONTROL_YOUTUBE_DISPLAY_PLAYBACK, Jtt), this._composers.set(S.GET_YOUTUBE_DISPLAY_STATUS, tet), this._composers.set(S.SET_YOUTUBE_DISPLAY_PLAYLIST, eet), this._composers.set(S.FURNITURE_FLOOR_UPDATE, fE), this._composers.set(S.FURNITURE_WALL_UPDATE, zx), this._composers.set(S.ITEM_DIMMER_SETTINGS, yx), this._composers.set(S.ITEM_DIMMER_SAVE, vx), this._composers.set(S.ITEM_DIMMER_TOGGLE, Cx), this._composers.set(S.ROOM_TONER_APPLY, Qtt), this._composers.set(S.ITEM_COLOR_WHEEL_CLICK, Ux), this._composers.set(S.ITEM_DICE_CLICK, Dx), this._composers.set(S.ITEM_DICE_CLOSE, Lx), this._composers.set(S.FURNITURE_MULTISTATE, _I), this._composers.set(S.FURNITURE_RANDOMSTATE, wx), this._composers.set(S.ITEM_STACK_HELPER, Ytt), this._composers.set(S.FURNITURE_WALL_MULTISTATE, Gx), this._composers.set(S.ONE_WAY_DOOR_CLICK, Fx), this._composers.set(S.ITEM_EXCHANGE_REDEEM, Htt), this._composers.set(S.ITEM_CLOTHING_REDEEM, net), this._composers.set(S.ROOM_MODEL, gE), this._composers.set(S.GET_OCCUPIED_TILES, set), this._composers.set(S.GET_ROOM_ENTRY_TILE, iet), this._composers.set(S.ROOM_MODEL_SAVE, ret), this._composers.set(S.UNIT_ACTION, Kx), this._composers.set(S.UNIT_DANCE, qx), this._composers.set(S.UNIT_DROP_HAND_ITEM, oet), this._composers.set(S.UNIT_GIVE_HANDITEM, het), this._composers.set(S.UNIT_GIVE_HANDITEM_PET, uet), this._composers.set(S.UNIT_LOOK, $x), this._composers.set(S.UNIT_SIGN, Qx), this._composers.set(S.UNIT_POSTURE, Zx), this._composers.set(S.UNIT_WALK, Jx), this._composers.set(S.UNIT_CHAT, dI), this._composers.set(S.UNIT_CHAT_SHOUT, Yx), this._composers.set(S.USER_SETTINGS_CHAT_STYLE, aet), this._composers.set(S.UNIT_CHAT_WHISPER, Wx), this._composers.set(S.UNIT_TYPING, jx), this._composers.set(S.UNIT_TYPING_STOP, Xx), this._composers.set(S.WIRED_APPLY_SNAPSHOT, det), this._composers.set(S.WIRED_OPEN, fet), this._composers.set(S.WIRED_ACTION_SAVE, pet), this._composers.set(S.WIRED_CONDITION_SAVE, met), this._composers.set(S.WIRED_TRIGGER_SAVE, Eet), this._composers.set(S.ROOM_MUTE, get), this._composers.set(S.APPROVE_NAME, bet), this._composers.set(S.USER_RESPECT, _M), this._composers.set(S.SCR_GET_KICKBACK_INFO, ket), this._composers.set(S.PEER_USERS_CLASSIFICATION, dM), this._composers.set(S.USER_CLASSIFICATION, fM), this._composers.set(S.USER_IGNORED, rM), this._composers.set(S.USER_IGNORE, aM), this._composers.set(S.USER_IGNORE_ID, oM), this._composers.set(S.USER_UNIGNORE, hM), this._composers.set(S.USER_BADGES_CURRENT, uM), this._composers.set(S.USER_FIGURE, Det), this._composers.set(S.USER_MOTTO, lM), this._composers.set(S.USER_PROFILE, Let), this._composers.set(S.USER_PROFILE_BY_NAME, Uet), this._composers.set(S.USER_TAGS, nM), this._composers.set(S.MESSENGER_RELATIONSHIPS, Fet), this._composers.set(S.MANNEQUIN_SAVE_NAME, jtt), this._composers.set(S.MANNEQUIN_SAVE_LOOK, Wtt), this._composers.set(S.PRESENT_OPEN_PRESENT, kx), this._composers.set(S.MARKETPLACE_CONFIG, YQ), this._composers.set(S.MARKETPLACE_SELL_ITEM, KQ), this._composers.set(S.MARKETPLACE_REQUEST_OWN_ITEMS, XQ), this._composers.set(S.MARKETPLACE_TAKE_BACK_ITEM, VQ), this._composers.set(S.MARKETPLACE_REQUEST_OFFERS, jQ), this._composers.set(S.MARKETPLACE_BUY_OFFER, kQ), this._composers.set(S.MARKETPLACE_REDEEM_CREDITS, qQ), this._composers.set(S.MARKETPLACE_BUY_TOKENS, zQ), this._composers.set(S.REQUEST_SELL_ITEM, HQ), this._composers.set(S.REQUEST_MARKETPLACE_ITEM_STATS, WQ), this._composers.set(S.USER_BOTS, RR), this._composers.set(S.USER_PETS, OR), this._composers.set(S.USER_CURRENCY, Get), this._composers.set(S.USER_SUBSCRIPTION, Bet), this._composers.set(S.MODTOOL_REQUEST_ROOM_INFO, JQ), this._composers.set(S.MODTOOL_CHANGE_ROOM_SETTINGS, nJ), this._composers.set(S.MODTOOL_REQUEST_USER_CHATLOG, iJ), this._composers.set(S.MODTOOL_REQUEST_ROOM_CHATLOG, eJ), this._composers.set(S.MOD_TOOL_USER_INFO, tJ), this._composers.set(S.MODTOOL_SANCTION_ALERT, rJ), this._composers.set(S.MODTOOL_SANCTION_BAN, yr), this._composers.set(S.MODTOOL_SANCTION_KICK, aJ), this._composers.set(S.MODTOOL_SANCTION_TRADELOCK, cJ), this._composers.set(S.MODTOOL_ALERTEVENT, oJ), this._composers.set(S.MODTOOL_SANCTION_MUTE, hJ), this._composers.set(S.MODTOOL_REQUEST_USER_ROOMS, sJ), this._composers.set(S.MODTOOL_ROOM_ALERT, lE), this._composers.set(S.CLOSE_ISSUE_DEFAULT_ACTION, $Q), this._composers.set(S.CLOSE_ISSUES, uE), this._composers.set(S.DEFAULT_SANCTION, ZQ), this._composers.set(S.GET_CFH_CHATLOG, QQ), this._composers.set(S.MODTOOL_PREFERENCES, uJ), this._composers.set(S.MODTOOL_SANCTION, lJ), this._composers.set(S.PICK_ISSUES, _J), this._composers.set(S.RELEASE_ISSUES, dJ), this._composers.set(S.MYSTERYBOXWAITINGCANCELEDMESSAGE, fJ), this._composers.set(S.MYSTERYBOX_OPEN_TROPHY, Xtt), this._composers.set(S.USER_SETTINGS_CAMERA, zet), this._composers.set(S.USER_SETTINGS_OLD_CHAT, Vet), this._composers.set(S.USER_SETTINGS_INVITES, Het), this._composers.set(S.USER_SETTINGS_VOLUME, Yet), this._composers.set(S.COMMUNITY_GOAL_VOTE_COMPOSER, BQ), this._composers.set(S.GET_PROMO_ARTICLES, GQ), this._composers.set(S.ACCEPT_QUEST, ctt), this._composers.set(S.ACTIVATE_QUEST, _tt), this._composers.set(S.CANCEL_QUEST, dtt), this._composers.set(S.FRIEND_REQUEST_QUEST_COMPLETE, ftt), this._composers.set(S.GET_COMMUNITY_GOAL_EARNED_PRIZES, gtt), this._composers.set(S.GET_COMMUNITY_GOAL_HALL_OF_FAME, ptt), this._composers.set(S.GET_COMMUNITY_GOAL_PROGRESS, mtt), this._composers.set(S.GET_CONCURRENT_USERS_GOAL_PROGRESS, Ett), this._composers.set(S.GET_CONCURRENT_USERS_REWARD, Ttt), this._composers.set(S.GET_DAILY_QUEST, Itt), this._composers.set(S.GET_QUESTS, Stt), this._composers.set(S.GET_SEASONAL_QUESTS_ONLY, Att), this._composers.set(S.OPEN_QUEST_TRACKER, Rtt), this._composers.set(S.REDEEM_COMMUNITY_GOAL_PRIZE, Ott), this._composers.set(S.REJECT_QUEST, ytt), this._composers.set(S.START_CAMPAIGN, vtt), this._composers.set(S.GET_SOUND_SETTINGS, Oet), this._composers.set(S.ADD_JUKEBOX_DISK, Iet), this._composers.set(S.GET_JUKEBOX_PLAYLIST, tM), this._composers.set(S.GET_NOW_PLAYING, eM), this._composers.set(S.GET_OFFICIAL_SONG_ID, Aet), this._composers.set(S.GET_SONG_INFO, sM), this._composers.set(S.GET_SOUND_MACHINE_PLAYLIST, Ret), this._composers.set(S.GET_USER_SONG_DISKS, iM), this._composers.set(S.REMOVE_JUKEBOX_DISK, yet), this._composers.set(S.HELPER_TALENT_TRACK, Cet), this._composers.set(S.TALENT_TRACK_GET_LEVEL, vet), this._composers.set(S.NEW_USER_EXPERIENCE_GET_GIFTS, utt), this._composers.set(S.NEW_USER_EXPERIENCE_SCRIPT_PROCEED, XC), this._composers.set(S.WELCOME_OPEN_GIFT, Ktt), this._composers.set(S.WELCOME_GIFT_CHANGE_EMAIL, jet), this._composers.set(S.EMAIL_GET_STATUS, wet), this._composers.set(S.EMAIL_CHANGE, Net), this._composers.set(S.RENTABLE_SPACE_CANCEL_RENT, qtt), this._composers.set(S.RENTABLE_SPACE_RENT, $tt), this._composers.set(S.RENTABLE_SPACE_STATUS, Ztt), this._composers.set(S.RECYCLER_STATUS, Ctt), this._composers.set(S.RECYCLER_ITEMS, xtt), this._composers.set(S.TRACKING_PERFORMANCE_LOG, Met), this._composers.set(S.TRACKING_LAG_WARNING_REPORT, xet), this._composers.set(S.ROOM_DIRECTORY_ROOM_NETWORK_OPEN_CONNECTION, _et), this._composers.set(S.RENTABLE_EXTEND_RENT_OR_BUYOUT_STRIP_ITEM, ktt), this._composers.set(S.RENTABLE_EXTEND_RENT_OR_BUYOUT_FURNI, Btt), this._composers.set(S.RENTABLE_GET_RENT_OR_BUYOUT_OFFER, Vtt);
  }
  get events() {
    return this._events;
  }
  get composers() {
    return this._composers;
  }
}
class Ket {
  constructor(t) {
    this._value = t;
  }
  get value() {
    return this._value;
  }
}
class qet {
  constructor(t, e) {
    this._header = t, this._buffer = e;
  }
  readBytes(t) {
    return this._buffer ? this._buffer.readBytes(t) : null;
  }
  readByte() {
    return this._buffer ? this._buffer.readByte() : -1;
  }
  readBoolean() {
    return this.readByte() === 1;
  }
  readShort() {
    return this._buffer ? this._buffer.readShort() : -1;
  }
  readInt() {
    return this._buffer ? this._buffer.readInt() : -1;
  }
  readFloat() {
    return this._buffer ? this._buffer.readFloat() : -1;
  }
  readDouble() {
    return this._buffer ? this._buffer.readDouble() : -1;
  }
  readString() {
    const t = this.readShort();
    return this._buffer.readBytes(t).toString("utf8");
  }
  get header() {
    return this._header;
  }
  get bytesAvailable() {
    return this._buffer && this._buffer.remaining() > 0;
  }
}
class $et {
  constructor(t) {
    this._value = t;
  }
  get value() {
    return this._value;
  }
}
class Zet {
  encode(t, e) {
    const s = new dA();
    s.writeShort(t);
    for (const n of e) {
      let a = typeof n;
      switch (a === "object" && (n === null ? a = "null" : n instanceof Ket ? a = "byte" : n instanceof $et ? a = "short" : n instanceof ArrayBuffer && (a = "arraybuffer")), a) {
        case "undefined":
        case "null":
          s.writeShort(0);
          break;
        case "byte":
          s.writeByte(n.value);
          break;
        case "short":
          s.writeShort(n.value);
          break;
        case "number":
          s.writeInt(n);
          break;
        case "boolean":
          s.writeByte(n ? 1 : 0);
          break;
        case "string":
          n ? s.writeString(n, !0) : s.writeShort(0);
          break;
        case "arraybuffer":
          s.writeBytes(n);
          break;
      }
    }
    const r = s.getBuffer();
    return r ? new dA().writeInt(r.byteLength).writeBytes(r) : null;
  }
  decode(t) {
    if (!t || !t.dataBuffer || !t.dataBuffer.byteLength) return null;
    const e = [];
    for (; t.dataBuffer.byteLength && !(t.dataBuffer.byteLength < 4); ) {
      const s = new Gd(t.dataBuffer), r = s.readInt();
      if (r > t.dataBuffer.byteLength - 4) break;
      const n = s.readBytes(r);
      e.push(new qet(n.readShort(), n)), t.dataBuffer = t.dataBuffer.slice(r + 4);
    }
    return e;
  }
}
class Qet {
  constructor() {
    this._socket = null, this._messages = new LB(), this._codec = new Zet(), this._dataBuffer = null, this._isReady = !1, this._pendingClientMessages = [], this._pendingServerMessages = [], this._isAuthenticated = !1;
  }
  init(t) {
    !t || !t.length || (this._dataBuffer = new ArrayBuffer(0), this._socket = new WebSocket(t), this._socket.binaryType = "arraybuffer", this._socket.addEventListener(Va.CONNECTION_OPENED, (e) => x().dispatchEvent(new qt(Ze.SOCKET_OPENED))), this._socket.addEventListener(Va.CONNECTION_CLOSED, (e) => x().dispatchEvent(new qt(Ze.SOCKET_CLOSED))), this._socket.addEventListener(Va.CONNECTION_ERROR, (e) => x().dispatchEvent(new qt(Ze.SOCKET_ERROR))), this._socket.addEventListener(Va.CONNECTION_MESSAGE, (e) => {
      this._dataBuffer = this.concatArrayBuffers(this._dataBuffer, e.data), this.processReceivedData();
    }));
  }
  ready() {
    this._isReady || (this._isReady = !0, this._pendingServerMessages && this._pendingServerMessages.length && this.processWrappers(...this._pendingServerMessages), this._pendingClientMessages && this._pendingClientMessages.length && this.send(...this._pendingClientMessages), this._pendingServerMessages = [], this._pendingClientMessages = []);
  }
  authenticated() {
    this._isAuthenticated = !0;
  }
  send(...t) {
    if (!t) return !1;
    if (t = [...t], this._isAuthenticated && !this._isReady)
      return this._pendingClientMessages.push(...t), !1;
    for (const e of t) {
      if (!e) continue;
      const s = this._messages.getComposerId(e);
      if (s === -1) {
        rt.packets("Unknown Composer", e.constructor.name);
        continue;
      }
      const r = e.getMessageArray(), n = this._codec.encode(s, r);
      if (!n) {
        rt.packets("Encoding Failed", e.constructor.name);
        continue;
      }
      rt.packets("OutgoingComposer", s, e.constructor.name, r), this.write(n.getBuffer());
    }
    return !0;
  }
  write(t) {
    this._socket.readyState === WebSocket.OPEN && this._socket.send(t);
  }
  processReceivedData() {
    try {
      this.processData();
    } catch (t) {
      rt.error(t);
    }
  }
  processData() {
    const t = this.splitReceivedMessages();
    if (!(!t || !t.length)) {
      if (this._isAuthenticated && !this._isReady) {
        this._pendingServerMessages || (this._pendingServerMessages = []), this._pendingServerMessages.push(...t);
        return;
      }
      this.processWrappers(...t);
    }
  }
  processWrappers(...t) {
    if (!(!t || !t.length))
      for (const e of t) {
        if (!e) continue;
        const s = this.getMessagesForWrapper(e);
        !s || !s.length || (rt.packets("IncomingMessage", e.header, s[0].constructor.name, s[0].parser), this.handleMessages(...s));
      }
  }
  splitReceivedMessages() {
    return !this._dataBuffer || !this._dataBuffer.byteLength ? null : this._codec.decode(this);
  }
  concatArrayBuffers(t, e) {
    const s = new Uint8Array(t.byteLength + e.byteLength);
    return s.set(new Uint8Array(t), 0), s.set(new Uint8Array(e), t.byteLength), s.buffer;
  }
  getMessagesForWrapper(t) {
    if (!t) return null;
    const e = this._messages.getEvents(t.header);
    if (!e || !e.length)
      return rt.packets("IncomingMessage", t.header, "UNREGISTERED", t), null;
    try {
      const s = new e[0].parserClass();
      if (!s || !s.flush() || !s.parse(t)) return null;
      for (const r of e) r.parser = s;
    } catch (s) {
      return rt.error("Error parsing message", s, e[0].constructor.name), null;
    }
    return e;
  }
  handleMessages(...t) {
    t = [...t];
    for (const e of t)
      e && (e.connection = this, e.callBack && e.callBack(e));
  }
  registerMessages(t) {
    t && this._messages.registerMessages(t);
  }
  addMessageEvent(t) {
    !t || !this._messages || this._messages.registerMessageEvent(t);
  }
  removeMessageEvent(t) {
    !t || !this._messages || this._messages.removeMessageEvent(t);
  }
  get isAuthenticated() {
    return this._isAuthenticated;
  }
  get dataBuffer() {
    return this._dataBuffer;
  }
  set dataBuffer(t) {
    this._dataBuffer = t;
  }
}
class Jet {
  constructor() {
    this._connection = new Qet(), this._messages = new Xet(), this._pongInterval = null, this._connection.registerMessages(this._messages);
  }
  async init() {
    return x().addEventListener(Ze.SOCKET_CLOSED, () => {
      this.stopPong();
    }), new Promise((t, e) => {
      x().addEventListener(Ze.SOCKET_OPENED, () => {
        Ct().getValue("system.pong.manually", !1) && this.startPong(), this._connection.send(new HC(null, null, null, null)), this._connection.send(new jC(Ct().getValue("sso.ticket", null), Nt()));
      }), x().addEventListener(Ze.SOCKET_ERROR, () => {
        e();
      }), this._connection.addMessageEvent(new Hv((s) => this.sendPong())), this._connection.addMessageEvent(new yC((s) => {
        this._connection.authenticated(), t(), s.connection.send(new YC());
      })), this._connection.init(Ct().getValue("socket.url"));
    });
  }
  startPong() {
    this._pongInterval && this.stopPong(), this._pongInterval = setInterval(() => this.sendPong(), Ct().getValue("system.pong.interval.ms", 2e4));
  }
  stopPong() {
    this._pongInterval && (clearInterval(this._pongInterval), this._pongInterval = null);
  }
  sendPong() {
    var t;
    (t = this._connection) == null || t.send(new WC());
  }
  registerMessageEvent(t) {
    return this._connection && this._connection.addMessageEvent(t), t;
  }
  removeMessageEvent(t) {
    this._connection && this._connection.removeMessageEvent(t);
  }
  get connection() {
    return this._connection;
  }
}
const tst = new Jet(), G = () => tst;
class Zf {
  constructor(t) {
    this._badgeId = "", this._level = 1, this._base = "", this._badgeId = t, this.parseText();
  }
  parseText() {
    let t = this._badgeId.length - 1;
    for (; t > 0 && this.isNumber(this._badgeId.charAt(t)); ) t--;
    this._base = this._badgeId.substr(0, t + 1);
    const e = this._badgeId.substr(t + 1, this._badgeId.length);
    e && e !== "" && (this._level = Number.parseInt(e));
  }
  isNumber(t) {
    const e = t.charCodeAt(0);
    return e >= 48 && e <= 57;
  }
  get level() {
    return this._level;
  }
  set level(t) {
    this._level = Math.max(1, t);
  }
  get getBadgeId() {
    return this._base + this._level;
  }
  get base() {
    return this._base;
  }
}
class est {
  constructor() {
    this._definitions = /* @__PURE__ */ new Map(), this._parameters = /* @__PURE__ */ new Map(), this._badgePointLimits = /* @__PURE__ */ new Map(), this._romanNumerals = ["I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X", "XI", "XII", "XIII", "XIV", "XV", "XVI", "XVII", "XVIII", "XIX", "XX", "XXI", "XXII", "XXIII", "XXIV", "XXV", "XXVI", "XXVII", "XXVIII", "XXIX", "XXX"];
  }
  async init() {
    try {
      const t = Ct().getValue("external.texts.url").slice();
      if (!t || !t.length) throw new Error("Invalid localization urls");
      for (let e of t) {
        if (!e || !e.length) return;
        e = Ct().interpolate(e);
        const s = await fetch(e);
        if (s.status !== 200) throw new Error("Invalid localization file");
        this.parseLocalization(await s.json());
      }
      G().registerMessageEvent(new $v(this.onBadgePointLimitsEvent.bind(this)));
    } catch (t) {
      throw new Error(t);
    }
  }
  parseLocalization(t) {
    if (!t) return !1;
    for (const e in t) this._definitions.set(e, t[e]);
    return !0;
  }
  onBadgePointLimitsEvent(t) {
    const e = t.getParser();
    for (const s of e.data) this.setBadgePointLimit(s.badgeId, s.limit);
  }
  getBadgePointLimit(t) {
    return this._badgePointLimits.get(t) || -1;
  }
  setBadgePointLimit(t, e) {
    this._badgePointLimits.set(t, e);
  }
  getRomanNumeral(t) {
    return this._romanNumerals[Math.max(0, t - 1)];
  }
  getPreviousLevelBadgeId(t) {
    const e = new Zf(t);
    return e.level--, e.getBadgeId;
  }
  hasValue(t) {
    return this._definitions.has(t);
  }
  getValue(t, e = !0) {
    if (!t || !t.length) return null;
    const s = t.match(/\$\{.[^}]*\}/g);
    if (s && s.length)
      for (const n of s) t = t.replace(n, this.getValue(n.slice(2, -1), e));
    let r = this._definitions.get(t) || null;
    if (!r && (r = Ct().definitions.get(t), r))
      return r;
    if (r && e) {
      const n = this._parameters.get(t);
      if (n)
        for (const [a, o] of n)
          r = r.replace("%" + a + "%", o);
    }
    return r || t;
  }
  getValueWithParameter(t, e, s) {
    const r = this.getValue(t, !1), n = r.replace("%" + e + "%", s);
    if (r.startsWith("%{")) {
      const a = new RegExp("%{" + e.toUpperCase() + "\\|([^|]*)\\|([^|]*)\\|([^|]*)}"), o = r.match(a);
      if (!o) return n;
      let h = -1;
      switch (Number.parseInt(s)) {
        case 0:
          h = 1;
          break;
        case 1:
          h = 2;
          break;
        default:
        case 2:
          h = 3;
          break;
      }
      if (h == -1 || typeof o[h] > "u")
        return n;
      const c = o[h];
      if (c)
        return c.replace("%%", s);
    }
    return n;
  }
  getValueWithParameters(t, e, s) {
    let r = this.getValue(t, !1);
    if (e)
      for (let n = 0; n < e.length; n++) {
        const a = e[n], o = s[n];
        if (o !== void 0 && (r = r.replace("%" + a + "%", o), r.startsWith("%{"))) {
          const h = new RegExp("%{" + a.toUpperCase() + "\\|([^|]*)\\|([^|]*)\\|([^|]*)}"), u = r.match(h);
          if (!u) continue;
          const c = parseInt(o);
          let l = -1;
          switch (c) {
            case 0:
              l = 1;
              break;
            case 1:
              l = 2;
              break;
            case 2:
            default:
              l = 3;
              break;
          }
          if (l === -1 || typeof u[l] > "u") continue;
          const _ = u[l];
          _ && (r = _.replace("%%", o));
        }
      }
    return r;
  }
  setValue(t, e) {
    this._definitions.set(t, e);
  }
  registerParameter(t, e, s) {
    if (!t || t.length === 0 || !e || e.length === 0) return;
    let r = this._parameters.get(t);
    r || (r = /* @__PURE__ */ new Map(), this._parameters.set(t, r)), r.set(e, s);
  }
  getBadgeName(t) {
    const e = new Zf(t), s = ["badge_name_" + t, "badge_name_" + e.base];
    let r = this.fixBadLocalization(this.getExistingKey(s));
    return r = r.replace("%roman%", this.getRomanNumeral(e.level)), r;
  }
  getBadgeDesc(t) {
    const e = new Zf(t), s = ["badge_desc_" + t, "badge_desc_" + e.base];
    let r = this.fixBadLocalization(this.getExistingKey(s));
    const n = this.getBadgePointLimit(t);
    return n > -1 && (r = r.replace("%limit%", n.toString())), r = r.replace("%roman%", this.getRomanNumeral(e.level)), r;
  }
  getExistingKey(t) {
    for (const e of t) {
      const s = this.getValue(e);
      if (s != e) return s;
    }
    return "";
  }
  fixBadLocalization(t) {
    return t.replace("${", "$").replace("{", "$").replace("}", "$");
  }
}
const sst = new est(), pl = () => sst, Mi = class Mi {
  constructor() {
    this._userDataByType = /* @__PURE__ */ new Map(), this._userDataByRoomIndex = /* @__PURE__ */ new Map(), this._userBadges = /* @__PURE__ */ new Map();
  }
  getUserData(t) {
    return this.getDataByType(t, Mi.TYPE_USER);
  }
  getPetData(t) {
    return this.getDataByType(t, Mi.TYPE_PET);
  }
  getBotData(t) {
    return this.getDataByType(t, Mi.TYPE_BOT);
  }
  getRentableBotData(t) {
    return this.getDataByType(t, Mi.TYPE_RENTABLE_BOT);
  }
  getDataByType(t, e) {
    const s = this._userDataByType.get(e);
    if (!s) return null;
    const r = s.get(t);
    return r || null;
  }
  getUserDataByIndex(t) {
    const e = this._userDataByRoomIndex.get(t);
    return e || null;
  }
  getUserDataByName(t) {
    for (const e of this._userDataByRoomIndex.values())
      if (!(!e || e.name !== t))
        return e;
    return null;
  }
  updateUserData(t) {
    if (!t) return;
    this.removeUserData(t.roomIndex);
    let e = this._userDataByType.get(t.type);
    e || (e = /* @__PURE__ */ new Map(), this._userDataByType.set(t.type, e)), e.set(t.webID, t), this._userDataByRoomIndex.set(t.roomIndex, t);
  }
  removeUserData(t) {
    const e = this.getUserDataByIndex(t);
    if (!e) return;
    this._userDataByRoomIndex.delete(t);
    const s = this._userDataByType.get(e.type);
    s && s.delete(e.webID);
  }
  getUserBadges(t) {
    G().connection.send(new uM(t));
    const e = this._userBadges.get(t);
    return e || [];
  }
  setUserBadges(t, e) {
    this._userBadges.set(t, e);
  }
  updateFigure(t, e, s, r, n) {
    const a = this.getUserDataByIndex(t);
    a && (a.figure = e, a.sex = s, a.hasSaddle = r, a.isRiding = n);
  }
  updateName(t, e) {
    const s = this.getUserDataByIndex(t);
    s && (s.name = e);
  }
  updateMotto(t, e) {
    const s = this.getUserDataByIndex(t);
    s && (s.custom = e);
  }
  updateAchievementScore(t, e) {
    const s = this.getUserDataByIndex(t);
    s && (s.activityPoints = e);
  }
  updatePetLevel(t, e) {
    const s = this.getUserDataByIndex(t);
    s && (s.petLevel = e);
  }
  updatePetBreedingStatus(t, e, s, r, n) {
    const a = this.getUserDataByIndex(t);
    a && (a.canBreed = e, a.canHarvest = s, a.canRevive = r, a.hasBreedingPermission = n);
  }
  requestPetInfo(t) {
    this.getPetData(t) && G().connection.send(new ZC(t));
  }
};
Mi.TYPE_USER = 1, Mi.TYPE_PET = 2, Mi.TYPE_BOT = 3, Mi.TYPE_RENTABLE_BOT = 4;
let mE = Mi;
class ist {
  constructor() {
    this._userData = new mE(), this._roomId = 0, this._password = null, this._state = mt.CREATED, this._tradeMode = Dg.NO_TRADING, this._doorMode = 0, this._allowPets = !1, this._controllerLevel = mr.NONE, this._ownRoomIndex = -1, this._isGuildRoom = !1, this._isRoomOwner = !1, this._isDecorating = !1, this._isSpectator = !1, this._moderationSettings = null;
  }
  setControllerLevel(t) {
    if (t >= mr.NONE && t <= mr.MODERATOR) {
      this._controllerLevel = t;
      return;
    }
    this._controllerLevel = mr.NONE;
  }
  setOwnRoomIndex(t) {
    this._ownRoomIndex = t;
  }
  setRoomOwner() {
    this._isRoomOwner = !0;
  }
  start() {
    return this._state !== mt.CREATED || !G().connection ? !1 : (this._state = mt.STARTED, this.enterRoom());
  }
  enterRoom() {
    return G().connection ? (G().connection.send(new ax(this._roomId, this._password)), !0) : !1;
  }
  reset(t) {
    t !== this._roomId && (this._roomId = t);
  }
  sendChatMessage(t, e) {
    G().connection.send(new dI(t, e));
  }
  sendShoutMessage(t, e) {
    G().connection.send(new Yx(t, e));
  }
  sendWhisperMessage(t, e, s) {
    G().connection.send(new Wx(t, e, s));
  }
  sendChatTypingMessage(t) {
    t ? G().connection.send(new jx()) : G().connection.send(new Xx());
  }
  sendMottoMessage(t) {
    G().connection.send(new lM(t));
  }
  sendDanceMessage(t) {
    G().connection.send(new qx(t));
  }
  sendExpressionMessage(t) {
    G().connection.send(new Kx(t));
  }
  sendSignMessage(t) {
    t < 0 || t > 17 || G().connection.send(new Qx(t));
  }
  sendPostureMessage(t) {
    G().connection.send(new Zx(t));
  }
  sendDoorbellApprovalMessage(t, e) {
    G().connection.send(new nx(t, e));
  }
  sendAmbassadorAlertMessage(t) {
    G().connection.send(new ox(t));
  }
  sendKickMessage(t) {
    G().connection.send(new lx(t));
  }
  sendMuteMessage(t, e) {
    G().connection.send(new cx(t, e, this._roomId));
  }
  sendBanMessage(t, e) {
    G().connection.send(new hx(t, this._roomId, e));
  }
  sendGiveRightsMessage(t) {
    G().connection.send(new ux(t));
  }
  sendTakeRightsMessage(t) {
    G().connection.send(new _x(t));
  }
  sendPollStartMessage(t) {
    G().connection.send(new ix(t));
  }
  sendPollRejectMessage(t) {
    G().connection.send(new sx(t));
  }
  sendPollAnswerMessage(t, e, s) {
    G().connection.send(new ex(t, e, s));
  }
  sendPeerUsersClassificationMessage(t) {
    G().connection.send(new dM(t));
  }
  sendOpenPetPackageMessage(t, e) {
    G().connection.send(new Bx(t, e));
  }
  sendRoomUsersClassificationMessage(t) {
    G().connection.send(new fM(t));
  }
  updateMoodlightData(t, e, s, r, n) {
    let a = "000000" + s.toString(16).toUpperCase();
    a = "#" + a.substring(a.length - 6), G().connection.send(new vx(t, e, a, r, n));
  }
  toggleMoodlightState() {
    G().connection.send(new Cx());
  }
  pickupPet(t) {
    G().connection && G().connection.send(new Ix(t));
  }
  pickupBot(t) {
    G().connection && G().connection.send(new fx(t));
  }
  requestMoodlightSettings() {
    G().connection && G().connection.send(new yx());
  }
  openGift(t) {
    G().connection.send(new kx(t));
  }
  mountPet(t) {
    G().connection.send(new cE(t, !0));
  }
  dismountPet(t) {
    G().connection.send(new cE(t, !1));
  }
  usePetProduct(t, e) {
    G().connection.send(new tx(t, e));
  }
  removePetSaddle(t) {
    G().connection.send(new $C(t));
  }
  togglePetBreeding(t) {
    G().connection.send(new QC(t));
  }
  togglePetRiding(t) {
    G().connection.send(new JC(t));
  }
  useMultistateItem(t) {
    G().connection.send(new _I(t));
  }
  harvestPet(t) {
    G().connection.send(new Ex(t));
  }
  compostPlant(t) {
    G().connection.send(new px(t));
  }
  requestPetCommands(t) {
    G().connection.send(new KC(t));
  }
  sendScriptProceed() {
    G().connection.send(new XC());
  }
  sendUpdateClothingChangeFurniture(t, e, s) {
    G().connection.send(new Ax(t, e, s));
  }
  changeQueue(t) {
    G().connection.send(new Vx(t));
  }
  votePoll(t) {
    G().connection.send(new rx(t));
  }
  get userDataManager() {
    return this._userData;
  }
  get roomId() {
    return this._roomId;
  }
  set roomId(t) {
    this._roomId = t;
  }
  get password() {
    return this._password;
  }
  set password(t) {
    this._password = t;
  }
  get state() {
    return this._state;
  }
  get isPrivateRoom() {
    return !0;
  }
  get tradeMode() {
    return this._tradeMode;
  }
  set tradeMode(t) {
    this._tradeMode = t;
  }
  get doorMode() {
    return this._doorMode;
  }
  set doorMode(t) {
    this._doorMode = t;
  }
  get allowPets() {
    return this._allowPets;
  }
  set allowPets(t) {
    this._allowPets = t;
  }
  get controllerLevel() {
    return this._controllerLevel;
  }
  get ownRoomIndex() {
    return this._ownRoomIndex;
  }
  get isGuildRoom() {
    return this._isGuildRoom;
  }
  set isGuildRoom(t) {
    this._isGuildRoom = t;
  }
  get isRoomOwner() {
    return this._isRoomOwner;
  }
  get isDecorating() {
    return this._isDecorating;
  }
  set isDecorating(t) {
    this._isDecorating = t;
  }
  get isSpectator() {
    return this._isSpectator;
  }
  set isSpectator(t) {
    this._isSpectator = t;
  }
  get moderationSettings() {
    return this._moderationSettings;
  }
  set moderationSettings(t) {
    this._moderationSettings = t;
  }
}
class gi {
  constructor(t, e) {
    this._connection = t, this._listener = e, this._roomId = 0;
  }
  dispose() {
    this._connection = null, this._listener = null;
  }
  setRoomId(t) {
    this._roomId = t;
  }
  get connection() {
    return this._connection;
  }
  get listener() {
    return this._listener;
  }
  get roomId() {
    return this._roomId;
  }
}
class rst extends gi {
  constructor(t, e) {
    super(t, e), t.addMessageEvent(new Em(this.onRoomGenericError.bind(this)));
  }
  onRoomGenericError(t) {
    if (!(t instanceof Em)) return;
    const e = t.getParser();
    if (!e) return;
    const s = this.listener.getSession(this.roomId);
    if (!s) return;
    let r = "";
    switch (e.errorCode) {
      case Ug.KICKED_OUT_OF_ROOM:
        r = We.RSEME_KICKED;
        break;
      default:
        return;
    }
    !r || r.length == 0 || x().dispatchEvent(new We(r, s));
  }
}
class nst extends gi {
  constructor(t, e) {
    super(t, e), G().registerMessageEvent(new sC(this.onOpenPetPackageRequested.bind(this))), G().registerMessageEvent(new iC(this.onOpenPetPackageResult.bind(this)));
  }
  onOpenPetPackageRequested(t) {
    if (!this.listener) return;
    const e = t.getParser();
    if (!e) return;
    const s = this.listener.getSession(this.roomId);
    s && x().dispatchEvent(new Wa(Wa.RSOPPE_OPEN_PET_PACKAGE_REQUESTED, s, e.objectId, e.figureData, 0, null));
  }
  onOpenPetPackageResult(t) {
    if (!this.listener) return;
    const e = t.getParser();
    if (!e) return;
    const s = this.listener.getSession(this.roomId);
    s && x().dispatchEvent(new Wa(Wa.RSOPPE_OPEN_PET_PACKAGE_RESULT, s, e.objectId, null, e.nameValidationStatus, e.nameValidationInfo));
  }
}
class ast extends gi {
  constructor(t, e) {
    super(t, e), t.addMessageEvent(new aC(this.onPollContentsEvent.bind(this))), t.addMessageEvent(new hC(this.onPollOfferEvent.bind(this))), t.addMessageEvent(new oC(this.onPollErrorEvent.bind(this))), t.addMessageEvent(new dC(this.onStartRoomPollEvent.bind(this))), t.addMessageEvent(new _C(this.onRoomPollResultEvent.bind(this)));
  }
  onPollContentsEvent(t) {
    if (!this.listener) return;
    const e = this.listener.getSession(this.roomId);
    if (!e) return;
    const s = t.getParser();
    if (!s) return;
    const r = new br(br.CONTENT, e, s.id);
    r.startMessage = s.startMessage, r.endMessage = s.endMessage, r.numQuestions = s.numQuestions, r.questionArray = s.questionArray, r.npsPoll = s.npsPoll, x().dispatchEvent(r);
  }
  onPollOfferEvent(t) {
    if (!this.listener) return;
    const e = this.listener.getSession(this.roomId);
    if (!e) return;
    const s = t.getParser();
    if (!s) return;
    const r = new br(br.OFFER, e, s.id);
    r.summary = s.headline, r.summary = s.summary, x().dispatchEvent(r);
  }
  onPollErrorEvent(t) {
    if (!this.listener) return;
    const e = this.listener.getSession(this.roomId);
    if (!e || !t.getParser()) return;
    const r = new br(br.ERROR, e, -1);
    r.headline = "???", r.summary = "???", x().dispatchEvent(r);
  }
  onStartRoomPollEvent(t) {
    if (!this.listener) return;
    const e = this.listener.getSession(this.roomId);
    if (!e) return;
    const s = t.getParser();
    if (!s) return;
    const r = new ja(ja.VOTE_QUESTION, e, s.question, s.choices);
    x().dispatchEvent(r);
  }
  onRoomPollResultEvent(t) {
    if (!this.listener) return;
    const e = this.listener.getSession(this.roomId);
    if (!e) return;
    const s = t.getParser();
    if (!s) return;
    const r = new ja(ja.VOTE_RESULT, e, s.question, s.choices, s.SafeStr_7651, s.SafeStr_7654);
    x().dispatchEvent(r);
  }
}
class ost extends gi {
  constructor(t, e) {
    super(t, e), t.addMessageEvent(new uI(this.onRoomUnitChatEvent.bind(this))), t.addMessageEvent(new Rc(this.onRoomUnitChatEvent.bind(this))), t.addMessageEvent(new Oc(this.onRoomUnitChatEvent.bind(this))), t.addMessageEvent(new OC(this.onRoomUnitHandItemReceivedEvent.bind(this))), t.addMessageEvent(new zC(this.onRespectReceivedEvent.bind(this))), t.addMessageEvent(new BC(this.onPetRespectNoficationEvent.bind(this))), t.addMessageEvent(new kC(this.onPetSupplementedNotificationEvent.bind(this))), t.addMessageEvent(new AC(this.onFloodControlEvent.bind(this))), t.addMessageEvent(new RC(this.onRemainingMuteEvent.bind(this)));
  }
  onRoomUnitChatEvent(t) {
    if (!this.listener) return;
    const e = this.listener.getSession(this.roomId);
    if (!e) return;
    const s = t.getParser();
    if (!s) return;
    let r = Jt.CHAT_TYPE_SPEAK;
    t instanceof Rc ? r = Jt.CHAT_TYPE_SHOUT : t instanceof Oc && (r = Jt.CHAT_TYPE_WHISPER);
    const n = new Jt(Jt.CHAT_EVENT, e, s.roomIndex, s.message, r, s.bubble);
    x().dispatchEvent(n);
  }
  onRoomUnitHandItemReceivedEvent(t) {
    if (!this.listener) return;
    const e = this.listener.getSession(this.roomId);
    if (!e) return;
    const s = t.getParser();
    s && x().dispatchEvent(new Jt(Jt.CHAT_EVENT, e, s.giverUserId, "", Jt.CHAT_TYPE_HAND_ITEM_RECEIVED, Ln.GENERIC, [], s.handItemType));
  }
  onRespectReceivedEvent(t) {
    if (!this.listener) return;
    const e = this.listener.getSession(this.roomId);
    if (!e) return;
    const s = t.getParser();
    if (!s) return;
    const r = e.userDataManager.getUserData(s.userId);
    r && x().dispatchEvent(new Jt(Jt.CHAT_EVENT, e, r.roomIndex, "", Jt.CHAT_TYPE_RESPECT, Ln.GENERIC));
  }
  onPetRespectNoficationEvent(t) {
    if (!this.listener) return;
    const e = this.listener.getSession(this.roomId);
    if (!e) return;
    const s = t.getParser();
    if (!s) return;
    const r = e.userDataManager.getPetData(s.petData.id);
    if (!r) return;
    let n = Jt.CHAT_TYPE_PETRESPECT;
    s.isTreat && (n = Jt.CHAT_TYPE_PETTREAT), x().dispatchEvent(new Jt(Jt.CHAT_EVENT, e, r.roomIndex, "", n, Ln.GENERIC));
  }
  onPetSupplementedNotificationEvent(t) {
    if (!this.listener) return;
    const e = this.listener.getSession(this.roomId);
    if (!e) return;
    const s = t.getParser();
    if (!s) return;
    const r = e.userDataManager.getPetData(s.petId);
    if (!r) return;
    let n = -1;
    const a = e.userDataManager.getUserData(s.userId);
    a && (n = a.roomIndex);
    let o = Jt.CHAT_TYPE_PETREVIVE;
    switch (s.supplementType) {
      case xh.REVIVE:
        o = Jt.CHAT_TYPE_PETREVIVE;
        break;
      case xh.REBREED_FERTILIZER:
        o = Jt.CHAT_TYPE_PET_REBREED_FERTILIZE;
        break;
      case xh.SPEED_FERTILIZER:
        o = Jt.CHAT_TYPE_PET_SPEED_FERTILIZE;
        break;
    }
    x().dispatchEvent(new Jt(Jt.CHAT_EVENT, e, r.roomIndex, "", o, Ln.GENERIC, null, n));
  }
  onFloodControlEvent(t) {
    if (!this.listener) return;
    const e = this.listener.getSession(this.roomId);
    if (!e) return;
    const s = t.getParser();
    if (!s) return;
    const r = s.seconds;
    x().dispatchEvent(new Jt(Jt.FLOOD_EVENT, e, -1, r.toString(), 0, 0));
  }
  onRemainingMuteEvent(t) {
    if (!this.listener) return;
    const e = this.listener.getSession(this.roomId);
    if (!e) return;
    const s = t.getParser();
    s && x().dispatchEvent(new Jt(Jt.CHAT_EVENT, e, e.ownRoomIndex, "", Jt.CHAT_TYPE_MUTE_REMAINING, Ln.GENERIC, [], s.seconds));
  }
}
class hst extends gi {
  constructor(t, e) {
    super(t, e), t.addMessageEvent(new Im(this.onGetGuestRoomResultEvent.bind(this)));
  }
  onGetGuestRoomResultEvent(t) {
    if (!(t instanceof Im)) return;
    const e = t.getParser();
    if (!e || e.roomForward) return;
    const s = this.listener.getSession(this.roomId);
    if (!s) return;
    const r = e.data;
    s.tradeMode = r.tradeMode, s.isGuildRoom = r.habboGroupId !== 0, s.doorMode = r.doorMode, s.allowPets = r.allowPets, s.moderationSettings = e.moderation, x().dispatchEvent(new _c(_c.RSDUE_ALLOW_PETS, s)), x().dispatchEvent(new mt(mt.ROOM_DATA, s));
  }
}
class ust extends gi {
  constructor(t, e) {
    super(t, e), t.addMessageEvent(new gC(this.onRoomDimmerPresets.bind(this)));
  }
  onRoomDimmerPresets(t) {
    if (!t) return;
    const e = t.getParser();
    if (!e) return;
    const s = this.listener.getSession(this.roomId);
    if (!s) return;
    const r = new lc(lc.ROOM_DIMMER_PRESETS, s);
    r.selectedPresetId = e.selectedPresetId;
    let n = 0;
    for (; n < e.presetCount; ) {
      const a = e.getPreset(n);
      a && r.storePreset(a.id, a.type, a.color, a.brightness), n++;
    }
    x().dispatchEvent(r);
  }
}
class lst extends gi {
  constructor(t, e) {
    super(t, e), t.addMessageEvent(new ym(this.onRoomRightsEvent.bind(this))), t.addMessageEvent(new Om(this.onRoomRightsClearEvent.bind(this))), t.addMessageEvent(new vm(this.onRoomRightsOwnerEvent.bind(this)));
  }
  onRoomRightsEvent(t) {
    if (!(t instanceof ym)) return;
    const e = this.listener.getSession(this.roomId);
    e && e.setControllerLevel(t.getParser().controllerLevel);
  }
  onRoomRightsClearEvent(t) {
    if (!(t instanceof Om)) return;
    const e = this.listener.getSession(this.roomId);
    e && e.setControllerLevel(mr.NONE);
  }
  onRoomRightsOwnerEvent(t) {
    if (!(t instanceof vm)) return;
    const e = this.listener.getSession(this.roomId);
    e && e.setRoomOwner();
  }
}
class cst extends gi {
  constructor(t, e) {
    super(t, e), t && t.addMessageEvent(new Zv(this.onFurnitureGiftOpenedEvent.bind(this)));
  }
  onFurnitureGiftOpenedEvent(t) {
    if (!t) return;
    const e = t.getParser();
    if (!e) return;
    const s = this.listener.getSession(this.roomId);
    s && x().dispatchEvent(new cc(cc.RSPE_PRESENT_OPENED, s, e.classId, e.itemType, e.productCode, e.placedItemId, e.placedItemType, e.placedInRoom, e.petFigureString));
  }
}
const ur = class ur extends gi {
  constructor(t, e) {
    super(t, e), t.addMessageEvent(new Cm(this.onRoomEnterEvent.bind(this))), t.addMessageEvent(new jo(this.onRoomReadyMessageEvent.bind(this))), t.addMessageEvent(new mm(this.onDesktopViewEvent.bind(this))), t.addMessageEvent(new Rm(this.onRoomDoorbellAcceptedEvent.bind(this))), t.addMessageEvent(new Tm(this.onRoomDoorbellRejectedEvent.bind(this))), t.addMessageEvent(new SC(this.onYouAreSpectatorMessageEvent.bind(this)));
  }
  onRoomEnterEvent(t) {
    t instanceof Cm && this.listener && this.listener.sessionUpdate(this.roomId, ur.RS_CONNECTED);
  }
  onRoomReadyMessageEvent(t) {
    if (!(t instanceof jo)) return;
    const e = this.roomId, s = t.getParser().roomId;
    this.listener && (this.listener.sessionReinitialize(e, s), this.listener.sessionUpdate(this.roomId, ur.RS_READY));
  }
  onDesktopViewEvent(t) {
    t instanceof mm && this.listener && this.listener.sessionUpdate(this.roomId, ur.RS_DISCONNECTED);
  }
  onRoomDoorbellAcceptedEvent(t) {
    if (!(t instanceof Rm) || !this.listener) return;
    const e = t.getParser();
    if (!e) return;
    const s = e.userName;
    if (!s || !s.length)
      this.connection.send(new Hx(this.roomId));
    else {
      const r = this.listener.getSession(this.roomId);
      if (!r) return;
      x().dispatchEvent(new rn(rn.RSDE_ACCEPTED, r, s));
    }
  }
  onRoomDoorbellRejectedEvent(t) {
    if (!(t instanceof Tm) || !this.listener) return;
    const e = t.getParser();
    if (!e) return;
    const s = e.userName;
    if (!s || !s.length)
      this.listener.sessionUpdate(this.roomId, ur.RS_DISCONNECTED);
    else {
      const r = this.listener.getSession(this.roomId);
      if (!r) return;
      x().dispatchEvent(new rn(rn.RSDE_REJECTED, r, s));
    }
  }
  onYouAreSpectatorMessageEvent(t) {
    if (this.listener) {
      const e = this.listener.getSession(this.roomId);
      if (!e) return;
      e.isSpectator = !0, x().dispatchEvent(new dc(dc.SPECTATOR_MODE, e));
    }
  }
};
ur.RS_CONNECTED = "RS_CONNECTED", ur.RS_READY = "RS_READY", ur.RS_DISCONNECTED = "RS_DISCONNECTED";
let $a = ur;
class _st {
  constructor() {
    this._adultLevel = 7;
  }
  get id() {
    return this._id;
  }
  set id(t) {
    this._id = t;
  }
  get level() {
    return this._level;
  }
  set level(t) {
    this._level = t;
  }
  get maximumLevel() {
    return this._maximumLevel;
  }
  set maximumLevel(t) {
    this._maximumLevel = t;
  }
  get experience() {
    return this._experience;
  }
  set experience(t) {
    this._experience = t;
  }
  get levelExperienceGoal() {
    return this._levelExperienceGoal;
  }
  set levelExperienceGoal(t) {
    this._levelExperienceGoal = t;
  }
  get energy() {
    return this._energy;
  }
  set energy(t) {
    this._energy = t;
  }
  get maximumEnergy() {
    return this._maximumEnergy;
  }
  set maximumEnergy(t) {
    this._maximumEnergy = t;
  }
  get happyness() {
    return this._happyness;
  }
  set happyness(t) {
    this._happyness = t;
  }
  get maximumHappyness() {
    return this._maximumHappyness;
  }
  set maximumHappyness(t) {
    this._maximumHappyness = t;
  }
  get ownerId() {
    return this._ownerId;
  }
  set ownerId(t) {
    this._ownerId = t;
  }
  get ownerName() {
    return this._ownerName;
  }
  set ownerName(t) {
    this._ownerName = t;
  }
  get respect() {
    return this._respect;
  }
  set respect(t) {
    this._respect = t;
  }
  get age() {
    return this._age;
  }
  set age(t) {
    this._age = t;
  }
  get unknownRarity() {
    return this._unknownRarity;
  }
  set unknownRarity(t) {
    this._unknownRarity = t;
  }
  get saddle() {
    return this._saddle;
  }
  set saddle(t) {
    this._saddle = t;
  }
  get rider() {
    return this._rider;
  }
  set rider(t) {
    this._rider = t;
  }
  get skillTresholds() {
    return this._skillThresholds;
  }
  set skillTresholds(t) {
    this._skillThresholds = t;
  }
  get publiclyRideable() {
    return this._publiclyRideable;
  }
  set publiclyRideable(t) {
    this._publiclyRideable = t;
  }
  get breedable() {
    return this._breedable;
  }
  set breedable(t) {
    this._breedable = t;
  }
  get fullyGrown() {
    return this._fullyGrown;
  }
  set fullyGrown(t) {
    this._fullyGrown = t;
  }
  get dead() {
    return this._dead;
  }
  set dead(t) {
    this._dead = t;
  }
  get rarityLevel() {
    return this._rarityLevel;
  }
  set rarityLevel(t) {
    this._rarityLevel = t;
  }
  get maximumTimeToLive() {
    return this._maximumTimeToLive;
  }
  set maximumTimeToLive(t) {
    this._maximumTimeToLive = t;
  }
  get remainingTimeToLive() {
    return this._remainingTimeToLive;
  }
  set remainingTimeToLive(t) {
    this._remainingTimeToLive = t;
  }
  get remainingGrowTime() {
    return this._remainingGrowTime;
  }
  set remainingGrowTime(t) {
    this._remainingGrowTime = t;
  }
  get publiclyBreedable() {
    return this._publiclyBreedable;
  }
  set publiclyBreedable(t) {
    this._publiclyBreedable = t;
  }
  get adultLevel() {
    return this._adultLevel;
  }
}
class dst {
  constructor(t) {
    this._roomIndex = -1, this._name = "", this._type = 0, this._sex = "", this._figure = "", this._custom = "", this._webID = 0, this._groupID = 0, this._groupStatus = 0, this._groupName = "", this._ownerId = 0, this._ownerName = "", this._petLevel = 0, this._rarityLevel = 0, this._roomIndex = t;
  }
  get roomIndex() {
    return this._roomIndex;
  }
  get activityPoints() {
    return this._activityPoints;
  }
  set activityPoints(t) {
    this._activityPoints = t;
  }
  get name() {
    return this._name;
  }
  set name(t) {
    this._name = t;
  }
  get type() {
    return this._type;
  }
  set type(t) {
    this._type = t;
  }
  get sex() {
    return this._sex;
  }
  set sex(t) {
    this._sex = t;
  }
  get figure() {
    return this._figure;
  }
  set figure(t) {
    this._figure = t;
  }
  get custom() {
    return this._custom;
  }
  set custom(t) {
    this._custom = t;
  }
  get webID() {
    return this._webID;
  }
  set webID(t) {
    this._webID = t;
  }
  get groupId() {
    return this._groupID;
  }
  set groupId(t) {
    this._groupID = t;
  }
  get groupName() {
    return this._groupName;
  }
  set groupName(t) {
    this._groupName = t;
  }
  get groupStatus() {
    return this._groupStatus;
  }
  set groupStatus(t) {
    this._groupStatus = t;
  }
  get ownerId() {
    return this._ownerId;
  }
  set ownerId(t) {
    this._ownerId = t;
  }
  get ownerName() {
    return this._ownerName;
  }
  set ownerName(t) {
    this._ownerName = t;
  }
  get rarityLevel() {
    return this._rarityLevel;
  }
  set rarityLevel(t) {
    this._rarityLevel = t;
  }
  get hasSaddle() {
    return this._hasSaddle;
  }
  set hasSaddle(t) {
    this._hasSaddle = t;
  }
  get isRiding() {
    return this._isRiding;
  }
  set isRiding(t) {
    this._isRiding = t;
  }
  get canBreed() {
    return this._canBreed;
  }
  set canBreed(t) {
    this._canBreed = t;
  }
  get canHarvest() {
    return this._canHarvest;
  }
  set canHarvest(t) {
    this._canHarvest = t;
  }
  get canRevive() {
    return this._canRevive;
  }
  set canRevive(t) {
    this._canRevive = t;
  }
  get hasBreedingPermission() {
    return this._hasBreedingPermission;
  }
  set hasBreedingPermission(t) {
    this._hasBreedingPermission = t;
  }
  get petLevel() {
    return this._petLevel;
  }
  set petLevel(t) {
    this._petLevel = t;
  }
  get botSkills() {
    return this._botSkills;
  }
  set botSkills(t) {
    this._botSkills = t;
  }
  get isModerator() {
    return this._isModerator;
  }
  set isModerator(t) {
    this._isModerator = t;
  }
}
class fst extends gi {
  constructor(t, e) {
    super(t, e), t.addMessageEvent(new vc(this.onRoomUnitEvent.bind(this))), t.addMessageEvent(new Cc(this.onRoomUnitInfoEvent.bind(this))), t.addMessageEvent(new xc(this.onRoomUnitRemoveEvent.bind(this))), t.addMessageEvent(new yc(this.onRoomUnitDanceEvent.bind(this))), t.addMessageEvent(new UC(this.onUserCurrentBadgesEvent.bind(this))), t.addMessageEvent(new Jv(this.onRoomDoorbellEvent.bind(this))), t.addMessageEvent(new lI(this.onUserNameChangeMessageEvent.bind(this))), t.addMessageEvent(new Yv(this.onNewFriendRequestEvent.bind(this))), t.addMessageEvent(new EC(this.onPetInfoEvent.bind(this))), t.addMessageEvent(new TC(this.onPetStatusUpdateEvent.bind(this))), t.addMessageEvent(new F7(this.onPetBreedingMessageEvent.bind(this))), t.addMessageEvent(new rC(this.onPetLevelUpdateMessageEvent.bind(this))), t.addMessageEvent(new aK(this.onConfirmBreedingResultEvent.bind(this))), t.addMessageEvent(new oK(this.onNestBreedingSuccessEvent.bind(this))), t.addMessageEvent(new nK(this.onConfirmBreedingRequestEvent.bind(this))), t.addMessageEvent(new Ac(this.onPetFigureUpdateEvent.bind(this))), t.addMessageEvent(new pC(this.onPetBreedingResultEvent.bind(this))), t.addMessageEvent(new eC(this.onPetPlacingError.bind(this))), t.addMessageEvent(new tC(this.onBotError.bind(this))), t.addMessageEvent(new fC(this.onFavoriteMembershipUpdateMessageEvent.bind(this)));
  }
  onRoomUnitEvent(t) {
    if (!this.listener) return;
    const e = this.listener.getSession(this.roomId);
    if (!e) return;
    const s = t.getParser().users, r = [];
    if (s && s.length)
      for (const n of s) {
        if (!n) continue;
        const a = new dst(n.roomIndex);
        a.name = n.name, a.custom = n.custom, a.activityPoints = n.activityPoints, a.figure = n.figure, a.type = n.userType, a.webID = n.webID, a.groupId = n.groupID, a.groupName = n.groupName, a.groupStatus = n.groupStatus, a.sex = n.sex, a.ownerId = n.ownerId, a.ownerName = n.ownerName, a.rarityLevel = n.rarityLevel, a.hasSaddle = n.hasSaddle, a.isRiding = n.isRiding, a.canBreed = n.canBreed, a.canHarvest = n.canHarvest, a.canRevive = n.canRevive, a.hasBreedingPermission = n.hasBreedingPermission, a.petLevel = n.petLevel, a.botSkills = n.botSkills, a.isModerator = n.isModerator, e.userDataManager.getUserData(n.roomIndex) || r.push(a), e.userDataManager.updateUserData(a);
      }
    x().dispatchEvent(new Tp(e, r));
  }
  onRoomUnitInfoEvent(t) {
    if (!this.listener) return;
    const e = this.listener.getSession(this.roomId);
    if (!e) return;
    const s = t.getParser();
    s && (e.userDataManager.updateFigure(s.unitId, s.figure, s.gender, !1, !1), e.userDataManager.updateMotto(s.unitId, s.motto), e.userDataManager.updateAchievementScore(s.unitId, s.achievementScore), x().dispatchEvent(new Ip(e, s.unitId, s.figure, s.gender, s.motto, s.achievementScore)));
  }
  onRoomUnitRemoveEvent(t) {
    if (!this.listener) return;
    const e = this.listener.getSession(this.roomId);
    e && e.userDataManager.removeUserData(t.getParser().unitId);
  }
  onRoomUnitDanceEvent(t) {
    if (!this.listener) return;
    const e = t.getParser();
    if (!e) return;
    const s = this.listener.getSession(this.roomId);
    s && x().dispatchEvent(new hp(s, e.unitId, e.danceId));
  }
  onUserCurrentBadgesEvent(t) {
    if (!this.listener) return;
    const e = t.getParser();
    if (!e) return;
    const s = this.listener.getSession(this.roomId);
    s && (s.userDataManager.setUserBadges(e.userId, e.badges), x().dispatchEvent(new Ep(s, e.userId, e.badges)));
  }
  onRoomDoorbellEvent(t) {
    if (!this.listener) return;
    const e = t.getParser();
    if (!e) return;
    const s = e.userName;
    if (!s || !s.length) return;
    const r = this.listener.getSession(this.roomId);
    r && x().dispatchEvent(new rn(rn.DOORBELL, r, s));
  }
  onUserNameChangeMessageEvent(t) {
    if (!this.listener) return;
    const e = t.getParser();
    if (!e) return;
    const s = this.listener.getSession(this.roomId);
    s && s.userDataManager.updateName(e.id, e.newName);
  }
  onNewFriendRequestEvent(t) {
    if (!this.listener) return;
    const e = t.getParser();
    if (!e) return;
    const s = this.listener.getSession(this.roomId);
    if (!s) return;
    const r = e.request;
    x().dispatchEvent(new lp(s, r.requestId, r.requesterUserId, r.requesterName));
  }
  onPetInfoEvent(t) {
    if (!this.listener) return;
    const e = t.getParser();
    if (!e) return;
    const s = this.listener.getSession(this.roomId);
    if (!s) return;
    const r = new _st();
    r.id = e.id, r.level = e.level, r.maximumLevel = e.maximumLevel, r.experience = e.experience, r.levelExperienceGoal = e.levelExperienceGoal, r.energy = e.energy, r.maximumEnergy = e.maximumEnergy, r.happyness = e.happyness, r.maximumHappyness = e.maximumHappyness, r.ownerId = e.ownerId, r.ownerName = e.ownerName, r.respect = e.respect, r.age = e.age, r.unknownRarity = e.unknownRarity, r.saddle = e.saddle, r.rider = e.rider, r.breedable = e.breedable, r.fullyGrown = e.fullyGrown, r.rarityLevel = e.rarityLevel, r.dead = e.dead, r.skillTresholds = e.skillTresholds, r.publiclyRideable = e.publiclyRideable, r.maximumTimeToLive = e.maximumTimeToLive, r.remainingTimeToLive = e.remainingTimeToLive, r.remainingGrowTime = e.remainingGrowTime, r.publiclyBreedable = e.publiclyBreedable, x().dispatchEvent(new gp(s, r));
  }
  onPetStatusUpdateEvent(t) {
    if (!this.listener) return;
    const e = t.getParser();
    if (!e) return;
    const s = this.listener.getSession(this.roomId);
    s && (s.userDataManager.updatePetBreedingStatus(e.roomIndex, e.canBreed, e.canHarvest, e.canRevive, e.hasBreedingPermission), x().dispatchEvent(new mp(s, e.petId, e.canBreed, e.canHarvest, e.canRevive, e.hasBreedingPermission)));
  }
  onPetBreedingMessageEvent(t) {
    if (!this.listener) return;
    const e = t.getParser();
    if (!e) return;
    const s = this.listener.getSession(this.roomId);
    s && x().dispatchEvent(new _p(s, e.state, e.ownPetId, e.otherPetId));
  }
  onPetLevelUpdateMessageEvent(t) {
    if (!this.listener) return;
    const e = t.getParser();
    if (!e) return;
    const s = this.listener.getSession(this.roomId);
    s && (s.userDataManager.updatePetLevel(e.roomIndex, e.level), x().dispatchEvent(new pp(s, e.petId, e.level)));
  }
  onConfirmBreedingResultEvent(t) {
    if (!this.listener) return;
    const e = t.getParser();
    if (!e) return;
    const s = this.listener.getSession(this.roomId);
    s && x().dispatchEvent(new op(s, e.breedingNestStuffId, e.result));
  }
  onNestBreedingSuccessEvent(t) {
    if (!this.listener) return;
    const e = t.getParser();
    if (!e) return;
    const s = this.listener.getSession(this.roomId);
    s && x().dispatchEvent(new cp(s, e.petId, e.rarityCategory));
  }
  onConfirmBreedingRequestEvent(t) {
    if (!this.listener) return;
    const e = t.getParser();
    if (!e) return;
    const s = this.listener.getSession(this.roomId);
    s && x().dispatchEvent(new ap(s, e.nestId, e.pet1, e.pet2, e.rarityCategories, e.resultPetType));
  }
  onPetFigureUpdateEvent(t) {
    if (!this.listener) return;
    const e = t.getParser();
    if (!e) return;
    const s = this.listener.getSession(this.roomId);
    if (!s) return;
    const r = e.figureData.figuredata;
    s.userDataManager.updateFigure(e.roomIndex, r, "", e.hasSaddle, e.isRiding), x().dispatchEvent(new fp(s, e.petId, r));
  }
  onPetBreedingResultEvent(t) {
    if (!this.listener) return;
    const e = t.getParser();
    if (!e) return;
    const s = this.listener.getSession(this.roomId);
    s && x().dispatchEvent(new dp(s, e.resultData, e.otherResultData));
  }
  onPetPlacingError(t) {
    if (!t || !this.listener) return;
    const e = t.getParser();
    if (!e) return;
    const s = this.listener.getSession(this.roomId);
    if (!s) return;
    let r = "";
    switch (e.errorCode) {
      case 0:
        r = We.RSEME_PETS_FORBIDDEN_IN_HOTEL;
        break;
      case 1:
        r = We.RSEME_PETS_FORBIDDEN_IN_FLAT;
        break;
      case 2:
        r = We.RSEME_MAX_PETS;
        break;
      case 3:
        r = We.RSEME_NO_FREE_TILES_FOR_PET;
        break;
      case 4:
        r = We.RSEME_SELECTED_TILE_NOT_FREE_FOR_PET;
        break;
      case 5:
        r = We.RSEME_MAX_NUMBER_OF_OWN_PETS;
        break;
    }
    !r || r.length == 0 || x().dispatchEvent(new We(r, s));
  }
  onBotError(t) {
    if (!t || !this.listener) return;
    const e = t.getParser();
    if (!e) return;
    const s = this.listener.getSession(this.roomId);
    if (!s) return;
    let r = "";
    switch (e.errorCode) {
      case 0:
        r = We.RSEME_BOTS_FORBIDDEN_IN_HOTEL;
        break;
      case 1:
        r = We.RSEME_BOTS_FORBIDDEN_IN_FLAT;
        break;
      case 2:
        r = We.RSEME_BOT_LIMIT_REACHED;
        break;
      case 3:
        r = We.RSEME_SELECTED_TILE_NOT_FREE_FOR_BOT;
        break;
      case 4:
        r = We.RSEME_BOT_NAME_NOT_ACCEPTED;
        break;
    }
    !r || r.length == 0 || x().dispatchEvent(new We(r, s));
  }
  onFavoriteMembershipUpdateMessageEvent(t) {
    if (!this.listener) return;
    const e = t.getParser(), s = this.listener.getSession(this.roomId);
    if (!s) return;
    const r = s.userDataManager.getUserDataByIndex(e.roomIndex);
    r && (r.groupId = e.groupId, r.groupName = e.groupName, x().dispatchEvent(new up(s, e.roomIndex, e.groupId, e.status, e.groupName)));
  }
}
class gst extends gi {
  constructor(t, e) {
    super(t, e), t.addMessageEvent(new lC(this.onQuestionEvent.bind(this))), t.addMessageEvent(new uC(this.onQuestionAnsweredEvent.bind(this))), t.addMessageEvent(new cC(this.onQuestionFinishedEvent.bind(this)));
  }
  onQuestionEvent(t) {
    if (!this.listener) return;
    const e = this.listener.getSession(this.roomId);
    if (!e) return;
    const s = t.getParser();
    if (!s) return;
    const r = new Pr(Pr.QUESTION, e, s.pollId);
    r.question = s.question, r.duration = s.duration, r.pollType = s.pollType, r.questionId = s.questionId, r.pollId = s.pollId, x().dispatchEvent(r);
  }
  onQuestionAnsweredEvent(t) {
    if (!this.listener) return;
    const e = this.listener.getSession(this.roomId);
    if (!e) return;
    const s = t.getParser();
    if (!s) return;
    const r = new Pr(Pr.ANSWERED, e, s.userId);
    r.value = s.value, r.userId = s.userId, r.answerCounts = s.answerCounts, x().dispatchEvent(r);
  }
  onQuestionFinishedEvent(t) {
    if (!this.listener) return;
    const e = this.listener.getSession(this.roomId);
    if (!e) return;
    const s = t.getParser();
    if (!s) return;
    const r = new Pr(Pr.FINISHED, e);
    r.questionId = s.questionId, r.answerCounts = s.answerCounts, x().dispatchEvent(r);
  }
}
class pst {
  constructor() {
    this._handlers = [], this._sessions = /* @__PURE__ */ new Map(), this._pendingSession = null, this._sessionStarting = !1, this._viewerSession = null;
  }
  async init() {
    this.createHandlers(), this.processPendingSession();
  }
  createHandlers() {
    const t = G().connection;
    t && this._handlers.push(
      new ost(t, this),
      new hst(t, this),
      new ust(t, this),
      new lst(t, this),
      new $a(t, this),
      new fst(t, this),
      new cst(t, this),
      new rst(t, this),
      new gst(t, this),
      new ast(t, this),
      new nst(t, this)
    );
  }
  setHandlers(t) {
    if (!(!this._handlers || !this._handlers.length))
      for (const e of this._handlers)
        e && e.setRoomId(t.roomId);
  }
  processPendingSession() {
    this._pendingSession && (this.addSession(this._pendingSession), this._pendingSession = null);
  }
  getSession(t) {
    const e = this._sessions.get(this.getRoomId(t));
    return e || null;
  }
  createSession(t, e = null) {
    const s = new ist();
    return s.roomId = t, s.password = e, this.addSession(s);
  }
  addSession(t) {
    return this._sessionStarting = !0, this._sessions.get(this.getRoomId(t.roomId)) && this.removeSession(t.roomId, !1), this._sessions.set(this.getRoomId(t.roomId), t), x().dispatchEvent(new mt(mt.CREATED, t)), this._viewerSession = t, this.startSession(this._viewerSession), !0;
  }
  startSession(t) {
    return t.state === mt.STARTED ? !1 : (this._sessionStarting = !1, t.start() ? (x().dispatchEvent(new mt(mt.STARTED, t)), this.setHandlers(t), !0) : (this.removeSession(t.roomId), !1));
  }
  removeSession(t, e = !0) {
    const s = this.getSession(t);
    s && (this._sessions.delete(this.getRoomId(t)), x().dispatchEvent(new mt(mt.ENDED, s, e)));
  }
  sessionUpdate(t, e) {
    if (this.getSession(t))
      switch (e) {
        case $a.RS_CONNECTED:
          return;
        case $a.RS_READY:
          return;
        case $a.RS_DISCONNECTED:
          this.removeSession(t);
          return;
      }
  }
  sessionReinitialize(t, e) {
    const s = this.getSession(t);
    s && (this._sessions.delete(this.getRoomId(t)), s.reset(e), this._sessions.set(this.getRoomId(e), s), this.setHandlers(s));
  }
  getRoomId(t) {
    return "hard_coded_room_id";
  }
  get viewerSession() {
    return this._viewerSession;
  }
}
const mst = new pst(), Zr = () => mst;
class Est {
  constructor() {
    this._groupBadges = /* @__PURE__ */ new Map();
  }
  init() {
    G().registerMessageEvent(new jo(this.onRoomReadyMessageEvent.bind(this))), G().registerMessageEvent(new FC(this.onGroupBadgesEvent.bind(this)));
  }
  onRoomReadyMessageEvent(t) {
    G().connection.send(new cM());
  }
  onGroupBadgesEvent(t) {
    const e = t.getParser();
    for (const [s, r] of e.badges.entries()) this._groupBadges.set(s, r);
  }
  getGroupBadge(t) {
    return this._groupBadges.get(t) ?? "";
  }
}
class Tst {
  constructor() {
    this._ignoredUsers = [];
  }
  init() {
    G().registerMessageEvent(new wC(this.onIgnoredUsersEvent.bind(this))), G().registerMessageEvent(new cI(this.onIgnoreResultEvent.bind(this)));
  }
  requestIgnoredUsers(t) {
    G().connection.send(new rM(t));
  }
  onIgnoredUsersEvent(t) {
    if (!t) return;
    const e = t.getParser();
    e && (this._ignoredUsers = e.ignoredUsers);
  }
  onIgnoreResultEvent(t) {
    if (!t) return;
    const e = t.getParser();
    if (!e) return;
    const s = e.name;
    switch (e.result) {
      case 0:
        return;
      case 1:
        this.addUserToIgnoreList(s);
        return;
      case 2:
        this.addUserToIgnoreList(s), this._ignoredUsers.shift();
        return;
      case 3:
        this.removeUserFromIgnoreList(s);
        return;
    }
  }
  addUserToIgnoreList(t) {
    this._ignoredUsers.indexOf(t) < 0 && this._ignoredUsers.push(t);
  }
  removeUserFromIgnoreList(t) {
    const e = this._ignoredUsers.indexOf(t);
    e >= 0 && this._ignoredUsers.splice(e, 1);
  }
  ignoreUserId(t) {
    G().connection.send(new oM(t));
  }
  ignoreUser(t) {
    G().connection.send(new aM(t));
  }
  unignoreUser(t) {
    G().connection.send(new hM(t));
  }
  isIgnored(t) {
    return this._ignoredUsers.indexOf(t) >= 0;
  }
}
class yR {
  constructor(t, e) {
    this._image = t, this._placeHolder = e;
  }
  get image() {
    return this._image;
  }
  get placeHolder() {
    return this._placeHolder;
  }
}
class Ist {
  constructor(t) {
    this._code = t, this._parts = [];
  }
  get code() {
    return this._code;
  }
  get parts() {
    return this._parts;
  }
}
const he = class he {
  constructor(t, e = 0, s = 0, r = 0) {
    this.type = t, this.key = e, this.color = s, this.position = r;
  }
  get code() {
    return this.key === 0 ? null : he.getCode(this.type, this.key, this.color, this.position);
  }
  static getCode(t, e, s, r) {
    return (t === he.BASE ? t : e >= 100 ? he.SYMBOL_ALT : he.SYMBOL) + (e < 10 ? "0" : "") + (t === he.BASE ? e : e >= 100 ? e - 100 : e) + (s < 10 ? "0" : "") + s + r;
  }
  calculatePosition(t) {
    const e = this.calculateGridPos(this.position);
    let s = he.CELL_WIDTH * e.x + he.CELL_WIDTH / 2 - t.width / 2, r = he.CELL_HEIGHT * e.y + he.CELL_HEIGHT / 2 - t.height / 2;
    return s < 0 && (s = 0), s + t.width > he.IMAGE_WIDTH && (s = he.IMAGE_WIDTH - t.width), r < 0 && (r = 0), r + t.height > he.IMAGE_HEIGHT && (r = he.IMAGE_HEIGHT - t.height), new st(Math.floor(s), Math.floor(r));
  }
  calculateGridPos(t) {
    const e = new st();
    return e.x = Math.floor(t % 3), e.y = Math.floor(t / 3), e;
  }
};
he.BASE = "b", he.SYMBOL = "s", he.SYMBOL_ALT = "t", he.BASE_PART = 0, he.LAYER_PART = 1, he.IMAGE_WIDTH = 39, he.IMAGE_HEIGHT = 39, he.CELL_WIDTH = 13, he.CELL_HEIGHT = 13;
let Mh = he;
const ks = class ks {
  constructor() {
    this._groupBases = /* @__PURE__ */ new Map(), this._groupSymbols = /* @__PURE__ */ new Map(), this._groupPartColors = /* @__PURE__ */ new Map(), this._requestedBadges = /* @__PURE__ */ new Map(), this._groupBadgesQueue = /* @__PURE__ */ new Map(), this._readyToGenerateGroupBadges = !1;
  }
  async init() {
    G().registerMessageEvent(new Wv(this.onGroupBadgePartsEvent.bind(this)));
  }
  getBadgeImage(t, e = ks.NORMAL_BADGE, s = !0) {
    return this.getBadgeTexture(t, e);
  }
  getBadgeInfo(t) {
    const e = this.getBadgeTexture(t);
    return e ? new yR(e, !1) : new yR(this.getBadgePlaceholder(), !0);
  }
  loadBadgeImage(t, e = ks.NORMAL_BADGE) {
    return Rt().getTexture(this.getBadgeUrl(t, e)) ? t : (this.getBadgeTexture(t, e), null);
  }
  getBadgeTexture(t, e = ks.NORMAL_BADGE) {
    const s = this.getBadgeUrl(t, e);
    if (!s || !s.length) return null;
    const r = Rt().getTexture(s);
    if (r) return r;
    if (e === ks.NORMAL_BADGE)
      (async () => {
        try {
          if (!await Rt().downloadAsset(s)) return;
          const a = Rt().getTexture(s);
          a && x().dispatchEvent(new Vo(t, a));
        } catch (a) {
          rt.error(a);
        }
      })();
    else if (e === ks.GROUP_BADGE) {
      if (this._groupBadgesQueue.get(t)) return;
      this._groupBadgesQueue.set(t, !0), this._readyToGenerateGroupBadges && this.loadGroupBadge(t);
    }
    return this.getBadgePlaceholder();
  }
  getBadgePlaceholder() {
    return Rt().getTexture(Ct().getValue("images.url") + "/loading_icon.png");
  }
  getBadgeUrl(t, e = ks.NORMAL_BADGE) {
    let s = null;
    switch (e) {
      case ks.NORMAL_BADGE:
        s = Ct().getValue("badge.asset.url").replace("%badgename%", t);
        break;
      case ks.GROUP_BADGE:
        s = t;
        break;
    }
    return s;
  }
  loadGroupBadge(t) {
    const e = new Ist(t), s = [...t.matchAll(/[b|s][0-9]{4,6}/g)];
    for (const r of s) {
      const n = r[0], a = n.length === 6, o = n[0], h = parseInt(n.slice(1, a ? 3 : 4)), u = parseInt(n.slice(a ? 3 : 4, a ? 5 : 6)), c = n.length < 6 ? 0 : parseInt(n.slice(a ? 5 : 6, a ? 6 : 7)), l = new Mh(o, h, u, c);
      e.parts.push(l);
    }
    this.renderGroupBadge(e);
  }
  renderGroupBadge(t) {
    const e = new Qt(), s = new Ft(W.EMPTY);
    s.width = Mh.IMAGE_WIDTH, s.height = Mh.IMAGE_HEIGHT, e.addChild(s);
    for (const n of t.parts) {
      let a = !0;
      const o = n.type === "b" ? this._groupBases.get(n.key) : this._groupSymbols.get(n.key);
      if (o)
        for (const h of o) {
          if (!h || !h.length) continue;
          const u = Rt().getTexture(`badgepart_${h}`);
          if (!u) continue;
          const { x: c, y: l } = n.calculatePosition(u), _ = new Ft(u);
          _.position.set(c, l), a && (_.tint = parseInt(this._groupPartColors.get(n.color), 16)), a = !1, e.addChild(_);
        }
    }
    this._requestedBadges.delete(t.code), this._groupBadgesQueue.delete(t.code);
    const r = le.generateTexture(e);
    Rt().setTexture(t.code, r), x().dispatchEvent(new Vo(t.code, r));
  }
  onGroupBadgePartsEvent(t) {
    if (!t) return;
    const e = t.getParser();
    if (e) {
      e.bases.forEach((s, r) => this._groupBases.set(r, s.map((n) => n.replace(".png", "").replace(".gif", "")))), e.symbols.forEach((s, r) => this._groupSymbols.set(r, s.map((n) => n.replace(".png", "").replace(".gif", "")))), this._groupPartColors = e.partColors, this._readyToGenerateGroupBadges = !0;
      for (const s of this._groupBadgesQueue.keys()) this.loadGroupBadge(s);
    }
  }
};
ks.GROUP_BADGE = "group_badge", ks.NORMAL_BADGE = "normal_badge";
let Za = ks;
class vR {
  constructor(t, e, s, r, n, a, o, h, u, c, l, _, d, f, p, g, m, O, y, C, b, D, P, F, M, U, k, ft, K) {
    this._type = t, this._id = e, this._fullName = s, this._className = r, this._category = n, this._revision = h, this._tileSizeX = u, this._tileSizeY = c, this._tileSizeZ = l, this._colors = _, this._hasIndexedColor = d, this._colourIndex = f, this._localizedName = a, this._description = o, this._adUrl = p, this._purchaseOfferId = g, this._purchaseCouldBeUsedForBuyout = m, this._rentOfferId = O, this._rentCouldBeUsedForBuyout = y, this._customParams = b, this._specialType = D, this._availableForBuildersClub = C, this._canStandOn = P, this._canSitOn = F, this._canLayOn = M, this._excludedFromDynamic = U, this._furniLine = k, this._environment = ft, this._rare = K;
  }
  get type() {
    return this._type;
  }
  get id() {
    return this._id;
  }
  get className() {
    return this._className;
  }
  set className(t) {
    this._className = t;
  }
  get fullName() {
    return this._fullName;
  }
  get category() {
    return this._category;
  }
  get hasIndexedColor() {
    return this._hasIndexedColor;
  }
  get colorIndex() {
    return this._colourIndex;
  }
  get revision() {
    return this._revision;
  }
  get tileSizeX() {
    return this._tileSizeX;
  }
  get tileSizeY() {
    return this._tileSizeY;
  }
  get tileSizeZ() {
    return this._tileSizeZ;
  }
  get colors() {
    return this._colors;
  }
  get name() {
    return this._localizedName;
  }
  get description() {
    return this._description;
  }
  get adUrl() {
    return this._adUrl;
  }
  get purchaseOfferId() {
    return this._purchaseOfferId;
  }
  get customParams() {
    return this._customParams;
  }
  get specialType() {
    return this._specialType;
  }
  get rentOfferId() {
    return this._rentOfferId;
  }
  get purchaseCouldBeUsedForBuyout() {
    return this._purchaseCouldBeUsedForBuyout;
  }
  get rentCouldBeUsedForBuyout() {
    return this._rentCouldBeUsedForBuyout;
  }
  get availableForBuildersClub() {
    return this._availableForBuildersClub;
  }
  get canStandOn() {
    return this._canStandOn;
  }
  get canSitOn() {
    return this._canSitOn;
  }
  get canLayOn() {
    return this._canLayOn;
  }
  get isExternalImage() {
    return this._className.indexOf("external_image") !== -1;
  }
  get excludeDynamic() {
    return this._excludedFromDynamic;
  }
  get furniLine() {
    return this._furniLine;
  }
  get environment() {
    return this._environment;
  }
  get rare() {
    return this._rare;
  }
}
class Sst {
  constructor(t, e) {
    this._floorItems = t, this._wallItems = e;
  }
  async init() {
    const t = Ct().getValue("furnidata.url");
    if (!t || !t.length) throw new Error("invalid furni data url");
    const e = await fetch(t);
    if (e.status !== 200) throw new Error("Invalid furni data file");
    const s = await e.json();
    s.roomitemtypes && this.parseFloorItems(s.roomitemtypes), s.wallitemtypes && this.parseWallItems(s.wallitemtypes);
  }
  parseFloorItems(t) {
    if (!(!t || !t.furnitype))
      for (const e of t.furnitype) {
        if (!e) continue;
        const s = [];
        if (e.partcolors)
          for (const u of e.partcolors.color) {
            let c = u;
            c.charAt(0) === "#" && (c = c.replace("#", "")), s.push(parseInt(c, 16));
          }
        const r = e.classname.split("*"), n = r[0], a = r.length > 1 ? parseInt(r[1]) : 0, o = r.length > 1, h = new vR(en.FLOOR, e.id, e.classname, n, e.category, e.name, e.description, e.revision, e.xdim, e.ydim, 0, s, o, a, e.adurl, e.offerid, e.buyout, e.rentofferid, e.rentbuyout, e.bc, e.customparams, e.specialtype, e.canstandon, e.cansiton, e.canlayon, e.excludeddynamic, e.furniline, e.environment, e.rare);
        this._floorItems.set(h.id, h), this.updateLocalizations(h);
      }
  }
  parseWallItems(t) {
    if (!(!t || !t.furnitype))
      for (const e of t.furnitype) {
        if (!e) continue;
        const s = new vR(en.WALL, e.id, e.classname, e.classname, e.category, e.name, e.description, e.revision, 0, 0, 0, null, !1, 0, e.adurl, e.offerid, e.buyout, e.rentofferid, e.rentbuyout, e.bc, null, e.specialtype, !1, !1, !1, e.excludeddynamic, e.furniline, e.environment, e.rare);
        this._wallItems.set(s.id, s), this.updateLocalizations(s);
      }
  }
  updateLocalizations(t) {
    switch (t.type) {
      case en.FLOOR:
        pl().setValue("roomItem.name." + t.id, t.name), pl().setValue("roomItem.desc." + t.id, t.description);
        return;
      case en.WALL:
        pl().setValue("wallItem.name." + t.id, t.name), pl().setValue("wallItem.desc." + t.id, t.description);
        return;
    }
  }
}
class Ast {
  constructor(t, e, s) {
    this._type = t, this._name = e, this._description = s;
  }
  get type() {
    return this._type;
  }
  get name() {
    return this._name;
  }
  get description() {
    return this._description;
  }
}
class Rst {
  constructor(t) {
    this._products = t;
  }
  async init() {
    const t = Ct().getValue("productdata.url");
    if (!t || !t.length) throw new Error("invalid product data url");
    const e = await fetch(t);
    if (e.status !== 200) throw new Error("Invalid product data file");
    const s = await e.json();
    this.parseProducts(s.productdata);
  }
  parseProducts(t) {
    if (t)
      for (const e of t.product) e && this._products.set(e.code, new Ast(e.code, e.name, e.description));
  }
}
class Ost {
  constructor() {
    this._ignoredUsersManager = new Tst(), this._groupInformationManager = new Est(), this._clubLevel = 0, this._securityLevel = 0, this._isAmbassador = !1, this._noobnessLevel = -1, this._isEmailVerified = !1, this._systemOpen = !1, this._systemShutdown = !1, this._isAuthenticHabbo = !1, this._isRoomCameraFollowDisabled = !1, this._uiFlags = 0, this._floorItems = /* @__PURE__ */ new Map(), this._wallItems = /* @__PURE__ */ new Map(), this._products = /* @__PURE__ */ new Map(), this._furnitureData = new Sst(this._floorItems, this._wallItems), this._productData = new Rst(this._products), this._tags = [], this._badgeImageManager = new Za(), this.resetUserInfo();
  }
  async init() {
    await Promise.all([
      this._furnitureData.init(),
      this._productData.init(),
      this._badgeImageManager.init(),
      this._ignoredUsersManager.init(),
      this._groupInformationManager.init()
    ]), G().registerMessageEvent(new Vv((t) => {
      this._figure = t.getParser().figure, this._gender = t.getParser().gender, Tu.updateFigure(this._figure);
    })), G().registerMessageEvent(new Mc(this.onUserInfoEvent.bind(this))), G().registerMessageEvent(new PC(this.onUserPermissionsEvent.bind(this))), G().registerMessageEvent(new zv(this.onAvailabilityStatusMessageEvent.bind(this))), G().registerMessageEvent(new nC(this.onPetRespectFailed.bind(this))), G().registerMessageEvent(new Lu(this.onChangeNameUpdateEvent.bind(this))), G().registerMessageEvent(new lI(this.onUserNameChangeMessageEvent.bind(this))), G().registerMessageEvent(new DC(this.onUserTags.bind(this))), G().registerMessageEvent(new jo(this.onRoomModelNameEvent.bind(this))), G().registerMessageEvent(new GC(this.onInClientLinkEvent.bind(this))), G().registerMessageEvent(new Qv(this.onMysteryBoxKeysEvent.bind(this))), G().registerMessageEvent(new jv(this.onNoobnessLevelMessageEvent.bind(this))), G().registerMessageEvent(new NC(this.onAccountSafetyLockStatusChangeMessageEvent.bind(this))), G().registerMessageEvent(new LC(this.onEmailStatus.bind(this))), x().addEventListener(Mu.SETTINGS_UPDATED, (t) => {
      this._isRoomCameraFollowDisabled = t.cameraFollow, this._uiFlags = t.flags, x().dispatchEvent(new Sp(this._uiFlags));
    });
  }
  resetUserInfo() {
    this._userId = 0, this._name = null, this._figure = null, this._gender = null, this._realName = null, this._canChangeName = !1, this._safetyLocked = !1;
  }
  getAllFurnitureData() {
    return [...Array.from(this._floorItems.values()), ...Array.from(this._wallItems.values())];
  }
  onUserInfoEvent(t) {
    if (!t || !t.connection) return;
    this.resetUserInfo();
    const e = t.getParser().userInfo;
    e && (this._userId = e.userId, this._name = e.username, this._figure = e.figure, this._gender = e.gender, this._realName = e.realName, this._respectsReceived = e.respectsReceived, this._respectsLeft = e.respectsRemaining, this._respectsPetLeft = e.respectsPetRemaining, this._canChangeName = e.canChangeName, this._safetyLocked = e.safetyLocked, this._ignoredUsersManager.requestIgnoredUsers(e.username));
  }
  onUserPermissionsEvent(t) {
    !t || !t.connection || (this._clubLevel = t.getParser().clubLevel, this._securityLevel = t.getParser().securityLevel, this._isAmbassador = t.getParser().isAmbassador);
  }
  onAvailabilityStatusMessageEvent(t) {
    if (!t || !t.connection) return;
    const e = t.getParser();
    e && (this._systemOpen = e.isOpen, this._systemShutdown = e.onShutdown, this._isAuthenticHabbo = e.isAuthenticUser);
  }
  onPetRespectFailed(t) {
    !t || !t.connection || this._respectsPetLeft++;
  }
  onChangeNameUpdateEvent(t) {
    if (!t || !t.connection) return;
    const e = t.getParser();
    e && e.resultCode === Lu.NAME_OK && (this._canChangeName = !1, x().dispatchEvent(new fc(e.name)));
  }
  onUserNameChangeMessageEvent(t) {
    if (!t || !t.connection) return;
    const e = t.getParser();
    e && e.webId === this.userId && (this._name = e.newName, this._canChangeName = !1, x().dispatchEvent(new fc(this._name)));
  }
  onUserTags(t) {
    if (!t || !t.connection) return;
    const e = t.getParser();
    e && (this._tags = e.tags);
  }
  onRoomModelNameEvent(t) {
    if (!t) return;
    const e = t.getParser();
    e && Tu.roomVisited(e.roomId);
  }
  onInClientLinkEvent(t) {
    if (!t) return;
    const e = t.getParser();
    e && wg(e.link);
  }
  onMysteryBoxKeysEvent(t) {
    if (!t) return;
    const e = t.getParser();
    e && x().dispatchEvent(new np(e.boxColor, e.keyColor));
  }
  onNoobnessLevelMessageEvent(t) {
    this._noobnessLevel = t.getParser().noobnessLevel, this._noobnessLevel !== Rh.OLD_IDENTITY && Ct().setValue("new.identity", 1);
  }
  onAccountSafetyLockStatusChangeMessageEvent(t) {
    if (!t) return;
    const e = t.getParser();
    e && (this._safetyLocked = e.status === pc.SAFETY_LOCK_STATUS_LOCKED);
  }
  onEmailStatus(t) {
    var e;
    this._isEmailVerified = ((e = t == null ? void 0 : t.getParser()) == null ? void 0 : e.isVerified) ?? !1;
  }
  getFloorItemData(t) {
    const e = this._floorItems.get(t);
    return e || null;
  }
  getFloorItemDataByName(t) {
    if (!t || !this._floorItems || !this._floorItems.size) return null;
    for (const e of this._floorItems.values())
      if (!(!e || e.className !== t))
        return e;
    return null;
  }
  getWallItemData(t) {
    const e = this._wallItems.get(t);
    return e || null;
  }
  getWallItemDataByName(t) {
    if (!t || !this._wallItems || !this._wallItems.size) return null;
    for (const e of this._wallItems.values())
      if (!(!e || e.className !== t))
        return e;
    return null;
  }
  getProductData(t) {
    return this._products.get(t);
  }
  getBadgeUrl(t) {
    return this._badgeImageManager.getBadgeUrl(t);
  }
  getGroupBadgeUrl(t) {
    return this._badgeImageManager.getBadgeUrl(t, Za.GROUP_BADGE);
  }
  getBadgeImage(t) {
    return this._badgeImageManager.getBadgeImage(t);
  }
  getGroupBadgeImage(t) {
    return this._badgeImageManager.getBadgeImage(t, Za.GROUP_BADGE);
  }
  getUserTags(t) {
    t < 0 || this.send(new nM(t));
  }
  loadBadgeImage(t) {
    return this._badgeImageManager.loadBadgeImage(t);
  }
  loadGroupBadgeImage(t) {
    return this._badgeImageManager.loadBadgeImage(t, Za.GROUP_BADGE);
  }
  hasSecurity(t) {
    return this._securityLevel >= t;
  }
  giveRespect(t) {
    t < 0 || this._respectsLeft <= 0 || (this.send(new _M(t)), this._respectsLeft--);
  }
  givePetRespect(t) {
    t < 0 || this._respectsPetLeft <= 0 || (this.send(new qC(t)), this._respectsPetLeft--);
  }
  sendSpecialCommandMessage(t, e = 0) {
    this.send(new dI(t));
  }
  ignoreUser(t) {
    this._ignoredUsersManager.ignoreUser(t);
  }
  unignoreUser(t) {
    this._ignoredUsersManager.unignoreUser(t);
  }
  isUserIgnored(t) {
    return this._ignoredUsersManager.isIgnored(t);
  }
  getGroupBadge(t) {
    return this._groupInformationManager.getGroupBadge(t);
  }
  send(t) {
    G().connection.send(t);
  }
  get userId() {
    return this._userId;
  }
  get userName() {
    return this._name;
  }
  get figure() {
    return this._figure;
  }
  get gender() {
    return this._gender;
  }
  get realName() {
    return this._realName;
  }
  get ignoredUsersManager() {
    return this._ignoredUsersManager;
  }
  get groupInformationManager() {
    return this._groupInformationManager;
  }
  get respectsReceived() {
    return this._respectsReceived;
  }
  get respectsLeft() {
    return this._respectsLeft;
  }
  get respectsPetLeft() {
    return this._respectsPetLeft;
  }
  get canChangeName() {
    return this._canChangeName;
  }
  get clubLevel() {
    return this._clubLevel;
  }
  get securityLevel() {
    return this._securityLevel;
  }
  get isAmbassador() {
    return this._isAmbassador;
  }
  get isEmailVerified() {
    return this._isEmailVerified;
  }
  get isNoob() {
    return this._noobnessLevel !== Rh.OLD_IDENTITY;
  }
  get isRealNoob() {
    return this._noobnessLevel === Rh.REAL_NOOB;
  }
  get isSystemOpen() {
    return this._systemOpen;
  }
  get isSystemShutdown() {
    return this._systemShutdown;
  }
  get isAuthenticHabbo() {
    return this._isAuthenticHabbo;
  }
  get isModerator() {
    return this._securityLevel >= Lg.MODERATOR;
  }
  get isCameraFollowDisabled() {
    return this._isRoomCameraFollowDisabled;
  }
  get uiFlags() {
    return this._uiFlags;
  }
  get tags() {
    return this._tags;
  }
}
const yst = new Ost(), Xo = () => yst, iu = class iu {
};
iu.NO_CLUB = 0, iu.CLUB = 1, iu.VIP = 2;
let CR = iu;
const ru = class ru {
  constructor(t, e, s, r, n, a, o) {
    this._layerTags = [], this._primaryColor = t & 16777215, this._secondaryColor = e & 16777215, this._breed = s, this._tag = r > -1 && r < ru.COLOR_TAGS.length ? ru.COLOR_TAGS[r] : "", this._id = n, this._isMaster = a, this._layerTags = o;
  }
  get primaryColor() {
    return this._primaryColor;
  }
  get secondaryColor() {
    return this._secondaryColor;
  }
  get breed() {
    return this._breed;
  }
  get tag() {
    return this._tag;
  }
  get id() {
    return this._id;
  }
  get isMaster() {
    return this._isMaster;
  }
  get layerTags() {
    return this._layerTags;
  }
};
ru.COLOR_TAGS = ["Null", "Black", "White", "Grey", "Red", "Orange", "Pink", "Green", "Lime", "Blue", "Light-Blue", "Dark-Blue", "Yellow", "Brown", "Dark-Brown", "Beige", "Cyan", "Purple", "Gold"];
let Pc = ru;
const Bt = class Bt {
  constructor() {
    this._images = /* @__PURE__ */ new Map(), this._activeObjects = {}, this._activeObjectTypes = /* @__PURE__ */ new Map(), this._activeObjectTypeIds = /* @__PURE__ */ new Map(), this._objectTypeAdUrls = /* @__PURE__ */ new Map(), this._wallItems = {}, this._wallItemTypes = /* @__PURE__ */ new Map(), this._wallItemTypeIds = /* @__PURE__ */ new Map(), this._furniRevisions = /* @__PURE__ */ new Map(), this._pets = {}, this._petColors = /* @__PURE__ */ new Map(), this._objectAliases = /* @__PURE__ */ new Map(), this._objectOriginalNames = /* @__PURE__ */ new Map(), this._pendingContentTypes = [];
  }
  async init() {
    this.processFurnitureData(Xo().getAllFurnitureData());
    for (const [t, e] of Ct().getValue("pet.types").entries()) this._pets[e] = t;
    await Promise.all(Bt.MANDATORY_LIBRARIES.map((t) => this.downloadAsset(t)));
  }
  processFurnitureData(t) {
    if (t)
      for (const e of t) {
        if (!e) continue;
        const s = e.id;
        let r = e.className;
        e.hasIndexedColor && (r = r + "*" + e.colorIndex);
        const n = e.revision, a = e.adUrl;
        a && a.length > 0 && this._objectTypeAdUrls.set(r, a);
        let o = e.className;
        e.type === en.FLOOR ? (this._activeObjectTypes.set(s, r), this._activeObjectTypeIds.set(r, s), this._activeObjects[o] || (this._activeObjects[o] = 1)) : e.type === en.WALL && (o === "post.it" && (r = "post_it", o = "post_it"), o === "post.it.vd" && (r = "post_it_vd", o = "post_id_vd"), this._wallItemTypes.set(s, r), this._wallItemTypeIds.set(r, s), this._wallItems[o] || (this._wallItems[o] = 1));
        const h = this._furniRevisions.get(o);
        n > h && (this._furniRevisions.delete(o), this._furniRevisions.set(o, n));
      }
  }
  getFurnitureFloorNameForTypeId(t) {
    const e = this._activeObjectTypes.get(t);
    return this.removeColorIndex(e);
  }
  getFurnitureWallNameForTypeId(t, e = null) {
    let s = this._wallItemTypes.get(t);
    return s === "poster" && e !== null && (s = s + e), this.removeColorIndex(s);
  }
  getFurnitureFloorColorIndex(t) {
    const e = this._activeObjectTypes.get(t);
    return e ? this.getColorIndexFromName(e) : -1;
  }
  getFurnitureWallColorIndex(t) {
    const e = this._wallItemTypes.get(t);
    return e ? this.getColorIndexFromName(e) : -1;
  }
  getColorIndexFromName(t) {
    if (!t) return -1;
    const e = t.indexOf("*");
    return e === -1 ? 0 : parseInt(t.substr(e + 1));
  }
  removeColorIndex(t) {
    if (!t) return null;
    const e = t.indexOf("*");
    return e === -1 ? t : t.substr(0, e);
  }
  getRoomObjectAdUrl(t) {
    const e = this._objectTypeAdUrls.get(t);
    return e || "";
  }
  getPetColorResult(t, e) {
    const s = this._petColors.get(t);
    return s ? s.get(e) : null;
  }
  getPetColorResultsForTag(t, e) {
    const s = this._petColors.get(t), r = [];
    if (s)
      for (const n of s.values())
        n.tag === e && r.push(n);
    return r;
  }
  getCollection(t) {
    return Rt().getCollection(t);
  }
  getImage(t) {
    if (!t) return null;
    const e = this._images.get(t);
    if (!e) return null;
    const s = new Image();
    return s.src = e.src, s;
  }
  addAssetToCollection(t, e, s, r = !0) {
    return Rt().addAssetToCollection(t, e, s, r);
  }
  getPlaceholderName(t) {
    switch (this.getCategoryForType(t)) {
      case L.FLOOR:
        return Bt.PLACE_HOLDER;
      case L.WALL:
        return Bt.PLACE_HOLDER_WALL;
      default:
        return this._pets[t] !== void 0 ? Bt.PLACE_HOLDER_PET : Bt.PLACE_HOLDER_DEFAULT;
    }
  }
  getCategoryForType(t) {
    return t ? this._activeObjects[t] !== void 0 ? L.FLOOR : this._wallItems[t] !== void 0 ? L.WALL : this._pets[t] !== void 0 ? L.UNIT : t.indexOf("poster") === 0 ? L.WALL : t === "room" ? L.ROOM : t === Xt.USER || t === Xt.PET || t === Xt.BOT || t === Xt.RENTABLE_BOT ? L.UNIT : t === Bt.TILE_CURSOR || t === Bt.SELECTION_ARROW ? L.CURSOR : L.MINIMUM : L.MINIMUM;
  }
  getPetNameForType(t) {
    return Ct().getValue("pet.types")[t] || null;
  }
  isLoaderType(t) {
    return t = Xt.getRealType(t), t !== j.USER;
  }
  downloadImage(t, e, s, r = null) {
    let n = null, a = [];
    if (e && e.indexOf(",") >= 0 && (n = e, e = n.split(",")[0]), n ? a = this.getAssetUrls(n, s, !0) : a = this.getAssetUrls(e, s, !0), a && a.length) {
      const o = a[0], h = new Image();
      return h.src = o, h.onload = () => {
        h.onerror = null, this._images.set([e, s].join("_"), h), this._iconListener.onRoomContentLoaded(t, [e, s].join("_"), !0);
      }, h.onerror = () => {
        h.onload = null, rt.error("Failed to download asset", o), this._iconListener.onRoomContentLoaded(t, [e, s].join("_"), !1);
      }, !0;
    }
    return !1;
  }
  downloadAssetSync(t) {
    var s;
    const e = (s = this.getAssetUrls(t)) == null ? void 0 : s[0];
    !e || !e.length || this._pendingContentTypes.indexOf(t) >= 0 || (this._pendingContentTypes.push(t), Rt().downloadAsset(e).then(() => {
      const r = this._pets[t];
      if (r !== void 0) {
        const n = this.getCollection(t), a = n.getPaletteNames(), o = /* @__PURE__ */ new Map();
        for (const h of a) {
          const u = n.getPalette(h), c = n.data.palettes[h], l = u.primaryColor, _ = u.secondaryColor, d = c.breed !== void 0 ? c.breed : 0, f = c.colorTag !== void 0 ? c.colorTag : -1, p = c.master !== void 0 ? c.master : !1, g = c.tags !== void 0 ? c.tags : [];
          o.set(parseInt(h), new Pc(l, _, d, f, h, p, g));
        }
        this._petColors.set(r, o);
      }
      x().dispatchEvent(new bs(bs.RCLE_SUCCESS, t));
    }).catch((r) => {
      x().dispatchEvent(new bs(bs.RCLE_FAILURE, t));
    }));
  }
  async downloadAsset(t) {
    var r;
    const e = (r = this.getAssetUrls(t)) == null ? void 0 : r[0];
    if (!e || !e.length || this._pendingContentTypes.indexOf(t) >= 0) return;
    if (this._pendingContentTypes.push(t), !await Rt().downloadAsset(e)) {
      x().dispatchEvent(new bs(bs.RCLE_FAILURE, t));
      return;
    }
    const s = this._pets[t];
    if (s !== void 0) {
      const n = this.getCollection(t), a = n.getPaletteNames(), o = /* @__PURE__ */ new Map();
      for (const h of a) {
        const u = n.getPalette(h), c = n.data.palettes[h], l = u.primaryColor, _ = u.secondaryColor, d = c.breed !== void 0 ? c.breed : 0, f = c.colorTag !== void 0 ? c.colorTag : -1, p = c.master !== void 0 ? c.master : !1, g = c.tags !== void 0 ? c.tags : [];
        o.set(parseInt(h), new Pc(l, _, d, f, h, p, g));
      }
      this._petColors.set(s, o);
    }
    x().dispatchEvent(new bs(bs.RCLE_SUCCESS, t));
  }
  getAssetAliasName(t) {
    const e = this._objectAliases.get(t);
    return e || t;
  }
  setAssetAliasName(t, e) {
    this._objectAliases.set(t, e), this._objectOriginalNames.set(e, t);
  }
  getAssetOriginalName(t) {
    const e = this._objectOriginalNames.get(t);
    return e || t;
  }
  getAssetUrls(t, e = null, s = !1) {
    switch (t) {
      case Bt.PLACE_HOLDER:
        return [this.getAssetUrlWithGenericBase(Bt.PLACE_HOLDER)];
      case Bt.PLACE_HOLDER_WALL:
        return [this.getAssetUrlWithGenericBase(Bt.PLACE_HOLDER_WALL)];
      case Bt.PLACE_HOLDER_PET:
        return [this.getAssetUrlWithGenericBase(Bt.PLACE_HOLDER_PET)];
      case Bt.ROOM:
        return [this.getAssetUrlWithGenericBase("room")];
      case Bt.TILE_CURSOR:
        return [this.getAssetUrlWithGenericBase(Bt.TILE_CURSOR)];
      case Bt.SELECTION_ARROW:
        return [this.getAssetUrlWithGenericBase(Bt.SELECTION_ARROW)];
      default: {
        const r = this.getCategoryForType(t);
        if (r === L.FLOOR || r === L.WALL) {
          const n = this.getAssetAliasName(t);
          let a = s ? this.getAssetUrlWithFurniIconBase(n) : this.getAssetUrlWithFurniBase(t);
          if (s) {
            const o = e && e !== "" && this._activeObjectTypeIds.has(n + "*" + e);
            a = a.replace(/%param%/gi, o ? "_" + e : "");
          }
          return [a];
        }
        return r === L.UNIT ? [this.getAssetUrlWithPetBase(t)] : null;
      }
    }
  }
  getAssetIconUrl(t, e) {
    let s = null, r = [];
    return t && t.indexOf(",") >= 0 && (s = t, t = s.split(",")[0]), s ? r = this.getAssetUrls(s, e, !0) : r = this.getAssetUrls(t, e, !0), r && r.length ? r[0] : null;
  }
  getAssetUrlWithGenericBase(t) {
    return Ct().getValue("generic.asset.url").replace(/%libname%/gi, t);
  }
  getAssetUrlWithFurniBase(t) {
    return Ct().getValue("furni.asset.url").replace(/%libname%/gi, t);
  }
  getAssetUrlWithFurniIconBase(t) {
    return Ct().getValue("furni.asset.icon.url").replace(/%libname%/gi, t);
  }
  getAssetUrlWithPetBase(t) {
    return Ct().getValue("pet.asset.url").replace(/%libname%/gi, t);
  }
  setRoomObjectRoomId(t, e) {
    const s = t && t.model;
    s && s.setValue(I.OBJECT_ROOM_ID, e);
  }
  setIconListener(t) {
    this._iconListener = t;
  }
  get pets() {
    return this._pets;
  }
};
Bt.PLACE_HOLDER = "place_holder", Bt.PLACE_HOLDER_WALL = "place_holder_wall", Bt.PLACE_HOLDER_PET = "place_holder_pet", Bt.PLACE_HOLDER_DEFAULT = Bt.PLACE_HOLDER, Bt.ROOM = "room", Bt.TILE_CURSOR = "tile_cursor", Bt.SELECTION_ARROW = "selection_arrow", Bt.MANDATORY_LIBRARIES = [Bt.PLACE_HOLDER, Bt.PLACE_HOLDER_WALL, Bt.PLACE_HOLDER_PET, Bt.ROOM, Bt.TILE_CURSOR, Bt.SELECTION_ARROW];
let EE = Bt;
const vst = new EE(), si = () => vst;
class xR {
  constructor(t, e, s, r) {
    this._x = t, this._y = e, this._width = s, this._height = r;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
}
class gM {
  constructor() {
    this._width = 0, this._height = 0, this._wallHeight = 0, this._fixedWallsHeight = 0, this._tileMap = [], this._holeMap = [], this._doors = [], this._dimensions = {
      minX: 0,
      maxX: 0,
      minY: 0,
      maxY: 0
    };
  }
  get width() {
    return this._width;
  }
  set width(t) {
    this._width = t;
  }
  get height() {
    return this._height;
  }
  set height(t) {
    this._height = t;
  }
  get wallHeight() {
    return this._wallHeight;
  }
  set wallHeight(t) {
    this._wallHeight = t;
  }
  get fixedWallsHeight() {
    return this._fixedWallsHeight;
  }
  set fixedWallsHeight(t) {
    this._fixedWallsHeight = t;
  }
  get tileMap() {
    return this._tileMap;
  }
  get holeMap() {
    return this._holeMap;
  }
  get doors() {
    return this._doors;
  }
  get dimensions() {
    return this._dimensions;
  }
}
class Cst {
  constructor() {
    this._masks = [];
  }
  get masks() {
    return this._masks;
  }
}
class pM {
  constructor() {
    this._map = /* @__PURE__ */ new Map(), this._updateCounter = 0;
  }
  dispose() {
    this._map.clear(), this._updateCounter = 0;
  }
  getValue(t) {
    return this._map.get(t);
  }
  setValue(t, e) {
    this._map.has(t) && this._map.get(t) === e || (this._map.set(t, e), this._updateCounter++);
  }
  removeKey(t) {
    t && (this._map.delete(t), this._updateCounter++);
  }
  get updateCounter() {
    return this._updateCounter;
  }
}
const ud = class ud {
  constructor(t, e, s) {
    this._model = new pM(), this._location = new v(), this._direction = new v(), this._states = [], this._visualization = null, this._logic = null, this._pendingLogicMessages = [], this._updateCounter = 0, this._isReady = !1, this._id = t, this._instanceId = ud.OBJECT_COUNTER++, this._type = s;
    let r = e - 1;
    for (; r >= 0; )
      this._states[r] = 0, r--;
  }
  dispose() {
    this._pendingLogicMessages = [], this.setVisualization(null), this.setLogic(null), this._model && this._model.dispose();
  }
  getLocation() {
    return this._location;
  }
  setLocation(t) {
    t && (t.x === this._location.x && t.y === this._location.y && t.z === this._location.z || (this._location.x = t.x, this._location.y = t.y, this._location.z = t.z, this._updateCounter++));
  }
  getDirection() {
    return this._direction;
  }
  setDirection(t) {
    t && (t.x === this._direction.x && t.y === this._direction.y && t.z === this._direction.z || (this._direction.x = (t.x % 360 + 360) % 360, this._direction.y = (t.y % 360 + 360) % 360, this._direction.z = (t.z % 360 + 360) % 360, this._updateCounter++));
  }
  getState(t = 0) {
    return t >= 0 && t < this._states.length ? this._states[t] : -1;
  }
  setState(t, e = 0) {
    return e >= 0 && e < this._states.length ? (this._states[e] !== t && (this._states[e] = t, this._updateCounter++), !0) : !1;
  }
  setVisualization(t) {
    this._visualization !== t && (this._visualization && this._visualization.dispose(), this._visualization = t, this._visualization && (this._visualization.object = this));
  }
  setLogic(t) {
    if (this._logic === t) return;
    const e = this._logic;
    if (e && (this._logic = null, e.setObject(null)), this._logic = t, this._logic)
      for (this._logic.setObject(this); this._pendingLogicMessages.length; ) {
        const s = this._pendingLogicMessages.shift();
        this._logic.processUpdateMessage(s);
      }
  }
  processUpdateMessage(t) {
    if (this._logic) return this._logic.processUpdateMessage(t);
    this._pendingLogicMessages.push(t);
  }
  tearDown() {
    this._logic && this._logic.tearDown();
  }
  get id() {
    return this._id;
  }
  get instanceId() {
    return this._instanceId;
  }
  get type() {
    return this._type;
  }
  get model() {
    return this._model;
  }
  get visualization() {
    return this._visualization;
  }
  get mouseHandler() {
    return this._logic;
  }
  get logic() {
    return this._logic;
  }
  get location() {
    return this._location;
  }
  get direction() {
    return this._direction;
  }
  get updateCounter() {
    return this._updateCounter;
  }
  set updateCounter(t) {
    this._updateCounter = t;
  }
  get isReady() {
    return this._isReady;
  }
  set isReady(t) {
    this._isReady = t;
  }
};
ud.OBJECT_COUNTER = 0;
let TE = ud;
const ld = class ld {
  constructor(t, e, s) {
    this.type = t, this.loc = e, this.category = s;
  }
  get loc() {
    return this._loc;
  }
  set loc(t) {
    this._loc || (this._loc = new v()), this._loc.assign(t);
  }
  get type() {
    return this._type;
  }
  set type(t) {
    this._type = t;
  }
  get category() {
    return this._category;
  }
  set category(t) {
    this._category = t;
  }
  dispose() {
    this._loc = null;
  }
};
ld.WINDOW = "window", ld.HOLE = "hole";
let Ia = ld;
class mM {
  constructor() {
    this._masks = /* @__PURE__ */ new Map();
  }
  get maskCount() {
    return this._masks.size;
  }
  dispose() {
    this._masks && (this.reset(), this._masks = null);
  }
  initialize(t) {
    if (!t) return !1;
    if (this._masks.clear(), t.masks.length)
      for (const e of t.masks) {
        if (!e) continue;
        const s = e.locations.length ? e.locations[0] : null;
        s && this._masks.set(e.id, new Ia(e.type, s, e.category));
      }
    return !0;
  }
  reset() {
    for (const t of this._masks.values())
      t && t.dispose();
    this._masks.clear();
  }
  addMask(t, e, s, r) {
    const n = new Ia(e, s, r);
    this._masks.delete(t), this._masks.set(t, n);
  }
  removeMask(t) {
    const e = this._masks.get(t);
    return e ? (this._masks.delete(t), e.dispose(), !0) : !1;
  }
  getXML() {
    const t = new Cst();
    for (const [e, s] of this._masks.entries()) {
      if (!s) continue;
      const r = this.getMaskType(s), n = this.getMaskCategory(s), a = this.getMaskLocation(s);
      if (r && n && a) {
        const o = {
          id: e,
          type: r,
          category: n,
          locations: [
            {
              x: a.x,
              y: a.y,
              z: a.z
            }
          ]
        };
        t.masks.push(o);
      }
    }
    return t;
  }
  getMaskLocation(t) {
    return t ? t.loc : null;
  }
  getMaskType(t) {
    return t ? t.type : null;
  }
  getMaskCategory(t) {
    return t ? t.category : null;
  }
  get masks() {
    return this._masks;
  }
}
class xst {
  constructor(t, e, s, r) {
    this._leftSideLoc = 0, this._rightSideLoc = 0, this._leftSideLength = 0, this._rightSideLength = 0, this._leftSideLoc = t, this._rightSideLoc = e, this._leftSideLength = s, this._rightSideLength = r;
  }
  get leftSideLoc() {
    return this._leftSideLoc;
  }
  get rightSideLoc() {
    return this._rightSideLoc;
  }
  get leftSideLength() {
    return this._leftSideLength;
  }
  get rightSideLength() {
    return this._rightSideLength;
  }
}
const $n = class $n {
  constructor(t, e, s, r, n) {
    this._type = 0, this._loc = null, this._leftSide = null, this._rightSide = null, this._normal = null, this._normalDirection = null;
    let a, o, h, u, c, l, _, d;
    if (this._secondaryNormals = [], this._masks = [], this._loc = new v(), this._loc.assign(e), this._leftSide = new v(), this._leftSide.assign(s), this._rightSide = new v(), this._rightSide.assign(r), this._type = t, s != null && r != null && (this._normal = v.crossProduct(s, r), a = 0, o = 0, h = 0, u = 0, c = 0, this.normal.x != 0 || this.normal.y != 0 ? (u = this.normal.x, c = this.normal.y, a = 360 + Math.atan2(c, u) / Math.PI * 180, a >= 360 && (a = a - 360), u = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y), c = this.normal.z, o = 360 + Math.atan2(c, u) / Math.PI * 180, o >= 360 && (o = o - 360)) : this.normal.z < 0 ? o = 90 : o = 270, this._normalDirection = new v(a, o, h)), n != null && n.length > 0)
      for (l = 0; l < n.length; )
        _ = n[l], _ != null && _.length > 0 && (d = new v(), d.assign(_), d.multiply(1 / d.length), this._secondaryNormals.push(d)), l++;
  }
  get type() {
    return this._type;
  }
  get loc() {
    return this._loc;
  }
  get leftSide() {
    return this._leftSide;
  }
  get rightSide() {
    return this._rightSide;
  }
  get normal() {
    return this._normal;
  }
  get normalDirection() {
    return this._normalDirection;
  }
  get secondaryNormalCount() {
    return this._secondaryNormals.length;
  }
  get maskCount() {
    return this._masks.length;
  }
  getSecondaryNormal(t) {
    if (t < 0 || t >= this.secondaryNormalCount)
      return null;
    const e = new v();
    return e.assign(this._secondaryNormals[t]), e;
  }
  addMask(t, e, s, r) {
    const n = new xst(t, e, s, r);
    this._masks.push(n);
  }
  getMask(t) {
    return t < 0 || t >= this.maskCount ? null : this._masks[t];
  }
  getMaskLeftSideLoc(t) {
    const e = this.getMask(t);
    return e != null ? e.leftSideLoc : -1;
  }
  getMaskRightSideLoc(t) {
    const e = this.getMask(t);
    return e != null ? e.rightSideLoc : -1;
  }
  getMaskLeftSideLength(t) {
    const e = this.getMask(t);
    return e != null ? e.leftSideLength : -1;
  }
  getMaskRightSideLength(t) {
    const e = this.getMask(t);
    return e != null ? e.rightSideLength : -1;
  }
};
$n.PLANE_UNDEFINED = 0, $n.PLANE_FLOOR = 1, $n.PLANE_WALL = 2, $n.PLANE_LANDSCAPE = 3, $n.PLANE_BILLBOARD = 4;
let ue = $n;
const Ro = class Ro {
  constructor() {
    this._corners = [], this._endPoints = [], this._directions = [], this._lengths = [], this._leftTurns = [], this._borders = [], this._hideWalls = [], this._manuallyLeftCut = [], this._manuallyRightCut = [], this._addDuplicates = !1, this._count = 0;
  }
  addWall(t, e, s, r, n) {
    (this._addDuplicates || this.checkIsNotDuplicate(t, e, s, r, n)) && (this._corners.push(t), this._directions.push(e), this._lengths.push(s), this._borders.push(r), this._leftTurns.push(n), this._hideWalls.push(!1), this._manuallyLeftCut.push(!1), this._manuallyRightCut.push(!1), this._count++);
  }
  checkIsNotDuplicate(t, e, s, r, n) {
    let a = 0;
    for (; a < this._count; ) {
      if (this._corners[a].x == t.x && this._corners[a].y == t.y && this._directions[a] == e && this._lengths[a] == s && this._borders[a] == r && this._leftTurns[a] == n)
        return !1;
      a++;
    }
    return !0;
  }
  get count() {
    return this._count;
  }
  getCorner(t) {
    return this._corners[t];
  }
  getEndPoint(t) {
    return this.calculateWallEndPoints(), this._endPoints[t];
  }
  getLength(t) {
    return this._lengths[t];
  }
  getDirection(t) {
    return this._directions[t];
  }
  getBorder(t) {
    return this._borders[t];
  }
  getHideWall(t) {
    return this._hideWalls[t];
  }
  getLeftTurn(t) {
    return this._leftTurns[t];
  }
  getManuallyLeftCut(t) {
    return this._manuallyLeftCut[t];
  }
  getManuallyRightCut(t) {
    return this._manuallyRightCut[t];
  }
  setHideWall(t, e) {
    this._hideWalls[t] = e;
  }
  setLength(t, e) {
    e < this._lengths[t] && (this._lengths[t] = e, this._manuallyRightCut[t] = !0);
  }
  moveCorner(t, e) {
    let s;
    if (e > 0 && e < this._lengths[t]) {
      const r = this._corners[t];
      s = Ro.WALL_DIRECTION_VECTORS[this.getDirection(t)], this._corners[t] = new st(r.x + e * s.x, r.y + e * s.y), this._lengths[t] = this._lengths[t] - e, this._manuallyLeftCut[t] = !0;
    }
  }
  calculateWallEndPoints() {
    let t, e, s, r, n;
    if (this._endPoints.length != this.count)
      for (this._endPoints = [], t = 0; t < this.count; )
        e = this.getCorner(t), s = new st(e.x, e.y), r = Ro.WALL_DIRECTION_VECTORS[this.getDirection(t)], n = this.getLength(t), s.x = s.x + r.x * n, s.y = s.y + r.y * n, this._endPoints.push(s), t++;
  }
};
Ro.WALL_DIRECTION_VECTORS = [
  new v(1, 0, 0),
  new v(0, 1, 0),
  new v(-1, 0, 0),
  new v(0, -1, 0)
], Ro.WALL_NORMAL_VECTORS = [
  new v(0, 1, 0),
  new v(-1, 0, 0),
  new v(0, -1, 0),
  new v(1, 0, 0)
];
let Ai = Ro;
const St = class St {
  constructor() {
    this._width = 0, this._height = 0, this._fixedWallHeight = -1, this._minX = 0, this._maxX = 0, this._minY = 0, this._maxY = 0, this._floorHeight = 0, this._restrictsScaling = !1, this._restrictedScale = 1, this._tileMatrix = [], this._tileMatrixOriginal = [], this._highlights = [], this._planes = [], this._floorHoleMatrix = [], this._wallHeight = 3.6, this._wallThicknessMultiplier = 1, this._floorThicknessMultiplier = 1, this._floorHoles = /* @__PURE__ */ new Map(), this._floorHolesInverted = /* @__PURE__ */ new Map();
  }
  get minX() {
    return this._minX;
  }
  get maxX() {
    return this._maxX;
  }
  get minY() {
    return this._minY;
  }
  get maxY() {
    return this._maxY;
  }
  get wallHeight() {
    return this._fixedWallHeight != -1 ? this._fixedWallHeight + 3.6 : this._wallHeight;
  }
  set wallHeight(t) {
    t < 0 && (t = 0), this._wallHeight = t;
  }
  get wallThicknessMultiplier() {
    return this._wallThicknessMultiplier;
  }
  set wallThicknessMultiplier(t) {
    t < 0 && (t = 0), this._wallThicknessMultiplier = t;
  }
  get floorThicknessMultiplier() {
    return this._floorThicknessMultiplier;
  }
  set floorThicknessMultiplier(t) {
    t < 0 && (t = 0), this._floorThicknessMultiplier = t;
  }
  get floorHeight() {
    return this._fixedWallHeight != -1 ? this._fixedWallHeight : this._floorHeight;
  }
  get restrictsDragging() {
    return this._restrictsDragging;
  }
  set restrictsDragging(t) {
    this._restrictsDragging = t;
  }
  get restrictsScaling() {
    return this._restrictsScaling;
  }
  set restrictsScaling(t) {
    this._restrictsScaling = t;
  }
  get restrictedScale() {
    return this._restrictedScale;
  }
  set restrictedScale(t) {
    this._restrictedScale = t;
  }
  get tileMapWidth() {
    return this._width;
  }
  get tileMapHeight() {
    return this._height;
  }
  get planeCount() {
    return this._planes.length;
  }
  static getFloorHeight(t) {
    const e = t.length;
    if (!e) return 0;
    let s = 0, r = 0;
    for (; r < e; ) {
      const n = t[r];
      let a = 0;
      for (; a < n.length; ) {
        const o = n[a];
        o > s && (s = o), a++;
      }
      r++;
    }
    return s;
  }
  static findEntranceTile(t) {
    if (!t) return null;
    const e = t.length;
    if (!e) return null;
    const s = [];
    let r = 0;
    for (; r < e; ) {
      const n = t[r];
      if (!n || !n.length) return null;
      let a = 0;
      for (; a < n.length; ) {
        if (n[a] >= 0) {
          s.push(a);
          break;
        }
        a++;
      }
      s.length < r + 1 && s.push(n.length + 1), r++;
    }
    for (r = 1; r < s.length - 1; ) {
      if (Math.trunc(s[r]) <= Math.trunc(s[r - 1]) - 1 && Math.trunc(s[r]) <= Math.trunc(s[r + 1]) - 1) return new st(Math.trunc(s[r] | 0), r);
      r++;
    }
    return null;
  }
  static expandFloorTiles(t) {
    let e, s, r, n, a, o, h, u, c, l, _, d;
    const f = t.length, p = t[0].length, g = [];
    for (s = 0; s < f * 4; )
      g[s] = [], s++;
    let m = 0;
    for (s = 0; s < f; ) {
      for (a = 0, e = 0; e < p; ) {
        if (o = t[s][e], o < 0 || o <= 255)
          for (n = 0; n < 4; ) {
            for (r = 0; r < 4; )
              g[m + n] === void 0 && (g[m + n] = []), g[m + n][a + r] = o < 0 ? o : o * 4, r++;
            n++;
          }
        else {
          for (h = (o & 255) * 4, u = h + (o >> 11 & 1) * 3, c = h + (o >> 10 & 1) * 3, l = h + (o >> 9 & 1) * 3, _ = h + (o >> 8 & 1) * 3, r = 0; r < 3; )
            d = r + 1, g[m][a + r] = (u * (3 - r) + c * r) / 3, g[m + 3][a + d] = (l * (3 - d) + _ * d) / 3, g[m + d][a] = (u * (3 - d) + l * d) / 3, g[m + r][a + 3] = (c * (3 - r) + _ * r) / 3, r++;
          g[m + 1][a + 1] = u > h ? h + 2 : h + 1, g[m + 1][a + 2] = c > h ? h + 2 : h + 1, g[m + 2][a + 1] = l > h ? h + 2 : h + 1, g[m + 2][a + 2] = _ > h ? h + 2 : h + 1;
        }
        a = a + 4, e++;
      }
      m = m + 4, s++;
    }
    return g;
  }
  static addTileTypes(t) {
    let e, s, r, n, a, o, h, u, c, l, _, d, f;
    const p = t.length - 1, g = t[0].length - 1;
    for (s = 1; s < p; ) {
      for (e = 1; e < g; )
        r = t[s][e], r < 0 || (n = t[s - 1][e - 1] & 255, a = t[s - 1][e] & 255, o = t[s - 1][e + 1] & 255, h = t[s][e - 1] & 255, u = t[s][e + 1] & 255, c = t[s + 1][e - 1] & 255, l = t[s + 1][e] & 255, _ = t[s + 1][e + 1] & 255, d = r + 1, f = (n == d || a == d || h == d ? 8 : 0) | (o == d || a == d || u == d ? 4 : 0) | (c == d || l == d || h == d ? 2 : 0) | (_ == d || l == d || u == d ? 1 : 0), f == 15 && (f = 0), t[s][e] = r | f << 8), e++;
      s++;
    }
  }
  static unpadHeightMap(t) {
    t.shift(), t.pop();
    for (const e of t)
      e.shift(), e.pop();
  }
  static padHeightMap(t) {
    const e = [], s = [];
    for (const r of t)
      r.push(St.TILE_BLOCKED), r.unshift(St.TILE_BLOCKED);
    for (const r of t[0])
      e.push(St.TILE_BLOCKED), s.push(St.TILE_BLOCKED);
    t.push(s), t.unshift(e);
  }
  dispose() {
    this._planes = null, this._tileMatrix = null, this._tileMatrixOriginal = null, this._floorHoleMatrix = null, this._floorHoles != null && (this._floorHoles.clear(), this._floorHoles = null), this._floorHolesInverted != null && (this._floorHolesInverted.clear(), this._floorHolesInverted = null);
  }
  reset() {
    this._planes = [], this._tileMatrix = [], this._tileMatrixOriginal = [], this._width = 0, this._height = 0, this._minX = 0, this._maxX = 0, this._minY = 0, this._maxY = 0, this._floorHeight = 0, this._floorHoleMatrix = [];
  }
  initializeTileMap(t, e) {
    t < 0 && (t = 0), e < 0 && (e = 0), this._tileMatrix = [], this._tileMatrixOriginal = [], this._floorHoleMatrix = [];
    let s = 0;
    for (; s < e; ) {
      const r = [], n = [], a = [];
      let o = 0;
      for (; o < t; )
        r[o] = St.TILE_BLOCKED, n[o] = St.TILE_BLOCKED, a[o] = !1, o++;
      this._tileMatrix.push(r), this._tileMatrixOriginal.push(n), this._floorHoleMatrix.push(a), s++;
    }
    return this._width = t, this._height = e, this._minX = this._width, this._maxX = -1, this._minY = this._height, this._maxY = -1, !0;
  }
  setTileHeight(t, e, s) {
    let r, n, a, o, h;
    if (t >= 0 && t < this._width && e >= 0 && e < this._height) {
      if (r = this._tileMatrix[e], r[t] = s, s >= 0)
        t < this._minX && (this._minX = t), t > this._maxX && (this._maxX = t), e < this._minY && (this._minY = e), e > this._maxY && (this._maxY = e);
      else {
        if (t == this._minX || t == this._maxX) {
          for (n = !1, a = this._minY; a < this._maxY; ) {
            if (this.getTileHeightInternal(t, a) >= 0) {
              n = !0;
              break;
            }
            a++;
          }
          n || (t == this._minX && this._minX++, t == this._maxX && this._maxX--);
        }
        if (e == this._minY || e == this._maxY) {
          for (o = !1, h = this._minX; h < this._maxX; ) {
            if (this.getTileHeight(h, e) >= 0) {
              o = !0;
              break;
            }
            h++;
          }
          o || (e == this._minY && this._minY++, e == this._maxY && this._maxY--);
        }
      }
      return !0;
    }
    return !1;
  }
  getTileHeight(t, e) {
    if (t < 0 || t >= this._width || e < 0 || e >= this._height)
      return St.TILE_BLOCKED;
    const s = this._tileMatrix[e];
    return s[t] === void 0 ? 0 : Math.abs(s[t]);
  }
  initializeFromTileData(t = -1) {
    let e, s;
    for (this._fixedWallHeight = t, s = 0; s < this._height; ) {
      for (e = 0; e < this._width; )
        this._tileMatrixOriginal[s] === void 0 && (this._tileMatrixOriginal[s] = []), this._tileMatrixOriginal[s][e] = this._tileMatrix[s][e], e++;
      s++;
    }
    const r = St.findEntranceTile(this._tileMatrix);
    for (s = 0; s < this._height; ) {
      for (e = 0; e < this._width; )
        this._floorHoleMatrix[s] === void 0 && (this._floorHoleMatrix[s] = []), this._floorHoleMatrix[s][e] && this.setTileHeight(e, s, St.TILE_HOLE), e++;
      s++;
    }
    return this.initialize(r);
  }
  initializeHighlightArea(t, e, s, r) {
    this.clearHighlightArea(), this.extractPlanes(this.floorTiles, t * 4, e * 4, s * 4, r * 4, !0);
  }
  clearHighlightArea() {
    const t = this._highlights.length;
    return this._planes = this._planes.slice(0, this._planes.length - this._highlights.length), this._highlights.length = 0, t;
  }
  initializeFromMapData(t) {
    if (!t) return !1;
    this.reset(), this.resetFloorHoles();
    const e = t.width, s = t.height, r = t.wallHeight, n = t.fixedWallsHeight;
    if (this.initializeTileMap(e, s), t.tileMap) {
      let a = 0;
      for (; a < t.tileMap.length; ) {
        const o = t.tileMap[a];
        if (o) {
          let h = 0;
          for (; h < o.length; ) {
            const u = o[h];
            u && this.setTileHeight(h, a, u.height), h++;
          }
        }
        a++;
      }
    }
    if (t.holeMap && t.holeMap.length) {
      let a = 0;
      for (; a < t.holeMap.length; ) {
        const o = t.holeMap[a];
        o && (this.addFloorHole(o.id, o.x, o.y, o.width, o.height, o.invert), a++);
      }
      this.initializeHoleMap();
    }
    return this.wallHeight = r, this.initializeFromTileData(n), !0;
  }
  isPlaneTemporaryHighlighter(t) {
    if (t < 0 || t >= this.planeCount)
      return !1;
    const e = this._planes[t];
    return e == null ? !1 : this._highlights.indexOf(e) != -1;
  }
  getMapData() {
    const t = new gM();
    t.width = this._width, t.height = this._height, t.wallHeight = this._wallHeight, t.fixedWallsHeight = this._fixedWallHeight, t.dimensions.minX = this.minX, t.dimensions.maxX = this.maxX, t.dimensions.minY = this.minY, t.dimensions.maxY = this.maxY;
    let e = 0;
    for (; e < this._height; ) {
      const s = [], r = this._tileMatrixOriginal[e];
      let n = 0;
      for (; n < this._width; ) {
        const a = r[n];
        s.push({ height: a }), n++;
      }
      t.tileMap.push(s), e++;
    }
    for (const [s, r] of this._floorHoles.entries())
      r && t.holeMap.push({
        id: s,
        x: r.x,
        y: r.y,
        width: r.width,
        height: r.height,
        invert: !1
      });
    for (const [s, r] of this._floorHolesInverted.entries())
      r && t.holeMap.push({
        id: s,
        x: r.x,
        y: r.y,
        width: r.width,
        height: r.height,
        invert: !0
      });
    return t;
  }
  getPlaneLocation(t) {
    if (t < 0 || t >= this.planeCount) return null;
    const e = this._planes[t];
    return e ? e.loc : null;
  }
  getPlaneNormal(t) {
    if (t < 0 || t >= this.planeCount) return null;
    const e = this._planes[t];
    return e ? e.normal : null;
  }
  getPlaneLeftSide(t) {
    if (t < 0 || t >= this.planeCount) return null;
    const e = this._planes[t];
    return e ? e.leftSide : null;
  }
  getPlaneRightSide(t) {
    if (t < 0 || t >= this.planeCount) return null;
    const e = this._planes[t];
    return e ? e.rightSide : null;
  }
  getPlaneNormalDirection(t) {
    if (t < 0 || t >= this.planeCount) return null;
    const e = this._planes[t];
    return e ? e.normalDirection : null;
  }
  getPlaneSecondaryNormals(t) {
    let e, s;
    if (t < 0 || t >= this.planeCount)
      return null;
    const r = this._planes[t];
    if (r != null) {
      for (e = [], s = 0; s < r.secondaryNormalCount; )
        e.push(r.getSecondaryNormal(s)), s++;
      return e;
    }
    return null;
  }
  getPlaneType(t) {
    if (t < 0 || t >= this.planeCount) return ue.PLANE_UNDEFINED;
    const e = this._planes[t];
    return e ? e.type : ue.PLANE_UNDEFINED;
  }
  getPlaneMaskCount(t) {
    if (t < 0 || t >= this.planeCount) return 0;
    const e = this._planes[t];
    return e ? e.maskCount : 0;
  }
  getPlaneMaskLeftSideLoc(t, e) {
    if (t < 0 || t >= this.planeCount) return -1;
    const s = this._planes[t];
    return s ? s.getMaskLeftSideLoc(e) : -1;
  }
  getPlaneMaskRightSideLoc(t, e) {
    if (t < 0 || t >= this.planeCount) return -1;
    const s = this._planes[t];
    return s ? s.getMaskRightSideLoc(e) : -1;
  }
  getPlaneMaskLeftSideLength(t, e) {
    if (t < 0 || t >= this.planeCount) return -1;
    const s = this._planes[t];
    return s ? s.getMaskLeftSideLength(e) : -1;
  }
  getPlaneMaskRightSideLength(t, e) {
    if (t < 0 || t >= this.planeCount) return -1;
    const s = this._planes[t];
    return s ? s.getMaskRightSideLength(e) : -1;
  }
  addFloorHole(t, e, s, r, n, a = !1) {
    this.removeFloorHole(t), a ? this._floorHolesInverted.set(t, new xR(e, s, r, n)) : this._floorHoles.set(t, new xR(e, s, r, n));
  }
  removeFloorHole(t) {
    this._floorHoles.delete(t), this._floorHolesInverted.delete(t);
  }
  resetFloorHoles() {
    this._floorHoles.clear(), this._floorHolesInverted.clear();
  }
  getTileHeightOriginal(t, e) {
    return t < 0 || t >= this._width || e < 0 || e >= this._height ? St.TILE_BLOCKED : this._floorHoleMatrix[e][t] ? St.TILE_HOLE : this._tileMatrixOriginal[e][t];
  }
  getTileHeightInternal(t, e) {
    return t < 0 || t >= this._width || e < 0 || e >= this._height ? St.TILE_BLOCKED : this._tileMatrix[e][t];
  }
  initialize(t) {
    let e = 0;
    t != null && (e = this.getTileHeight(t.x, t.y), this.setTileHeight(t.x, t.y, St.TILE_BLOCKED)), this._floorHeight = St.getFloorHeight(this._tileMatrix), this.createWallPlanes();
    const s = [];
    for (const r of this._tileMatrix) s.push(r.concat());
    return St.padHeightMap(s), St.addTileTypes(s), St.unpadHeightMap(s), this.floorTiles = St.expandFloorTiles(s), this.extractPlanes(this.floorTiles), t != null && (this.setTileHeight(t.x, t.y, e), this.addFloor(new v(t.x + 0.5, t.y + 0.5, e), new v(-1, 0, 0), new v(0, -1, 0), !1, !1, !1, !1)), !0;
  }
  generateWallData(t, e) {
    let s, r, n, a, o;
    const h = new Ai(), u = [this.extractTopWall.bind(this), this.extractRightWall.bind(this), this.extractBottomWall.bind(this), this.extractLeftWall.bind(this)];
    let c = 0, l = new st(t.x, t.y), _ = 0;
    for (; _++ < 1e3; ) {
      if (s = !1, r = !1, n = c, (l.x < this.minX || l.x > this.maxX || l.y < this.minY || l.y > this.maxY) && (s = !0), a = u[c](l, e), a == null)
        return null;
      if (o = Math.abs(a.x - l.x) + Math.abs(a.y - l.y), l.x == a.x || l.y == a.y ? (c = (c - 1 + u.length) % u.length, o = o + 1, r = !0) : (c = (c + 1) % u.length, o--), h.addWall(l, n, o, s, r), a.x == t.x && a.y == t.y && (a.x != l.x || a.y != l.y))
        break;
      l = a;
    }
    return h.count == 0 ? null : h;
  }
  hidePeninsulaWallChains(t) {
    let e, s, r, n, a = 0;
    const o = t.count;
    for (; a < o; ) {
      const h = a;
      for (e = a, s = 0, r = !1; !t.getBorder(a) && a < o; )
        t.getLeftTurn(a) ? s++ : s > 0 && s--, s > 1 && (r = !0), e = a, a++;
      if (r)
        for (n = h; n <= e; )
          t.setHideWall(n, !0), n++;
      a++;
    }
  }
  updateWallsNextToHoles(t) {
    let e, s, r, n, a, o, h;
    const u = t.count;
    let c = 0;
    for (; c < u; ) {
      if (!t.getHideWall(c)) {
        for (e = t.getCorner(c), s = t.getDirection(c), r = t.getLength(c), n = Ai.WALL_DIRECTION_VECTORS[s], a = Ai.WALL_NORMAL_VECTORS[s], o = 0, h = 0; h < r; ) {
          if (this.getTileHeightInternal(e.x + h * n.x - a.x, e.y + h * n.y - a.y) == St.TILE_HOLE) {
            if (h > 0 && o == 0) {
              t.setLength(c, h);
              break;
            }
            o++;
          } else if (o > 0) {
            t.moveCorner(c, o);
            break;
          }
          h++;
        }
        o == r && t.setHideWall(c, !0);
      }
      c++;
    }
  }
  resolveOriginalWallIndex(t, e, s) {
    let r, n, a, o, h, u;
    const c = Math.min(t.y, e.y), l = Math.max(t.y, e.y), _ = Math.min(t.x, e.x), d = Math.max(t.x, e.x), f = s.count;
    let p = 0;
    for (; p < f; ) {
      if (r = s.getCorner(p), n = s.getEndPoint(p), t.x == e.x) {
        if (r.x == t.x && n.x == t.x && (a = Math.min(r.y, n.y), o = Math.max(r.y, n.y), a <= c && l <= o))
          return p;
      } else if (t.y == e.y && r.y == t.y && n.y == t.y && (h = Math.min(r.x, n.x), u = Math.max(r.x, n.x), h <= _ && d <= u))
        return p;
      p++;
    }
    return -1;
  }
  hideOriginallyHiddenWalls(t, e) {
    let s, r, n, a, o;
    const h = t.count;
    let u = 0;
    for (; u < h; )
      t.getHideWall(u) || (s = t.getCorner(u), r = new st(s.x, s.y), n = Ai.WALL_DIRECTION_VECTORS[t.getDirection(u)], a = t.getLength(u), r.x = r.x + n.x * a, r.y = r.y + n.y * a, o = this.resolveOriginalWallIndex(s, r, e), o >= 0 ? e.getHideWall(o) && t.setHideWall(u, !0) : t.setHideWall(u, !0)), u++;
  }
  checkWallHiding(t, e) {
    this.hidePeninsulaWallChains(e), this.updateWallsNextToHoles(t), this.hideOriginallyHiddenWalls(t, e);
  }
  addWalls(t, e) {
    const s = t.count, r = e.count;
    let n = 0;
    for (; n < s; ) {
      if (!t.getHideWall(n)) {
        const a = t.getCorner(n), o = t.getDirection(n), h = t.getLength(n), u = Ai.WALL_DIRECTION_VECTORS[o], c = Ai.WALL_NORMAL_VECTORS[o];
        let l = -1, _ = 0;
        for (; _ < h; ) {
          const k = this.getTileHeightInternal(a.x + _ * u.x + c.x, a.y + _ * u.y + c.y);
          k >= 0 && (k < l || l < 0) && (l = k), _++;
        }
        const d = l;
        let f = new v(a.x, a.y, d);
        f = v.sum(f, v.product(c, 0.5)), f = v.sum(f, v.product(u, -0.5));
        const p = this.wallHeight + Math.min(St.MAX_WALL_ADDITIONAL_HEIGHT, this.floorHeight) - l, g = v.product(u, -h), m = new v(0, 0, p);
        f = v.dif(f, g);
        const O = this.resolveOriginalWallIndex(a, t.getEndPoint(n), e);
        let y = 0, C = 0;
        O >= 0 ? (y = e.getDirection((O + 1) % r), C = e.getDirection((O - 1 + r) % r)) : (y = t.getDirection((n + 1) % s), C = t.getDirection((n - 1 + s) % s));
        let b = null;
        (y - o + 4) % 4 == 3 ? b = Ai.WALL_NORMAL_VECTORS[y] : (o - C + 4) % 4 == 3 && (b = Ai.WALL_NORMAL_VECTORS[C]);
        const D = t.getLeftTurn(n), P = t.getLeftTurn((n - 1 + s) % s), F = t.getHideWall((n + 1) % s), M = t.getManuallyLeftCut(n), U = t.getManuallyRightCut(n);
        this.addWall(f, g, m, b, !P || M, !D || U, !F);
      }
      n++;
    }
  }
  createWallPlanes() {
    const t = this._tileMatrix;
    if (t == null)
      return !1;
    let e, s, r;
    const n = t.length;
    let a = 0;
    if (n == 0)
      return !1;
    for (e = 0; e < n; ) {
      if (r = t[e], r == null || r.length == 0)
        return !1;
      a > 0 ? a = Math.min(a, r.length) : a = r.length, e++;
    }
    const o = Math.min(St.MAX_WALL_ADDITIONAL_HEIGHT, this._fixedWallHeight != -1 ? this._fixedWallHeight : St.getFloorHeight(t)), h = this.minX;
    let u = this.minY;
    for (u = this.minY; u <= this.maxY; ) {
      if (this.getTileHeightInternal(h, u) > St.TILE_HOLE) {
        u--;
        break;
      }
      u++;
    }
    if (u > this.maxY)
      return !1;
    const c = new st(h, u), l = this.generateWallData(c, !0), _ = this.generateWallData(c, !1);
    for (l != null && (l.count, _.count, this.checkWallHiding(l, _), this.addWalls(l, _)), s = 0; s < this.tileMapHeight; ) {
      for (e = 0; e < this.tileMapWidth; )
        this.getTileHeightInternal(e, s) < 0 && this.setTileHeight(e, s, -(o + this.wallHeight)), e++;
      s++;
    }
    return !0;
  }
  extractTopWall(t, e) {
    if (t == null)
      return null;
    let s = 1, r = St.TILE_HOLE;
    for (e || (r = St.TILE_BLOCKED); s < 1e3; ) {
      if (this.getTileHeightInternal(t.x + s, t.y) > r)
        return new st(t.x + s - 1, t.y);
      if (this.getTileHeightInternal(t.x + s, t.y + 1) <= r)
        return new st(t.x + s, t.y + 1);
      s++;
    }
    return null;
  }
  extractRightWall(t, e) {
    if (t == null)
      return null;
    let s = 1, r = St.TILE_HOLE;
    for (e || (r = St.TILE_BLOCKED); s < 1e3; ) {
      if (this.getTileHeightInternal(t.x, t.y + s) > r)
        return new st(t.x, t.y + (s - 1));
      if (this.getTileHeightInternal(t.x - 1, t.y + s) <= r)
        return new st(t.x - 1, t.y + s);
      s++;
    }
    return null;
  }
  extractBottomWall(t, e) {
    if (t == null)
      return null;
    let s = 1, r = St.TILE_HOLE;
    for (e || (r = St.TILE_BLOCKED); s < 1e3; ) {
      if (this.getTileHeightInternal(t.x - s, t.y) > r)
        return new st(t.x - (s - 1), t.y);
      if (this.getTileHeightInternal(t.x - s, t.y - 1) <= r)
        return new st(t.x - s, t.y - 1);
      s++;
    }
    return null;
  }
  extractLeftWall(t, e) {
    if (t == null)
      return null;
    let s = 1, r = St.TILE_HOLE;
    for (e || (r = St.TILE_BLOCKED); s < 1e3; ) {
      if (this.getTileHeightInternal(t.x, t.y - s) > r)
        return new st(t.x, t.y - (s - 1));
      if (this.getTileHeightInternal(t.x + 1, t.y - s) <= r)
        return new st(t.x + 1, t.y - s);
      s++;
    }
    return null;
  }
  addWall(t, e, s, r, n, a, o) {
    this.addPlane(ue.PLANE_WALL, t, e, s, [r]), this.addPlane(ue.PLANE_LANDSCAPE, t, e, s, [r]);
    const h = St.WALL_THICKNESS * this._wallThicknessMultiplier, u = St.FLOOR_THICKNESS * this._floorThicknessMultiplier, c = v.crossProduct(e, s), l = v.product(c, 1 / c.length * -h);
    if (this.addPlane(ue.PLANE_WALL, v.sum(t, s), e, l, [c, r]), n && this.addPlane(ue.PLANE_WALL, v.sum(v.sum(t, e), s), v.product(s, -(s.length + u) / s.length), l, [c, r]), a && (this.addPlane(ue.PLANE_WALL, v.sum(t, v.product(s, -u / s.length)), v.product(s, (s.length + u) / s.length), l, [c, r]), o)) {
      const _ = v.product(e, h / e.length);
      this.addPlane(ue.PLANE_WALL, v.sum(v.sum(t, s), v.product(_, -1)), _, l, [c, e, r]);
    }
  }
  addFloor(t, e, s, r, n, a, o, h = !1) {
    let u, c, l;
    this.addPlane(ue.PLANE_FLOOR, t, e, s, null, h) != null && (u = St.FLOOR_THICKNESS * this._floorThicknessMultiplier, c = new v(0, 0, u), l = v.dif(t, c), a && this.addPlane(ue.PLANE_FLOOR, l, e, c, null, h), o && this.addPlane(ue.PLANE_FLOOR, v.sum(l, v.sum(e, s)), v.product(e, -1), c, null, h), r && this.addPlane(ue.PLANE_FLOOR, v.sum(l, s), v.product(s, -1), c, null, h), n && this.addPlane(ue.PLANE_FLOOR, v.sum(l, e), s, c, null, h));
  }
  addPlane(t, e, s, r, n = null, a = !1) {
    if (s.length == 0 || r.length == 0)
      return null;
    const o = new ue(t, e, s, r, n);
    return this._planes.push(o), a && this._highlights.push(o), o;
  }
  initializeHoleMap() {
    let t, e, s;
    for (e = 0; e < this._height; ) {
      for (s = this._floorHoleMatrix[e], t = 0; t < this._width; )
        s[t] = this._floorHolesInverted.size > 0, t++;
      e++;
    }
    for (const r of this._floorHolesInverted.values())
      this.initializeHole(r, !0);
    for (const r of this._floorHoles.values())
      this.initializeHole(r);
  }
  initializeHole(t, e = !1) {
    let s, r, n, a, o, h, u;
    const c = t;
    if (c != null)
      for (a = c.x, o = c.x + c.width - 1, h = c.y, u = c.y + c.height - 1, a = a < 0 ? 0 : a, o = o >= this._width ? this._width - 1 : o, h = h < 0 ? 0 : h, u = u >= this._height ? this._height - 1 : u, r = h; r <= u; ) {
        for (n = this._floorHoleMatrix[r], s = a; s <= o; )
          n[s] = !e, s++;
        r++;
      }
  }
  extractPlanes(t, e = 0, s = 0, r = -1, n = -1, a = !1) {
    let o = 0, h = 0, u = 0, c = 0, l = 0, _ = 0, d = !1, f = !1, p = !1, g = !1, m = 0, O = 0, y = !1, C = NaN, b = NaN, D = NaN, P = NaN;
    const F = t.length, M = t[0].length, U = n == -1 ? F : Math.min(F, s + n), k = r == -1 ? M : Math.min(M, e + r), ft = [];
    for (o = 0; o < U; )
      ft[o] = [], o++;
    for (h = s; h < U; ) {
      for (u = e; u < k; ) {
        if (!((c = t[h][u]) < 0 || ft[h][u])) {
          for (d = u == 0 || t[h][u - 1] != c, f = h == 0 || t[h - 1][u] != c, l = u + 1; l < k && !(t[h][l] != c || ft[h][l] || h > 0 && t[h - 1][l] == c == f); )
            l++;
          for (p = l == M || t[h][l] != c, y = !1, _ = h + 1; _ <= U && !y && (g = _ == F || t[_][u] != c, y = _ == U || g || u > 0 && t[_][u - 1] == c == d || l < M && t[_][l] == c == p, _ != F); ) {
            for (m = u; m < l; ) {
              if (t[_][m] == c == g) {
                y = !0, l = m;
                break;
              }
              m++;
            }
            if (y)
              break;
            _++;
          }
          for (g || (g = _ == F), p = l == M || t[h][l] != c, O = h; O < _; ) {
            for (m = u; m < l; )
              ft[O][m] = !0, m++;
            O++;
          }
          C = u / 4 - 0.5, b = h / 4 - 0.5, D = (l - u) / 4, P = (_ - h) / 4, this.addFloor(new v(C + D, b + P, c / 4), new v(-D, 0, 0), new v(0, -P, 0), p, d, g, f, a);
        }
        u++;
      }
      h++;
    }
  }
};
St.TILE_BLOCKED = -110, St.TILE_HOLE = -100, St.FLOOR_THICKNESS = 0.25, St.WALL_THICKNESS = 0.25, St.MAX_WALL_ADDITIONAL_HEIGHT = 20;
let ye = St;
class Ce {
  constructor(t, e) {
    this._location = t, this._direction = e;
  }
  get location() {
    return this._location;
  }
  get direction() {
    return this._direction;
  }
}
const cd = class cd extends Ce {
  constructor(t) {
    super(null, null), this._type = t;
  }
  get type() {
    return this._type;
  }
};
cd.IMAGE_LOADED = "ROAUM_IMAGE_LOADED", cd.IMAGE_LOADING_FAILED = "ROAUM_IMAGE_FAILED";
let Ji = cd;
class Ae extends Ce {
  constructor() {
    super(null, null);
  }
}
class EM extends Ae {
  constructor(t, e) {
    super(), this._itemType = t, this._itemName = e;
  }
  get itemType() {
    return this._itemType;
  }
  get itemName() {
    return this._itemName;
  }
}
class fI extends Ae {
  constructor(t = 0) {
    super(), this._numberOfWords = t;
  }
  get numberOfWords() {
    return this._numberOfWords;
  }
}
class TM extends Ae {
  constructor(t = 0) {
    super(), this._danceStyle = t;
  }
  get danceStyle() {
    return this._danceStyle;
  }
}
class IM extends Ae {
  constructor(t, e = 0) {
    super(), this._effect = t, this._delayMilliseconds = e;
  }
  get effect() {
    return this._effect;
  }
  get delayMilliseconds() {
    return this._delayMilliseconds;
  }
}
class SM extends Ae {
  constructor(t) {
    super(), this._gainedExperience = t;
  }
  get gainedExperience() {
    return this._gainedExperience;
  }
}
class AM extends Ae {
  constructor(t = 0) {
    super(), this._expressionType = t;
  }
  get expressionType() {
    return this._expressionType;
  }
}
class Nc extends Ae {
  constructor(t, e = null, s = null, r = !1) {
    super(), this._figure = t, this._gender = e, this._subType = s, this._isRiding = r;
  }
  get figure() {
    return this._figure;
  }
  get gender() {
    return this._gender;
  }
  get subType() {
    return this._subType;
  }
  get isRiding() {
    return this._isRiding;
  }
}
class RM extends Ae {
  constructor(t = 0) {
    super(), this._level = t;
  }
  get level() {
    return this._level;
  }
}
class OM extends Ae {
  constructor(t = 0) {
    super(), this._gesture = t;
  }
  get gesture() {
    return this._gesture;
  }
}
class Mst extends Ae {
  constructor(t) {
    super(), this._guideStatus = t;
  }
  get guideStatus() {
    return this._guideStatus;
  }
}
class yM extends Ae {
  constructor(t = !1) {
    super(), this._isMuted = t;
  }
  get isMuted() {
    return this._isMuted;
  }
}
class vM extends Ae {
}
class CM extends Ae {
  constructor(t) {
    super(), this._gesture = t;
  }
  get gesture() {
    return this._gesture;
  }
}
class xM extends Ae {
  constructor(t) {
    super(), this._value = t;
  }
  get value() {
    return this._value;
  }
}
class MM extends Ae {
  constructor(t) {
    super(), this._isPlayingGame = t;
  }
  get isPlayingGame() {
    return this._isPlayingGame;
  }
}
class gI extends Ae {
  constructor(t, e = "") {
    super(), this._postureType = t, this._parameter = e;
  }
  get postureType() {
    return this._postureType;
  }
  get parameter() {
    return this._parameter;
  }
}
class Uc extends Ae {
  constructor(t) {
    super(), this._selected = t;
  }
  get selected() {
    return this._selected;
  }
}
class bM extends Ae {
  constructor(t = 0) {
    super(), this._signType = t;
  }
  get signType() {
    return this._signType;
  }
}
class pI extends Ae {
  constructor(t = !1) {
    super(), this._isSleeping = t;
  }
  get isSleeping() {
    return this._isSleeping;
  }
}
class PM extends Ae {
  constructor(t = !1) {
    super(), this._isTyping = t;
  }
  get isTyping() {
    return this._isTyping;
  }
}
class _n extends Ce {
  constructor(t, e, s, r = !1) {
    super(t, s), this._targetLocation = e, this._isSlide = r;
  }
  get targetLocation() {
    return this._targetLocation ? this._targetLocation : this.location;
  }
  get isSlide() {
    return this._isSlide;
  }
}
class Dc extends _n {
  constructor(t, e, s, r, n, a) {
    super(t, e, s), this._headDirection = r, this._canStandUp = n, this._baseY = a;
  }
  get headDirection() {
    return this._headDirection;
  }
  get canStandUp() {
    return this._canStandUp;
  }
  get baseY() {
    return this._baseY;
  }
}
class NM extends Ae {
  constructor(t) {
    super(), this._itemType = t;
  }
  get itemType() {
    return this._itemType;
  }
}
class Ht extends Ce {
  constructor(t, e, s = null) {
    super(null, null), this._state = t, this._data = e, this._extra = s;
  }
  get state() {
    return this._state;
  }
  get data() {
    return this._data;
  }
  get extra() {
    return this._extra;
  }
}
const XI = class XI extends Ce {
  constructor(t, e) {
    super(null, null), this._badgeId = t, this._assetName = e;
  }
  get badgeId() {
    return this._badgeId;
  }
  get assetName() {
    return this._assetName;
  }
};
XI.BADGE_LOADED = "ROGBUM_BADGE_LOADED";
let Sa = XI;
class UM extends Ce {
  constructor(t, e, s) {
    super(t, e), this._height = s;
  }
  get height() {
    return this._height;
  }
}
class mI extends Ce {
  constructor(t) {
    super(null, null), this._data = t;
  }
  get data() {
    return this._data;
  }
}
class DM extends Ce {
  constructor(t, e) {
    super(null, null), this._numberKey = t, this._numberValue = e;
  }
  get numberKey() {
    return this._numberKey;
  }
  get numberValue() {
    return this._numberValue;
  }
}
const KI = class KI extends Ce {
  constructor(t, e, s, r) {
    super(null, null), this._type = t, this._color = e, this._light = s, this._backgroundOnly = r;
  }
  get type() {
    return this._type;
  }
  get color() {
    return this._color;
  }
  get light() {
    return this._light;
  }
  get backgroundOnly() {
    return this._backgroundOnly;
  }
};
KI.BACKGROUND_COLOR = "RORCUM_BACKGROUND_COLOR";
let Fu = KI;
const _d = class _d extends Ce {
  constructor(t, e, s = 0, r = 0, n = 0, a = 0, o = !1) {
    super(null, null), this._type = t, this._id = e, this._x = s, this._y = r, this._width = n, this._height = a, this._invert = o;
  }
  get type() {
    return this._type;
  }
  get id() {
    return this._id;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get invert() {
    return this._invert;
  }
};
_d.ADD = "ORPFHUM_ADD", _d.REMOVE = "ORPFHUM_REMOVE";
let Ps = _d;
const dd = class dd extends Ce {
  constructor(t) {
    super(null, null), this._type = dd.UPDATE_MAP, this._mapData = t;
  }
  get type() {
    return this._type;
  }
  get mapData() {
    return this._mapData;
  }
};
dd.UPDATE_MAP = "RORMUM_UPDATE_MAP";
let Lc = dd;
const Zn = class Zn extends Ce {
  constructor(t, e, s = null, r = null, n = "window") {
    super(null, null), this._type = t, this._maskId = e, this._maskType = s, this._maskLocation = r ? new v(r.x, r.y, r.z) : null, this._maskCategory = n;
  }
  get type() {
    return this._type;
  }
  get maskId() {
    return this._maskId;
  }
  get maskType() {
    return this._maskType;
  }
  get maskLocation() {
    return this._maskLocation;
  }
  get maskCategory() {
    return this._maskCategory;
  }
};
Zn.ADD_MASK = "RORMUM_ADD_MASK", Zn.REMOVE_MASK = "RORMUM_ADD_MASK", Zn.DOOR = "door", Zn.WINDOW = "window", Zn.HOLE = "hole";
let qe = Zn;
const fd = class fd extends Ce {
  constructor(t, e) {
    super(null, null), this._type = t, this._value = e;
  }
  get type() {
    return this._type;
  }
  get value() {
    return this._value;
  }
};
fd.WALL_THICKNESS = "RORPPUM_WALL_THICKNESS", fd.FLOOR_THICKNESS = "RORPVUM_FLOOR_THICKNESS";
let Tr = fd;
const gd = class gd extends Ce {
  constructor(t, e) {
    super(null, null), this._type = t, this._visible = e;
  }
  get type() {
    return this._type;
  }
  get visible() {
    return this._visible;
  }
};
gd.WALL_VISIBILITY = "RORPVUM_WALL_VISIBILITY", gd.FLOOR_VISIBILITY = "RORPVUM_FLOOR_VISIBILITY";
let Ir = gd;
const nu = class nu extends Ce {
  constructor(t, e) {
    super(null, null), this._type = t, this._value = e;
  }
  get type() {
    return this._type;
  }
  get value() {
    return this._value;
  }
};
nu.ROOM_WALL_UPDATE = "RORUM_ROOM_WALL_UPDATE", nu.ROOM_FLOOR_UPDATE = "RORUM_ROOM_FLOOR_UPDATE", nu.ROOM_LANDSCAPE_UPDATE = "RORUM_ROOM_LANDSCAPE_UPDATE";
let we = nu;
class wu extends Ae {
  constructor(t) {
    super(), this._selected = t;
  }
  get selected() {
    return this._selected;
  }
}
class ka extends Ce {
  constructor(t, e, s, r, n = !1) {
    super(t, null), this._height = e, this._visible = s, this._sourceEventId = r, this._toggleVisibility = n;
  }
  get height() {
    return this._height;
  }
  get visible() {
    return this._visible;
  }
  get sourceEventId() {
    return this._sourceEventId;
  }
  get toggleVisibility() {
    return this._toggleVisibility;
  }
}
const pd = class pd extends Ce {
  constructor(t) {
    super(null, null), this._type = t;
  }
  get type() {
    return this._type;
  }
};
pd.ENABLED = "ROVUM_ENABLED", pd.DISABLED = "ROVUM_DISABLED";
let Sr = pd;
class $d {
  constructor() {
    this._events = null, this._object = null, this._time = 0;
  }
  initialize(t) {
  }
  dispose() {
    this._object = null;
  }
  update(t) {
    this._time = t;
  }
  processUpdateMessage(t) {
    !t || !this._object || (this._object.setLocation(t.location), this._object.setDirection(t.direction));
  }
  getEventTypes() {
    return [];
  }
  mergeTypes(t, e) {
    const s = t.concat();
    for (const r of e)
      !r || s.indexOf(r) >= 0 || s.push(r);
    return s;
  }
  mouseEvent(t, e) {
  }
  useObject() {
  }
  setObject(t) {
    if (this._object !== t) {
      if (this._object && this._object.setLogic(null), !t) {
        this.dispose(), this._object = null;
        return;
      }
      this._object = t, this._object.setLogic(this);
    }
  }
  tearDown() {
  }
  get object() {
    return this._object;
  }
  get eventDispatcher() {
    return this._events;
  }
  set eventDispatcher(t) {
    this._events = t;
  }
  get widget() {
    return null;
  }
  get contextMenu() {
    return null;
  }
  get time() {
    return this._time;
  }
}
const Oo = class Oo extends $d {
  constructor() {
    super(), this._liftAmount = 0, this._location = new v(), this._locationDelta = new v(), this._lastUpdateTime = 0, this._changeTime = 0, this._updateInterval = Oo.DEFAULT_UPDATE_INTERVAL;
  }
  dispose() {
    this._liftAmount = 0, super.dispose();
  }
  update(t) {
    super.update(t);
    const e = this.getLocationOffset(), s = this.object && this.object.model;
    if (s && (e ? this._liftAmount !== e.z && (this._liftAmount = e.z, s.setValue(I.FURNITURE_LIFT_AMOUNT, this._liftAmount)) : this._liftAmount !== 0 && (this._liftAmount = 0, s.setValue(I.FURNITURE_LIFT_AMOUNT, this._liftAmount))), this._locationDelta.length > 0 || e) {
      const r = Oo.TEMP_VECTOR;
      let n = this.time - this._changeTime;
      n === this._updateInterval >> 1 && n++, n > this._updateInterval && (n = this._updateInterval), this._locationDelta.length > 0 ? (r.assign(this._locationDelta), r.multiply(n / this._updateInterval), r.add(this._location)) : r.assign(this._location), e && r.add(e), this.object.setLocation(r), n === this._updateInterval && (this._locationDelta.x = 0, this._locationDelta.y = 0, this._locationDelta.z = 0);
    }
    this._lastUpdateTime = this.time;
  }
  setObject(t) {
    super.setObject(t), t && this._location.assign(t.getLocation());
  }
  processUpdateMessage(t) {
    if (t && (super.processUpdateMessage(t), t.location && this._location.assign(t.location), t instanceof _n))
      return this.processMoveMessage(t);
  }
  processMoveMessage(t) {
    !t || !this.object || !t.location || (this._changeTime = this._lastUpdateTime, this._locationDelta.assign(t.targetLocation), this._locationDelta.subtract(this._location));
  }
  getLocationOffset() {
    return null;
  }
  get lastUpdateTime() {
    return this._lastUpdateTime;
  }
  set updateInterval(t) {
    t <= 0 && (t = 1), this._updateInterval = t;
  }
};
Oo.DEFAULT_UPDATE_INTERVAL = 500, Oo.TEMP_VECTOR = new v();
let dn = Oo;
const de = class de extends dn {
  constructor() {
    super(), this._selected = !1, this._reportedLocation = null, this._effectChangeTimeStamp = 0, this._newEffect = 0, this._blinkingStartTimestamp = Nt() + this.randomBlinkStartTimestamp(), this._blinkingEndTimestamp = 0, this._talkingEndTimestamp = 0, this._talkingPauseStartTimestamp = 0, this._talkingPauseEndTimestamp = 0, this._carryObjectStartTimestamp = 0, this._carryObjectEndTimestamp = 0, this._allowUseCarryObject = !1, this._animationEndTimestamp = 0, this._signEndTimestamp = 0, this._gestureEndTimestamp = 0, this._numberValueEndTimestamp = 0;
  }
  getEventTypes() {
    const t = [at.CLICK, at.DOUBLE_CLICK, $e.POSITION_CHANGED, at.MOUSE_ENTER, at.MOUSE_LEAVE, z.MOUSE_BUTTON, z.MOUSE_ARROW];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  dispose() {
    this._selected && this.object && this.eventDispatcher && this.eventDispatcher.dispatchEvent(new $e($e.OBJECT_REMOVED, this.object)), super.dispose(), this._reportedLocation = null;
  }
  update(t) {
    if (super.update(t), this._selected && this.object && this.eventDispatcher) {
      const s = this.object.getLocation();
      (!this._reportedLocation || this._reportedLocation.x !== s.x || this._reportedLocation.y !== s.y || this._reportedLocation.z !== s.z) && (this._reportedLocation || (this._reportedLocation = new v()), this._reportedLocation.assign(s), this.eventDispatcher.dispatchEvent(new $e($e.POSITION_CHANGED, this.object)));
    }
    const e = this.object && this.object.model;
    e && this.updateModel(this.time, e);
  }
  updateModel(t, e) {
    this._talkingEndTimestamp > 0 && (t > this._talkingEndTimestamp ? (e.setValue(I.FIGURE_TALK, 0), this._talkingEndTimestamp = 0, this._talkingPauseStartTimestamp = 0, this._talkingPauseEndTimestamp = 0) : !this._talkingPauseEndTimestamp && !this._talkingPauseStartTimestamp ? (this._talkingPauseStartTimestamp = t + this.randomTalkingPauseStartTimestamp(), this._talkingPauseEndTimestamp = this._talkingPauseStartTimestamp + this.randomTalkingPauseEndTimestamp()) : this._talkingPauseStartTimestamp > 0 && t > this._talkingPauseStartTimestamp ? (e.setValue(I.FIGURE_TALK, 0), this._talkingPauseStartTimestamp = 0) : this._talkingPauseEndTimestamp > 0 && t > this._talkingPauseEndTimestamp && (e.setValue(I.FIGURE_TALK, 1), this._talkingPauseEndTimestamp = 0)), this._animationEndTimestamp > 0 && t > this._animationEndTimestamp && (e.setValue(I.FIGURE_EXPRESSION, 0), this._animationEndTimestamp = 0), this._gestureEndTimestamp > 0 && t > this._gestureEndTimestamp && (e.setValue(I.FIGURE_GESTURE, 0), this._gestureEndTimestamp = 0), this._signEndTimestamp > 0 && t > this._signEndTimestamp && (e.setValue(I.FIGURE_SIGN, -1), this._signEndTimestamp = 0), this._carryObjectEndTimestamp > 0 && t > this._carryObjectEndTimestamp && (e.setValue(I.FIGURE_CARRY_OBJECT, 0), e.setValue(I.FIGURE_USE_OBJECT, 0), this._carryObjectStartTimestamp = 0, this._carryObjectEndTimestamp = 0, this._allowUseCarryObject = !1), this._allowUseCarryObject && t - this._carryObjectStartTimestamp > 5e3 && ((t - this._carryObjectStartTimestamp) % 1e4 < 1e3 ? e.setValue(I.FIGURE_USE_OBJECT, 1) : e.setValue(I.FIGURE_USE_OBJECT, 0)), this._blinkingStartTimestamp > -1 && t > this._blinkingStartTimestamp && (e.setValue(I.FIGURE_BLINK, 1), this._blinkingStartTimestamp = t + this.randomBlinkStartTimestamp(), this._blinkingEndTimestamp = t + this.randomBlinkEndTimestamp()), this._blinkingEndTimestamp > 0 && t > this._blinkingEndTimestamp && (e.setValue(I.FIGURE_BLINK, 0), this._blinkingEndTimestamp = 0), this._effectChangeTimeStamp > 0 && t > this._effectChangeTimeStamp && (e.setValue(I.FIGURE_EFFECT, this._newEffect), this._effectChangeTimeStamp = 0), this._numberValueEndTimestamp > 0 && t > this._numberValueEndTimestamp && (e.setValue(I.FIGURE_NUMBER_VALUE, 0), this._numberValueEndTimestamp = 0);
  }
  processUpdateMessage(t) {
    if (!t || !this.object) return;
    super.processUpdateMessage(t);
    const e = this.object && this.object.model;
    if (e) {
      if (t instanceof gI) {
        e.setValue(I.FIGURE_POSTURE, t.postureType), e.setValue(I.FIGURE_POSTURE_PARAMETER, t.parameter);
        return;
      }
      if (t instanceof fI) {
        e.setValue(I.FIGURE_TALK, 1), this._talkingEndTimestamp = this.time + t.numberOfWords * 1e3;
        return;
      }
      if (t instanceof PM) {
        e.setValue(I.FIGURE_IS_TYPING, t.isTyping ? 1 : 0);
        return;
      }
      if (t instanceof yM) {
        e.setValue(I.FIGURE_IS_MUTED, t.isMuted ? 1 : 0);
        return;
      }
      if (t instanceof MM) {
        e.setValue(I.FIGURE_IS_PLAYING_GAME, t.isPlayingGame ? 1 : 0);
        return;
      }
      if (t instanceof Dc) {
        e.setValue(I.HEAD_DIRECTION, t.headDirection), e.setValue(I.FIGURE_CAN_STAND_UP, t.canStandUp), e.setValue(I.FIGURE_VERTICAL_OFFSET, t.baseY);
        return;
      }
      if (t instanceof OM) {
        e.setValue(I.FIGURE_GESTURE, t.gesture), this._gestureEndTimestamp = this.time + 3e3;
        return;
      }
      if (t instanceof AM) {
        e.setValue(I.FIGURE_EXPRESSION, t.expressionType), this._animationEndTimestamp = et.getExpressionTimeout(e.getValue(I.FIGURE_EXPRESSION)), this._animationEndTimestamp > -1 && (this._animationEndTimestamp += this.time);
        return;
      }
      if (t instanceof TM) {
        e.setValue(I.FIGURE_DANCE, t.danceStyle);
        return;
      }
      if (t instanceof pI) {
        e.setValue(I.FIGURE_SLEEP, t.isSleeping ? 1 : 0), t.isSleeping ? this._blinkingStartTimestamp = -1 : this._blinkingStartTimestamp = this.time + this.randomBlinkStartTimestamp();
        return;
      }
      if (t instanceof xM) {
        e.setValue(I.FIGURE_NUMBER_VALUE, t.value), this._numberValueEndTimestamp = this.time + 3e3;
        return;
      }
      if (t instanceof IM) {
        this.updateAvatarEffect(t.effect, t.delayMilliseconds, e);
        return;
      }
      if (t instanceof EM) {
        e.setValue(I.FIGURE_CARRY_OBJECT, t.itemType), e.setValue(I.FIGURE_USE_OBJECT, 0), t.itemType === 0 ? (this._carryObjectStartTimestamp = 0, this._carryObjectEndTimestamp = 0, this._allowUseCarryObject = !1) : (this._carryObjectStartTimestamp = this.time, t.itemType < de.MAX_HAND_ID ? (this._carryObjectEndTimestamp = 0, this._allowUseCarryObject = t.itemType <= de.MAX_HAND_USE_ID) : (this._carryObjectEndTimestamp = this._carryObjectStartTimestamp + 1500, this._allowUseCarryObject = !1));
        return;
      }
      if (t instanceof NM) {
        e.setValue(I.FIGURE_USE_OBJECT, t.itemType);
        return;
      }
      if (t instanceof bM) {
        e.setValue(I.FIGURE_SIGN, t.signType), this._signEndTimestamp = this.time + 5e3;
        return;
      }
      if (t instanceof RM) {
        e.setValue(I.FIGURE_FLAT_CONTROL, t.level);
        return;
      }
      if (t instanceof Nc) {
        e.setValue(I.FIGURE, t.figure), e.setValue(I.GENDER, t.gender);
        return;
      }
      if (t instanceof Uc) {
        this._selected = t.selected, this._reportedLocation = null;
        return;
      }
      if (t instanceof vM) {
        e.setValue(I.OWN_USER, 1);
        return;
      }
    }
  }
  updateAvatarEffect(t, e, s) {
    if (t === de.EFFECT_TYPE_SPLASH)
      this._effectChangeTimeStamp = Nt() + de.EFFECT_SPLASH_LENGTH, this._newEffect = de.EFFECT_TYPE_SWIM;
    else if (t === de.EFFECT_TYPE_SPLASH_DARK)
      this._effectChangeTimeStamp = Nt() + de.EFFECT_SPLASH_LENGTH, this._newEffect = de.EFFECT_TYPE_SWIM_DARK;
    else if (s.getValue(I.FIGURE_EFFECT) === de.EFFECT_TYPE_SWIM)
      this._effectChangeTimeStamp = Nt() + de.EFFECT_SPLASH_LENGTH, this._newEffect = t, t = de.EFFECT_TYPE_SPLASH;
    else if (s.getValue(I.FIGURE_EFFECT) === de.EFFECT_TYPE_SWIM_DARK)
      this._effectChangeTimeStamp = Nt() + de.EFFECT_SPLASH_LENGTH, this._newEffect = t, t = de.EFFECT_TYPE_SPLASH_DARK;
    else if (e === 0)
      this._effectChangeTimeStamp = 0;
    else {
      this._effectChangeTimeStamp = Nt() + e, this._newEffect = t;
      return;
    }
    s.setValue(I.FIGURE_EFFECT, t);
  }
  mouseEvent(t, e) {
    let s = null;
    switch (t.type) {
      case J.MOUSE_CLICK:
        s = at.CLICK;
        break;
      case J.DOUBLE_CLICK:
        s = at.DOUBLE_CLICK;
        break;
      case J.ROLL_OVER:
        s = at.MOUSE_ENTER, this.object.model && this.object.model.setValue(I.FIGURE_HIGHLIGHT, 1), this.eventDispatcher && this.eventDispatcher.dispatchEvent(new z(z.MOUSE_BUTTON, this.object));
        break;
      case J.ROLL_OUT:
        s = at.MOUSE_LEAVE, this.object.model && this.object.model.setValue(I.FIGURE_HIGHLIGHT, 0), this.eventDispatcher && this.eventDispatcher.dispatchEvent(new z(z.MOUSE_ARROW, this.object));
        break;
    }
    s && this.eventDispatcher && this.eventDispatcher.dispatchEvent(new at(s, this.object, t.eventId, t.altKey, t.ctrlKey, t.shiftKey, t.buttonDown));
  }
  randomTalkingPauseStartTimestamp() {
    return 100 + Math.random() * 200;
  }
  randomTalkingPauseEndTimestamp() {
    return 75 + Math.random() * 75;
  }
  randomBlinkStartTimestamp() {
    return 4500 + Math.random() * 1e3;
  }
  randomBlinkEndTimestamp() {
    return 50 + Math.random() * 200;
  }
};
de.MAX_HAND_ID = 999999999, de.MAX_HAND_USE_ID = 999, de.EFFECT_TYPE_SPLASH = 28, de.EFFECT_SPLASH_LENGTH = 500, de.EFFECT_TYPE_SWIM = 29, de.EFFECT_TYPE_SPLASH_DARK = 184, de.EFFECT_TYPE_SWIM_DARK = 185;
let IE = de;
class bst extends dn {
  constructor() {
    super(), this._selected = !1, this._reportedLocation = null, this._postureIndex = 0, this._gestureIndex = 0, this._headDirectionDelta = 0, this._directions = [], this._talkingEndTimestamp = 0, this._gestureEndTimestamp = 0, this._expressionEndTimestamp = 0;
  }
  getEventTypes() {
    const t = [at.CLICK, $e.POSITION_CHANGED];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  initialize(t) {
    if (!t) return;
    const e = this.object && this.object.model;
    if (e) {
      if (t.logic && t.logic.model) {
        const s = t.logic.model.directions;
        if (s && s.length) {
          for (const r of s) this._directions.push(r);
          this._directions.sort();
        }
      }
      e.setValue(I.PET_ALLOWED_DIRECTIONS, this._directions);
    }
  }
  dispose() {
    this._selected && this.object && this.eventDispatcher && this.eventDispatcher.dispatchEvent(new $e($e.OBJECT_REMOVED, this.object)), this._directions = null, this._reportedLocation = null;
  }
  update(t) {
    if (super.update(t), this._selected && this.object && this.eventDispatcher) {
      const e = this.object.getLocation();
      (!this._reportedLocation || this._reportedLocation.x !== e.x || this._reportedLocation.y !== e.y || this._reportedLocation.z !== e.z) && (this._reportedLocation || (this._reportedLocation = new v()), this._reportedLocation.assign(e), this.eventDispatcher.dispatchEvent(new $e($e.POSITION_CHANGED, this.object)));
    }
    this.object && this.object.model && this.updateModel(t, this.object.model);
  }
  updateModel(t, e) {
    this._gestureEndTimestamp > 0 && t > this._gestureEndTimestamp && (e.setValue(I.FIGURE_GESTURE, null), this._gestureEndTimestamp = 0), this._talkingEndTimestamp > 0 && t > this._talkingEndTimestamp && (e.setValue(I.FIGURE_TALK, 0), this._talkingEndTimestamp = 0), this._expressionEndTimestamp > 0 && t > this._expressionEndTimestamp && (e.setValue(I.FIGURE_EXPRESSION, 0), this._expressionEndTimestamp = 0);
  }
  processUpdateMessage(t) {
    if (!t || !this.object) return;
    super.processUpdateMessage(t);
    const e = this.object && this.object.model;
    if (e) {
      if (t instanceof Dc) {
        e.setValue(I.HEAD_DIRECTION, t.headDirection);
        return;
      }
      if (t instanceof Nc) {
        const s = new $l(t.figure);
        e.setValue(I.FIGURE, t.figure), e.setValue(I.RACE, t.subType), e.setValue(I.PET_PALETTE_INDEX, s.paletteId), e.setValue(I.PET_COLOR, s.color), e.setValue(I.PET_TYPE, s.typeId), e.setValue(I.PET_CUSTOM_LAYER_IDS, s.customLayerIds), e.setValue(I.PET_CUSTOM_PARTS_IDS, s.customPartIds), e.setValue(I.PET_CUSTOM_PALETTE_IDS, s.customPaletteIds), e.setValue(I.PET_IS_RIDING, t.isRiding ? 1 : 0);
        return;
      }
      if (t instanceof gI) {
        e.setValue(I.FIGURE_POSTURE, t.postureType);
        return;
      }
      if (t instanceof fI) {
        e.setValue(I.FIGURE_TALK, 1), this._talkingEndTimestamp = this.time + t.numberOfWords * 1e3;
        return;
      }
      if (t instanceof pI) {
        e.setValue(I.FIGURE_SLEEP, t.isSleeping ? 1 : 0);
        return;
      }
      if (t instanceof CM) {
        e.setValue(I.FIGURE_GESTURE, t.gesture), this._gestureEndTimestamp = this.time + 3e3;
        return;
      }
      if (t instanceof Uc) {
        this._selected = t.selected, this._reportedLocation = null;
        return;
      }
      if (t instanceof SM) {
        e.setValue(I.FIGURE_EXPERIENCE_TIMESTAMP, this.time), e.setValue(I.FIGURE_GAINED_EXPERIENCE, t.gainedExperience);
        return;
      }
    }
  }
  mouseEvent(t, e) {
    let s = null;
    switch (t.type) {
      case J.MOUSE_CLICK:
        s = at.CLICK;
        break;
      case J.DOUBLE_CLICK:
        break;
      case J.MOUSE_DOWN: {
        this.object.model.getValue(I.PET_TYPE) === Eu.MONSTERPLANT && this.eventDispatcher && this.eventDispatcher.dispatchEvent(new at(at.MOUSE_DOWN, this.object, t.eventId, t.altKey, t.ctrlKey, t.shiftKey, t.buttonDown));
        break;
      }
    }
    s && this.eventDispatcher && this.eventDispatcher.dispatchEvent(new at(s, this.object, t.eventId, t.altKey, t.ctrlKey, t.shiftKey, t.buttonDown));
  }
}
class Pst extends $d {
  constructor() {
    super(), this._planeParser = new ye(), this._planeBitmapMaskParser = new mM(), this._color = 16777215, this._light = 255, this._originalColor = 16777215, this._originalLight = 255, this._targetColor = 16777215, this._targetLight = 255, this._colorChangedTime = 0, this._colorTransitionLength = 1500, this._lastHoleUpdate = 0, this._needsMapUpdate = !1, this._skipColorTransition = !1;
  }
  getEventTypes() {
    const t = [at.MOUSE_MOVE, at.CLICK];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  dispose() {
    super.dispose(), this._planeParser && (this._planeParser.dispose(), this._planeParser = null), this._planeBitmapMaskParser && (this._planeBitmapMaskParser.dispose(), this._planeBitmapMaskParser = null);
  }
  initialize(t) {
    !t || !this.object || t instanceof gM && this._planeParser.initializeFromMapData(t) && (this.object.model.setValue(I.ROOM_MAP_DATA, t), this.object.model.setValue(I.ROOM_BACKGROUND_COLOR, 16777215), this.object.model.setValue(I.ROOM_FLOOR_VISIBILITY, 1), this.object.model.setValue(I.ROOM_WALL_VISIBILITY, 1), this.object.model.setValue(I.ROOM_LANDSCAPE_VISIBILITY, 1), this._skipColorTransition = Ct().getValue("room.color.skip.transition") === !0);
  }
  update(t) {
    if (super.update(t), this.updateBackgroundColor(t), this._needsMapUpdate) {
      if (this._lastHoleUpdate && t - this._lastHoleUpdate < 5) return;
      const e = this.object && this.object.model;
      if (e) {
        const s = this._planeParser.getMapData();
        e.setValue(I.ROOM_MAP_DATA, s), e.setValue(I.ROOM_FLOOR_HOLE_UPDATE_TIME, t), this._planeParser.initializeFromMapData(s);
      }
      this._lastHoleUpdate = 0, this._needsMapUpdate = !1;
    }
  }
  updateBackgroundColor(t) {
    if (!this.object || !this._colorChangedTime) return;
    let e = this._color, s = this._light;
    if (t - this._colorChangedTime >= this._colorTransitionLength)
      e = this._targetColor, s = this._targetLight, this._colorChangedTime = 0;
    else {
      let n = this._originalColor >> 16 & 255, a = this._originalColor >> 8 & 255, o = this._originalColor & 255;
      const h = this._targetColor >> 16 & 255, u = this._targetColor >> 8 & 255, c = this._targetColor & 255, l = (t - this._colorChangedTime) / this._colorTransitionLength;
      n = n + (h - n) * l, a = a + (u - a) * l, o = o + (c - o) * l, e = (n << 16) + (a << 8) + o, s = this._originalLight + (this._targetLight - this._originalLight) * l, this._color = e, this._light = s;
    }
    let r = Ql.rgbToHSL(e);
    r = (r & 16776960) + s, e = Ql.hslToRGB(r), this.object.model && this.object.model.setValue(I.ROOM_BACKGROUND_COLOR, e);
  }
  processUpdateMessage(t) {
    if (!t || !this.object) return;
    const e = this.object.model;
    if (e) {
      if (t instanceof we) {
        this.onObjectRoomUpdateMessage(t, e);
        return;
      }
      if (t instanceof qe) {
        this.onObjectRoomMaskUpdateMessage(t, e);
        return;
      }
      if (t instanceof Ir) {
        this.onObjectRoomPlaneVisibilityUpdateMessage(t, e);
        return;
      }
      if (t instanceof Tr) {
        this.onObjectRoomPlanePropertyUpdateMessage(t, e);
        return;
      }
      if (t instanceof Ps) {
        this.onObjectRoomFloorHoleUpdateMessage(t, e);
        return;
      }
      if (t instanceof Fu) {
        this.onObjectRoomColorUpdateMessage(t, e);
        return;
      }
      t instanceof Lc && this.onObjectRoomMapUpdateMessage(t);
    }
  }
  onObjectRoomUpdateMessage(t, e) {
    switch (t.type) {
      case we.ROOM_FLOOR_UPDATE:
        e.setValue(I.ROOM_FLOOR_TYPE, t.value);
        return;
      case we.ROOM_WALL_UPDATE:
        e.setValue(I.ROOM_WALL_TYPE, t.value);
        return;
      case we.ROOM_LANDSCAPE_UPDATE:
        e.setValue(I.ROOM_LANDSCAPE_TYPE, t.value);
        return;
    }
  }
  onObjectRoomMaskUpdateMessage(t, e) {
    let s = null, r = !1;
    switch (t.type) {
      case qe.ADD_MASK:
        s = Ia.WINDOW, t.maskCategory === qe.HOLE && (s = Ia.HOLE), this._planeBitmapMaskParser.addMask(t.maskId, t.maskType, t.maskLocation, s), r = !0;
        break;
      case qe.REMOVE_MASK:
        r = this._planeBitmapMaskParser.removeMask(t.maskId);
        break;
    }
    r && e.setValue(I.ROOM_PLANE_MASK_XML, this._planeBitmapMaskParser.getXML());
  }
  onObjectRoomPlaneVisibilityUpdateMessage(t, e) {
    let s = 0;
    switch (t.visible && (s = 1), t.type) {
      case Ir.FLOOR_VISIBILITY:
        e.setValue(I.ROOM_FLOOR_VISIBILITY, s);
        return;
      case Ir.WALL_VISIBILITY:
        e.setValue(I.ROOM_WALL_VISIBILITY, s), e.setValue(I.ROOM_LANDSCAPE_VISIBILITY, s);
        return;
    }
  }
  onObjectRoomPlanePropertyUpdateMessage(t, e) {
    switch (t.type) {
      case Tr.FLOOR_THICKNESS:
        e.setValue(I.ROOM_FLOOR_THICKNESS, t.value);
        return;
      case Tr.WALL_THICKNESS:
        e.setValue(I.ROOM_WALL_THICKNESS, t.value);
        return;
    }
  }
  onObjectRoomFloorHoleUpdateMessage(t, e) {
    switch (t.type) {
      case Ps.ADD:
        this._planeParser.addFloorHole(t.id, t.x, t.y, t.width, t.height), this._needsMapUpdate = !0;
        return;
      case Ps.REMOVE:
        this._planeParser.removeFloorHole(t.id), this._needsMapUpdate = !0;
        return;
    }
    this._lastHoleUpdate = this.time;
  }
  onObjectRoomColorUpdateMessage(t, e) {
    !t || !e || (this._originalColor = this._color, this._originalLight = this._light, this._targetColor = t.color, this._targetLight = t.light, this._colorChangedTime = this.time, this._skipColorTransition ? this._colorTransitionLength = 0 : this._colorTransitionLength = 1500, e.setValue(I.ROOM_COLORIZE_BG_ONLY, t.backgroundOnly));
  }
  onObjectRoomMapUpdateMessage(t) {
    !t || !t.mapData || (this.object.model.setValue(I.ROOM_MAP_DATA, t.mapData), this.object.model.setValue(I.ROOM_FLOOR_HOLE_UPDATE_TIME, this.time), this._planeParser.initializeFromMapData(t.mapData));
  }
  mouseEvent(t, e) {
    if (!t || !e || !this.object || !this.object.model) return;
    const s = t.spriteTag;
    let r = 0;
    if (s && s.indexOf("@") >= 0 && (r = parseInt(s.substr(s.indexOf("@") + 1))), r < 1 || r > this._planeParser.planeCount) {
      t.type === J.ROLL_OUT && this.object.model.setValue(I.ROOM_SELECTED_PLANE, 0);
      return;
    }
    r--;
    let n = null;
    const a = this._planeParser.getPlaneLocation(r), o = this._planeParser.getPlaneLeftSide(r), h = this._planeParser.getPlaneRightSide(r), u = this._planeParser.getPlaneNormalDirection(r), c = this._planeParser.getPlaneType(r);
    if (a == null || o == null || h == null || u == null) return;
    const l = o.length, _ = h.length;
    if (l == 0 || _ == 0) return;
    const d = t.screenX, f = t.screenY, p = new st(d, f);
    if (n = e.getPlanePosition(p, a, o, h), !n) {
      this.object.model.setValue(I.ROOM_SELECTED_PLANE, 0);
      return;
    }
    const g = v.product(o, n.x / l);
    g.add(v.product(h, n.y / _)), g.add(a);
    const m = g.x, O = g.y, y = g.z;
    if (n.x >= 0 && n.x < l && n.y >= 0 && n.y < _)
      this.object.model.setValue(I.ROOM_SELECTED_X, m), this.object.model.setValue(I.ROOM_SELECTED_Y, O), this.object.model.setValue(I.ROOM_SELECTED_Z, y), this.object.model.setValue(I.ROOM_SELECTED_PLANE, r + 1);
    else {
      this.object.model.setValue(I.ROOM_SELECTED_PLANE, 0);
      return;
    }
    let C = null;
    switch (t.type === J.MOUSE_MOVE || t.type === J.ROLL_OVER ? C = at.MOUSE_MOVE : t.type === J.MOUSE_CLICK ? C = at.CLICK : t.type === J.MOUSE_DOWN && (C = at.MOUSE_DOWN), t.type) {
      case J.MOUSE_MOVE:
      case J.ROLL_OVER:
      case J.MOUSE_DOWN:
      case J.MOUSE_CLICK: {
        let b = null;
        if (c === ue.PLANE_FLOOR)
          b = new Ii(C, this.object, t.eventId, m, O, y, t.altKey, t.ctrlKey, t.shiftKey, t.buttonDown);
        else if (c === ue.PLANE_WALL || c === ue.PLANE_LANDSCAPE) {
          let D = 90;
          u && (D = u.x + 90, D > 360 && (D -= 360));
          const P = o.length * n.x / l, F = h.length * n.y / _;
          b = new La(C, this.object, t.eventId, a, o, h, P, F, D, t.altKey, t.ctrlKey, t.shiftKey, t.buttonDown);
        }
        this.eventDispatcher && this.eventDispatcher.dispatchEvent(b);
        return;
      }
    }
  }
}
class Nst extends $d {
  initialize(t) {
    this.object && (this.object.model.setValue(I.FURNITURE_ALPHA_MULTIPLIER, 1), this.object.setState(1, 0));
  }
  processUpdateMessage(t) {
    if (super.processUpdateMessage(t), t instanceof Sr && this.object)
      switch (t.type) {
        case Sr.ENABLED:
          this.object.setState(0, 0);
          return;
        case Sr.DISABLED:
          this.object.setState(1, 0);
          return;
      }
  }
}
const bi = class bi extends $d {
  constructor() {
    super(), this._lastEventId = null, this._isHidden = !1;
  }
  initialize(t) {
    this.object && (this.object.model.setValue(I.FURNITURE_ALPHA_MULTIPLIER, 1), this.object.setState(bi.CURSOR_HIDDEN_STATE, 0));
  }
  processUpdateMessage(t) {
    t instanceof ka && (this._lastEventId && this._lastEventId === t.sourceEventId || (t.toggleVisibility && (this._isHidden = !this._isHidden), super.processUpdateMessage(t), this.object && (this._isHidden ? this.object.setState(bi.CURSOR_HIDDEN_STATE, 0) : t.visible ? (this.object.model.setValue(I.TILE_CURSOR_HEIGHT, t.height), this.object.setState(t.height > 0.8 ? bi.CURSOR_HEIGHT_STATE : bi.CURSOR_VISIBLE_STATE)) : this.object.setState(bi.CURSOR_HIDDEN_STATE, 0)), this._lastEventId = t.sourceEventId));
  }
};
bi.CURSOR_VISIBLE_STATE = 0, bi.CURSOR_HIDDEN_STATE = 1, bi.CURSOR_HEIGHT_STATE = 6;
let SE = bi;
const cs = class cs extends dn {
  constructor() {
    super(), this._sizeX = 0, this._sizeY = 0, this._sizeZ = 0, this._centerX = 0, this._centerY = 0, this._centerZ = 0, this._directions = [], this._mouseOver = !1, this._locationOffset = new v(), this._bouncingStep = 0, this._storedRotateMessage = null, this._directionInitialized = !1, cs.BOUNCING_STEPS === -1 && (cs.BOUNCING_STEPS = Ct().getValue("furni.rotation.bounce.steps", 8)), cs.BOUNCING_Z === -1 && (cs.BOUNCING_Z = Ct().getValue("furni.rotation.bounce.height", 0.0625));
  }
  getEventTypes() {
    const t = [
      At.STATE_CHANGE,
      at.CLICK,
      at.MOUSE_DOWN,
      at.MOUSE_DOWN_LONG,
      ee.ROOM_AD_TOOLTIP_SHOW,
      ee.ROOM_AD_TOOLTIP_HIDE,
      ee.ROOM_AD_FURNI_DOUBLE_CLICK,
      ee.ROOM_AD_FURNI_CLICK
    ];
    return this.widget && t.push(N.OPEN_WIDGET, N.CLOSE_WIDGET), this.contextMenu && t.push(N.OPEN_FURNI_CONTEXT_MENU, N.CLOSE_FURNI_CONTEXT_MENU), this.mergeTypes(super.getEventTypes(), t);
  }
  initialize(t) {
    if (!t) return;
    const e = this.object && this.object.model;
    if (e) {
      if (t.logic) {
        if (t.logic.model) {
          const s = t.logic.model.dimensions;
          s && (this._sizeX = s.x, this._sizeY = s.y, this._sizeZ = s.z, this._centerX = this._sizeX / 2, this._centerY = this._sizeY / 2, this._centerZ = this._sizeZ / 2);
          const r = t.logic.model.directions;
          if (r && r.length) {
            for (const n of r) this._directions.push(n);
            this._directions.sort((n, a) => n - a);
          }
        }
        if (t.logic.customVars) {
          const s = t.logic.customVars.variables;
          s && s.length && e.setValue(I.FURNITURE_CUSTOM_VARIABLES, s);
        }
      }
      e.setValue(I.FURNITURE_SIZE_X, this._sizeX), e.setValue(I.FURNITURE_SIZE_Y, this._sizeY), e.setValue(I.FURNITURE_SIZE_Z, this._sizeZ), e.setValue(I.FURNITURE_CENTER_X, this._centerX), e.setValue(I.FURNITURE_CENTER_Y, this._centerY), e.setValue(I.FURNITURE_CENTER_Z, this._centerZ), e.setValue(I.FURNITURE_ALLOWED_DIRECTIONS, this._directions), e.setValue(I.FURNITURE_ALPHA_MULTIPLIER, 1);
    }
  }
  dispose() {
    this._storedRotateMessage = null, this._directions = null, super.dispose();
  }
  setObject(t) {
    super.setObject(t), t && t.getLocation().length && (this._directionInitialized = !0);
  }
  getAdClickUrl(t) {
    return t.getValue(I.FURNITURE_AD_URL);
  }
  handleAdClick(t, e, s) {
    this.eventDispatcher && this.eventDispatcher.dispatchEvent(new ee(ee.ROOM_AD_FURNI_CLICK, this.object));
  }
  update(t) {
    super.update(t), this._bouncingStep > 0 && (this._bouncingStep++, this._bouncingStep > cs.BOUNCING_STEPS && (this._bouncingStep = 0));
  }
  processUpdateMessage(t) {
    if (t instanceof Ht) {
      this.processDataUpdateMessage(t);
      return;
    }
    if (t instanceof UM) {
      this.processObjectHeightUpdateMessage(t);
      return;
    }
    if (t instanceof mI) {
      this.processItemDataUpdateMessage(t);
      return;
    }
    if (this._mouseOver = !1, t.location && t.direction) {
      if (!(t instanceof _n)) {
        const e = this.object.getDirection(), s = this.object.getLocation();
        e.x !== t.direction.x && this._directionInitialized && s.x === t.location.x && s.y === t.location.y && s.z === t.location.z && (this._bouncingStep = 1, this._storedRotateMessage = new Ce(t.location, t.direction), t = null);
      }
      this._directionInitialized = !0;
    }
    if (t instanceof wu && this.contextMenu && this.eventDispatcher && this.object) {
      const e = t.selected ? N.OPEN_FURNI_CONTEXT_MENU : N.CLOSE_FURNI_CONTEXT_MENU;
      this.eventDispatcher.dispatchEvent(new N(e, this.object));
    }
    super.processUpdateMessage(t);
  }
  processDataUpdateMessage(t) {
    t && (this.object.setState(t.state, 0), t.data && t.data.writeRoomObjectModel(this.object.model), t.extra !== null && this.object.model.setValue(I.FURNITURE_EXTRAS, t.extra.toString()), this.object.model.setValue(I.FURNITURE_STATE_UPDATE_TIME, this.lastUpdateTime));
  }
  processObjectHeightUpdateMessage(t) {
    t && this.object.model.setValue(I.FURNITURE_SIZE_Z, t.height);
  }
  processItemDataUpdateMessage(t) {
    t && this.object.model.setValue(I.FURNITURE_ITEMDATA, t.data);
  }
  mouseEvent(t, e) {
    const s = this.getAdClickUrl(this.object.model);
    switch (t.type) {
      case J.MOUSE_MOVE:
        if (this.eventDispatcher) {
          const r = new at(at.MOUSE_MOVE, this.object, t.eventId, t.altKey, t.ctrlKey, t.shiftKey, t.buttonDown);
          r.localX = t.localX, r.localY = t.localY, r.spriteOffsetX = t.spriteOffsetX, r.spriteOffsetY = t.spriteOffsetY, this.eventDispatcher.dispatchEvent(r);
        }
        return;
      case J.ROLL_OVER:
        if (!this._mouseOver) {
          if (this.eventDispatcher) {
            s && s.indexOf("http") === 0 && this.eventDispatcher.dispatchEvent(new ee(ee.ROOM_AD_TOOLTIP_SHOW, this.object));
            const r = new at(at.MOUSE_ENTER, this.object, t.eventId, t.altKey, t.ctrlKey, t.shiftKey, t.buttonDown);
            r.localX = t.localX, r.localY = t.localY, r.spriteOffsetX = t.spriteOffsetX, r.spriteOffsetY = t.spriteOffsetY, this.eventDispatcher.dispatchEvent(r);
          }
          this._mouseOver = !0;
        }
        return;
      case J.ROLL_OUT:
        if (this._mouseOver) {
          if (this.eventDispatcher) {
            s && s.indexOf("http") === 0 && this.eventDispatcher.dispatchEvent(new ee(ee.ROOM_AD_TOOLTIP_HIDE, this.object));
            const r = new at(at.MOUSE_LEAVE, this.object, t.eventId, t.altKey, t.ctrlKey, t.shiftKey, t.buttonDown);
            r.localX = t.localX, r.localY = t.localY, r.spriteOffsetX = t.spriteOffsetX, r.spriteOffsetY = t.spriteOffsetY, this.eventDispatcher.dispatchEvent(r);
          }
          this._mouseOver = !1;
        }
        return;
      case J.DOUBLE_CLICK:
        this.useObject();
        return;
      case J.MOUSE_CLICK:
        if (this.eventDispatcher) {
          const r = new at(at.CLICK, this.object, t.eventId, t.altKey, t.ctrlKey, t.shiftKey, t.buttonDown);
          r.localX = t.localX, r.localY = t.localY, r.spriteOffsetX = t.spriteOffsetX, r.spriteOffsetY = t.spriteOffsetY, this.eventDispatcher.dispatchEvent(r), s && s.indexOf("http") === 0 && this.eventDispatcher.dispatchEvent(new ee(ee.ROOM_AD_TOOLTIP_HIDE, this.object)), s && s.length && this.handleAdClick(this.object.id, this.object.type, s);
        }
        return;
      case J.MOUSE_DOWN:
        if (this.eventDispatcher) {
          const r = new at(at.MOUSE_DOWN, this.object, t.eventId, t.altKey, t.ctrlKey, t.shiftKey, t.buttonDown);
          this.eventDispatcher.dispatchEvent(r);
        }
        return;
      case J.MOUSE_DOWN_LONG:
        if (this.eventDispatcher) {
          const r = new at(at.MOUSE_DOWN_LONG, this.object, t.eventId, t.altKey, t.ctrlKey, t.shiftKey, t.buttonDown);
          this.eventDispatcher.dispatchEvent(r);
        }
        return;
    }
  }
  getLocationOffset() {
    return this._bouncingStep <= 0 ? null : (this._locationOffset.x = 0, this._locationOffset.y = 0, this._bouncingStep <= cs.BOUNCING_STEPS / 2 ? this._locationOffset.z = cs.BOUNCING_Z * this._bouncingStep : this._bouncingStep <= cs.BOUNCING_STEPS && (this._storedRotateMessage && (super.processUpdateMessage(this._storedRotateMessage), this._storedRotateMessage = null), this._locationOffset.z = cs.BOUNCING_Z * (cs.BOUNCING_STEPS - this._bouncingStep)), this._locationOffset);
  }
  useObject() {
    if (!this.object || !this.eventDispatcher) return;
    const t = this.getAdClickUrl(this.object.model);
    t && t.length && this.eventDispatcher.dispatchEvent(new ee(ee.ROOM_AD_FURNI_DOUBLE_CLICK, this.object, null, t)), this.widget && this.eventDispatcher.dispatchEvent(new N(N.OPEN_WIDGET, this.object)), this.eventDispatcher.dispatchEvent(new At(At.STATE_CHANGE, this.object));
  }
  tearDown() {
    this.object.model.getValue(I.FURNITURE_REAL_ROOM_OBJECT) === 1 && (this.widget && this.eventDispatcher.dispatchEvent(new N(N.CLOSE_WIDGET, this.object)), this.contextMenu && this.eventDispatcher.dispatchEvent(new N(N.CLOSE_FURNI_CONTEXT_MENU, this.object))), super.tearDown();
  }
};
cs.BOUNCING_STEPS = -1, cs.BOUNCING_Z = -1;
let wt = cs;
class LM extends wt {
  getEventTypes() {
    const t = [N.BADGE_DISPLAY_ENGRAVING, di.LOAD_BADGE];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  processUpdateMessage(t) {
    if (super.processUpdateMessage(t), !!this.object) {
      if (t instanceof Ht) {
        const e = t.data;
        e instanceof wo && this.updateBadge(e.getValue(1));
        return;
      }
      if (t instanceof Sa) {
        t.assetName !== "loading_icon" && (this.object.model.setValue(I.FURNITURE_BADGE_ASSET_NAME, t.assetName), this.object.model.setValue(I.FURNITURE_BADGE_IMAGE_STATUS, 1), this.update(Nt()));
        return;
      }
    }
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new N(N.BADGE_DISPLAY_ENGRAVING, this.object));
  }
  updateBadge(t) {
    t !== "" && this.eventDispatcher && (this.object.model.setValue(I.FURNITURE_BADGE_IMAGE_STATUS, -1), this.eventDispatcher.dispatchEvent(new di(di.LOAD_BADGE, this.object, t, !1)));
  }
}
const _s = class _s extends LM {
  getEventTypes() {
    const t = [N.ACHIEVEMENT_RESOLUTION_OPEN, N.ACHIEVEMENT_RESOLUTION_ENGRAVING, N.ACHIEVEMENT_RESOLUTION_FAILED, di.LOAD_BADGE];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  processUpdateMessage(t) {
    if (super.processUpdateMessage(t), t instanceof Sa && t.assetName !== "loading_icon" && this.object.model.setValue(I.FURNITURE_BADGE_VISIBLE_IN_STATE, _s.BADGE_VISIBLE_IN_STATE), t instanceof wu) {
      if (!this.eventDispatcher || !this.object) return;
      this.eventDispatcher.dispatchEvent(new N(N.CLOSE_FURNI_CONTEXT_MENU, this.object));
    }
  }
  useObject() {
    if (!this.object || !this.eventDispatcher) return;
    let t = null;
    switch (this.object.getState(0)) {
      case _s.STATE_RESOLUTION_NOT_STARTED:
      case _s.STATE_RESOLUTION_IN_PROGRESS:
        t = new N(N.ACHIEVEMENT_RESOLUTION_OPEN, this.object);
        break;
      case _s.STATE_RESOLUTION_ACHIEVED:
        t = new N(N.ACHIEVEMENT_RESOLUTION_ENGRAVING, this.object);
        break;
      case _s.STATE_RESOLUTION_FAILED:
        t = new N(N.ACHIEVEMENT_RESOLUTION_FAILED, this.object);
        break;
    }
    t && this.eventDispatcher.dispatchEvent(t);
  }
  updateBadge(t) {
    t !== _s.ACH_NOT_SET && super.updateBadge(t);
  }
};
_s.STATE_RESOLUTION_NOT_STARTED = 0, _s.STATE_RESOLUTION_IN_PROGRESS = 1, _s.STATE_RESOLUTION_ACHIEVED = 2, _s.STATE_RESOLUTION_FAILED = 3, _s.ACH_NOT_SET = "ach_0", _s.BADGE_VISIBLE_IN_STATE = 2;
let AE = _s;
class _e extends wt {
  getEventTypes() {
    const t = [z.MOUSE_BUTTON, z.MOUSE_ARROW];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  mouseEvent(t, e) {
    if (!(!t || !e || !this.object)) {
      switch (t.type) {
        case J.ROLL_OVER:
          this.eventDispatcher && this.eventDispatcher.dispatchEvent(new z(z.MOUSE_BUTTON, this.object));
          break;
        case J.ROLL_OUT:
          this.eventDispatcher && this.eventDispatcher.dispatchEvent(new z(z.MOUSE_ARROW, this.object));
          break;
      }
      super.mouseEvent(t, e);
    }
  }
}
class Ust extends _e {
  getEventTypes() {
    const t = [N.AREA_HIDE];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  processUpdateMessage(t) {
    super.processUpdateMessage(t), this.object && t instanceof Ht && (t.data.writeRoomObjectModel(this.object.model), this.object.model.getValue(I.FURNITURE_REAL_ROOM_OBJECT) === 1 && this.setupObject());
  }
  setupObject() {
    if (!this.object || !this.object.model) return;
    const t = new Fo();
    t.initializeFromRoomObjectModel(this.object.model);
    const e = t.getValue(0), s = t.getValue(1), r = t.getValue(2), n = t.getValue(3), a = t.getValue(4), o = t.getValue(5) === 1, h = t.getValue(6) === 1, u = t.getValue(7) === 1;
    this.object.model.setValue(I.FURNITURE_AREA_HIDE_ROOT_X, s), this.object.model.setValue(I.FURNITURE_AREA_HIDE_ROOT_Y, r), this.object.model.setValue(I.FURNITURE_AREA_HIDE_WIDTH, n), this.object.model.setValue(I.FURNITURE_AREA_HIDE_LENGTH, a), this.object.model.setValue(I.FURNITURE_AREA_HIDE_INVISIBILITY, o ? 1 : 0), this.object.model.setValue(I.FURNITURE_AREA_HIDE_WALL_ITEMS, h ? 1 : 0), this.object.model.setValue(I.FURNITURE_AREA_HIDE_INVERT, u ? 1 : 0), this.object.setState(e, 0);
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new N(N.AREA_HIDE, this.object));
  }
  mouseEvent(t, e) {
    if (!t || !e || !this.object) return;
    let s = null;
    switch (t.type) {
      case J.DOUBLE_CLICK: {
        if (t.spriteTag === "turn_on" || t.spriteTag === "turn_off" ? s = new At(At.STATE_CHANGE, this.object) : s = new N(N.AREA_HIDE, this.object), this.eventDispatcher && s) {
          this.eventDispatcher.dispatchEvent(s);
          return;
        }
        break;
      }
    }
    super.mouseEvent(t, e);
  }
}
class Dst extends wt {
  constructor() {
    super(), this.onRoomToObjectOwnAvatarMoveEvent = this.onRoomToObjectOwnAvatarMoveEvent.bind(this);
  }
  initialize(t) {
    super.initialize(t), this.eventDispatcher && this.eventDispatcher.addEventListener(zo.ROAME_MOVE_TO, this.onRoomToObjectOwnAvatarMoveEvent);
  }
  tearDown() {
    this.eventDispatcher && this.eventDispatcher.removeEventListener(zo.ROAME_MOVE_TO, this.onRoomToObjectOwnAvatarMoveEvent), super.tearDown();
  }
  onRoomToObjectOwnAvatarMoveEvent(t) {
    if (!t || !this.object) return;
    const e = this.object.getLocation(), s = t.targetLocation;
    if (!s) return;
    let r = this.object.model.getValue(I.FURNITURE_SIZE_X), n = this.object.model.getValue(I.FURNITURE_SIZE_Y);
    const a = (Math.floor(this.object.getDirection().x) + 45) % 360 / 90;
    (a === 1 || a === 3) && ([r, n] = [n, r]), s.x >= e.x && s.x < e.x + r && s.y >= e.y && s.y < e.y + n ? this.object.setState(1, 0) : this.object.setState(0, 0);
  }
}
class Lst extends wt {
  getEventTypes() {
    const t = [N.CLOTHING_CHANGE];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  initialize(t) {
    super.initialize(t);
    const e = this.object.model.getValue(I.FURNITURE_DATA);
    this.updateClothingData(e);
  }
  processUpdateMessage(t) {
    super.processUpdateMessage(t), t instanceof Ht && t.data && this.updateClothingData(t.data.getLegacyString());
  }
  updateClothingData(t) {
    if (!t || !t.length) return;
    const [e, s] = t.split(",");
    e && e.length && this.object.model.setValue(I.FURNITURE_CLOTHING_BOY, e), s && s.length && this.object.model.setValue(I.FURNITURE_CLOTHING_GIRL, s);
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new N(N.CLOTHING_CHANGE, this.object));
  }
}
class Fst extends wt {
  getEventTypes() {
    const t = [At.STATE_CHANGE];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  mouseEvent(t, e) {
    if (!t || !e || !this.object) return;
    let s = null;
    switch (t.type) {
      case J.DOUBLE_CLICK:
        switch (t.spriteTag) {
          case "start_stop":
            s = new At(At.STATE_CHANGE, this.object, 1);
            break;
          case "reset":
            s = new At(At.STATE_CHANGE, this.object, 2);
            break;
        }
        if (this.eventDispatcher && s) {
          this.eventDispatcher.dispatchEvent(s);
          return;
        }
        break;
    }
    super.mouseEvent(t, e);
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new At(At.STATE_CHANGE, this.object, 1));
  }
}
class wst extends wt {
  processUpdateMessage(t) {
    super.processUpdateMessage(t), this.object && this.object.model.getValue(I.FURNITURE_REAL_ROOM_OBJECT) === 1 && this.object.model.setValue(Ss.INFOSTAND_EXTRA_PARAM, Ss.CRACKABLE_FURNI);
  }
}
class Gst extends wt {
  get widget() {
    return Zl.CRAFTING;
  }
}
class Bst extends wt {
  getEventTypes() {
    const t = [
      N.CREDITFURNI
    ];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  initialize(t) {
    super.initialize(t);
    let e = 0;
    t.logic && t.logic.credits && t.logic.credits !== "" && t.logic.credits.length > 0 && (e = parseInt(t.logic.credits)), this.object.model.setValue(I.FURNITURE_CREDIT_VALUE, e);
  }
  useObject() {
    !this.object || !this.eventDispatcher || (this.eventDispatcher.dispatchEvent(new N(N.CREDITFURNI, this.object)), super.useObject());
  }
}
class kst extends _e {
  constructor() {
    super(...arguments), this._state = 1;
  }
  getEventTypes() {
    const t = [Er.PLAY_SOUND_AT_PITCH];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  processUpdateMessage(t) {
    super.processUpdateMessage(t), t instanceof Ht && (this._state !== -1 && t.state !== this._state && this.dispatchSoundEvent(this.object.location.z), this._state = t.state);
  }
  dispatchSoundEvent(t) {
    const e = Math.pow(2, t - 1.2);
    this.eventDispatcher.dispatchEvent(new Er(Er.PLAY_SOUND_AT_PITCH, this.object, "FURNITURE_cuckoo_clock", e));
  }
}
class zst extends _e {
  getEventTypes() {
    const t = [
      N.STACK_HEIGHT
    ];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  initialize(t) {
    super.initialize(t), this.object && this.object.model && this.object.model.setValue(I.FURNITURE_ALWAYS_STACKABLE, 1);
  }
  useObject() {
    !this.object || !this.eventDispatcher || (this.eventDispatcher.dispatchEvent(new N(N.STACK_HEIGHT, this.object)), super.useObject());
  }
}
class Vst extends wt {
  constructor() {
    super(), this._noTags = !1, this._noTagsLastStateActivate = !1;
  }
  getEventTypes() {
    const t = [z.DICE_ACTIVATE, z.DICE_OFF];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  mouseEvent(t, e) {
    if (!t || !e || !this.object) return;
    let s = null;
    switch (t.type) {
      case J.DOUBLE_CLICK:
        this._noTags ? !this._noTagsLastStateActivate || this.object.getState(0) === 0 || this.object.getState(0) === 100 ? (s = new z(z.DICE_ACTIVATE, this.object), this._noTagsLastStateActivate = !0) : (s = new z(z.DICE_OFF, this.object), this._noTagsLastStateActivate = !1) : t.spriteTag === "activate" || this.object.getState(0) === 0 || this.object.getState(0) === 100 ? s = new z(z.DICE_ACTIVATE, this.object) : t.spriteTag === "deactivate" && (s = new z(z.DICE_OFF, this.object)), s && this.eventDispatcher && this.eventDispatcher.dispatchEvent(s);
        return;
    }
    super.mouseEvent(t, e);
  }
}
class Hst extends wt {
  getEventTypes() {
    const t = [
      N.ECOTRONBOX
    ];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new N(N.ECOTRONBOX, this.object));
  }
}
class Yst extends wt {
  constructor() {
    super(), this._showStateOnceRendered = !1, this._updateCount = 0;
  }
  getEventTypes() {
    const t = [N.INERNAL_LINK];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  initialize(t) {
    super.initialize(t), t.logic && t.logic.action && t.logic.action.startState === 1 && (this._showStateOnceRendered = !0);
  }
  update(t) {
    super.update(t), this._showStateOnceRendered && (this._updateCount++, this._showStateOnceRendered && this._updateCount > 20 && (this.setAutomaticStateIndex(1), this._showStateOnceRendered = !1));
  }
  setAutomaticStateIndex(t) {
    this.object && this.object.model && this.object.model.setValue(I.FURNITURE_AUTOMATIC_STATE_INDEX, t);
  }
  mouseEvent(t, e) {
    !t || !e || (t.type === J.DOUBLE_CLICK && this.setAutomaticStateIndex(0), super.mouseEvent(t, e));
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new N(N.INERNAL_LINK, this.object));
  }
}
class Wst extends wt {
  getEventTypes() {
    const t = [N.ROOM_LINK];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  initialize(t) {
    super.initialize(t), t.logic && t.logic.action && t.logic.action.link && t.logic.action.link !== "" && t.logic.action.link.length > 0 && this.object && this.object.model && this.object.model.setValue(I.FURNITURE_INTERNAL_LINK, t.logic.action.link);
  }
  dispose() {
    this._timer && (clearTimeout(this._timer), this._timer = null), super.dispose();
  }
  setAutomaticStateIndex(t) {
    this.object && this.object.model && this.object.model.setValue(I.FURNITURE_AUTOMATIC_STATE_INDEX, t);
  }
  useObject() {
    this.setAutomaticStateIndex(1), this._timer && (clearTimeout(this._timer), this._timer = null), this._timer = setTimeout(() => {
      this.setAutomaticStateIndex(0), this._timer = null;
    }, 2500), !(!this.object || !this.eventDispatcher) && this.eventDispatcher.dispatchEvent(new N(N.ROOM_LINK, this.object));
  }
}
class jst extends wt {
  getEventTypes() {
    const t = [N.EFFECTBOX_OPEN_DIALOG];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new N(N.EFFECTBOX_OPEN_DIALOG, this.object));
  }
  get contextMenu() {
    return ji.EFFECT_BOX;
  }
}
class Xst extends _e {
  getEventTypes() {
    const t = [
      N.EXTERNAL_IMAGE
    ];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  initialize(t) {
    if (super.initialize(t), !!t && this.object && this.object.model) {
      let e = "";
      t.logic && t.logic.maskType && t.logic.maskType !== "" && t.logic.maskType.length > 0 && (e = t.logic.maskType), this.object.model.setValue(I.FURNITURE_USES_PLANE_MASK, 0), this.object.model.setValue(I.FURNITURE_PLANE_MASK_TYPE, e);
    }
  }
  useObject() {
    !this.object || !this.eventDispatcher || (this.eventDispatcher.dispatchEvent(new N(N.EXTERNAL_IMAGE, this.object)), super.useObject());
  }
}
class Kst extends wt {
  getEventTypes() {
    const t = [At.STATE_CHANGE];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  initialize(t) {
    super.initialize(t), t.logic && t.logic.particleSystems && t.logic.particleSystems.length && this.object.model.setValue(I.FURNITURE_FIREWORKS_DATA, t.logic.particleSystems);
  }
  mouseEvent(t, e) {
    if (!t || !e || !this.object) return;
    let s = null;
    switch (t.type) {
      case J.DOUBLE_CLICK:
        switch (t.spriteTag) {
          case "start_stop":
            s = new At(At.STATE_CHANGE, this.object, 1);
            break;
          case "reset":
            s = new At(At.STATE_CHANGE, this.object, 2);
            break;
        }
        if (this.eventDispatcher && s) {
          this.eventDispatcher.dispatchEvent(s);
          return;
        }
        break;
    }
    super.mouseEvent(t, e);
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new At(At.STATE_CHANGE, this.object, 0));
  }
}
const Qn = class Qn extends _e {
  constructor() {
    super(), this._currentState = -1, this._currentLocation = null;
  }
  getEventTypes() {
    const t = [Ke.ADD_HOLE, Ke.REMOVE_HOLE];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  dispose() {
    this._currentState === Qn.STATE_HOLE && this.eventDispatcher.dispatchEvent(new Ke(Ke.REMOVE_HOLE, this.object)), super.dispose();
  }
  update(t) {
    super.update(t), this.handleAutomaticStateUpdate();
  }
  processUpdateMessage(t) {
    if (super.processUpdateMessage(t), !this.object) return;
    t instanceof Ht && this.handleStateUpdate(this.object.getState(0));
    const e = this.object.getLocation();
    this._currentLocation ? (e.x !== this._currentLocation.x || e.y !== this._currentLocation.y) && this._currentState === Qn.STATE_HOLE && this.eventDispatcher && this.eventDispatcher.dispatchEvent(new Ke(Ke.ADD_HOLE, this.object)) : this._currentLocation = new v(), this._currentLocation.assign(e);
  }
  handleStateUpdate(t) {
    t !== this._currentState && (this.eventDispatcher && (t === Qn.STATE_HOLE ? this.eventDispatcher.dispatchEvent(new Ke(Ke.ADD_HOLE, this.object)) : this._currentState === Qn.STATE_HOLE && this.eventDispatcher.dispatchEvent(new Ke(Ke.REMOVE_HOLE, this.object))), this._currentState = t);
  }
  handleAutomaticStateUpdate() {
    if (!this.object) return;
    const t = this.object.model;
    if (!t) return;
    const e = t.getValue(I.FURNITURE_AUTOMATIC_STATE_INDEX);
    isNaN(e) || this.handleStateUpdate(e % 2);
  }
};
Qn.STATE_HOLE = 0;
let RE = Qn;
const Jn = class Jn extends _e {
  constructor() {
    super(...arguments), this._state = -1;
  }
  initialize(t) {
    super.initialize(t), this.object && this.object.model.setValue(I.FURNITURE_FRIENDFURNI_ENGRAVING, this.engravingDialogType);
  }
  processUpdateMessage(t) {
    if (t instanceof Ht) {
      const e = t.data;
      e ? this._state = e.state : this._state = t.state;
    }
    super.processUpdateMessage(t);
  }
  getEventTypes() {
    const t = [N.FRIEND_FURNITURE_ENGRAVING];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  useObject() {
    !this.object || !this.eventDispatcher || (this._state === Jn.STATE_LOCKED ? this.eventDispatcher.dispatchEvent(new N(N.FRIEND_FURNITURE_ENGRAVING, this.object)) : super.useObject());
  }
  get engravingDialogType() {
    return 0;
  }
  get contextMenu() {
    return this._state === Jn.STATE_UNLOCKED ? ji.FRIEND_FURNITURE : ji.DUMMY;
  }
};
Jn.STATE_UNINITIALIZED = -1, Jn.STATE_UNLOCKED = 0, Jn.STATE_LOCKED = 1;
let Fc = Jn;
const Pi = class Pi extends _e {
  getEventTypes() {
    const t = [
      di.LOAD_BADGE,
      N.GUILD_FURNI_CONTEXT_MENU,
      N.CLOSE_FURNI_CONTEXT_MENU
    ];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  processUpdateMessage(t) {
    if (super.processUpdateMessage(t), t instanceof Ht) {
      const e = t.data;
      e instanceof wo && (this.updateGroupId(e.getValue(Pi.GROUPID_KEY)), this.updateBadge(e.getValue(Pi.BADGE_KEY)), this.updateColors(e.getValue(Pi.COLOR1_KEY), e.getValue(Pi.COLOR2_KEY)));
    } else t instanceof Sa ? t.assetName !== "loading_icon" && (this.object.model.setValue(I.FURNITURE_GUILD_CUSTOMIZED_ASSET_NAME, t.assetName), this.update(Nt())) : t instanceof wu && (t.selected || this.eventDispatcher.dispatchEvent(new N(N.CLOSE_FURNI_CONTEXT_MENU, this.object)));
  }
  updateGroupId(t) {
    this.object.model.setValue(I.FURNITURE_GUILD_CUSTOMIZED_GUILD_ID, parseInt(t));
  }
  updateBadge(t) {
    this.eventDispatcher.dispatchEvent(new di(di.LOAD_BADGE, this.object, t, !0));
  }
  updateColors(t, e) {
    this.object.model.setValue(I.FURNITURE_GUILD_CUSTOMIZED_COLOR_1, parseInt(t, 16)), this.object.model.setValue(I.FURNITURE_GUILD_CUSTOMIZED_COLOR_2, parseInt(e, 16));
  }
  mouseEvent(t, e) {
    if (!(!t || !e || !this.object)) {
      switch (t.type) {
        case J.MOUSE_CLICK:
          this.openContextMenu();
      }
      super.mouseEvent(t, e);
    }
  }
  openContextMenu() {
    this.eventDispatcher.dispatchEvent(new N(N.GUILD_FURNI_CONTEXT_MENU, this.object));
  }
};
Pi.GROUPID_KEY = 1, Pi.BADGE_KEY = 2, Pi.COLOR1_KEY = 3, Pi.COLOR2_KEY = 4;
let wc = Pi;
class qst extends wc {
  getEventTypes() {
    const t = [
      N.INERNAL_LINK
    ];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  updateGroupId(t) {
    super.updateGroupId(t), this.object.model.setValue(I.FURNITURE_INTERNAL_LINK, `groupforum/${t}`);
  }
  useObject() {
    !this.object || !this.eventDispatcher || (this.eventDispatcher.dispatchEvent(new N(N.INERNAL_LINK, this.object)), super.useObject());
  }
}
class $st extends wt {
  getEventTypes() {
    const t = [z.USE_HABBOWHEEL];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new z(z.USE_HABBOWHEEL, this.object));
  }
}
const md = class md extends wt {
  constructor() {
    super(...arguments), this._state = -1;
  }
  getEventTypes() {
    return [N.HIGH_SCORE_DISPLAY, N.HIDE_HIGH_SCORE_DISPLAY];
  }
  tearDown() {
    this.object.model.getValue(I.FURNITURE_REAL_ROOM_OBJECT) === 1 && this.eventDispatcher.dispatchEvent(new N(N.HIDE_HIGH_SCORE_DISPLAY, this.object)), super.tearDown();
  }
  processUpdateMessage(t) {
    super.processUpdateMessage(t), this.object.model.getValue(I.FURNITURE_REAL_ROOM_OBJECT) === 1 && t instanceof Ht && (t.state === md.SHOW_WIDGET_IN_STATE ? this.eventDispatcher.dispatchEvent(new N(N.HIGH_SCORE_DISPLAY, this.object)) : this.eventDispatcher.dispatchEvent(new N(N.HIDE_HIGH_SCORE_DISPLAY, this.object)), this._state = t.state);
  }
};
md.SHOW_WIDGET_IN_STATE = 1;
let OE = md;
class Zst extends wt {
  getEventTypes() {
    const t = [At.STATE_CHANGE];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  mouseEvent(t, e) {
    if (!t || !e || !this.object) return;
    let s = null;
    switch (t.type) {
      case J.DOUBLE_CLICK:
        switch (t.spriteTag) {
          case "off":
            s = new At(At.STATE_CHANGE, this.object, 3);
            break;
        }
        break;
      case J.MOUSE_CLICK:
        switch (t.spriteTag) {
          case "inc":
            s = new At(At.STATE_CHANGE, this.object, 2);
            break;
          case "dec":
            s = new At(At.STATE_CHANGE, this.object, 1);
            break;
        }
        break;
    }
    if (this.eventDispatcher && s) {
      this.eventDispatcher.dispatchEvent(s);
      return;
    }
    super.mouseEvent(t, e);
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new At(At.STATE_CHANGE, this.object, 3));
  }
}
class Qst extends Fc {
  get engravingDialogType() {
    return jl.HABBOWEEN;
  }
}
class Jst extends _e {
  constructor() {
    super(), this._nextState = 0, this._nextStateTimestamp = 0;
  }
  update(t) {
    if (this._nextStateTimestamp > 0 && t >= this._nextStateTimestamp) {
      this._nextStateTimestamp = 0;
      const e = new ns();
      e.setString(this._nextState.toString()), super.processUpdateMessage(new Ht(this._nextState, e, this._nextStateExtra));
    }
    super.update(t);
  }
  processUpdateMessage(t) {
    if (t instanceof Ht) {
      this.processUpdate(t);
      return;
    }
    super.processUpdateMessage(t);
  }
  processUpdate(t) {
    if (!t) return;
    const e = ~~(t.state / 1e3), s = ~~(t.state % 1e3);
    if (s)
      this._nextState = e, this._nextStateExtra = t.extra, this._nextStateTimestamp = this.time + s;
    else {
      this._nextStateTimestamp = 0;
      const r = new ns();
      r.setString(e.toString()), super.processUpdateMessage(new Ht(e, r, t.extra));
    }
  }
}
class tit extends wt {
  constructor() {
    super(...arguments), this._showStateOnceRendered = !1, this._updateCount = 0;
  }
  getEventTypes() {
    const t = [
      N.INERNAL_LINK
    ];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  initialize(t) {
    super.initialize(t), t.logic && t.logic.action && (this.object.model.setValue(I.FURNITURE_INTERNAL_LINK, t.logic.action.link), t.logic.action.startState === 1 && (this._showStateOnceRendered = !0));
  }
  update(t) {
    super.update(t), this._showStateOnceRendered && (this._updateCount++, this._showStateOnceRendered && this._updateCount === 20 && (this.setAutomaticStateIndex(1), this._showStateOnceRendered = !1));
  }
  setAutomaticStateIndex(t) {
    this.object && this.object.model && this.object.model.setValue(I.FURNITURE_AUTOMATIC_STATE_INDEX, t);
  }
  mouseEvent(t, e) {
    !t || !e || (t.type === J.DOUBLE_CLICK && this._showStateOnceRendered && this.setAutomaticStateIndex(0), super.mouseEvent(t, e));
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new N(N.INERNAL_LINK, this.object));
  }
}
class eit extends _e {
  constructor() {
    super(...arguments), this._disposeEventsAllowed = !1, this._isInitialized = !1, this._currentState = -1;
  }
  getEventTypes() {
    const t = [
      z.JUKEBOX_START,
      z.JUKEBOX_MACHINE_STOP,
      z.JUKEBOX_DISPOSE,
      z.JUKEBOX_INIT,
      N.JUKEBOX_PLAYLIST_EDITOR
    ];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  dispose() {
    this.requestDispose(), super.dispose();
  }
  processUpdateMessage(t) {
    if (super.processUpdateMessage(t), this.object.model.getValue(I.FURNITURE_REAL_ROOM_OBJECT) === 1 && (this._isInitialized || this.requestInit(), this.object.model.setValue(Ss.INFOSTAND_EXTRA_PARAM, Ss.JUKEBOX), t instanceof Ht)) {
      const e = this.object.getState(0);
      e !== this._currentState && (this._currentState = e, e === 1 ? this.requestPlayList() : e === 0 && this.requestStopPlaying());
    }
  }
  requestInit() {
    !this.object || !this.eventDispatcher || (this._disposeEventsAllowed = !0, this.eventDispatcher.dispatchEvent(new z(z.JUKEBOX_INIT, this.object)), this._isInitialized = !0);
  }
  requestPlayList() {
    !this.object || !this.eventDispatcher || (this._disposeEventsAllowed = !0, this.eventDispatcher.dispatchEvent(new z(z.JUKEBOX_START, this.object)));
  }
  requestStopPlaying() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new z(z.JUKEBOX_MACHINE_STOP, this.object));
  }
  requestDispose() {
    !this._disposeEventsAllowed || !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new z(z.JUKEBOX_DISPOSE, this.object));
  }
  useObject() {
    !this.object || !this.eventDispatcher || (this.eventDispatcher.dispatchEvent(new N(N.JUKEBOX_PLAYLIST_EDITOR, this.object)), this.eventDispatcher.dispatchEvent(new At(At.STATE_CHANGE, this.object, -1)));
  }
}
class sit extends Fc {
  get engravingDialogType() {
    return jl.LOVE_LOCK;
  }
}
const Yr = class Yr extends wt {
  getEventTypes() {
    const t = [N.MANNEQUIN];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  processUpdateMessage(t) {
    super.processUpdateMessage(t), t instanceof Ht && (t.data.writeRoomObjectModel(this.object.model), this.processObjectData());
  }
  processObjectData() {
    if (!this.object || !this.object.model) return;
    const t = new pa();
    t.initializeFromRoomObjectModel(this.object.model), this.object.model.setValue(I.FURNITURE_MANNEQUIN_GENDER, t.getValue(Yr.GENDER)), this.object.model.setValue(I.FURNITURE_MANNEQUIN_FIGURE, t.getValue(Yr.FIGURE)), this.object.model.setValue(I.FURNITURE_MANNEQUIN_NAME, t.getValue(Yr.OUTFIT_NAME));
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new N(N.MANNEQUIN, this.object));
  }
};
Yr.GENDER = "GENDER", Yr.FIGURE = "FIGURE", Yr.OUTFIT_NAME = "OUTFIT_NAME";
let yE = Yr;
class iit extends _e {
  getEventTypes() {
    const t = [N.MONSTERPLANT_SEED_PLANT_CONFIRMATION_DIALOG];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new N(N.MONSTERPLANT_SEED_PLANT_CONFIRMATION_DIALOG, this.object));
  }
  get contextMenu() {
    return ji.MONSTERPLANT_SEED;
  }
}
class rit extends _e {
  initialize(t) {
    super.initialize(t), this.object && this.object.model && this.object.model.setValue(I.FURNITURE_IS_VARIABLE_HEIGHT, 1);
  }
}
class nit extends _e {
  getEventTypes() {
    const t = [N.MYSTERYBOX_OPEN_DIALOG];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new N(N.MYSTERYBOX_OPEN_DIALOG, this.object));
  }
  get contextMenu() {
    return ji.MYSTERY_BOX;
  }
}
class ait extends _e {
  getEventTypes() {
    const t = [N.MYSTERYTROPHY_OPEN_DIALOG];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new N(N.MYSTERYTROPHY_OPEN_DIALOG, this.object));
  }
  get contextMenu() {
    return ji.MYSTERY_TROPHY;
  }
}
class oit extends wt {
  getEventTypes() {
    const t = [z.ENTER_ONEWAYDOOR];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new z(z.ENTER_ONEWAYDOOR, this.object));
  }
}
class hit extends wt {
  getEventTypes() {
    const t = [N.PET_PRODUCT_MENU];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  processUpdateMessage(t) {
    super.processUpdateMessage(t), this.object && this.object.model.getValue(I.FURNITURE_REAL_ROOM_OBJECT) === 1 && this.object.model.setValue(Ss.INFOSTAND_EXTRA_PARAM, Ss.USABLE_PRODUCT);
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new N(N.PET_PRODUCT_MENU, this.object));
  }
}
class uit extends wt {
  getEventTypes() {
    const t = [
      N.PLACEHOLDER
    ];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new N(N.PLACEHOLDER, this.object));
  }
}
class lit extends wt {
  initialize(t) {
    super.initialize(t), t.logic && t.logic.planetSystems && this.object.model.setValue(I.FURNITURE_PLANETSYSTEM_DATA, t.logic.planetSystems);
  }
}
const zs = class zs extends wt {
  getEventTypes() {
    const t = [
      N.PRESENT
    ];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  initialize(t) {
    super.initialize(t), t.logic && t.logic.particleSystems && t.logic.particleSystems.length && this.object.model.setValue(I.FURNITURE_FIREWORKS_DATA, t.logic.particleSystems);
  }
  processUpdateMessage(t) {
    super.processUpdateMessage(t), t instanceof Ht && (t.data.writeRoomObjectModel(this.object.model), this.updateStuffData()), t instanceof DM && t.numberKey === I.FURNITURE_DISABLE_PICKING_ANIMATION && this.object.model.setValue(I.FURNITURE_DISABLE_PICKING_ANIMATION, t.numberValue);
  }
  updateStuffData() {
    if (!this.object || !this.object.model) return;
    const t = new pa();
    t.initializeFromRoomObjectModel(this.object.model);
    const e = t.getValue(zs.MESSAGE), s = this.object.model.getValue(I.FURNITURE_DATA);
    !e && typeof s == "string" ? this.object.model.setValue(I.FURNITURE_DATA, s.substr(1)) : this.object.model.setValue(I.FURNITURE_DATA, t.getValue(zs.MESSAGE)), this.writeToModel(I.FURNITURE_TYPE_ID, t.getValue(zs.PRODUCT_CODE)), this.writeToModel(I.FURNITURE_PURCHASER_NAME, t.getValue(zs.PURCHASER_NAME)), this.writeToModel(I.FURNITURE_PURCHASER_FIGURE, t.getValue(zs.PURCHASER_FIGURE));
  }
  writeToModel(t, e) {
    e && this.object.model.setValue(t, e);
  }
  mouseEvent(t, e) {
    if (!(!t || !e || !this.object)) {
      switch (t.type) {
        case J.ROLL_OVER:
          this.eventDispatcher.dispatchEvent(new z(z.MOUSE_BUTTON, this.object));
          break;
        case J.ROLL_OUT:
          this.eventDispatcher.dispatchEvent(new z(z.MOUSE_ARROW, this.object));
          break;
      }
      super.mouseEvent(t, e);
    }
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new N(N.PRESENT, this.object));
  }
};
zs.MESSAGE = "MESSAGE", zs.PRODUCT_CODE = "PRODUCT_CODE", zs.EXTRA_PARAM = "EXTRA_PARAM", zs.PURCHASER_NAME = "PURCHASER_NAME", zs.PURCHASER_FIGURE = "PURCHASER_FIGURE";
let vE = zs;
class cit extends _e {
  getEventTypes() {
    const t = [
      N.PURCHASABLE_CLOTHING_CONFIRMATION_DIALOG
    ];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new N(N.PURCHASABLE_CLOTHING_CONFIRMATION_DIALOG, this.object));
  }
  get contextMenu() {
    return ji.PURCHASABLE_CLOTHING;
  }
}
const lr = class lr extends _e {
  constructor() {
    super(), this.updateInterval = dn.DEFAULT_UPDATE_INTERVAL, this._oldLocation = new v();
  }
  processUpdateMessage(t) {
    if (!t) return;
    const e = t instanceof _n;
    if (this.object && !e && t.location) {
      const s = this.object.getLocation(), r = v.dif(t.location, s);
      if (r && Math.abs(r.x) < 2 && Math.abs(r.y) < 2) {
        let n = s;
        (Math.abs(r.x) > 1 || Math.abs(r.y) > 1) && (n = v.sum(s, v.product(r, 0.5))), super.processUpdateMessage(new _n(n, t.location, t.direction));
        return;
      }
    }
    if (t.location && !e && super.processUpdateMessage(new _n(t.location, t.location, t.direction)), t instanceof Ht) {
      t.state > 0 ? this.updateInterval = dn.DEFAULT_UPDATE_INTERVAL / this.getUpdateIntervalValue(t.state) : this.updateInterval = 1, this.handleDataUpdate(t);
      return;
    }
    e && t.isSlide && (this.updateInterval = dn.DEFAULT_UPDATE_INTERVAL), super.processUpdateMessage(t);
  }
  getUpdateIntervalValue(t) {
    return t / lr.MAX_ANIMATION_COUNT;
  }
  getAnimationValue(t) {
    return t % lr.MAX_ANIMATION_COUNT;
  }
  handleDataUpdate(t) {
    const e = this.getAnimationValue(t.state);
    if (e !== t.state) {
      const s = new ns();
      s.setString(e.toString()), t = new Ht(e, s, t.extra);
    }
    super.processUpdateMessage(t);
  }
  update(t) {
    this.object && (this._oldLocation.assign(this.object.getLocation()), super.update(t), v.dif(this.object.getLocation(), this._oldLocation).length === 0 && this.object.getState(0) !== lr.ANIMATION_NOT_MOVING && this.object.setState(lr.ANIMATION_NOT_MOVING, 0));
  }
};
lr.ANIMATION_NOT_MOVING = 0, lr.ANIMATION_MOVING = 1, lr.MAX_ANIMATION_COUNT = 10;
let CE = lr;
class _it extends wt {
  getEventTypes() {
    const t = [
      At.STATE_RANDOM
    ];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new At(At.STATE_RANDOM, this.object));
  }
}
class dit extends _e {
  get contextMenu() {
    return ji.RANDOM_TELEPORT;
  }
}
class fit extends wt {
  getEventTypes() {
    const t = [
      qs.RODRE_CURRENT_USER_ID
    ];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  update(t) {
    if (super.update(t), this.object && this.object.model) {
      this.object.model.getValue(I.SESSION_CURRENT_USER_ID) || this.eventDispatcher.dispatchEvent(new qs(qs.RODRE_CURRENT_USER_ID, this.object));
      const e = this.object.model.getValue(I.FURNITURE_DATA).renterId, s = this.object.model.getValue(I.SESSION_CURRENT_USER_ID);
      e ? parseInt(e) === s ? this.object.setState(2, 0) : this.object.setState(1, 0) : this.object.setState(0, 0);
    }
  }
  get widget() {
    return Zl.RENTABLESPACE;
  }
}
class git extends _e {
  constructor() {
    super(), this._roomColorUpdated = !1;
  }
  getEventTypes() {
    const t = [
      N.BACKGROUND_COLOR,
      gr.ROOM_BACKGROUND_COLOR
    ];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  dispose() {
    this._roomColorUpdated && (this.eventDispatcher && this.object && this.object.model.getValue(I.FURNITURE_REAL_ROOM_OBJECT) === 1 && this.eventDispatcher.dispatchEvent(new gr(gr.ROOM_BACKGROUND_COLOR, this.object, !1, 0, 0, 0)), this._roomColorUpdated = !1), super.dispose();
  }
  processUpdateMessage(t) {
    super.processUpdateMessage(t), t instanceof Ht && (t.data.writeRoomObjectModel(this.object.model), this.object.model.getValue(I.FURNITURE_REAL_ROOM_OBJECT) === 1 && this.processColorUpdate());
  }
  processColorUpdate() {
    if (!this.object || !this.object.model) return;
    const t = new Fo();
    t.initializeFromRoomObjectModel(this.object.model);
    const e = t.getValue(0), s = t.getValue(1), r = t.getValue(2), n = t.getValue(3);
    e > -1 && s > -1 && r > -1 && n > -1 && (this.object.model.setValue(I.FURNITURE_ROOM_BACKGROUND_COLOR_HUE, s), this.object.model.setValue(I.FURNITURE_ROOM_BACKGROUND_COLOR_SATURATION, r), this.object.model.setValue(I.FURNITURE_ROOM_BACKGROUND_COLOR_LIGHTNESS, n), this.object.setState(e, 0), this.eventDispatcher && this.eventDispatcher.dispatchEvent(new gr(gr.ROOM_BACKGROUND_COLOR, this.object, e === 1, s, r, n)), this._roomColorUpdated = !0);
  }
  mouseEvent(t, e) {
    if (!(!t || !e || !this.object)) {
      switch (t.type) {
        case J.DOUBLE_CLICK:
          this.eventDispatcher && this.eventDispatcher.dispatchEvent(new N(N.BACKGROUND_COLOR, this.object));
          return;
      }
      super.mouseEvent(t, e);
    }
  }
}
const Ne = class Ne extends wt {
  constructor() {
    super(), this._disableFurnitureSelection = !0, this._hasClickUrl = !1;
  }
  getEventTypes() {
    const t = [ee.ROOM_AD_LOAD_IMAGE];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  initialize(t) {
    super.initialize(t), this._disableFurnitureSelection && this.object.model.setValue(I.FURNITURE_SELECTION_DISABLED, 1);
  }
  processUpdateMessage(t) {
    super.processUpdateMessage(t), t instanceof Ht && this.processAdDataUpdateMessage(t), t instanceof Ji && this.processAdUpdate(t);
  }
  processAdDataUpdateMessage(t) {
    if (!t) return;
    const e = new pa();
    e.initializeFromRoomObjectModel(this.object.model);
    const s = parseInt(e.getValue(Ne.STATE));
    !isNaN(s) && this.object.getState(0) !== s && this.object.setState(s, 0);
    const r = e.getValue(Ne.IMAGEURL_KEY), n = this.object.model.getValue(I.FURNITURE_BRANDING_IMAGE_URL);
    (!n || n !== r) && (this.object.model.setValue(I.FURNITURE_BRANDING_IMAGE_URL, r), this.object.model.setValue(I.FURNITURE_BRANDING_IMAGE_STATUS, 0), this.downloadBackground());
    const a = e.getValue(Ne.CLICKURL_KEY);
    if (a) {
      const l = this.object.model.getValue(I.FURNITURE_BRANDING_URL);
      (!l || l !== a) && this.object.model && this.object.model.setValue(I.FURNITURE_BRANDING_URL, a);
    }
    const o = parseInt(e.getValue(Ne.OFFSETX_KEY)), h = parseInt(e.getValue(Ne.OFFSETY_KEY)), u = parseInt(e.getValue(Ne.OFFSETZ_KEY));
    isNaN(o) || this.object.model.setValue(I.FURNITURE_BRANDING_OFFSET_X, o), isNaN(h) || this.object.model.setValue(I.FURNITURE_BRANDING_OFFSET_Y, h), isNaN(u) || this.object.model.setValue(I.FURNITURE_BRANDING_OFFSET_Z, u);
    let c = Ne.IMAGEURL_KEY + "=" + (r !== null ? r : "") + "	";
    this._hasClickUrl && (c = c + (Ne.CLICKURL_KEY + "=" + (a !== null ? a : "") + "	")), c = c + (Ne.OFFSETX_KEY + "=" + o + "	"), c = c + (Ne.OFFSETY_KEY + "=" + h + "	"), c = c + (Ne.OFFSETZ_KEY + "=" + u + "	"), this.object.model.setValue(Ss.INFOSTAND_EXTRA_PARAM, Ss.BRANDING_OPTIONS + c);
  }
  processAdUpdate(t) {
    if (!(!t || !this.object))
      switch (t.type) {
        case Ji.IMAGE_LOADED:
          this.object.model.setValue(I.FURNITURE_BRANDING_IMAGE_STATUS, 1);
          break;
        case Ji.IMAGE_LOADING_FAILED:
          this.object.model.setValue(I.FURNITURE_BRANDING_IMAGE_STATUS, -1);
          break;
      }
  }
  mouseEvent(t, e) {
    !t || !e || t.type === J.MOUSE_MOVE || t.type === J.DOUBLE_CLICK || super.mouseEvent(t, e);
  }
  async downloadBackground() {
    const t = this.object && this.object.model;
    if (!t) return;
    const e = t.getValue(I.FURNITURE_BRANDING_IMAGE_URL), s = t.getValue(I.FURNITURE_BRANDING_IMAGE_STATUS);
    if (!e || e === "" || s === 1) return;
    const r = Rt();
    if (!r) return;
    if (!r.getTexture(e) && !await r.downloadAsset(e)) {
      this.processUpdateMessage(new Ji(Ji.IMAGE_LOADING_FAILED));
      return;
    }
    this.processUpdateMessage(new Ji(Ji.IMAGE_LOADED));
  }
};
Ne.STATE = "state", Ne.IMAGEURL_KEY = "imageUrl", Ne.CLICKURL_KEY = "clickUrl", Ne.OFFSETX_KEY = "offsetX", Ne.OFFSETY_KEY = "offsetY", Ne.OFFSETZ_KEY = "offsetZ";
let Gc = Ne;
class pit extends Gc {
  getAdClickUrl(t) {
    return null;
  }
}
class mit extends Gc {
  constructor() {
    super(), this._hasClickUrl = !0;
  }
  getAdClickUrl(t) {
    return t.getValue(I.FURNITURE_BRANDING_URL);
  }
  handleAdClick(t, e, s) {
    if (s.indexOf("http") === 0) {
      Tu.openWebPage(s);
      return;
    }
    this.eventDispatcher && this.eventDispatcher.dispatchEvent(new ee(ee.ROOM_AD_FURNI_CLICK, this.object, "", s));
  }
}
class Eit extends wt {
  constructor() {
    super(), this._roomColorUpdated = !1;
  }
  getEventTypes() {
    const t = [
      N.DIMMER,
      N.WIDGET_REMOVE_DIMMER,
      _a.DIMMER_STATE
    ];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  dispose() {
    this._roomColorUpdated && this.eventDispatcher && this.object && (this.object.model.getValue(I.FURNITURE_REAL_ROOM_OBJECT) === 1 && (this.eventDispatcher.dispatchEvent(new _a(this.object, 0, 1, 1, 16777215, 255)), this.eventDispatcher.dispatchEvent(new N(N.WIDGET_REMOVE_DIMMER, this.object))), this._roomColorUpdated = !1), super.dispose();
  }
  processUpdateMessage(t) {
    if (t instanceof Ht) {
      if (t.data) {
        const e = t.data.getLegacyString();
        this.object.model.getValue(I.FURNITURE_REAL_ROOM_OBJECT) === 1 && this.processDimmerData(e), super.processUpdateMessage(new Ht(this.getStateFromDimmerData(e), t.data));
      }
      return;
    }
    super.processUpdateMessage(t);
  }
  getStateFromDimmerData(t) {
    if (!t) return 0;
    const e = t.split(",");
    return e.length >= 5 ? parseInt(e[0]) - 1 : 0;
  }
  processDimmerData(t) {
    if (!t) return;
    const e = t.split(",");
    if (e.length >= 5) {
      const s = this.getStateFromDimmerData(t), r = parseInt(e[1]), n = parseInt(e[2]), a = e[3];
      let o = parseInt(a.substr(1), 16), h = parseInt(e[4]);
      s || (o = 16777215, h = 255), this.eventDispatcher && this.object && (this.eventDispatcher.dispatchEvent(new _a(this.object, s, r, n, o, h)), this._roomColorUpdated = !0);
    }
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new N(N.DIMMER, this.object));
  }
  update(t) {
    super.update(t);
  }
}
const Wr = class Wr extends wt {
  constructor() {
    super(), this._score = 0, this._scoreIncreaser = 50, this._scoreTimer = 0;
  }
  processUpdateMessage(t) {
    if (t instanceof Ht) return this.updateScore(t.state);
    super.processUpdateMessage(t);
  }
  updateScore(t) {
    this._score = t;
    const e = this.object.getState(0);
    if (this._score !== e) {
      let s = this._score - e;
      s < 0 && (s = -s), s * Wr.UPDATE_INTERVAL > Wr.MAX_UPDATE_TIME ? this._scoreIncreaser = Wr.MAX_UPDATE_TIME / s : this._scoreIncreaser = Wr.UPDATE_INTERVAL, this._scoreTimer = Nt();
    }
  }
  update(t) {
    super.update(t);
    const e = this.object.getState(0);
    if (e !== this._score && t >= this._scoreTimer + this._scoreIncreaser) {
      const s = t - this._scoreTimer;
      let r = s / this._scoreIncreaser, n = 1;
      this._score < e && (n = -1), r > n * (this._score - e) && (r = n * (this._score - e)), this.object.setState(e + n * r, 0), this._scoreTimer = t - (s - r * this._scoreIncreaser);
    }
  }
};
Wr.UPDATE_INTERVAL = 50, Wr.MAX_UPDATE_TIME = 3e3;
let xE = Wr;
class Tit extends wt {
  processUpdateMessage(t) {
    if (super.processUpdateMessage(t), this.object.model.getValue(I.FURNITURE_REAL_ROOM_OBJECT) === 1) {
      const e = this.object.model.getValue(I.FURNITURE_EXTRAS), s = parseInt(e);
      this.object.model.setValue(Ss.INFOSTAND_EXTRA_PARAM, Ss.SONGDISK + s);
    }
  }
}
const Vs = class Vs extends _e {
  constructor() {
    super(...arguments), this._state = -1, this._sampleId = -1, this._noPitch = !1, this._lastLocZ = 0;
  }
  getEventTypes() {
    const t = [
      Ie.ROOM_OBJECT_INITIALIZED,
      Ie.ROOM_OBJECT_DISPOSED,
      Ie.PLAY_SAMPLE,
      Ie.CHANGE_PITCH
    ];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  initialize(t) {
    super.initialize(t), t.logic && t.logic.soundSample && (this._sampleId = t.logic.soundSample.id, this._noPitch = t.logic.soundSample.noPitch), this.object.model.setValue(I.FURNITURE_SOUNDBLOCK_RELATIVE_ANIMATION_SPEED, 1);
  }
  dispose() {
    this._state !== Vs.STATE_UNINITIALIZED && this.eventDispatcher.dispatchEvent(new Ie(Ie.ROOM_OBJECT_DISPOSED, this.object, this._sampleId)), super.dispose();
  }
  processUpdateMessage(t) {
    super.processUpdateMessage(t), t instanceof Ht && this.updateSoundBlockMessage(t);
  }
  updateSoundBlockMessage(t) {
    if (!t) return;
    const e = this.object && this.object.model, s = this.object && this.object.location;
    !e || !s || (this._state === Vs.STATE_UNINITIALIZED && e.getValue(I.FURNITURE_REAL_ROOM_OBJECT) === 1 && (this._lastLocZ = s.z, this.eventDispatcher.dispatchEvent(new Ie(Ie.ROOM_OBJECT_INITIALIZED, this.object, this._sampleId, this.getPitchForHeight(s.z)))), this._state !== Vs.STATE_UNINITIALIZED && e.getValue(I.FURNITURE_REAL_ROOM_OBJECT) === 1 && this._lastLocZ !== s.z && (this._lastLocZ = s.z, this.eventDispatcher.dispatchEvent(new Ie(Ie.CHANGE_PITCH, this.object, this._sampleId, this.getPitchForHeight(s.z)))), this._state !== Vs.STATE_UNINITIALIZED && t.state !== this._state && this.playSoundAt(s.z), this._state = t.state);
  }
  playSoundAt(t) {
    if (!this.object) return;
    const e = this.getPitchForHeight(t);
    this.object.model.setValue(I.FURNITURE_SOUNDBLOCK_RELATIVE_ANIMATION_SPEED, e), this.eventDispatcher.dispatchEvent(new Ie(Ie.PLAY_SAMPLE, this.object, this._sampleId, e));
  }
  getPitchForHeight(t) {
    if (this._noPitch) return 1;
    let e = t * 2;
    return e > Vs.HIGHEST_SEMITONE && (e = Math.min(0, Vs.LOWEST_SEMITONE + (e - Vs.HIGHEST_SEMITONE - 1))), Math.pow(2, e / 12);
  }
};
Vs.HIGHEST_SEMITONE = 12, Vs.LOWEST_SEMITONE = -12, Vs.STATE_UNINITIALIZED = -1;
let ME = Vs;
class Iit extends _e {
  constructor() {
    super(...arguments), this._disposeEventsAllowed = !1, this._isInitialized = !1, this._currentState = -1;
  }
  getEventTypes() {
    const t = [
      z.SOUND_MACHINE_START,
      z.SOUND_MACHINE_STOP,
      z.SOUND_MACHINE_DISPOSE,
      z.SOUND_MACHINE_INIT
    ];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  dispose() {
    this.requestDispose(), super.dispose();
  }
  processUpdateMessage(t) {
    if (super.processUpdateMessage(t), this.object.model.getValue(I.FURNITURE_REAL_ROOM_OBJECT) === 1 && (this._isInitialized || this.requestInit(), this.object.model.setValue(Ss.INFOSTAND_EXTRA_PARAM, Ss.JUKEBOX), t instanceof Ht)) {
      const e = this.object.getState(0);
      e !== this._currentState && (this._currentState = e, e === 1 ? this.requestPlayList() : e === 0 && this.requestStopPlaying());
    }
  }
  requestInit() {
    !this.object || !this.eventDispatcher || (this._disposeEventsAllowed = !0, this.eventDispatcher.dispatchEvent(new z(z.SOUND_MACHINE_INIT, this.object)), this._isInitialized = !0);
  }
  requestPlayList() {
    !this.object || !this.eventDispatcher || (this._disposeEventsAllowed = !0, this.eventDispatcher.dispatchEvent(new z(z.SOUND_MACHINE_START, this.object)));
  }
  requestStopPlaying() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new z(z.SOUND_MACHINE_STOP, this.object));
  }
  requestDispose() {
    !this._disposeEventsAllowed || !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new z(z.SOUND_MACHINE_DISPOSE, this.object));
  }
}
const Ed = class Ed extends wt {
  getEventTypes() {
    const t = [
      N.STICKIE,
      z.STICKIE
    ];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  initialize(t) {
    super.initialize(t), this.updateColor(), this.object && this.object.model.setValue(I.FURNITURE_IS_STICKIE, "");
  }
  processUpdateMessage(t) {
    super.processUpdateMessage(t), t instanceof mI && this.eventDispatcher && this.eventDispatcher.dispatchEvent(new N(N.STICKIE, this.object)), this.updateColor();
  }
  updateColor() {
    if (!this.object) return;
    const t = this.object.model.getValue(I.FURNITURE_DATA);
    let e = Ed.STICKIE_COLORS.indexOf(t);
    e < 0 && (e = 3), this.object.model.setValue(I.FURNITURE_COLOR, e + 1);
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new z(z.STICKIE, this.object));
  }
};
Ed.STICKIE_COLORS = ["9CCEFF", "FF9CFF", "9CFF9C", "FFFF33"];
let bE = Ed;
class Sit extends wt {
  getEventTypes() {
    const t = [N.TROPHY];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new N(N.TROPHY, this.object));
  }
}
const jr = class jr extends _e {
  constructor() {
    super(), this._total = 0, this._lastUpdate = 0, this._interval = 33;
  }
  processUpdateMessage(t) {
    if (super.processUpdateMessage(t), t instanceof Ht) {
      const e = t.data;
      if (!e) return;
      this.updateTotal(e.result);
    }
  }
  updateTotal(t) {
    if (this._total = t, !this._lastUpdate) {
      this.object.model.setValue(I.FURNITURE_VOTE_COUNTER_COUNT, t), this._lastUpdate = Nt();
      return;
    }
    if (this._total !== this.currentTotal) {
      const e = Math.abs(this._total - this.currentTotal);
      e * jr.UPDATE_INTERVAL > jr.MAX_UPDATE_TIME ? this._interval = jr.MAX_UPDATE_TIME / e : this._interval = jr.UPDATE_INTERVAL, this._lastUpdate = Nt();
    }
  }
  update(t) {
    if (super.update(t), this.object && this.currentTotal !== this._total && t >= this._lastUpdate + this._interval) {
      const e = t - this._lastUpdate;
      let s = e / this._interval, r = 1;
      this._total < this.currentTotal && (r = -1), s > r * (this._total - this.currentTotal) && (s = r * (this._total - this.currentTotal)), this.object.model.setValue(I.FURNITURE_VOTE_COUNTER_COUNT, this.currentTotal + r * s), this._lastUpdate = t - (e - s * this._interval);
    }
  }
  get currentTotal() {
    return this.object.model.getValue(I.FURNITURE_VOTE_COUNTER_COUNT);
  }
};
jr.UPDATE_INTERVAL = 33, jr.MAX_UPDATE_TIME = 1e3;
let PE = jr;
class Ait extends _e {
  processUpdateMessage(t) {
    if (super.processUpdateMessage(t), !!this.object && t instanceof Ht) {
      const e = t.data;
      e instanceof mu && this.object.model.setValue(I.FURNITURE_VOTE_MAJORITY_RESULT, e.result);
    }
  }
}
class Rit extends _e {
  mouseEvent(t, e) {
    !t || !e || (t.type === J.DOUBLE_CLICK && this.eventDispatcher && this.eventDispatcher.dispatchEvent(new At(At.STATE_CHANGE, this.object)), super.mouseEvent(t, e));
  }
}
class Oit extends _e {
  initialize(t) {
    super.initialize(t);
    let e = "";
    t.logic && t.logic.maskType && t.logic.maskType !== "" && t.logic.maskType.length > 0 && (e = t.logic.maskType), this.object.model.setValue(I.FURNITURE_USES_PLANE_MASK, 1), this.object.model.setValue(I.FURNITURE_PLANE_MASK_TYPE, e);
  }
}
class yit extends wt {
  getEventTypes() {
    const t = [
      N.YOUTUBE,
      qs.RODRE_URL_PREFIX
    ];
    return this.mergeTypes(super.getEventTypes(), t);
  }
  update(t) {
    super.update(t), this.object.model.getValue(I.SESSION_URL_PREFIX) || this.eventDispatcher.dispatchEvent(new qs(qs.RODRE_URL_PREFIX, this.object));
  }
  useObject() {
    !this.object || !this.eventDispatcher || this.eventDispatcher.dispatchEvent(new N(N.YOUTUBE, this.object));
  }
}
const Td = class Td {
  constructor() {
    this._id = Td.SPRITE_COUNTER++, this._name = "", this._type = "", this._spriteType = Us.DEFAULT, this._texture = null, this._width = 0, this._height = 0, this._offsetX = 0, this._offsetY = 0, this._flipH = !1, this._flipV = !1, this._direction = 0, this._alpha = 255, this._blendMode = "normal", this._color = 16777215, this._relativeDepth = 0, this._varyingDepth = !1, this._libraryAssetName = "", this._clickHandling = !1, this._skipMouseHandling = !1, this._visible = !0, this._tag = "", this._posture = null, this._alphaTolerance = _i.MATCH_OPAQUE_PIXELS, this._filters = [], this._updateCounter = 0;
  }
  dispose() {
    this._texture = null, this._width = 0, this._height = 0;
  }
  increaseUpdateCounter() {
    this._updateCounter++;
  }
  get id() {
    return this._id;
  }
  set id(t) {
    this._id = t;
  }
  get name() {
    return this._name;
  }
  set name(t) {
    this._name !== t && (this._name = t, this._updateCounter++);
  }
  get type() {
    return this._type;
  }
  set type(t) {
    this._type = t;
  }
  get spriteType() {
    return this._spriteType;
  }
  set spriteType(t) {
    this._spriteType = t;
  }
  get texture() {
    return this._texture;
  }
  set texture(t) {
    this._texture !== t && (t && (this._width = t.width, this._height = t.height), this._texture = t, this._updateCounter++);
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get offsetX() {
    return this._offsetX;
  }
  set offsetX(t) {
    this._offsetX !== t && (this._offsetX = t, this._updateCounter++);
  }
  get offsetY() {
    return this._offsetY;
  }
  set offsetY(t) {
    this._offsetY !== t && (this._offsetY = t, this._updateCounter++);
  }
  get flipH() {
    return this._flipH;
  }
  set flipH(t) {
    this._flipH !== t && (this._flipH = t, this._updateCounter++);
  }
  get flipV() {
    return this._flipV;
  }
  set flipV(t) {
    this._flipV !== t && (this._flipV = t, this._updateCounter++);
  }
  get direction() {
    return this._direction;
  }
  set direction(t) {
    this._direction = t;
  }
  get alpha() {
    return this._alpha;
  }
  set alpha(t) {
    t = t & 255, this._alpha !== t && (this._alpha = t, this._updateCounter++);
  }
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(t) {
    this._blendMode !== t && (this._blendMode = t, this._updateCounter++);
  }
  get color() {
    return this._color;
  }
  set color(t) {
    t = t & 16777215, this._color !== t && (this._color = t, this._updateCounter++);
  }
  get relativeDepth() {
    return this._relativeDepth;
  }
  set relativeDepth(t) {
    this._relativeDepth !== t && (this._relativeDepth = t, this._updateCounter++);
  }
  get varyingDepth() {
    return this._varyingDepth;
  }
  set varyingDepth(t) {
    t !== this._varyingDepth && (this._varyingDepth = t, this._updateCounter++);
  }
  get libraryAssetName() {
    return this._libraryAssetName;
  }
  set libraryAssetName(t) {
    this._libraryAssetName = t;
  }
  get clickHandling() {
    return this._clickHandling;
  }
  set clickHandling(t) {
    this._clickHandling = t;
  }
  get visible() {
    return this._visible;
  }
  set visible(t) {
    this._visible !== t && (this._visible = t, this._updateCounter++);
  }
  get tag() {
    return this._tag;
  }
  set tag(t) {
    this._tag !== t && (this._tag = t, this._updateCounter++);
  }
  get posture() {
    return this._posture;
  }
  set posture(t) {
    this._posture !== t && (this._posture = t, this._updateCounter++);
  }
  get alphaTolerance() {
    return this._alphaTolerance;
  }
  set alphaTolerance(t) {
    this._alphaTolerance !== t && (this._alphaTolerance = t, this._updateCounter++);
  }
  get filters() {
    return this._filters;
  }
  set filters(t) {
    this._filters = t, this._updateCounter++;
  }
  get updateCounter() {
    return this._updateCounter;
  }
  get skipMouseHandling() {
    return this._skipMouseHandling;
  }
  set skipMouseHandling(t) {
    this._skipMouseHandling = t;
  }
};
Td.SPRITE_COUNTER = 0;
let Bc = Td;
const Id = class Id {
  constructor() {
    this._id = Id.VISUALIZATION_COUNTER++, this._object = null, this._asset = null, this._sprites = [], this._scale = -1, this._updateObjectCounter = -1, this._updateModelCounter = -1, this._updateSpriteCounter = -1;
  }
  initialize(t) {
    return !1;
  }
  update(t, e, s, r) {
  }
  reset() {
    this._scale = -1;
  }
  dispose() {
    if (this._sprites) {
      for (; this._sprites.length; ) {
        const t = this._sprites[0];
        t && t.dispose(), this._sprites.shift();
      }
      this._sprites = null;
    }
    this._object = null, this._asset = null;
  }
  getSprite(t) {
    return t >= 0 && t < this._sprites.length ? this._sprites[t] : null;
  }
  getSpriteList() {
    return null;
  }
  createSprite() {
    return this.createSpriteAtIndex(this._sprites.length);
  }
  createSpriteAtIndex(t) {
    const e = new Bc();
    return t >= this._sprites.length ? this._sprites.push(e) : this._sprites.splice(t, 0, e), e;
  }
  createSprites(t) {
    for (; this._sprites.length > t; ) {
      const e = this._sprites[this._sprites.length - 1];
      e && e.dispose(), this._sprites.pop();
    }
    for (; this._sprites.length < t; )
      this._sprites.push(new Bc());
  }
  get image() {
    return this.getImage();
  }
  getImage() {
    const t = this.getBoundingRectangle();
    if (t.width * t.height === 0) return null;
    const e = this.totalSprites, s = [];
    let r = 0;
    for (; r < e; ) {
      const a = this.getSprite(r);
      a && a.visible && a.texture && s.push(a), r++;
    }
    s.sort((a, o) => o.relativeDepth - a.relativeDepth);
    const n = new Qt();
    for (r = 0; r < s.length; ) {
      const a = s[r], o = a.texture;
      if (o) {
        const h = new Ft(o);
        h.alpha = a.alpha / 255, h.tint = a.color, h.x = a.offsetX, h.y = a.offsetY, h.blendMode = a.blendMode, h.filters = a.filters, a.flipH && (h.scale.x = -1), a.flipV && (h.scale.y = -1), n.addChild(h);
      }
      r++;
    }
    return le.generateTexture({
      target: n
    });
  }
  getBoundingRectangle() {
    const t = this.totalSprites, e = new Kt();
    let s = 0;
    for (; s < t; ) {
      const r = this.getSprite(s);
      if (r && r.texture && r.visible) {
        const n = r.flipH ? -r.width + r.offsetX : r.offsetX, a = r.flipV ? -r.height + r.offsetY : r.offsetY, o = new st(n, a);
        s === 0 ? (e.x = o.x, e.y = o.y, e.width = r.width, e.height = r.height) : (o.x < e.x && (e.x = o.x), o.y < e.y && (e.y = o.y), o.x + r.width > e.right && (e.width = o.x + r.width - e.x), o.y + r.height > e.bottom && (e.height = o.y + r.height - e.y));
      }
      s++;
    }
    return e;
  }
  get instanceId() {
    return this._id;
  }
  get object() {
    return this._object;
  }
  set object(t) {
    this._object = t;
  }
  get asset() {
    return this._asset;
  }
  set asset(t) {
    this._asset && this._asset.removeReference(), this._asset = t, this._asset && this._asset.addReference();
  }
  get sprites() {
    return this._sprites;
  }
  get totalSprites() {
    return this._sprites.length;
  }
  get updateObjectCounter() {
    return this._updateObjectCounter;
  }
  set updateObjectCounter(t) {
    this._updateObjectCounter = t;
  }
  get updateModelCounter() {
    return this._updateModelCounter;
  }
  set updateModelCounter(t) {
    this._updateModelCounter = t;
  }
  get updateSpriteCounter() {
    return this._updateSpriteCounter;
  }
  set updateSpriteCounter(t) {
    this._updateSpriteCounter = t;
  }
  get spriteCount() {
    return this._sprites.length;
  }
};
Id.VISUALIZATION_COUNTER = 0;
let Ko = Id;
class EI {
  initialize(t) {
    return !0;
  }
  dispose() {
  }
  createAvatarImage(t, e, s = null, r = null, n = null) {
    let a = null;
    return e > 48 ? a = mR().createAvatarImage(t, ci.LARGE, s, r, n) : a = mR().createAvatarImage(t, ci.SMALL, s, r, n), a;
  }
  get layerCount() {
    return 0;
  }
}
class FM {
  constructor(t, e, s) {
    this._id = t, this._type = e, this._visualization = s;
  }
  dispose() {
    this._visualization = null;
  }
  update(t, e) {
  }
  animate(t) {
    return !1;
  }
  get id() {
    return this._id;
  }
  get type() {
    return this._type;
  }
  get visualization() {
    return this._visualization;
  }
}
const ds = class ds extends FM {
  constructor() {
    super(...arguments), this._asset = null, this._startTime = Nt(), this._delta = 0, this._offsetY = 0, this._scale = 0, this._state = 0;
  }
  update(t, e) {
    if (!t) return;
    this._scale = e;
    let s = 64, r = 0;
    if (e < 48 ? (this._asset = Rt().getTexture("avatar_addition_user_blowkiss_small"), this.visualization.angle === 90 || this.visualization.angle === 270 ? r = 0 : this.visualization.angle === 135 || this.visualization.angle === 180 || this.visualization.angle === 225 ? r = 6 : r = -6, this._offsetY = -38, s = 32) : (this._asset = Rt().getTexture("avatar_addition_user_blowkiss"), this.visualization.angle === 90 || this.visualization.angle === 270 ? r = -3 : this.visualization.angle === 135 || this.visualization.angle === 180 || this.visualization.angle === 225 ? r = 22 : r = -30, this._offsetY = -70), this.visualization.posture === et.POSTURE_SIT ? this._offsetY += s / 2 : this.visualization.posture === et.POSTURE_LAY && (this._offsetY += s), this._asset) {
      t.texture = this._asset, t.offsetX = r, t.offsetY = this._offsetY, t.relativeDepth = -0.02, t.alpha = 0;
      const n = this._delta;
      this.animate(t), this._delta = n;
    }
  }
  animate(t) {
    if (!t) return !1;
    if (this._asset && (t.texture = this._asset), this._state === ds.STATE_DELAY)
      return Nt() - this._startTime < ds.DELAY_BEFORE_ANIMATION ? !1 : (this._state = ds.STATE_FADE_IN, t.alpha = 0, t.visible = !0, this._delta = 0, !0);
    if (this._state === ds.STATE_FADE_IN)
      return this._delta += 0.1, t.offsetY = this._offsetY, t.alpha = Math.pow(this._delta, 0.9) * 255, this._delta >= 1 && (t.alpha = 255, this._delta = 0, this._state = ds.STATE_FLOAT), !0;
    if (this._state === ds.STATE_FLOAT) {
      const e = Math.pow(this._delta, 0.9);
      this._delta += 0.05;
      const s = this._scale < 48 ? -30 : -40;
      return t.offsetY = this._offsetY + (this._delta < 1 ? e : 1) * s, t.alpha = (1 - e) * 255, t.alpha <= 0 && (t.visible = !1, this._state = ds.STATE_COMPLETE), !0;
    }
    return !1;
  }
};
ds.DELAY_BEFORE_ANIMATION = 300, ds.STATE_DELAY = 0, ds.STATE_FADE_IN = 1, ds.STATE_FLOAT = 2, ds.STATE_COMPLETE = 3;
let NE = ds;
const ta = class ta {
  static getExpressionAddition(t, e, s) {
    switch (e) {
      case this.BLOW:
        return new NE(t, this.BLOW, s);
      default:
        return new FM(t, e, s);
    }
  }
};
ta.WAVE = 1, ta.BLOW = 2, ta.LAUGH = 3, ta.CRY = 4, ta.IDLE = 5;
let UE = ta;
const Ve = class Ve {
  constructor(t, e) {
    this._id = t, this._visualization = e, this._asset = null, this._startTime = Nt(), this._offsetY = 0, this._scale = 0, this._state = 0;
  }
  dispose() {
    this._visualization = null, this._asset = null;
  }
  getSpriteAssetName(t) {
    let e = "left";
    return (this._visualization.angle === 135 || this._visualization.angle === 180 || this._visualization.angle === 225 || this._visualization.angle === 270) && (e = "right"), "avatar_addition_user_idle_" + e + "_" + t + (this._scale < 48 ? "_small" : "");
  }
  update(t, e) {
    if (!t) return;
    this._scale = e, this._asset = Rt().getTexture(this.getSpriteAssetName(this._state === Ve.STATE_FRAME_A ? 1 : 2));
    let s = 64, r = 0;
    e < 48 ? (this._visualization.angle === 135 || this._visualization.angle === 180 || this._visualization.angle === 225 || this._visualization.angle === 270 ? r = 10 : r = -16, this._offsetY = -38, s = 32) : (this._visualization.angle === 135 || this._visualization.angle === 180 || this._visualization.angle === 225 || this._visualization.angle === 270 ? r = 22 : r = -30, this._offsetY = -70), this._visualization.posture === et.POSTURE_SIT ? this._offsetY += s / 2 : this._visualization.posture === et.POSTURE_LAY && (this._offsetY += s - 0.3 * s), this._asset && (t.texture = this._asset, t.offsetX = r, t.offsetY = this._offsetY, t.relativeDepth = -0.02, t.alpha = 0);
  }
  animate(t) {
    if (!t) return !1;
    const e = Nt();
    return this._state === Ve.STATE_DELAY && e - this._startTime >= Ve.DELAY_BEFORE_ANIMATION && (this._state = Ve.STATE_FRAME_A, this._startTime = e, this._asset = Rt().getTexture(this.getSpriteAssetName(1))), this._state === Ve.STATE_FRAME_A && e - this._startTime >= Ve.DELAY_PER_FRAME && (this._state = Ve.STATE_FRAME_B, this._startTime = e, this._asset = Rt().getTexture(this.getSpriteAssetName(2))), this._state === Ve.STATE_FRAME_B && e - this._startTime >= Ve.DELAY_PER_FRAME && (this._state = Ve.STATE_FRAME_A, this._startTime = e, this._asset = Rt().getTexture(this.getSpriteAssetName(1))), this._asset ? (t.texture = this._asset, t.alpha = 255, t.visible = !0) : t.visible = !1, !1;
  }
  get id() {
    return this._id;
  }
};
Ve.DELAY_BEFORE_ANIMATION = 2e3, Ve.DELAY_PER_FRAME = 2e3, Ve.STATE_DELAY = 0, Ve.STATE_FRAME_A = 1, Ve.STATE_FRAME_B = 2;
let DE = Ve;
const Ni = class Ni {
  constructor(t) {
    this._id = t, this._asset = null;
  }
  dispose() {
    this._asset && (on().putTexture(this._asset), this._asset = null);
  }
  update(t, e) {
    t && (this._asset || (this._asset = on().getTexture(Ni.WIDTH, Ni.HEIGHT)), t.visible = !0, t.texture = this._asset, t.offsetX = Ni.OFFSET_X, t.offsetY = Ni.OFFSET_Y, t.alphaTolerance = _i.MATCH_ALL_PIXELS);
  }
  animate(t) {
    return !1;
  }
  get id() {
    return this._id;
  }
};
Ni.WIDTH = 46, Ni.HEIGHT = 60, Ni.OFFSET_X = -23, Ni.OFFSET_Y = -48;
let LE = Ni;
class vit {
  constructor(t, e, s) {
    this._id = t, this._visualization = e, this._status = s, this._asset = null, this._relativeDepth = 0;
  }
  dispose() {
    this._visualization = null, this._asset = null;
  }
  update(t, e) {
    if (!t) return;
    t.visible = !0, t.relativeDepth = this._relativeDepth, t.alpha = 255;
    let s = 64, r = 0, n = 0;
    this._asset = Rt().getTexture(this._status === Gi.GUIDE ? "avatar_addition_user_guide_bubble" : "avatar_addition_user_guide_requester_bubble"), e < 48 ? (r = -19, n = -80, s = 32) : (r = -19, n = -120), this._visualization.posture === et.POSTURE_SIT ? n += s / 2 : this._visualization.posture === et.POSTURE_LAY && (n += e), this._asset && (t.texture = this._asset, t.offsetX = r, t.offsetY = n, t.relativeDepth = -0.02 + 0);
  }
  animate(t) {
    return this._asset && t && (t.texture = this._asset), !1;
  }
  get id() {
    return this._id;
  }
  get relativeDepth() {
    return this._relativeDepth;
  }
  set relativeDepth(t) {
    this._relativeDepth = t;
  }
}
class Cit {
  constructor(t, e) {
    this._id = t, this._visualization = e, this._asset = null;
  }
  dispose() {
    this._visualization = null, this._asset = null;
  }
  update(t, e) {
    if (!t) return;
    let s = 64, r = 0, n = 0;
    e < 48 ? (this._asset = Rt().getTexture("avatar_addition_user_muted_small"), s = 32, r = -12, n = -66) : (this._asset = Rt().getTexture("avatar_addition_user_muted"), r = -15, n = -110), this._visualization.posture === et.POSTURE_SIT ? n += s / 2 : this._visualization.posture === et.POSTURE_LAY && (n += e), this._asset ? (t.visible = !0, t.texture = this._asset, t.offsetX = r, t.offsetY = n, t.relativeDepth = -0.02) : t.visible = !1;
  }
  animate(t) {
    return this._asset && t && (t.texture = this._asset), !1;
  }
  get id() {
    return this._id;
  }
}
class xit {
  constructor(t, e, s) {
    this._id = t, this._number = e, this._visualization = s, this._asset = null, this._scale = 0, this._numberValueFadeDirection = 0, this._numberValueMoving = !1, this._numberValueMoveCounter = 0;
  }
  dispose() {
    this._visualization = null, this._asset = null;
  }
  update(t, e) {
    if (!t) return;
    this._scale = e;
    let s = 64, r = 0, n = 0;
    this._number > 0 ? (e < 48 ? (this._asset = Rt().getTexture("avatar_addition_number_" + this._number + "_small"), s = 32, r = -6, n = -52) : (this._asset = Rt().getTexture("avatar_addition_number_" + this._number), r = -8, n = -105), this._visualization.posture === et.POSTURE_SIT ? n += s / 2 : this._visualization.posture === et.POSTURE_LAY && (n += e), this._asset ? (t.visible = !0, t.texture = this._asset, t.offsetX = r, t.offsetY = n, t.relativeDepth = -0.01, t.alpha = 0, this._numberValueFadeDirection = 1, this._numberValueMoving = !0, this._numberValueMoveCounter = 0) : t.visible = !1) : t.visible && (this._numberValueFadeDirection = -1);
  }
  animate(t) {
    if (!t) return !1;
    this._asset && (t.texture = this._asset);
    let e = t.alpha, s = !1;
    if (this._numberValueMoving) {
      if (this._numberValueMoveCounter++, this._numberValueMoveCounter < 10) return !1;
      if (this._numberValueFadeDirection < 0)
        this._scale < 48 ? t.offsetY -= 2 : t.offsetY -= 4;
      else {
        let r = 4;
        this._scale < 48 && (r = 8), this._numberValueMoveCounter % r || (t.offsetY--, s = !0);
      }
    }
    return this._numberValueFadeDirection > 0 ? (e < 255 && (e += 32), e >= 255 && (e = 255, this._numberValueFadeDirection = 0), t.alpha = e, !0) : this._numberValueFadeDirection < 0 ? (e >= 0 && (e -= 32), e <= 0 && (this._numberValueFadeDirection = 0, this._numberValueMoving = !1, e = 0, t.visible = !1), t.alpha = e, !0) : s;
  }
  get id() {
    return this._id;
  }
}
class Mit {
  constructor(t, e) {
    this._id = t, this._visualization = e, this._asset = null, this._relativeDepth = 0;
  }
  dispose() {
    this._visualization = null, this._asset = null;
  }
  update(t, e) {
    if (!t) return;
    t.visible = !0, t.relativeDepth = this._relativeDepth, t.alpha = 255;
    let s = 64, r = 0, n = 0;
    e < 48 ? (this._asset = Rt().getTexture("avatar_addition_user_typing_small"), r = 3, n = -42, s = 32) : (this._asset = Rt().getTexture("avatar_addition_user_typing"), r = 14, n = -83), this._visualization.posture === et.POSTURE_SIT ? n += s / 2 : this._visualization.posture === et.POSTURE_LAY && (n += e), this._asset && (t.texture = this._asset, t.offsetX = r, t.offsetY = n, t.relativeDepth = -0.02 + 0);
  }
  animate(t) {
    return this._asset && t && (t.texture = this._asset), !1;
  }
  get id() {
    return this._id;
  }
  get relativeDepth() {
    return this._relativeDepth;
  }
  set relativeDepth(t) {
    this._relativeDepth = t;
  }
}
const $ = class $ extends Ko {
  constructor() {
    super(), this._data = null, this._avatarImage = null, this._cachedAvatars = new be(), this._cachedAvatarEffects = new be(), this._shadow = null, this._lastUpdate = -1e3, this._disposed = !1, this._figure = null, this._gender = null, this._direction = -1, this._headDirection = -1, this._posture = "", this._postureParameter = "", this._canStandUp = !1, this._postureOffset = 0, this._verticalOffset = 0, this._angle = -1, this._headAngle = -1, this._talk = !1, this._expression = 0, this._sleep = !1, this._blink = !1, this._gesture = 0, this._sign = -1, this._highlightEnabled = !1, this._highlight = !1, this._dance = 0, this._effect = 0, this._carryObject = 0, this._useObject = 0, this._ownUser = !1, this._isLaying = !1, this._layInside = !1, this._isAnimating = !1, this._extraSpritesStartIndex = 2, this._forcedAnimFrames = 0, this._updatesUntilFrameUpdate = 0, this._isAvatarReady = !1, this._needsUpdate = !1, this._geometryUpdateCounter = -1, this._additions = /* @__PURE__ */ new Map();
  }
  initialize(t) {
    return t instanceof EI ? (this._data = t, this.createSprites($.INITIAL_RESERVED_SPRITES), super.initialize(t), !0) : !1;
  }
  dispose() {
    this._disposed || (super.dispose(), this._avatarImage && this._avatarImage.dispose(), this._shadow = null, this._disposed = !0);
  }
  update(t, e, s, r) {
    if (!this.object || !t || !this._data || e < this._lastUpdate + $.UPDATE_TIME_INCREASER) return;
    this._lastUpdate += $.UPDATE_TIME_INCREASER, this._lastUpdate + $.UPDATE_TIME_INCREASER < e && (this._lastUpdate = e - $.UPDATE_TIME_INCREASER);
    const n = this.object.model, a = t.scale, o = this._effect;
    let h = !1, u = !1, c = !1, l = !1;
    const _ = this.updateModel(n, a);
    if (_ || a !== this._scale || !this._avatarImage) {
      if (a !== this._scale && (h = !0, this.updateScale(a)), o !== this._effect && (u = !0), h || !this._avatarImage || u) {
        if (this._avatarImage = this.createAvatarImage(a, this._effect), !this._avatarImage) return;
        c = !0;
        const p = this.getSprite($.AVATAR_LAYER_ID);
        p && this._avatarImage && this._avatarImage.isPlaceholder() ? p.alpha = 150 : p && (p.alpha = 255);
      }
      if (!this._avatarImage) return;
      if (u && this._avatarImage.animationHasResetOnToggle && this._avatarImage.resetAnimationFrameCounter(), this.updateShadow(a), l = this.updateObject(this.object, t, s, !0), this.processActionsForAvatar(this._avatarImage), this._additions) {
        let p = this._extraSpritesStartIndex;
        for (const g of this._additions.values())
          g.update(this.getSprite(p++), a);
      }
      this._scale = a;
    } else
      l = this.updateObject(this.object, t, s);
    if (this._additions) {
      let p = this._extraSpritesStartIndex;
      for (const g of this._additions.values())
        g.animate(this.getSprite(p++)) && this.updateSpriteCounter++;
    }
    const d = l || _ || h, f = (this._isAnimating || this._forcedAnimFrames > 0) && s;
    if (d && (this._forcedAnimFrames = $.ANIMATION_FRAME_UPDATE_INTERVAL), d || f) {
      if (this.updateSpriteCounter++, this._forcedAnimFrames--, this._updatesUntilFrameUpdate--, this._updatesUntilFrameUpdate <= 0 || h || _ || c)
        this._avatarImage.updateAnimationByFrames(1), this._updatesUntilFrameUpdate = $.ANIMATION_FRAME_UPDATE_INTERVAL;
      else
        return;
      let p = this._avatarImage.getCanvasOffsets();
      (!p || p.length < 3) && (p = $.DEFAULT_CANVAS_OFFSETS);
      const g = this.getSprite($.SPRITE_INDEX_AVATAR);
      if (g) {
        const C = this.object.model.getValue(I.FIGURE_HIGHLIGHT_ENABLE) === 1 && this.object.model.getValue(I.FIGURE_HIGHLIGHT) === 1, b = this._avatarImage.processAsTexture(gs.FULL, C);
        b && (g.texture = b, C || (g.filters = [])), g.texture && (g.offsetX = -1 * a / 2 + p[0] - (g.texture.width - a) / 2, g.offsetY = -g.texture.height + a / 4 + p[1] + this._postureOffset), this._isLaying ? this._layInside ? g.relativeDepth = -0.5 : g.relativeDepth = $.AVATAR_SPRITE_LAYING_DEPTH + p[2] : g.relativeDepth = $.AVATAR_SPRITE_DEFAULT_DEPTH + p[2], this._ownUser ? (g.relativeDepth -= $.AVATAR_OWN_DEPTH_ADJUST, g.spriteType = Us.AVATAR_OWN) : g.spriteType = Us.AVATAR;
      }
      const m = this.getAddition($.TYPING_BUBBLE_ID);
      m && (this._isLaying ? m.relativeDepth = $.AVATAR_SPRITE_LAYING_DEPTH - 0.01 + p[2] : m.relativeDepth = $.AVATAR_SPRITE_DEFAULT_DEPTH - 0.01 + p[2]), this._isAnimating = this._avatarImage.isAnimating();
      let O = $.INITIAL_RESERVED_SPRITES;
      const y = this._avatarImage.getDirection();
      for (const C of this._avatarImage.getSprites())
        if (C.id === $.AVATAR) {
          const b = this.getSprite($.SPRITE_INDEX_AVATAR);
          if (b) {
            const D = this._avatarImage.getLayerData(C);
            let P = C.getDirectionOffsetX(y), F = C.getDirectionOffsetY(y);
            D && (P += D.dx, F += D.dy), a < 48 && (P /= 2, F /= 2), this._canStandUp || (b.offsetX += P, b.offsetY += F);
          }
        } else {
          const b = this.getSprite(O);
          if (b) {
            b.alphaTolerance = _i.MATCH_NOTHING, b.visible = !0;
            const D = this._avatarImage.getLayerData(C);
            let P = 0, F = C.getDirectionOffsetX(y), M = C.getDirectionOffsetY(y);
            const U = C.getDirectionOffsetZ(y);
            let k = 0;
            C.hasDirections && (k = y), D && (P = D.animationFrame, F += D.dx, M += D.dy, k += D.dd), a < 48 && (F /= 2, M /= 2), k < 0 ? k += 8 : k > 7 && (k -= 8);
            const ft = this._avatarImage.getScale() + "_" + C.member + "_" + k + "_" + P, K = Rt().getAsset(ft);
            if (!K) continue;
            b.texture = K.texture, b.offsetX = K.offsetX - a / 2 + F, b.offsetY = K.offsetY + M, b.flipH = K.flipH, C.hasStaticY ? b.offsetY += this._verticalOffset * a / (2 * $.BASE_Y_SCALE) : b.offsetY += this._postureOffset, this._isLaying ? b.relativeDepth = $.AVATAR_SPRITE_LAYING_DEPTH - 1e-3 * this.totalSprites * U : b.relativeDepth = $.AVATAR_SPRITE_DEFAULT_DEPTH - 1e-3 * this.totalSprites * U, C.ink === 33 ? b.blendMode = "add" : b.blendMode = "normal";
          }
          O++;
        }
    }
  }
  createAvatarImage(t, e) {
    let s = null, r = "avatarImage" + t.toString();
    if (e ? (r += "-" + e, s = this._cachedAvatarEffects.getValue(r)) : s = this._cachedAvatars.getValue(r), !s && (s = this._data.createAvatarImage(this._figure, t, this._gender, this, this), s))
      if (!e)
        this._cachedAvatars.add(r, s);
      else {
        if (this._cachedAvatarEffects.length >= $.MAX_EFFECT_CACHE) {
          const n = this._cachedAvatarEffects.remove(this._cachedAvatarEffects.getKey(0));
          n && n.dispose();
        }
        this._cachedAvatarEffects.add(r, s);
      }
    return s;
  }
  updateObject(t, e, s, r = !1) {
    if (!r && this.updateObjectCounter === t.updateCounter && this._geometryUpdateCounter === e.updateId) return !1;
    let n = t.getDirection().x - e.direction.x, a = this._headDirection - e.direction.x;
    return this._posture === "float" && (a = n), n = (n % 360 + 360) % 360, a = (a % 360 + 360) % 360, this._posture === "sit" && this._canStandUp && (n -= n % 90 - 45, a -= a % 90 - 45), (n !== this._angle || r) && (s = !0, this._angle = n, n = n - (135 - 22.5), n = (n + 360) % 360, this._avatarImage.setDirectionAngle(gs.FULL, n)), (a !== this._headAngle || r) && (s = !0, this._headAngle = a, this._headAngle !== this._angle && (a = a - (135 - 22.5), a = (a + 360) % 360, this._avatarImage.setDirectionAngle(gs.HEAD, a))), this._geometryUpdateCounter = e.updateId, this.updateObjectCounter = this.object.updateCounter, s;
  }
  updateModel(t, e) {
    if (!t || this.updateModelCounter === t.updateCounter) return !1;
    let s = !1;
    const r = t.getValue(I.FIGURE_TALK) > 0;
    r !== this._talk && (this._talk = r, s = !0);
    const n = t.getValue(I.FIGURE_EXPRESSION);
    n !== this._expression && (this._expression = n, s = !0);
    const a = t.getValue(I.FIGURE_SLEEP) > 0;
    a !== this._sleep && (this._sleep = a, s = !0);
    const o = t.getValue(I.FIGURE_BLINK) > 0;
    o !== this._blink && (this._blink = o, s = !0);
    const h = t.getValue(I.FIGURE_GESTURE) || 0;
    h !== this._gesture && (this._gesture = h, s = !0);
    const u = t.getValue(I.FIGURE_POSTURE);
    u !== this._posture && (this._posture = u, s = !0);
    const c = t.getValue(I.FIGURE_POSTURE_PARAMETER);
    c !== this._postureParameter && (this._postureParameter = c, s = !0);
    const l = t.getValue(I.FIGURE_CAN_STAND_UP);
    l !== this._canStandUp && (this._canStandUp = l, s = !0);
    const _ = t.getValue(I.FIGURE_VERTICAL_OFFSET) * $.BASE_Y_SCALE;
    _ !== this._verticalOffset && (this._verticalOffset = _, s = !0);
    const d = t.getValue(I.FIGURE_DANCE) || 0;
    d !== this._dance && (this._dance = d, s = !0);
    const f = t.getValue(I.FIGURE_EFFECT) || 0;
    f !== this._effect && (this._effect = f, s = !0);
    const p = t.getValue(I.FIGURE_CARRY_OBJECT) || 0;
    p !== this._carryObject && (this._carryObject = p, s = !0);
    const g = t.getValue(I.FIGURE_USE_OBJECT) || 0;
    g !== this._useObject && (this._useObject = g, s = !0);
    const m = t.getValue(I.HEAD_DIRECTION);
    m !== this._headDirection && (this._headDirection = m, s = !0), this._carryObject > 0 && g > 0 ? this._useObject !== this._carryObject && (this._useObject = this._carryObject, s = !0) : this._useObject !== 0 && (this._useObject = 0, s = !0);
    let O = this.getAddition($.FLOATING_IDLE_Z_ID);
    this._sleep ? (O || (O = this.addAddition(new DE($.FLOATING_IDLE_Z_ID, this))), s = !0) : O && this.removeAddition($.FLOATING_IDLE_Z_ID);
    const y = t.getValue(I.FIGURE_IS_MUTED) > 0;
    let C = this.getAddition($.MUTED_BUBBLE_ID);
    if (y)
      C || (C = this.addAddition(new Cit($.MUTED_BUBBLE_ID, this))), s = !0;
    else {
      C && (this.removeAddition($.MUTED_BUBBLE_ID), s = !0);
      const ut = t.getValue(I.FIGURE_IS_TYPING) > 0;
      let Gt = this.getAddition($.TYPING_BUBBLE_ID);
      ut ? (Gt || (Gt = this.addAddition(new Mit($.TYPING_BUBBLE_ID, this))), s = !0) : Gt && (this.removeAddition($.TYPING_BUBBLE_ID), s = !0);
    }
    const b = t.getValue(I.FIGURE_GUIDE_STATUS) || 0;
    b !== Gi.NONE ? (this.removeAddition($.GUIDE_BUBBLE_ID), this.addAddition(new vit($.GUIDE_BUBBLE_ID, this, b)), s = !0) : this.getAddition($.GUIDE_BUBBLE_ID) && (this.removeAddition($.GUIDE_BUBBLE_ID), s = !0);
    const D = t.getValue(I.FIGURE_IS_PLAYING_GAME) > 0;
    let P = this.getAddition($.GAME_CLICK_TARGET_ID);
    D ? (P || (P = this.addAddition(new LE($.GAME_CLICK_TARGET_ID))), s = !0) : P && this.removeAddition($.GAME_CLICK_TARGET_ID);
    const F = t.getValue(I.FIGURE_NUMBER_VALUE);
    let M = this.getAddition($.NUMBER_BUBBLE_ID);
    F > 0 ? (M || (M = this.addAddition(new xit($.NUMBER_BUBBLE_ID, F, this))), s = !0) : M && this.removeAddition($.NUMBER_BUBBLE_ID);
    let U = this.getAddition($.EXPRESSION_ID);
    this._expression > 0 ? U || (U = UE.getExpressionAddition($.EXPRESSION_ID, this._expression, this), U && this.addAddition(U)) : U && this.removeAddition($.EXPRESSION_ID), this.updateScale(e);
    const k = t.getValue(I.GENDER);
    k !== this._gender && (this._gender = k, s = !0), this.updateFigure(t.getValue(I.FIGURE)) && (s = !0);
    let ft = t.getValue(I.FIGURE_SIGN);
    ft === null && (ft = -1), this._sign !== ft && (this._sign = ft, s = !0);
    const K = t.getValue(I.FIGURE_HIGHLIGHT_ENABLE) > 0;
    if (K !== this._highlightEnabled && (this._highlightEnabled = K, s = !0), this._highlightEnabled) {
      const ut = t.getValue(I.FIGURE_HIGHLIGHT) > 0;
      ut !== this._highlight && (this._highlight = ut, s = !0);
    }
    const Y = t.getValue(I.OWN_USER) > 0;
    return Y !== this._ownUser && (this._ownUser = Y, s = !0), this.updateModelCounter = t.updateCounter, s;
  }
  setDirection(t) {
    this._direction !== t && (this._direction = t, this._needsUpdate = !0);
  }
  updateScale(t) {
    t < 48 && (this._blink = !1), this._posture === "sit" || this._posture === "lay" ? this._postureOffset = t / 2 : this._postureOffset = 0, this._layInside = !1, this._isLaying = !1, this._posture === "lay" && (this._isLaying = !0, parseInt(this._postureParameter) < 0 && (this._layInside = !0));
  }
  processActionsForAvatar(t) {
    if (!t) return;
    if (t.initActionAppends(), t.appendAction(et.POSTURE, this._posture, this._postureParameter), this._gesture > 0 && this._avatarImage.appendAction(et.GESTURE, et.getGesture(this._gesture)), this._dance > 0 && this._avatarImage.appendAction(et.DANCE, this._dance), this._sign > -1 && this._avatarImage.appendAction(et.SIGN, this._sign), this._carryObject > 0 && this._avatarImage.appendAction(et.CARRY_OBJECT, this._carryObject), this._useObject > 0 && this._avatarImage.appendAction(et.USE_OBJECT, this._useObject), this._talk && this._avatarImage.appendAction(et.TALK), (this._sleep || this._blink) && this._avatarImage.appendAction(et.SLEEP), this._expression > 0) {
      const s = et.getExpression(this._expression);
      if (s !== "")
        switch (s) {
          case et.DANCE:
            this._avatarImage.appendAction(et.DANCE, 2);
            break;
          default:
            this._avatarImage.appendAction(s);
            break;
        }
    }
    this._effect > 0 && this._avatarImage.appendAction(et.EFFECT, this._effect), t.endActionAppends(), this._isAnimating = t.isAnimating();
    let e = $.INITIAL_RESERVED_SPRITES;
    for (const s of this._avatarImage.getSprites())
      s.id !== $.AVATAR && e++;
    if (e !== this.totalSprites && this.createSprites(e), this._extraSpritesStartIndex = e, this._additions)
      for (const s of this._additions.values()) this.createSprite();
  }
  updateFigure(t) {
    return this._figure === t ? !1 : (this._figure = t, this.clearAvatar(), !0);
  }
  resetFigure(t) {
    this.clearAvatar();
  }
  resetEffect(t) {
    this.clearAvatar();
  }
  clearAvatar() {
    const t = this.getSprite($.AVATAR_LAYER_ID);
    t && (t.texture = W.EMPTY, t.alpha = 255);
    for (const e of this._cachedAvatars.getValues()) e && e.dispose();
    for (const e of this._cachedAvatarEffects.getValues()) e && e.dispose();
    this._cachedAvatars.reset(), this._cachedAvatarEffects.reset(), this._avatarImage = null;
  }
  getAddition(t) {
    if (!this._additions) return null;
    const e = this._additions.get(t);
    return e || null;
  }
  addAddition(t) {
    if (!this.getAddition(t.id))
      return this._additions.set(t.id, t), t;
  }
  removeAddition(t) {
    const e = this.getAddition(t);
    e && (this._additions.delete(e.id), e.dispose());
  }
  updateShadow(t) {
    this._shadow = null;
    const e = this.getSprite($.SHADOW_LAYER_ID);
    if (!e) return;
    let s = this._posture === "mv" || this._posture === "std" || this._posture === "sit" && this._canStandUp;
    if (this._effect === $.SNOWBOARDING_EFFECT && (s = !1), s) {
      if (e.visible = !0, !this._shadow || t !== this._scale) {
        let r = 0, n = 0;
        t < 48 ? (e.libraryAssetName = "sh_std_sd_1_0_0", this._shadow = Rt().getAsset(e.libraryAssetName), r = -8, n = this._canStandUp ? 6 : -3) : (e.libraryAssetName = "h_std_sd_1_0_0", this._shadow = Rt().getAsset(e.libraryAssetName), r = -17, n = this._canStandUp ? 10 : -7), this._shadow ? (e.texture = this._shadow.texture, e.offsetX = r, e.offsetY = n, e.alpha = 50, e.relativeDepth = 1) : e.visible = !1;
      }
    } else
      this._shadow = null, e.visible = !1;
  }
  get direction() {
    return this._direction;
  }
  get posture() {
    return this._posture;
  }
  get angle() {
    return this._angle;
  }
  get disposed() {
    return this._disposed;
  }
};
$.AVATAR = "avatar", $.FLOATING_IDLE_Z_ID = 1, $.TYPING_BUBBLE_ID = 2, $.EXPRESSION_ID = 3, $.NUMBER_BUBBLE_ID = 4, $.GAME_CLICK_TARGET_ID = 5, $.MUTED_BUBBLE_ID = 6, $.GUIDE_BUBBLE_ID = 7, $.OWN_USER_ID = 4, $.UPDATE_TIME_INCREASER = 41, $.AVATAR_LAYER_ID = 0, $.SHADOW_LAYER_ID = 1, $.SNOWBOARDING_EFFECT = 97, $.INITIAL_RESERVED_SPRITES = 2, $.ANIMATION_FRAME_UPDATE_INTERVAL = 2, $.DEFAULT_CANVAS_OFFSETS = [0, 0, 0], $.MAX_EFFECT_CACHE = 2, $.SPRITE_INDEX_AVATAR = 0, $.BASE_Y_SCALE = 1e3, $.AVATAR_SPRITE_DEFAULT_DEPTH = -0.01, $.AVATAR_OWN_DEPTH_ADJUST = 1e-3, $.AVATAR_SPRITE_LAYING_DEPTH = -0.409;
let FE = $;
const fs = class fs {
  static allocate(t, e, s, r, n, a, o = -1, h = 0) {
    const u = fs.POOL.length ? fs.POOL.pop() : new fs();
    return r < 1 && (r = 1), n < 0 && (n = fs.FRAME_REPEAT_FOREVER), u._id = t, u._x = e || 0, u._y = s || 0, u._repeats = r, u._frameRepeats = n, u._remainingFrameRepeats = n, u._isLastFrame = a, u._isRecycled = !1, o >= 0 ? (u._activeSequence = o, u._activeSequenceOffset = h) : (u._activeSequence = -1, u._activeSequenceOffset = 0), u;
  }
  get id() {
    return this._id >= 0 ? this._id : -this._id * Math.random();
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  get repeats() {
    return this._repeats;
  }
  get frameRepeats() {
    return this._frameRepeats;
  }
  get isLastFrame() {
    return this._isLastFrame;
  }
  get remainingFrameRepeats() {
    return this._frameRepeats < 0 ? fs.FRAME_REPEAT_FOREVER : this._remainingFrameRepeats;
  }
  set remainingFrameRepeats(t) {
    t < 0 && (t = 0), this._frameRepeats > 0 && t > this._frameRepeats && (t = this._frameRepeats), this._remainingFrameRepeats = t;
  }
  get activeSequence() {
    return this._activeSequence;
  }
  get activeSequenceOffset() {
    return this._activeSequenceOffset;
  }
  recycle() {
    this._isRecycled || (this._isRecycled = !0, fs.POOL.length < fs.POOL_SIZE_LIMIT && fs.POOL.push(this));
  }
};
fs.FRAME_REPEAT_FOREVER = -1, fs.SEQUENCE_NOT_DEFINED = -1, fs.POOL_SIZE_LIMIT = 3e3, fs.POOL = [];
let fn = fs;
class wM {
  constructor(t, e, s, r, n, a) {
    this._id = 0, this._x = 0, this._y = 0, this._randomX = 0, this._randomY = 0, this._repeats = 1, this._id = t, this._x = e, this._y = s, this._randomX = r, this._randomY = n, this._repeats = a;
  }
  get id() {
    return this._id;
  }
  hasDirectionalOffsets() {
    return !1;
  }
  getX(t) {
    return this._x;
  }
  getY(t) {
    return this._y;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._x;
  }
  get randomX() {
    return this._randomX;
  }
  get randomY() {
    return this._randomY;
  }
  get repeats() {
    return this._repeats;
  }
}
class bit extends wM {
  constructor(t, e, s, r, n, a, o) {
    super(t, e, s, r, n, o), this._directionalOffsets = a;
  }
  hasDirectionalOffsets() {
    return this._directionalOffsets !== null;
  }
  getX(t) {
    return this._directionalOffsets ? this._directionalOffsets.getXOffset(t, super.getX(t)) : super.getX(t);
  }
  getY(t) {
    return this._directionalOffsets ? this._directionalOffsets.getYOffset(t, super.getY(t)) : super.getY(t);
  }
}
class Pit {
  constructor(t, e) {
    this._frames = [], this._frameIndexes = [], this._frameRepeats = [], this._isRandom = e, this._loopCount = t < 1 ? 1 : t;
  }
  get isRandom() {
    return this._isRandom;
  }
  get frameCount() {
    return this._frameIndexes.length * this._loopCount;
  }
  dispose() {
    this._frames = [];
  }
  initialize() {
    let t = this._frameIndexes.length - 1, e = -1, s = 1;
    for (; t >= 0; )
      this._frameIndexes[t] === e ? s++ : (e = this._frameIndexes[t], s = 1), this._frameRepeats[t] = s, t--;
  }
  addFrame(t, e, s, r, n, a) {
    let o = 1;
    if (this._frames.length > 0) {
      const u = this._frames[this._frames.length - 1];
      u.id === t && !u.hasDirectionalOffsets() && u.x === e && u.y === s && u.randomX === r && r === 0 && u.randomY === n && n === 0 && (o += u.repeats, this._frames.pop());
    }
    const h = a ? new bit(t, e, s, r, n, a, o) : new wM(t, e, s, r, n, o);
    this._frames.push(h), this._frameIndexes.push(this._frames.length - 1), this._frameRepeats.push(1);
  }
  getFrame(t) {
    return !this._frames.length || t < 0 || t >= this.frameCount ? null : this._frames[this._frameIndexes[t % this._frameIndexes.length]];
  }
  getFrameIndex(t) {
    return t < 0 || t >= this.frameCount ? -1 : (this._isRandom && (t = Math.round(Math.random() * this._frameIndexes.length), t === this._frameIndexes.length && t--), t);
  }
  getRepeats(t) {
    return t < 0 || t >= this.frameCount ? 0 : this._frameRepeats[t % this._frameRepeats.length];
  }
}
class Nit {
  constructor(t, e, s) {
    this._frameSequences = [], this._frameCount = -1, this._loopCount = t < 0 ? 0 : t, this._frameRepeat = e < 1 ? 1 : e, this._isRandom = s;
  }
  get frameCount() {
    return this._frameCount < 0 && this.calculateLength(), this._frameCount;
  }
  dispose() {
    if (!(!this._frameSequences || !this._frameSequences.length)) {
      for (const t of this._frameSequences)
        t && t.dispose();
      this._frameSequences = [];
    }
  }
  addFrameSequence(t, e) {
    const s = new Pit(t, e);
    return this._frameSequences.push(s), s;
  }
  calculateLength() {
    this._frameCount = 0;
    for (const t of this._frameSequences)
      t && (this._frameCount += t.frameCount);
  }
  getFrame(t, e) {
    if (this._frameCount < 1) return null;
    if (e = e / this._frameRepeat, !this._isRandom) {
      const n = Math.floor(e / this._frameCount);
      e = Math.floor(e % this._frameCount);
      let a = !1, o = null;
      (this._loopCount > 0 && n >= this._loopCount || this._loopCount <= 0 && this._frameCount === 1) && (e = this._frameCount - 1, a = !0);
      let h = 0, u = 0;
      for (; u < this._frameSequences.length; ) {
        if (o = this._frameSequences[u], o) {
          if (e < h + o.frameCount) break;
          h += o.frameCount;
        }
        u++;
      }
      return this.getFrameFromSpecificSequence(t, o, u, e - h, a);
    }
    const s = Math.trunc(this._frameSequences.length * Math.random()), r = this._frameSequences[s];
    return r.frameCount < 1 ? null : this.getFrameFromSpecificSequence(t, r, s, 0, !1);
  }
  getFrameFromSequence(t, e, s, r) {
    if (e < 0 || e >= this._frameSequences.length) return null;
    const n = this._frameSequences[e];
    return n ? s >= n.frameCount ? this.getFrame(t, r) : this.getFrameFromSpecificSequence(t, n, e, s, !1) : null;
  }
  getFrameFromSpecificSequence(t, e, s, r, n) {
    if (!e) return null;
    const a = e.getFrameIndex(r), o = e.getFrame(a);
    if (!o) return null;
    let h = o.getX(t), u = o.getY(t);
    const c = o.randomX, l = o.randomY;
    let _ = o.repeats, d = !1;
    c && (h = Math.trunc(h + c * Math.random())), l && (u = Math.trunc(u + l * Math.random())), _ > 1 && (_ = e.getRepeats(a));
    let f = this._frameRepeat * _;
    return n && (f = fn.FRAME_REPEAT_FOREVER), !this._isRandom && !e.isRandom && s === this._frameSequences.length - 1 && r === e.frameCount - 1 && (d = !0), fn.allocate(o.id, h, u, _, f, d, s, r);
  }
}
class GM {
  constructor() {
    this._offsetX = /* @__PURE__ */ new Map(), this._offsetY = /* @__PURE__ */ new Map();
  }
  getXOffset(t, e) {
    const s = this._offsetX.get(t);
    return s ?? e;
  }
  getYOffset(t, e) {
    const s = this._offsetY.get(t);
    return s ?? e;
  }
  setDirection(t, e, s) {
    this._offsetX.set(t, e), this._offsetY.set(t, s);
  }
}
const Ui = class Ui {
  constructor() {
    this._layers = /* @__PURE__ */ new Map(), this._frameCount = -1, this._randomStart = !1, this._immediateChanges = null;
  }
  static getTransitionToAnimationId(t) {
    return Ui.TRANSITION_TO_ANIMATION_OFFSET + t;
  }
  static getTransitionFromAnimationId(t) {
    return Ui.TRANSITION_FROM_ANIMATION_OFFSET + t;
  }
  static isTransitionToAnimation(t) {
    return t >= Ui.TRANSITION_TO_ANIMATION_OFFSET && t < Ui.TRANSITION_FROM_ANIMATION_OFFSET;
  }
  static isTransitionFromAnimation(t) {
    return t >= Ui.TRANSITION_FROM_ANIMATION_OFFSET;
  }
  dispose() {
    for (const t of this._layers.values())
      t && t.dispose();
    this._layers.clear(), this._immediateChanges = null;
  }
  setImmediateChanges(t) {
    this._immediateChanges = t;
  }
  isImmediateChange(t) {
    return !(!this._immediateChanges || this._immediateChanges.indexOf(t) === -1);
  }
  getStartFrame(t) {
    return this._randomStart ? Math.random() * this._frameCount : 0;
  }
  initialize(t) {
    if (t.randomStart && (this._randomStart = !0), t.layers)
      for (const e in t.layers) {
        const s = t.layers[e];
        if (!s) return !1;
        const r = parseInt(e), n = s.loopCount !== void 0 ? s.loopCount : 1, a = s.frameRepeat !== void 0 ? s.frameRepeat : 1, o = s.random !== void 0 && s.random !== 0;
        if (!this.addLayer(r, n, a, o, s)) return !1;
      }
    return !0;
  }
  addLayer(t, e, s, r, n) {
    const a = new Nit(e, s, r);
    if (n.frameSequences)
      for (const h in n.frameSequences) {
        const u = n.frameSequences[h];
        if (!u) continue;
        const c = u.loopCount !== void 0 ? u.loopCount : 1, l = u.random !== void 0 && u.random !== 0, _ = a.addFrameSequence(c, l);
        if (u.frames)
          for (const d in u.frames) {
            const f = u.frames[d];
            if (!f)
              return a.dispose(), !1;
            _.addFrame(f.id, f.x || 0, f.y || 0, f.randomX || 0, f.randomY || 0, this.readDirectionalOffsets(f));
          }
        _.initialize();
      }
    a.calculateLength(), this._layers.set(t, a);
    const o = a.frameCount;
    return o > this._frameCount && (this._frameCount = o), !0;
  }
  readDirectionalOffsets(t) {
    let e = null;
    if (t && t.offsets)
      for (const s in t.offsets) {
        const r = t.offsets[s];
        r && (e || (e = new GM()), e.setDirection(r.direction, r.x, r.y));
      }
    return e;
  }
  getFrame(t, e, s) {
    const r = this._layers.get(e);
    return r ? r.getFrame(t, s) : null;
  }
  getFrameFromSequence(t, e, s, r, n) {
    const a = this._layers.get(e);
    return a ? a.getFrameFromSequence(t, s, r, n) : null;
  }
};
Ui.TRANSITION_TO_ANIMATION_OFFSET = 1e6, Ui.TRANSITION_FROM_ANIMATION_OFFSET = 2e6, Ui.DEFAULT_FRAME_NUMBER = 0;
let xe = Ui;
const au = class au {
  constructor(t) {
    this._colors = [], this.createColors(t);
  }
  createColors(t) {
    if (t)
      for (let e = 0; e < t; e++) this._colors.push(au.DEFAULT_COLOR);
  }
  dispose() {
    this._colors = [];
  }
  getLayerColor(t) {
    const e = this._colors[t];
    return e || au.DEFAULT_COLOR;
  }
  setColorLayer(t, e) {
    this._colors[t] && (this._colors[t] = e);
  }
};
au.DEFAULT_COLOR = 16777215;
let Aa = au;
const Fe = class Fe {
  constructor() {
    this._tag = Fe.DEFAULT_TAG, this._blendMode = Fe.DEFAULT_BLEND_MODE, this._alpha = Fe.DEFAULT_ALPHA, this._ignoreMouse = Fe.DEFAULT_IGNORE_MOUSE, this._xOffset = Fe.DEFAULT_XOFFSET, this._yOffset = Fe.DEFAULT_YOFFSET, this._zOffset = Fe.DEFAULT_ZOFFSET;
  }
  setFromLayer(t) {
    t && (this._tag = t.tag, this._blendMode = t.blendMode, this._alpha = t.alpha, this._ignoreMouse = t.ignoreMouse, this._xOffset = t.xOffset, this._yOffset = t.yOffset, this._zOffset = t.zOffset);
  }
  get tag() {
    return this._tag;
  }
  set tag(t) {
    this._tag = t;
  }
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(t) {
    this._blendMode = t;
  }
  get alpha() {
    return this._alpha;
  }
  set alpha(t) {
    this._alpha = t;
  }
  get ignoreMouse() {
    return this._ignoreMouse;
  }
  set ignoreMouse(t) {
    this._ignoreMouse = t;
  }
  get xOffset() {
    return this._xOffset;
  }
  set xOffset(t) {
    this._xOffset = t;
  }
  get yOffset() {
    return this._yOffset;
  }
  set yOffset(t) {
    this._yOffset = t;
  }
  get zOffset() {
    return this._zOffset;
  }
  set zOffset(t) {
    this._zOffset = t;
  }
};
Fe.DEFAULT_COUNT = 0, Fe.DEFAULT_DIRECTION = 0, Fe.DEFAULT_TAG = "", Fe.DEFAULT_BLEND_MODE = "normal", Fe.DEFAULT_ALPHA = 255, Fe.DEFAULT_IGNORE_MOUSE = !1, Fe.DEFAULT_XOFFSET = 0, Fe.DEFAULT_YOFFSET = 0, Fe.DEFAULT_ZOFFSET = 0;
let Vt = Fe;
const qI = class qI {
  constructor(t) {
    this._layers = [], this.createLayers(t);
  }
  createLayers(t) {
    if (t)
      for (let e = 0; e < t; e++) this._layers.push(new Vt());
  }
  dispose() {
    this._layers = [];
  }
  setFromDirection(t) {
    if (!t) return;
    const e = this.layerCount;
    if (e === t.layerCount)
      for (let s = 0; s < e; s++) {
        const r = this.getLayer(s), n = t.getLayer(s);
        r && r.setFromLayer(n);
      }
  }
  getLayer(t) {
    const e = this._layers[t];
    return e || null;
  }
  getLayerTag(t) {
    const e = this.getLayer(t);
    return e ? e.tag : Vt.DEFAULT_TAG;
  }
  setLayerTag(t, e) {
    const s = this.getLayer(t);
    s && (s.tag = e);
  }
  getLayerBlendMode(t) {
    const e = this.getLayer(t);
    return e ? e.blendMode : Vt.DEFAULT_BLEND_MODE;
  }
  setLayerBlendMode(t, e) {
    const s = this.getLayer(t);
    s && (!e || !e.length || (s.blendMode = e));
  }
  getLayerAlpha(t) {
    const e = this.getLayer(t);
    return e ? e.alpha : Vt.DEFAULT_ALPHA;
  }
  setLayerAlpha(t, e) {
    const s = this.getLayer(t);
    s && (isNaN(e) || (s.alpha = e));
  }
  getLayerIgnoreMouse(t) {
    const e = this.getLayer(t);
    return e ? e.ignoreMouse : Vt.DEFAULT_IGNORE_MOUSE;
  }
  setLayerIgnoreMouse(t, e) {
    const s = this.getLayer(t);
    s && (s.ignoreMouse = e || !1);
  }
  getLayerXOffset(t) {
    const e = this.getLayer(t);
    return e ? e.xOffset : Vt.DEFAULT_XOFFSET;
  }
  setLayerXOffset(t, e) {
    const s = this.getLayer(t);
    s && (isNaN(e) || (s.xOffset = e));
  }
  getLayerYOffset(t) {
    const e = this.getLayer(t);
    return e ? e.yOffset : Vt.DEFAULT_YOFFSET;
  }
  setLayerYOffset(t, e) {
    const s = this.getLayer(t);
    s && (isNaN(e) || (s.yOffset = e));
  }
  getLayerZOffset(t) {
    const e = this.getLayer(t);
    return e ? e.zOffset : Vt.DEFAULT_ZOFFSET;
  }
  setLayerZOffset(t, e) {
    const s = this.getLayer(t);
    s && (isNaN(e) || (s.zOffset = e));
  }
  get layerCount() {
    return this._layers.length;
  }
};
qI.USE_DEFAULT_DIRECTION = -1;
let an = qI;
const ou = class ou {
  constructor(t, e) {
    this._layerCount = t < 0 ? 0 : t > ou.MAX_LAYERS ? ou.MAX_LAYERS : t, this._angle = e < 1 ? 1 : e > 360 ? 360 : e, this._defaultDirection = new an(this._layerCount), this._directions = /* @__PURE__ */ new Map(), this._colors = [], this._lastDirectionData = null, this._lastDirection = -1;
  }
  dispose() {
    this._defaultDirection && this._defaultDirection.dispose();
    for (const t of this._directions.values())
      t && t.dispose();
    for (const t of this._colors)
      t && t.dispose();
    this.reset();
  }
  reset() {
    this._defaultDirection = null, this._colors = [], this._lastDirectionData = null, this._lastDirection = -1, this._directions.clear();
  }
  processLayers(t) {
    return t ? this.setDirectionLayers(this._defaultDirection, t) : !1;
  }
  processDirections(t) {
    if (!t) return !1;
    for (const e in t) {
      const s = t[e];
      if (!s) continue;
      const r = parseInt(e);
      if (this._directions.get(r)) return !1;
      const n = new an(this._layerCount);
      n.setFromDirection(this._defaultDirection), this.setDirectionLayers(n, s.layers), this._directions.set(r, n), this._lastDirectionData = null, this._lastDirection = -1;
    }
    return !0;
  }
  processColors(t) {
    if (!t) return !1;
    for (const e in t) {
      const s = t[e];
      if (!s) continue;
      const r = parseInt(e);
      if (this._colors[r]) return !1;
      const n = new Aa(this._layerCount);
      for (const a in s.layers) {
        const o = s.layers[a];
        if (!o) continue;
        const h = parseInt(a), u = o.color;
        n.setColorLayer(h, u);
      }
      this._colors[r] = n;
    }
    return !0;
  }
  setDirectionLayers(t, e) {
    var s;
    if (!t || !e) return !1;
    for (const r in e) {
      const n = e[r];
      if (!n) continue;
      const a = parseInt(r);
      if (a < 0 || a >= this._layerCount) return !1;
      n.ink !== void 0 && t.setLayerBlendMode(a, (s = n.ink) == null ? void 0 : s.toLowerCase()), n.tag !== void 0 && t.setLayerTag(a, n.tag), n.alpha !== void 0 && t.setLayerAlpha(a, n.alpha), n.ignoreMouse !== void 0 && t.setLayerIgnoreMouse(a, n.ignoreMouse), n.x !== void 0 && t.setLayerXOffset(a, n.x), n.y !== void 0 && t.setLayerYOffset(a, n.y), n.z !== void 0 && t.setLayerZOffset(a, n.z / -1e3);
    }
    return !0;
  }
  getValidDirection(t) {
    if (this._directions.get(t)) return t;
    t = (t % 360 + 360) % 360;
    let s = -1, r = -1;
    for (const n of this._directions.keys()) {
      let a = (n * this._angle - t + 360) % 360;
      a > 180 && (a = 360 - a), (a < s || s < 0) && (s = a, r = n);
    }
    return r >= 0 ? Math.trunc(r) : 0;
  }
  getDirectionData(t) {
    if (t === this._lastDirection && this._lastDirectionData) return this._lastDirectionData;
    let e = this._directions.get(t);
    return e || (e = this._defaultDirection), this._lastDirection = t, this._lastDirectionData = e, this._lastDirectionData;
  }
  getLayerTag(t, e) {
    const s = this.getDirectionData(t);
    return s ? s.getLayerTag(e) : Vt.DEFAULT_TAG;
  }
  getLayerBlendMode(t, e) {
    const s = this.getDirectionData(t);
    return s ? s.getLayerBlendMode(e) : Vt.DEFAULT_BLEND_MODE;
  }
  getLayerAlpha(t, e) {
    const s = this.getDirectionData(t);
    return s ? s.getLayerAlpha(e) : Vt.DEFAULT_ALPHA;
  }
  getLayerColor(t, e) {
    const s = this._colors[e];
    return s ? s.getLayerColor(t) : Aa.DEFAULT_COLOR;
  }
  getLayerIgnoreMouse(t, e) {
    const s = this.getDirectionData(t);
    return s ? s.getLayerIgnoreMouse(e) : Vt.DEFAULT_IGNORE_MOUSE;
  }
  getLayerXOffset(t, e) {
    const s = this.getDirectionData(t);
    return s ? s.getLayerXOffset(e) : Vt.DEFAULT_XOFFSET;
  }
  getLayerYOffset(t, e) {
    const s = this.getDirectionData(t);
    return s ? s.getLayerYOffset(e) : Vt.DEFAULT_YOFFSET;
  }
  getLayerZOffset(t, e) {
    const s = this.getDirectionData(t);
    return s ? s.getLayerZOffset(e) : Vt.DEFAULT_ZOFFSET;
  }
  get layerCount() {
    return this._layerCount;
  }
};
ou.MAX_LAYERS = 26;
let kc = ou;
class zc extends kc {
  constructor(t, e) {
    super(t, e), this._animations = /* @__PURE__ */ new Map(), this._animationIds = [];
  }
  dispose() {
    super.dispose();
    for (const t of this._animations.values())
      t && t.dispose();
    this._animations.clear(), this._animationIds = [];
  }
  defineAnimations(t) {
    if (!t) return !0;
    for (const e in t) {
      const s = t[e];
      if (!s) return !1;
      let r = parseInt(e.split("_")[0]), n = !1;
      const a = s.transitionTo, o = s.transitionFrom;
      a !== void 0 && (r = xe.getTransitionToAnimationId(a), n = !0), o !== void 0 && (r = xe.getTransitionFromAnimationId(o), n = !0);
      const h = this.createAnimationData();
      if (!h.initialize(s))
        return h.dispose(), !1;
      const u = s.immediateChangeFrom;
      if (u !== void 0) {
        const c = u.split(","), l = [];
        for (const _ of c) {
          const d = parseInt(_);
          l.indexOf(d) === -1 && l.push(d);
        }
        h.setImmediateChanges(l);
      }
      this._animations.set(r, h), n || this._animationIds.push(r);
    }
    return !0;
  }
  createAnimationData() {
    return new xe();
  }
  hasAnimation(t) {
    return !!this._animations.get(t);
  }
  getAnimationCount() {
    return this._animationIds.length || 0;
  }
  getAnimationId(t) {
    const e = this.getAnimationCount();
    return t < 0 || e <= 0 ? 0 : this._animationIds[t % e];
  }
  isImmediateChange(t, e) {
    const s = this._animations.get(t);
    return s ? s.isImmediateChange(e) : !1;
  }
  getStartFrame(t, e) {
    const s = this._animations.get(t);
    return s ? s.getStartFrame(e) : 0;
  }
  getFrame(t, e, s, r) {
    const n = this._animations.get(t);
    return n ? n.getFrame(e, s, r) : null;
  }
  getFrameFromSequence(t, e, s, r, n, a) {
    const o = this._animations.get(t);
    return o ? o.getFrameFromSequence(e, s, r, n, a) : null;
  }
}
class BM {
  constructor() {
    this._animationId = -1, this._animationAfterTransitionId = 0, this._animationOver = !1, this._frameCounter = 0, this._frames = [], this._lastFramePlayed = [], this._animationPlayed = [], this._layerCount = 0;
  }
  get animationOver() {
    return this._animationOver;
  }
  set animationOver(t) {
    this._animationOver = t;
  }
  get frameCounter() {
    return this._frameCounter;
  }
  set frameCounter(t) {
    this._frameCounter = t;
  }
  get animationId() {
    return this._animationId;
  }
  set animationId(t) {
    t !== this._animationId && (this._animationId = t, this.resetAnimationFrames(!1));
  }
  get animationAfterTransitionId() {
    return this._animationAfterTransitionId;
  }
  set animationAfterTransitionId(t) {
    this._animationAfterTransitionId = t;
  }
  dispose() {
    this.recycleFrames(), this._frames = null, this._lastFramePlayed = null, this._animationPlayed = null;
  }
  setLayerCount(t) {
    this._layerCount = t, this.resetAnimationFrames();
  }
  resetAnimationFrames(t = !0) {
    (t || !this._frames) && (this.recycleFrames(), this._frames = []), this._lastFramePlayed = [], this._animationPlayed = [], this._animationOver = !1, this._frameCounter = 0;
    let e = 0;
    for (; e < this._layerCount; ) {
      if (t || this._frames.length <= e)
        this._frames[e] = null;
      else {
        const s = this._frames[e];
        s && (s.recycle(), this._frames[e] = fn.allocate(s.id, s.x, s.y, s.repeats, 0, s.isLastFrame));
      }
      this._lastFramePlayed[e] = !1, this._animationPlayed[e] = !1, e++;
    }
  }
  recycleFrames() {
    if (!(!this._frames || !this._frames.length))
      for (const t of this._frames)
        t && t.recycle();
  }
  getFrame(t) {
    return t < 0 || t >= this._layerCount ? null : this._frames[t];
  }
  setFrame(t, e) {
    if (t < 0 || t >= this._layerCount) return;
    const s = this._frames[t];
    s && s.recycle(), this._frames[t] = e;
  }
  getAnimationPlayed(t) {
    return t < 0 || t >= this._layerCount ? !0 : this._animationPlayed[t];
  }
  setAnimationPlayed(t, e) {
    t < 0 || t >= this._layerCount || (this._animationPlayed[t] = e);
  }
  getLastFramePlayed(t) {
    return t < 0 || t >= this._layerCount ? !0 : this._lastFramePlayed[t];
  }
  setLastFramePlayed(t, e) {
    t < 0 || t >= this._layerCount || (this._lastFramePlayed[t] = e);
  }
}
const Sd = class Sd extends zc {
  constructor() {
    super(...arguments), this._posturesToAnimations = /* @__PURE__ */ new Map(), this._gesturesToAnimations = /* @__PURE__ */ new Map(), this._defaultPosture = null;
  }
  processPostures(t) {
    if (!t || (t.defaultPosture && t.defaultPosture.length && (this._defaultPosture = t.defaultPosture), !t.postures)) return !1;
    for (const e of t.postures)
      this._posturesToAnimations.get(e.id) || (this._defaultPosture === null && (this._defaultPosture = e.id), this._posturesToAnimations.set(e.id, e.animationId));
    return this._posturesToAnimations.get(this._defaultPosture) !== void 0;
  }
  processGestures(t) {
    if (!t) return !1;
    for (const e of t)
      this._gesturesToAnimations.get(e.id) || this._gesturesToAnimations.set(e.id, e.animationId);
    return !0;
  }
  postureToAnimation(t) {
    return this._posturesToAnimations.get(t) || (t = this._defaultPosture), this._posturesToAnimations.get(t);
  }
  getGestureDisabled(t) {
    return t === "ded";
  }
  gestureToAnimation(t) {
    return this._gesturesToAnimations.get(t) ? this._gesturesToAnimations.get(t) : Sd.DEFAULT;
  }
  animationToPosture(t, e) {
    if (t >= 0 && t < this._posturesToAnimations.size) {
      const s = this._posturesToAnimations.keys();
      for (; ; ) {
        const r = s.next();
        if (r.done) return null;
        if (t <= 0) return r.value;
        --t;
      }
    }
    return e ? this._defaultPosture : null;
  }
  animationToGesture(t) {
    if (t >= 0 && t < this._gesturesToAnimations.size) {
      const e = this._gesturesToAnimations.keys();
      for (; ; ) {
        const s = e.next();
        if (s.done) return null;
        if (t <= 0) return s.value;
        --t;
      }
    }
    return null;
  }
  getGestureForAnimationId(t) {
    for (const e of this._gesturesToAnimations.keys())
      if (this._gesturesToAnimations.get(e) === t) return e;
    return null;
  }
  get totalPostures() {
    return this._posturesToAnimations.size;
  }
  get totalGestures() {
    return this._gesturesToAnimations.size;
  }
};
Sd.DEFAULT = -1;
let Fn = Sd;
class Uit {
  constructor(t, e) {
    this._width = t, this._height = e, this._heights = [], this._isNotStackable = [], this._isRoomTile = [];
    let s = t * e;
    for (; s > 0; )
      this._heights.push(0), this._isNotStackable.push(!1), this._isRoomTile.push(!1), s--;
  }
  dispose() {
    this._width = 0, this._height = 0, this._height = null, this._isNotStackable = null, this._isRoomTile = null;
  }
  validPosition(t, e) {
    return t >= 0 && t < this._width && e >= 0 && e < this._height;
  }
  getTileHeight(t, e) {
    return this.validPosition(t, e) ? this._heights[e * this._width + t] : 0;
  }
  setTileHeight(t, e, s) {
    this.validPosition(t, e) && (this._heights[e * this._width + t] = s);
  }
  setStackingBlocked(t, e, s) {
    this.validPosition(t, e) && (this._isNotStackable[e * this._width + t] = s);
  }
  setIsRoomTile(t, e, s) {
    this.validPosition(t, e) && (this._isRoomTile[e * this._width + t] = s);
  }
  validateLocation(t, e, s, r, n, a, o, h, u, c = -1) {
    let l = 0, _ = 0;
    if (!this.validPosition(t, e) || !this.validPosition(t + s - 1, e + r - 1)) return !1;
    (n < 0 || n >= this._width) && (n = 0), (a < 0 || a >= this._height) && (a = 0), o = Math.min(o, this._width - n), h = Math.min(h, this._height - a), c === -1 && (c = this.getTileHeight(t, e));
    let d = e;
    for (; d < e + r; ) {
      for (l = t; l < t + s; ) {
        if (l < n || l >= n + o || d < a || d >= a + h) {
          if (_ = d * this._width + l, u) {
            if (!this._isRoomTile[_]) return !1;
          } else if (this._isNotStackable[_] || !this._isRoomTile[_] || Math.abs(this._heights[_] - c) > 0.01) return !1;
        }
        l++;
      }
      d++;
    }
    return !0;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
}
const vs = class vs {
  constructor() {
    this._isDisposed = !1, this._scale = 64, this._heightMap = [], this._width = 0, this._height = 0, this._floorHeight = 0;
  }
  get disposed() {
    return this._isDisposed;
  }
  get scale() {
    return this._scale;
  }
  set scale(t) {
    this._scale = t;
  }
  dispose() {
    this.reset(), this._isDisposed = !0;
  }
  initialize(t, e, s) {
    if (t <= this._width && e <= this._height) {
      this._width = t, this._height = e, this._floorHeight = s;
      return;
    }
    this.reset();
    let r = 0;
    for (; r < e; ) {
      const n = [];
      this._heightMap.push(n);
      let a = 0;
      for (; a < t; )
        n.push(0), a++;
      r++;
    }
    this._width = t, this._height = e, this._floorHeight = s;
  }
  reset() {
    this._heightMap = [];
  }
  setHeight(t, e, s) {
    if (t < 0 || t >= this._width || e < 0 || e >= this._height) return !1;
    const r = this._heightMap[e];
    return r ? (r[t] = s, !0) : !1;
  }
  getHeight(t, e) {
    if (t < 0 || t >= this._width || e < 0 || e >= this._height) return 0;
    const s = this._heightMap[e];
    return s ? s[t] : 0;
  }
  getLocation(t, e, s, r, n) {
    if (t == 0 && e == 0) {
      t = this._width, e = this._height;
      const c = Math.round(this.scale / 10);
      if (n == vs.R) {
        let l = this._width - 1;
        for (; l >= 0; ) {
          let _ = 1;
          for (; _ < this._height; ) {
            if (this.getHeight(l, _) <= this._floorHeight) {
              _ - 1 < e && (t = l, e = _ - 1);
              break;
            }
            _++;
          }
          l--;
        }
        r = r + (this.scale / 4 - c / 2), s = s + this.scale / 2;
      } else {
        let l = this._height - 1;
        for (; l >= 0; ) {
          let _ = 1;
          for (; _ < this._width; ) {
            if (this.getHeight(_, l) <= this._floorHeight) {
              _ - 1 < t && (t = _ - 1, e = l);
              break;
            }
            _++;
          }
          l--;
        }
        r = r + (this.scale / 4 - c / 2), s = s - c;
      }
    }
    let a = t, o = e, h = this.getHeight(t, e);
    return n == vs.R ? (a = a + (s / (this._scale / 2) - 0.5), o = o + 0.5, h = h - (r - s / 2) / (this._scale / 2)) : (o = o + ((this._scale / 2 - s) / (this._scale / 2) - 0.5), a = a + 0.5, h = h - (r - (this._scale / 2 - s) / 2) / (this._scale / 2)), new v(a, o, h);
  }
  getLocationOldFormat(t, e, s) {
    let r, n, a = 0, o = 0;
    n = Math.ceil(t), a = n - t;
    let h, u, c, l = 0;
    for (r = 0; r < this._width; ) {
      if (n >= 0 && n < this._height) {
        if (this.getHeight(r, n) <= this._floorHeight) {
          h = r - 1, u = n, o = r, s = vs.L;
          break;
        }
        if (this.getHeight(r, n + 1) <= this._floorHeight) {
          h = r, u = n, o = u - t, s = vs.R;
          break;
        }
      }
      n++, r++;
    }
    const _ = this.scale / 2 * a;
    let d = -o * this.scale / 2;
    return d = d + -e * 18 / 32 * this.scale / 2, l = this.getHeight(h, u), c = l * this.scale / 2 + d, s == vs.R ? c = c + a * this.scale / 4 : c = c + (1 - a) * this.scale / 4, this.getLocation(h, u, _, c, s);
  }
  getOldLocation(t, e) {
    if (t == null)
      return null;
    let s = 0, r = 0, n = 0, a = 0, o = "", h = 0;
    if (e == 90)
      s = Math.floor(t.x - 0.5), r = Math.floor(t.y + 0.5), h = this.getHeight(s, r), n = this._scale / 2 - (t.y - r + 0.5) * (this._scale / 2), a = (h - t.z) * (this._scale / 2) + (this._scale / 2 - n) / 2, o = vs.L;
    else if (e == 180)
      s = Math.floor(t.x + 0.5), r = Math.floor(t.y - 0.5), h = this.getHeight(s, r), n = (t.x + 0.5 - s) * (this._scale / 2), a = (h - t.z) * (this._scale / 2) + n / 2, o = vs.R;
    else
      return null;
    return [s, r, n, a, o];
  }
  getOldLocationString(t, e) {
    const s = this.getOldLocation(t, e);
    if (s == null)
      return null;
    const r = Math.trunc(s[0]), n = Math.trunc(s[1]), a = Math.trunc(s[2]), o = Math.trunc(s[3]), h = s[4];
    return ":w=" + r + "," + n + " l=" + a + "," + o + " " + h;
  }
  getDirection(t) {
    return t == vs.R ? 180 : 90;
  }
  getFloorAltitude(t, e) {
    const s = this.getHeight(t, e), r = s + 1;
    return s + (Math.trunc(this.getHeight(t - 1, e - 1)) == r || Math.trunc(this.getHeight(t, e - 1)) == r || Math.trunc(this.getHeight(t + 1, e - 1)) == r || Math.trunc(this.getHeight(t - 1, e)) == r || Math.trunc(this.getHeight(t + 1, e)) == r || Math.trunc(this.getHeight(t - 1, e + 1)) == r || Math.trunc(this.getHeight(t, e + 1)) == r || Math.trunc(this.getHeight(t + 1, e + 1)) == r ? 0.5 : 0);
  }
  isRoomTile(t, e) {
    return t >= 0 && t < this._width && e >= 0 && e < this._height && this._heightMap[e][t] >= 0;
  }
};
vs.DEFAULT_SCALE = 32, vs.L = "l", vs.R = "r";
let Gu = vs;
const kt = class kt {
  constructor(t) {
    this._roomEngine = null, this._state = kt.NOT_ACTIVE, this._tileXInit = 0, this._tileYInit = 0, this._tileXEnd = 0, this._tileYEnd = 0, this._highlightRootX = 0, this._highlightRootY = 0, this._highlightWidth = 0, this._highlightHeight = 0, this._highlightType = kt.HIGHLIGHT_BRIGHTEN, this._roomEngine = t, x().addEventListener(lt.ADDED, (n) => {
      if (this._state === kt.NOT_ACTIVE || n.roomId !== this._roomEngine.activeRoomId || n.category !== 10 && n.category !== 20) return;
      const a = this._roomEngine.getRoomObject(n.roomId, n.objectId, n.category);
      a.visualization instanceof Xi && (a.visualization.lookThrough = !0);
    });
    const e = new Sh();
    e.matrix = [
      1.5,
      0,
      0,
      0,
      0,
      1.5,
      0,
      0,
      0,
      0,
      1.5,
      0,
      0,
      0,
      0,
      1,
      0,
      0.0784,
      0.0784,
      0
    ];
    const s = new Sh();
    s.matrix = [
      1.05,
      0,
      0,
      0,
      0,
      1.3,
      0,
      0,
      0,
      0,
      1.8,
      0,
      0,
      0,
      0,
      1,
      0,
      0.0314,
      0.0784,
      0
    ];
    const r = new Sh();
    r.matrix = [
      0.55,
      0,
      0,
      0,
      0,
      0.55,
      0,
      0,
      0,
      0,
      0.55,
      0,
      0,
      0,
      0,
      1,
      -0.0392,
      -0.0392,
      -0.0392,
      0
    ], kt.HIGHLIGHT_FILTERS[kt.HIGHLIGHT_DARKEN] = r, kt.HIGHLIGHT_FILTERS[kt.HIGHLIGHT_BRIGHTEN] = e, kt.HIGHLIGHT_FILTERS[kt.HIGHLIGHT_BLUE] = s;
  }
  getAllFurniture() {
    return this._roomEngine.getRoomObjects(this._roomEngine.activeRoomId, 20).concat(this._roomEngine.getRoomObjects(this._roomEngine.activeRoomId, 10));
  }
  startSelecting() {
    this._state === kt.NOT_SELECTING_AREA && (this.clearHighlightSilent(), this._state = kt.AWAITING_MOUSE_DOWN, this._roomEngine.moveBlocked = !0);
  }
  handleTileMouseEvent(t) {
    let e = this._state === kt.AWAITING_MOUSE_DOWN && t.type == at.MOUSE_DOWN;
    if (t.shiftKey && this._state === kt.NOT_SELECTING_AREA && t.type == at.MOUSE_DOWN && (this.startSelecting(), e = !0), e) {
      this._state = kt.SELECTING, this._tileXInit = t.tileXAsInt, this._tileYInit = t.tileYAsInt, this._tileXEnd = t.tileXAsInt, this._tileYEnd = t.tileYAsInt, this.setHighlight(this._tileXInit, this._tileYInit, 1, 1);
      return;
    }
    if (this._state === kt.SELECTING && t.type === at.MOUSE_MOVE && (t.tileXAsInt !== this._tileXEnd || t.tileYAsInt !== this._tileYEnd)) {
      let s = 0, r = 0, n = 0, a = 0;
      this._tileXEnd = t.tileXAsInt, this._tileYEnd = t.tileYAsInt, this._tileXEnd > this._tileXInit ? (s = this._tileXInit, n = this._tileXEnd - this._tileXInit + 1) : (s = this._tileXEnd, n = this._tileXInit - this._tileXEnd + 1), this._tileYEnd > this._tileYInit ? (r = this._tileYInit, a = this._tileYEnd - this._tileYInit + 1) : (r = this._tileYEnd, a = this._tileYInit - this._tileYEnd + 1), this.setHighlight(s, r, n, a);
    }
  }
  finishSelecting() {
    return this._state !== kt.SELECTING ? !1 : (this._state = kt.NOT_SELECTING_AREA, this._roomEngine.moveBlocked = !1, this._callback && this._callback(this._highlightRootX, this._highlightRootY, this._highlightWidth, this._highlightHeight), !0);
  }
  clearHighlightSilent() {
    var e;
    const t = this._roomEngine.getRoomObject(this._roomEngine.activeRoomId, -1, 0);
    t && ((e = t.visualization) == null || e.clearHighlightArea());
  }
  clearHighlight() {
    this._state !== kt.NOT_ACTIVE && (this.clearHighlightSilent(), this._state = kt.NOT_SELECTING_AREA, this._roomEngine.moveBlocked = !1, this._callback && this._callback(0, 0, 0, 0));
  }
  setHighlight(t, e, s, r) {
    var a;
    if (this._state === kt.NOT_ACTIVE) return;
    this._highlightRootX = t, this._highlightRootY = e, this._highlightWidth = s, this._highlightHeight = r;
    const n = this._roomEngine.getRoomObject(this._roomEngine.activeRoomId, -1, 0);
    n && ((a = n.visualization) == null || a.initializeHighlightArea(t, e, s, r, kt.HIGHLIGHT_FILTERS[this._highlightType]));
  }
  activate(t, e) {
    if (this._state !== kt.NOT_ACTIVE) return !1;
    this._callback = t, this._highlightType = e;
    for (const s of this.getAllFurniture()) {
      const r = s.visualization;
      r && (r.lookThrough = !0);
    }
    return this._state = kt.NOT_SELECTING_AREA, !0;
  }
  deactivate() {
    if (this._state !== kt.NOT_ACTIVE) {
      this._callback = null;
      for (const t of this.getAllFurniture()) {
        const e = t.visualization;
        e && (e.lookThrough = !1);
      }
      this.clearHighlight(), this._state = kt.NOT_ACTIVE;
    }
  }
  get areaSelectionState() {
    return this._state;
  }
};
kt.NOT_ACTIVE = 0, kt.NOT_SELECTING_AREA = 1, kt.AWAITING_MOUSE_DOWN = 2, kt.SELECTING = 3, kt.HIGHLIGHT_DARKEN = "highlight_darken", kt.HIGHLIGHT_BRIGHTEN = "highlight_brighten", kt.HIGHLIGHT_BLUE = "highlight_blue", kt.HIGHLIGHT_FILTERS = {};
let bh = kt;
const Ad = class Ad {
  constructor() {
    this._targetId = -1, this._targetCategory = -2, this._targetLoc = null, this._moveDistance = 0, this._previousMoveSpeed = 0, this._maintainPreviousMoveSpeed = !1, this._currentLoc = null, this._limitedLocX = !1, this._limitedLocY = !1, this._centeredLocX = !1, this._centeredLocY = !1, this._screenWd = 0, this._screenHt = 0, this._scale = 0, this._roomWd = 0, this._roomHt = 0, this._geometryUpdateId = -1, this._scaleChanged = !1, this._targetObjectLoc = new v();
  }
  get location() {
    return this._currentLoc;
  }
  get targetId() {
    return this._targetId;
  }
  set targetId(t) {
    this._targetId = t;
  }
  get targetCategory() {
    return this._targetCategory;
  }
  set targetCategory(t) {
    this._targetCategory = t;
  }
  get targetObjectLoc() {
    return this._targetObjectLoc;
  }
  set targetObjectLoc(t) {
    this._targetObjectLoc.assign(t);
  }
  get limitedLocationX() {
    return this._limitedLocX;
  }
  set limitedLocationX(t) {
    this._limitedLocX = t;
  }
  get limitedLocationY() {
    return this._limitedLocY;
  }
  set limitedLocationY(t) {
    this._limitedLocY = t;
  }
  get centeredLocX() {
    return this._centeredLocX;
  }
  set centeredLocX(t) {
    this._centeredLocX = t;
  }
  get centeredLocY() {
    return this._centeredLocY;
  }
  set centeredLocY(t) {
    this._centeredLocY = t;
  }
  get screenWd() {
    return this._screenWd;
  }
  set screenWd(t) {
    this._screenWd = t;
  }
  get screenHt() {
    return this._screenHt;
  }
  set screenHt(t) {
    this._screenHt = t;
  }
  get scale() {
    return this._scale;
  }
  set scale(t) {
    this._scale != t && (this._scale = t, this._scaleChanged = !0);
  }
  get roomWd() {
    return this._roomWd;
  }
  set roomWd(t) {
    this._roomWd = t;
  }
  get roomHt() {
    return this._roomHt;
  }
  set roomHt(t) {
    this._roomHt = t;
  }
  get geometryUpdateId() {
    return this._geometryUpdateId;
  }
  set geometryUpdateId(t) {
    this._geometryUpdateId = t;
  }
  get isMoving() {
    return this._targetLoc != null && this._currentLoc != null;
  }
  set target(t) {
    let e;
    this._targetLoc == null && (this._targetLoc = new v()), (this._targetLoc.x != t.x || this._targetLoc.y != t.y || this._targetLoc.z != t.z) && (this._targetLoc.assign(t), e = v.dif(this._targetLoc, this._currentLoc), this._moveDistance = e.length, this._maintainPreviousMoveSpeed = !0);
  }
  dispose() {
    this._targetLoc = null, this._currentLoc = null;
  }
  initializeLocation(t) {
    this._currentLoc == null && (this._currentLoc = new v(), this._currentLoc.assign(t));
  }
  resetLocation(t) {
    this._currentLoc == null && (this._currentLoc = new v()), this._currentLoc.assign(t);
  }
  update(t, e) {
    let s, r, n, a, o;
    if (this._followDuration > 0 && this._targetLoc != null && this._currentLoc != null) {
      if (this._scaleChanged) {
        this._scaleChanged = !1, this._currentLoc = this._targetLoc, this._targetLoc = null;
        return;
      }
      s = v.dif(this._targetLoc, this._currentLoc), s.length > this._moveDistance && (this._moveDistance = s.length), s.length <= e ? (this._currentLoc = this._targetLoc, this._targetLoc = null, this._previousMoveSpeed = 0) : (r = Math.sin(Math.PI * s.length / this._moveDistance), n = e * 0.5, a = this._moveDistance / Ad.MOVE_SPEED_DENOMINATOR, o = n + (a - n) * r, this._maintainPreviousMoveSpeed && (o < this._previousMoveSpeed ? (o = this._previousMoveSpeed, o > s.length && (o = s.length)) : this._maintainPreviousMoveSpeed = !1), this._previousMoveSpeed = o, s.divide(s.length), s.multiply(o), this._currentLoc = v.sum(this._currentLoc, s));
    }
  }
  reset() {
    this._geometryUpdateId = -1;
  }
  activateFollowing(t) {
    this._followDuration = t;
  }
};
Ad.MOVE_SPEED_DENOMINATOR = 12;
let wE = Ad;
class Dit {
  constructor(t, e) {
    this._roomId = t, this._data = e, this._floorType = null, this._wallType = null, this._landscapeType = null;
  }
  get roomId() {
    return this._roomId;
  }
  get data() {
    return this._data;
  }
  get floorType() {
    return this._floorType;
  }
  set floorType(t) {
    this._floorType = t;
  }
  get wallType() {
    return this._wallType;
  }
  set wallType(t) {
    this._wallType = t;
  }
  get landscapeType() {
    return this._landscapeType;
  }
  set landscapeType(t) {
    this._landscapeType = t;
  }
}
const pt = class pt {
  static init(t, e) {
    pt._currentDelta = 0, pt._startDelayMs = t, pt._effectDurationMs = e, pt._initializationTimeMs = Nt(), pt._state = pt.STATE_START_DELAY;
  }
  static turnVisualizationOn() {
    if (pt._state === pt.STATE_NOT_INITIALIZED || pt._state === pt.STATE_OVER) return;
    const t = Nt() - pt._initializationTimeMs;
    if (t > pt._startDelayMs + pt._effectDurationMs) {
      pt._state = pt.STATE_OVER;
      return;
    }
    if (pt._visualizationOn = !0, t < pt._startDelayMs) {
      pt._state = pt.STATE_START_DELAY;
      return;
    }
    pt._state = pt.STATE_RUNNING, pt._currentDelta = (t - pt._startDelayMs) / pt._effectDurationMs;
  }
  static turnVisualizationOff() {
    pt._visualizationOn = !1;
  }
  static isVisualizationOn() {
    return pt._visualizationOn && pt.isRunning();
  }
  static isRunning() {
    return pt._state === pt.STATE_START_DELAY || pt._state === pt.STATE_RUNNING;
  }
  static getDelta(t = 0, e = 1) {
    return Math.min(Math.max(pt._currentDelta, t), e);
  }
  static get totalRunningTime() {
    return pt._startDelayMs + pt._effectDurationMs;
  }
};
pt.STATE_NOT_INITIALIZED = 0, pt.STATE_START_DELAY = 1, pt.STATE_RUNNING = 2, pt.STATE_OVER = 3, pt._state = pt.STATE_NOT_INITIALIZED, pt._visualizationOn = !1, pt._currentDelta = 0, pt._initializationTimeMs = 0, pt._startDelayMs = 20 * 1e3, pt._effectDurationMs = 2e3;
let zi = pt;
class Qf {
  constructor(t, e, s, r, n, a, o, h = NaN, u = -1, c = 0, l = 0, _ = "", d = !0, f = !0, p = -1) {
    this._id = t, this._typeId = e, this._type = s, this._state = a, this._data = o, this._extra = h, this._expiryTime = u, this._usagePolicy = c, this._ownerId = l, this._ownerName = _, this._synchronized = d, this._realRoomObject = f, this._sizeZ = p, this._location = new v(), this._direction = new v(), this._location.assign(r), this._direction.assign(n);
  }
  get id() {
    return this._id;
  }
  get typeId() {
    return this._typeId;
  }
  get type() {
    return this._type;
  }
  get location() {
    return this._location;
  }
  get direction() {
    return this._direction;
  }
  get state() {
    return this._state;
  }
  get data() {
    return this._data;
  }
  get extra() {
    return this._extra;
  }
  get expiryTime() {
    return this._expiryTime;
  }
  get usagePolicy() {
    return this._usagePolicy;
  }
  get ownerId() {
    return this._ownerId;
  }
  get ownerName() {
    return this._ownerName;
  }
  get synchronized() {
    return this._synchronized;
  }
  get realRoomObject() {
    return this._realRoomObject;
  }
  get sizeZ() {
    return this._sizeZ;
  }
}
const Di = class Di {
  constructor(t, e, s, r = null) {
    this._updateId = 0, this._scale = 1, this._x_scale = 1, this._y_scale = 1, this._z_scale = 1, this._x_scale_internal = 1, this._y_scale_internal = 1, this._z_scale_internal = 1, this._clipNear = -500, this._clipFar = 500, this._displacements = null, this.scale = t, this._x = new v(), this._y = new v(), this._z = new v(), this._directionAxis = new v(), this._location = new v(), this._direction = new v(), this._depth = new v(), this._x_scale_internal = 1, this._y_scale_internal = 1, this.x_scale = 1, this.y_scale = 1, this._z_scale_internal = Math.sqrt(1 / 2) / Math.sqrt(3 / 4), this.z_scale = 1, this.location = new v(s.x, s.y, s.z), this.direction = new v(e.x, e.y, e.z), r != null ? this.setDepthVector(r) : this.setDepthVector(e), this._displacements = /* @__PURE__ */ new Map();
  }
  static getIntersectionVector(t, e, s, r) {
    const n = v.dotProduct(e, r);
    if (Math.abs(n) < 1e-5)
      return null;
    const a = v.dif(t, s), o = -v.dotProduct(r, a) / n;
    return v.sum(t, v.product(e, o));
  }
  get updateId() {
    return this._updateId;
  }
  get scale() {
    return this._scale / Math.sqrt(0.5);
  }
  set scale(t) {
    t <= 1 && (t = 1), t = t * Math.sqrt(0.5), t != this._scale && (this._scale = t, this._updateId++);
  }
  get directionAxis() {
    return this._directionAxis;
  }
  get location() {
    return this._location.assign(this._loc), this._location.x = this._location.x * this._x_scale, this._location.y = this._location.y * this._y_scale, this._location.z = this._location.z * this._z_scale, this._location;
  }
  set location(t) {
    if (t == null)
      return;
    this._loc == null && (this._loc = new v());
    const e = this._loc.x, s = this._loc.y, r = this._loc.z;
    this._loc.assign(t), this._loc.x = this._loc.x / this._x_scale, this._loc.y = this._loc.y / this._y_scale, this._loc.z = this._loc.z / this._z_scale, (this._loc.x != e || this._loc.y != s || this._loc.z != r) && this._updateId++;
  }
  get direction() {
    return this._direction;
  }
  set direction(t) {
    let e, s, r, n, a;
    if (t == null)
      return;
    this._dir == null && (this._dir = new v());
    const o = this._dir.x, h = this._dir.y, u = this._dir.z;
    this._dir.assign(t), this._direction.assign(t), (this._dir.x != o || this._dir.y != h || this._dir.z != u) && this._updateId++;
    const c = new v(0, 1, 0), l = new v(0, 0, 1), _ = new v(1, 0, 0), d = t.x / 180 * Math.PI, f = t.y / 180 * Math.PI, p = t.z / 180 * Math.PI, g = Math.cos(d), m = Math.sin(d), O = v.sum(v.product(c, g), v.product(_, -m)), y = new v(l.x, l.y, l.z), C = v.sum(v.product(c, m), v.product(_, g)), b = Math.cos(f), D = Math.sin(f), P = new v(O.x, O.y, O.z), F = v.sum(v.product(y, b), v.product(C, D)), M = v.sum(v.product(y, -D), v.product(C, b));
    p != 0 ? (e = Math.cos(p), s = Math.sin(p), r = v.sum(v.product(P, e), v.product(F, s)), n = v.sum(v.product(P, -s), v.product(F, e)), a = new v(M.x, M.y, M.z), this._x.assign(r), this._y.assign(n), this._z.assign(a), this._directionAxis.assign(this._z)) : (this._x.assign(P), this._y.assign(F), this._z.assign(M), this._directionAxis.assign(this._z));
  }
  set x_scale(t) {
    this._x_scale != t * this._x_scale_internal && (this._x_scale = t * this._x_scale_internal, this._updateId++);
  }
  set y_scale(t) {
    this._y_scale != t * this._y_scale_internal && (this._y_scale = t * this._y_scale_internal, this._updateId++);
  }
  set z_scale(t) {
    this._z_scale != t * this._z_scale_internal && (this._z_scale = t * this._z_scale_internal, this._updateId++);
  }
  dispose() {
    this._x = null, this._y = null, this._z = null, this._loc = null, this._dir = null, this._directionAxis = null, this._location = null, this._displacements != null && (this._displacements.clear(), this._displacements = null);
  }
  setDisplacement(t, e) {
    let s, r;
    t == null || e == null || this._displacements != null && (s = Math.trunc(Math.round(t.x)) + "_" + Math.trunc(Math.round(t.y)) + "_" + Math.trunc(Math.round(t.z)), this._displacements.delete(s), r = new v(), r.assign(e), this._displacements.set(s, r), this._updateId++);
  }
  getDisplacenent(t) {
    let e;
    return this._displacements != null ? (e = Math.trunc(Math.round(t.x)) + "_" + Math.trunc(Math.round(t.y)) + "_" + Math.trunc(Math.round(t.z)), this._displacements.get(e)) : null;
  }
  setDepthVector(t) {
    let e, s, r;
    const n = new v(0, 1, 0), a = new v(0, 0, 1), o = new v(1, 0, 0), h = t.x / 180 * Math.PI, u = t.y / 180 * Math.PI, c = t.z / 180 * Math.PI, l = Math.cos(h), _ = Math.sin(h), d = v.sum(v.product(n, l), v.product(o, -_)), f = new v(a.x, a.y, a.z), p = v.sum(v.product(n, _), v.product(o, l)), g = Math.cos(u), m = Math.sin(u), O = new v(d.x, d.y, d.z), y = v.sum(v.product(f, g), v.product(p, m)), C = v.sum(v.product(f, -m), v.product(p, g));
    c != 0 ? (e = Math.cos(c), s = Math.sin(c), v.sum(v.product(O, e), v.product(y, s)), v.sum(v.product(O, -s), v.product(y, e)), r = new v(C.x, C.y, C.z), this._depth.assign(r)) : this._depth.assign(C), this._updateId++;
  }
  adjustLocation(t, e) {
    if (t == null || this._z == null)
      return;
    const s = v.product(this._z, -e), r = new v(t.x + s.x, t.y + s.y, t.z + s.z);
    this.location = r;
  }
  getCoordinatePosition(t) {
    if (t == null)
      return null;
    const e = v.scalarProjection(t, this._x), s = v.scalarProjection(t, this._y), r = v.scalarProjection(t, this._z);
    return new v(e, s, r);
  }
  getScreenPosition(t) {
    let e = v.dif(t, this._loc);
    e.x = e.x * this._x_scale, e.y = e.y * this._y_scale, e.z = e.z * this._z_scale;
    let s = v.scalarProjection(e, this._depth);
    if (s < this._clipNear || s > this._clipFar)
      return null;
    let r = v.scalarProjection(e, this._x), n = -v.scalarProjection(e, this._y);
    r = r * this._scale, n = n * this._scale;
    const a = this.getDisplacenent(t);
    return a != null && (e = v.dif(t, this._loc), e.add(a), e.x = e.x * this._x_scale, e.y = e.y * this._y_scale, e.z = e.z * this._z_scale, s = v.scalarProjection(e, this._depth)), e.x = r, e.y = n, e.z = s, e;
  }
  getScreenPoint(t) {
    const e = this.getScreenPosition(t);
    return e == null ? null : new st(e.x, e.y);
  }
  getPlanePosition(t, e, s, r) {
    let n, a;
    const o = t.x / this._scale, h = -t.y / this._scale, u = v.product(this._x, o);
    u.add(v.product(this._y, h));
    const c = new v(this._loc.x * this._x_scale, this._loc.y * this._y_scale, this._loc.z * this._z_scale);
    c.add(u);
    const l = this._z, _ = new v(e.x * this._x_scale, e.y * this._y_scale, e.z * this._z_scale), d = new v(s.x * this._x_scale, s.y * this._y_scale, s.z * this._z_scale), f = new v(r.x * this._x_scale, r.y * this._y_scale, r.z * this._z_scale), p = v.crossProduct(d, f), g = new v();
    return g.assign(Di.getIntersectionVector(c, l, _, p)), g != null ? (g.subtract(_), n = v.scalarProjection(g, s) / d.length * s.length, a = v.scalarProjection(g, r) / f.length * r.length, new st(n, a)) : null;
  }
  performZoom() {
    this.isZoomedIn() ? this.scale = Di.SCALE_ZOOMED_OUT : this.scale = Di.SCALE_ZOOMED_IN;
  }
  isZoomedIn() {
    return this.scale == Di.SCALE_ZOOMED_IN;
  }
  performZoomOut() {
    this.scale = Di.SCALE_ZOOMED_OUT;
  }
  performZoomIn() {
    this.scale = Di.SCALE_ZOOMED_IN;
  }
};
Di.SCALE_ZOOMED_IN = 64, Di.SCALE_ZOOMED_OUT = 32;
let $s = Di;
class Lit {
  constructor(t, e) {
    this._tileObjectMap = /* @__PURE__ */ new Map();
    let s = 0;
    for (; s < e; )
      this._tileObjectMap.set(s, /* @__PURE__ */ new Map()), s++;
    this._width = t, this._height = e;
  }
  clear() {
    for (const t of this._tileObjectMap.values())
      t && t.clear();
    this._tileObjectMap.clear();
  }
  populate(t) {
    this.clear();
    for (const e of t) this.addRoomObject(e);
  }
  dispose() {
    this._tileObjectMap = null, this._width = 0, this._height = 0;
  }
  getObjectIntTile(t, e) {
    if (t >= 0 && t < this._width && e >= 0 && e < this._height) {
      const s = this._tileObjectMap.get(e);
      if (s) return s.get(t);
    }
    return null;
  }
  setObjectInTile(t, e, s) {
    if (!s.isReady) {
      rt.log("Assigning non initialized object to tile object map!");
      return;
    }
    if (t >= 0 && t < this._width && e >= 0 && e < this._height) {
      const r = this._tileObjectMap.get(e);
      r && r.set(t, s);
    }
  }
  addRoomObject(t) {
    if (!t || !t.model || !t.isReady) return;
    const e = t.getLocation(), s = t.getDirection();
    if (!e || !s) return;
    let r = t.model.getValue(I.FURNITURE_SIZE_X), n = t.model.getValue(I.FURNITURE_SIZE_Y);
    r < 1 && (r = 1), n < 1 && (n = 1);
    const a = Math.trunc(s.x + 45) % 360 / 90;
    (a === 1 || a === 3) && ([r, n] = [n, r]);
    let o = e.y;
    for (; o < e.y + n; ) {
      let h = e.x;
      for (; h < e.x + r; ) {
        const u = this.getObjectIntTile(h, o);
        (!u || u !== t && u.getLocation().z <= e.z) && this.setObjectInTile(h, o, t), h++;
      }
      o++;
    }
  }
}
class Fit {
  constructor(t) {
    this._roomId = t, this._modelName = null, this._legacyGeometry = new Gu(), this._tileObjectMap = null, this._roomCamera = new wE(), this._selectedObject = null, this._placedObject = null, this._furnitureStackingHeightMap = null, this._floorStack = /* @__PURE__ */ new Map(), this._wallStack = /* @__PURE__ */ new Map(), this._mouseButtonCursorOwners = [];
  }
  dispose() {
  }
  setModelName(t) {
    this._modelName = t;
  }
  setSelectedObject(t) {
    this._selectedObject && this._selectedObject.dispose(), this._selectedObject = t;
  }
  setPlacedObject(t) {
    this._placedObject && this._placedObject.dispose(), this._placedObject = t;
  }
  setFurnitureStackingHeightMap(t) {
    this._furnitureStackingHeightMap && this._furnitureStackingHeightMap.dispose(), this._furnitureStackingHeightMap = t, this._tileObjectMap && this._tileObjectMap.dispose(), this._furnitureStackingHeightMap && (this._tileObjectMap = new Lit(this._furnitureStackingHeightMap.width, this._furnitureStackingHeightMap.height));
  }
  addPendingFurnitureFloor(t) {
    t && (this._floorStack.delete(t.id), this._floorStack.set(t.id, t));
  }
  removePendingFunitureFloor(t) {
    const e = this._floorStack.get(t);
    return e ? (this._floorStack.delete(t), e) : null;
  }
  getPendingFurnitureFloor(t) {
    const e = this._floorStack.get(t);
    return e ? (this._floorStack.delete(t), e) : null;
  }
  getNextPendingFurnitureFloor() {
    if (!this._floorStack.size) return null;
    const t = this._floorStack.keys();
    return this.getPendingFurnitureFloor(t.next().value);
  }
  addPendingFurnitureWall(t) {
    t && (this._wallStack.delete(t.id), this._wallStack.set(t.id, t));
  }
  removePendingFurnitureWall(t) {
    const e = this._wallStack.get(t);
    return e ? (this._wallStack.delete(t), e) : null;
  }
  getPendingFurnitureWall(t) {
    const e = this._wallStack.get(t);
    return e ? (this._wallStack.delete(t), e) : null;
  }
  getNextPendingFurnitureWall() {
    if (!this._wallStack.size) return null;
    const t = this._wallStack.keys();
    return this.getPendingFurnitureWall(t.next().value);
  }
  addButtonMouseCursorOwner(t) {
    return this._mouseButtonCursorOwners.indexOf(t) === -1 ? (this._mouseButtonCursorOwners.push(t), !0) : !1;
  }
  removeButtonMouseCursorOwner(t) {
    const e = this._mouseButtonCursorOwners.indexOf(t);
    return e > -1 ? (this._mouseButtonCursorOwners.splice(e, 1), !0) : !1;
  }
  hasButtonMouseCursorOwners() {
    return this._mouseButtonCursorOwners.length > 0;
  }
  get roomId() {
    return this._roomId;
  }
  get modelName() {
    return this._modelName;
  }
  get legacyGeometry() {
    return this._legacyGeometry;
  }
  get tileObjectMap() {
    return this._tileObjectMap;
  }
  get roomCamera() {
    return this._roomCamera;
  }
  get selectedObject() {
    return this._selectedObject;
  }
  get placedObject() {
    return this._placedObject;
  }
  get furnitureStackingHeightMap() {
    return this._furnitureStackingHeightMap;
  }
}
class wit {
  constructor(t, e) {
    this._object = t, this._groupBadge = e;
  }
  get object() {
    return this._object;
  }
  get groupBadge() {
    return this._groupBadge;
  }
}
const Hs = class Hs {
  static init(t, e) {
    this._SafeStr_4513 = 0, this._SafeStr_4515 = t, this._SafeStr_4516 = e, this._SafeStr_4514 = Nt(), this._SafeStr_448 = 1;
  }
  static turnVisualizationOn() {
    if (this._SafeStr_448 === 0 || this._SafeStr_448 === 3) return;
    this._SafeStr_4524 || (this._SafeStr_4524 = setTimeout(() => this.turnVisualizationOff(), this._SafeStr_4516));
    const t = Nt() - this._SafeStr_4514;
    if (t > this._SafeStr_4515 + this._SafeStr_4516) {
      this._SafeStr_448 = 3;
      return;
    }
    if (this._SafeStr_4512 = !0, t < this._SafeStr_4515) {
      this._SafeStr_448 = 1;
      return;
    }
    this._SafeStr_448 = 2, this._SafeStr_4513 = (t - this._SafeStr_4515) / this._SafeStr_4516;
  }
  static turnVisualizationOff() {
    this._SafeStr_4512 = !1, clearTimeout(this._SafeStr_4524), this._SafeStr_4524 = null;
  }
  static isVisualizationOn() {
    return this._SafeStr_4512 && this.isRunning();
  }
  static isRunning() {
    return this._SafeStr_448 === 1 || this._SafeStr_448 === 2;
  }
};
Hs.STATE_NOT_INITIALIZED = 0, Hs.STATE_START_DELAY = 1, Hs.STATE_RUNNING = 2, Hs.STATE_OVER = 3, Hs._SafeStr_448 = 0, Hs._SafeStr_4512 = !1, Hs._SafeStr_4513 = 0, Hs._SafeStr_4514 = 0, Hs._SafeStr_4515 = 2e4, Hs._SafeStr_4516 = 5e3;
let GE = Hs;
const ai = class ai {
  static init(t, e) {
    this._SafeStr_4513 = 0, this._SafeStr_4515 = t, this._SafeStr_4516 = e, this._SafeStr_4514 = Nt(), this._SafeStr_448 = 1;
  }
  static turnVisualizationOn() {
    if (this._SafeStr_448 === 0 || this._SafeStr_448 === 3) return;
    this._SafeStr_4524 || (this._SafeStr_4524 = setTimeout(() => this.turnVisualizationOff(), this._SafeStr_4516));
    const t = Nt() - this._SafeStr_4514;
    if (t > this._SafeStr_4515 + this._SafeStr_4516) {
      this._SafeStr_448 = 3;
      return;
    }
    if (this._SafeStr_4512 = !0, t < this._SafeStr_4515) {
      this._SafeStr_448 = 1;
      return;
    }
    this._SafeStr_448 = 2, this._SafeStr_4513 = (t - this._SafeStr_4515) / this._SafeStr_4516;
  }
  static turnVisualizationOff() {
    this._SafeStr_4512 = !1, clearTimeout(this._SafeStr_4524), this._SafeStr_4524 = null;
  }
  static isVisualizationOn() {
    return this._SafeStr_4512 && this.isRunning();
  }
  static isRunning() {
    return this._SafeStr_448 === 1 || this._SafeStr_448 === 2;
  }
};
ai.STATE_NOT_INITIALIZED = 0, ai.STATE_START_DELAY = 1, ai.STATE_RUNNING = 2, ai.STATE_OVER = 3, ai._SafeStr_448 = 0, ai._SafeStr_4512 = !1, ai._SafeStr_4514 = 0, ai._SafeStr_4515 = 2e4, ai._SafeStr_4516 = 5e3;
let Vc = ai;
class Jf {
  constructor(t, e, s, r, n, a = 0, o = null, h = null, u = -1, c = -1, l = null) {
    this._id = 0, this._category = 0, this._operation = "", this._loc = null, this._dir = null, this._typeId = 0, this._instanceData = null, this._stuffData = null, this._state = -1, this._animFrame = -1, this._posture = null, this._id = t, this._category = e, this._operation = s, this._loc = new v(), this._loc.assign(r), this._dir = new v(), this._dir.assign(n), this._typeId = a, this._instanceData = o, this._stuffData = h, this._state = u, this._animFrame = c, this._posture = l;
  }
  get id() {
    return this._id;
  }
  get category() {
    return this._category;
  }
  get operation() {
    return this._operation;
  }
  get loc() {
    return this._loc;
  }
  get dir() {
    return this._dir;
  }
  get typeId() {
    return this._typeId;
  }
  get instanceData() {
    return this._instanceData;
  }
  get stuffData() {
    return this._stuffData;
  }
  get state() {
    return this._state;
  }
  get animFrame() {
    return this._animFrame;
  }
  get posture() {
    return this._posture;
  }
  dispose() {
    this._loc = null, this._dir = null;
  }
}
const $I = class $I {
  constructor() {
    this._type = "", this._sizes = [], this._sizeDatas = /* @__PURE__ */ new Map(), this._lastSize = -1, this._lastSizeScale = -1, this._lastSizeData = null, this._lastSizeDataScale = -1;
  }
  initialize(t) {
    return this.reset(), t ? (this._type = t.name, this.defineVisualizations(t.visualizations) ? !0 : (this.reset(), !1)) : !1;
  }
  dispose() {
    if (this._sizeDatas && this._sizeDatas.size) {
      for (const t of this._sizeDatas.values()) t && t.dispose();
      this._sizeDatas = null;
    }
    this._lastSizeData = null, this._sizes = null;
  }
  reset() {
    if (this._type = "", this._sizeDatas && this._sizeDatas.size)
      for (const t of this._sizeDatas.values()) t && t.dispose();
    this._sizeDatas.clear(), this._sizes = [], this._lastSizeData = null, this._lastSizeDataScale = -1;
  }
  createSizeData(t, e, s) {
    return new kc(e, s);
  }
  defineVisualizations(t) {
    if (!t) return !1;
    for (const e of Object.keys(t)) {
      const s = t[e], r = s.layerCount, n = s.angle;
      let a = s.size;
      if (a < 1 && (a = 1), this._sizeDatas.get(a)) return !1;
      const o = this.createSizeData(a, r, n);
      if (!o) return !1;
      for (const h in s) {
        const u = s[h];
        if (!this.processVisualElement(o, h, u))
          return o.dispose(), !1;
      }
      this._sizeDatas.set(a, o), this._sizes.push(a);
    }
    return this.removeInvalidSizes(), this._sizes.sort(), !0;
  }
  removeInvalidSizes() {
    if (!this._sizes || !this._sizes.length) return;
    const t = this._sizeDatas.get($s.SCALE_ZOOMED_IN), e = this._sizeDatas.get($s.SCALE_ZOOMED_OUT);
    if (t && e && t.layerCount !== e.layerCount) {
      this._sizeDatas.delete($s.SCALE_ZOOMED_OUT);
      const s = this._sizes.indexOf($s.SCALE_ZOOMED_OUT);
      s >= 0 && this._sizes.splice(s, 1);
    }
  }
  processVisualElement(t, e, s) {
    if (!t || !e || !s) return !1;
    switch (e) {
      case "layers":
        if (!t.processLayers(s)) return !1;
        break;
      case "directions":
        if (!t.processDirections(s)) return !1;
        break;
      case "colors":
        if (!t.processColors(s)) return !1;
        break;
    }
    return !0;
  }
  getValidSize(t) {
    if (t === this._lastSizeScale) return this._lastSize;
    const e = this.getSizeIndex(t);
    let s = -1;
    return e < this._sizes.length && (s = this._sizes[e]), this._lastSizeScale = t, this._lastSize = s, s;
  }
  getSizeIndex(t) {
    if (t <= 0) return 0;
    let e = 0, s = 1;
    for (; s < this._sizes.length; ) {
      if (this._sizes[s] > t) {
        this._sizes[s] / t < t / this._sizes[s - 1] && (e = s);
        break;
      }
      e = s, s++;
    }
    return e;
  }
  getSizeData(t) {
    if (t === this._lastSizeDataScale) return this._lastSizeData;
    const e = this.getSizeIndex(t);
    return e < this._sizes.length ? this._lastSizeData = this._sizeDatas.get(this._sizes[e]) : this._lastSizeData = null, this._lastSizeDataScale = t, this._lastSizeData;
  }
  getLayerCount(t) {
    const e = this.getSizeData(t);
    return e ? e.layerCount : Vt.DEFAULT_COUNT;
  }
  getValidDirection(t, e) {
    const s = this.getSizeData(t);
    return s ? s.getValidDirection(e) : Vt.DEFAULT_DIRECTION;
  }
  getLayerTag(t, e, s) {
    const r = this.getSizeData(t);
    return r ? r.getLayerTag(e, s) : Vt.DEFAULT_TAG;
  }
  getLayerBlendMode(t, e, s) {
    const r = this.getSizeData(t);
    return r ? r.getLayerBlendMode(e, s) : Vt.DEFAULT_BLEND_MODE;
  }
  getLayerAlpha(t, e, s) {
    const r = this.getSizeData(t);
    return r ? r.getLayerAlpha(e, s) : Vt.DEFAULT_ALPHA;
  }
  getLayerColor(t, e, s) {
    const r = this.getSizeData(t);
    return r ? r.getLayerColor(e, s) : Aa.DEFAULT_COLOR;
  }
  getLayerIgnoreMouse(t, e, s) {
    const r = this.getSizeData(t);
    return r ? r.getLayerIgnoreMouse(e, s) : Vt.DEFAULT_IGNORE_MOUSE;
  }
  getLayerXOffset(t, e, s) {
    const r = this.getSizeData(t);
    return r ? r.getLayerXOffset(e, s) : Vt.DEFAULT_XOFFSET;
  }
  getLayerYOffset(t, e, s) {
    const r = this.getSizeData(t);
    return r ? r.getLayerYOffset(e, s) : Vt.DEFAULT_YOFFSET;
  }
  getLayerZOffset(t, e, s) {
    const r = this.getSizeData(t);
    return r ? r.getLayerZOffset(e, s) : Vt.DEFAULT_ZOFFSET;
  }
  get type() {
    return this._type;
  }
};
$I.LAYER_LETTERS = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];
let Yi = $I;
class TI extends Yi {
  createSizeData(t, e, s) {
    return new zc(e, s);
  }
  processVisualElement(t, e, s) {
    if (!t || !e || !s) return !1;
    switch (e) {
      case "animations":
        if (!(t instanceof zc) || !t.defineAnimations(s)) return !1;
        break;
      default:
        if (!super.processVisualElement(t, e, s)) return !1;
        break;
    }
    return !0;
  }
  hasAnimation(t, e) {
    const s = this.getSizeData(t);
    return s ? s.hasAnimation(e) : null;
  }
  getAnimationCount(t) {
    const e = this.getSizeData(t);
    return e ? e.getAnimationCount() : null;
  }
  getAnimationId(t, e) {
    const s = this.getSizeData(t);
    return s ? s.getAnimationId(e) : null;
  }
  isImmediateChange(t, e, s) {
    const r = this.getSizeData(t);
    return r ? r.isImmediateChange(e, s) : null;
  }
  getStartFrame(t, e, s) {
    const r = this.getSizeData(t);
    return r ? r.getStartFrame(e, s) : null;
  }
  getFrame(t, e, s, r, n) {
    const a = this.getSizeData(t);
    return a ? a.getFrame(e, s, r, n) : null;
  }
  getFrameFromSequence(t, e, s, r, n, a, o) {
    const h = this.getSizeData(t);
    return h ? h.getFrameFromSequence(e, s, r, n, a, o) : null;
  }
}
const hu = class hu extends Ko {
  constructor() {
    super(), this._filters = [], this._data = null, this._type = null, this._direction = 0, this._lastCameraAngle = NaN, this._selectedColor = 0, this._furnitureLift = 0, this._alphaMultiplier = 1, this._alphaChanged = !1, this._clickUrl = null, this._clickHandling = !1, this._cacheDirection = -1, this._cacheScale = 0, this._cacheSize = -1, this._layerCount = 0, this._shadowLayerIndex = -1, this._updatedLayers = [], this._assetNames = [], this._spriteTags = [], this._spriteBlendModes = [], this._spriteAlphas = [], this._spriteColors = [], this._spriteMouseCaptures = [], this._spriteXOffsets = [], this._spriteYOffsets = [], this._spriteZOffsets = [], this._animationNumber = 0, this._lookThrough = !1;
  }
  initialize(t) {
    return this.reset(), t instanceof Yi ? (this._type = t.type, this._data = t, !0) : !1;
  }
  dispose() {
    super.dispose(), this._data = null, this._updatedLayers = null, this._assetNames = null, this._spriteTags = null, this._spriteBlendModes = null, this._spriteAlphas = null, this._spriteColors = null, this._spriteMouseCaptures = null, this._spriteXOffsets = null, this._spriteYOffsets = null, this._spriteZOffsets = null, this._filters = [];
  }
  reset() {
    super.reset(), this.setDirection(-1), this._data = null, this._updatedLayers = [], this._assetNames = [], this._spriteTags = [], this._spriteBlendModes = [], this._spriteAlphas = [], this._spriteColors = [], this._spriteMouseCaptures = [], this._spriteXOffsets = [], this._spriteYOffsets = [], this._spriteZOffsets = [], this.createSprites(0);
  }
  resetLayers(t, e) {
    this._cacheDirection === e && this._cacheScale === t || (this._updatedLayers = [], this._assetNames = [], this._spriteTags = [], this._spriteBlendModes = [], this._spriteAlphas = [], this._spriteColors = [], this._spriteMouseCaptures = [], this._spriteXOffsets = [], this._spriteYOffsets = [], this._spriteZOffsets = [], this._cacheDirection = e, this._cacheScale = t, this._cacheSize = this.getValidSize(t), this.setLayerCount((this._data && this._data.getLayerCount(t) || 0) + this.getAdditionalLayerCount()));
  }
  update(t, e, s, r) {
    if (!t) return;
    const n = t.scale;
    let a = !1;
    this.updateObject(n, t.direction.x) && (a = !0), this.updateModel(n) && (a = !0), this._needsLookThroughUpdate && (a = !0, this._needsLookThroughUpdate = !1);
    let o = 0;
    r ? this._animationNumber = this._animationNumber | this.updateAnimation(n) : (o = this.updateAnimation(n) | this._animationNumber, this._animationNumber = 0), (a || o !== 0) && (this.updateSprites(n, a, o), this._scale = n, this.updateSpriteCounter++);
  }
  updateObject(t, e) {
    if (!this.object || this.updateObjectCounter === this.object.updateCounter && t === this._scale && this._lastCameraAngle === e) return !1;
    let s = this.object.getDirection().x - (e + 135);
    if (s = (s % 360 + 360) % 360, this._data) {
      const r = this._data.getValidDirection(t, s);
      this.setDirection(r);
    }
    return this._lastCameraAngle = e, this._scale = t, this.updateObjectCounter = this.object.updateCounter, this.resetLayers(t, this._direction), !0;
  }
  updateModel(t) {
    const e = this.object && this.object.model;
    if (!e || this.updateModelCounter === e.updateCounter) return !1;
    this._selectedColor = e.getValue(I.FURNITURE_COLOR), this._clickUrl = e.getValue(I.FURNITURE_AD_URL), this._clickHandling = this._clickUrl && this._clickUrl !== "" && this._clickUrl.indexOf("http") === 0 || !1, this._furnitureLift = e.getValue(I.FURNITURE_LIFT_AMOUNT) || 0;
    let s = e.getValue(I.FURNITURE_ALPHA_MULTIPLIER);
    return isNaN(s) && (s = 1), this._alphaMultiplier !== s && (this._alphaMultiplier = s, this._alphaChanged = !0), this.updateModelCounter = e.updateCounter, !0;
  }
  updateSprites(t, e, s) {
    if (this._layerCount !== this.totalSprites && this.createSprites(this._layerCount), e) {
      let r = this.totalSprites - 1;
      for (; r >= 0; )
        this.updateSprite(t, r), r--;
    } else {
      let r = 0;
      for (; s > 0; )
        s && this.updateSprite(t, r), r++, s = s >> 1;
    }
    this._alphaChanged = !1;
  }
  updateSprite(t, e) {
    const s = this.getSpriteAssetName(t, e), r = this.getSprite(e);
    if (s && r) {
      const n = this.getAsset(s, e);
      if (n) {
        r.visible = !0, r.type = this._type, r.texture = this.getTexture(t, e, n), r.flipH = n.flipH, r.flipV = n.flipV, r.direction = this._direction;
        let a = 0;
        e !== this._shadowLayerIndex ? (r.tag = this.getLayerTag(t, this._direction, e), r.alpha = this.getLayerAlpha(t, this._direction, e), r.color = this.getLayerColor(t, e, this._selectedColor), r.offsetX = n.offsetX + this.getLayerXOffset(t, this._direction, e), r.offsetY = n.offsetY + this.getLayerYOffset(t, this._direction, e), r.blendMode = this.getLayerBlendMode(t, this._direction, e), r.alphaTolerance = this.getLayerIgnoreMouse(t, this._direction, e) ? _i.MATCH_NOTHING : _i.MATCH_OPAQUE_PIXELS, a = this.getLayerZOffset(t, this._direction, e), a = a - e * 1e-3) : (r.offsetX = n.offsetX, r.offsetY = n.offsetY + this.getLayerYOffset(t, this._direction, e), r.alpha = 48 * this._alphaMultiplier, r.alphaTolerance = _i.MATCH_NOTHING, a = 1), this._lookThrough && (r.alpha *= 0.2), r.relativeDepth = a * hu.DEPTH_MULTIPLIER, r.name = s, r.libraryAssetName = this.getLibraryAssetNameForSprite(n, r), r.posture = this.getPostureForAsset(t, n.source), r.clickHandling = this._clickHandling, r.blendMode !== "add" && (r.filters = this._filters);
      } else
        this.resetSprite(r);
    } else
      r && this.resetSprite(r);
  }
  getLibraryAssetNameForSprite(t, e) {
    return t.source;
  }
  getPostureForAssetFile(t, e) {
    return null;
  }
  resetSprite(t) {
    t && (t.texture = null, t.libraryAssetName = "", t.posture = "", t.tag = "", t.offsetX = 0, t.offsetY = 0, t.flipH = !1, t.flipV = !1, t.relativeDepth = 0, t.clickHandling = !1);
  }
  getSpriteAssetName(t, e) {
    if (!this._data || e >= Yi.LAYER_LETTERS.length) return "";
    let s = this._assetNames[e], r = this._updatedLayers[e];
    return (!s || !s.length) && (s = this.cacheSpriteAssetName(t, e, !0), r = this._cacheSize !== 1), r && (s += this.getFrameNumber(t, e)), s;
  }
  cacheSpriteAssetName(t, e, s) {
    this._type;
    const r = s ? this._cacheSize : this.getValidSize(t);
    let n = "";
    const a = r !== 1;
    if (e !== this._shadowLayerIndex ? n = Yi.LAYER_LETTERS[e] || "" : n = "sd", n === "") return null;
    const o = this._type + (a ? "_" + r + "_" + n + "_" + this._direction + "_" : "_icon_" + n);
    return s && (this._assetNames[e] = o, this._updatedLayers[e] = a), o;
  }
  getLayerTag(t, e, s) {
    const r = this._spriteTags[s];
    if (r !== void 0) return r;
    if (!this._data) return Vt.DEFAULT_TAG;
    const n = this._data.getLayerTag(t, e, s);
    return this._spriteTags[s] = n, n;
  }
  getLayerBlendMode(t, e, s) {
    const r = this._spriteBlendModes[s];
    if (r !== void 0) return r;
    if (!this._data) return Vt.DEFAULT_BLEND_MODE;
    const n = this._data.getLayerBlendMode(t, e, s);
    return this._spriteBlendModes[s] = n, n;
  }
  getLayerAlpha(t, e, s) {
    if (!this._alphaChanged) {
      const n = this._spriteAlphas[s];
      if (n !== void 0) return n;
    }
    if (!this._data) return Vt.DEFAULT_ALPHA;
    let r = this._data.getLayerAlpha(t, e, s);
    return this._alphaMultiplier !== null && (r = r * this._alphaMultiplier), this._spriteAlphas[s] = r, r;
  }
  getLayerColor(t, e, s) {
    const r = this._spriteColors[e];
    if (r !== void 0) return r;
    if (!this._data) return Aa.DEFAULT_COLOR;
    const n = this._data.getLayerColor(t, e, s);
    return this._spriteColors[e] = n, n;
  }
  getLayerIgnoreMouse(t, e, s) {
    const r = this._spriteMouseCaptures[s];
    if (r !== void 0) return r;
    if (!this._data) return Vt.DEFAULT_IGNORE_MOUSE;
    const n = this._data.getLayerIgnoreMouse(t, e, s);
    return this._spriteMouseCaptures[s] = n, n;
  }
  getLayerXOffset(t, e, s) {
    const r = this._spriteXOffsets[s];
    if (r !== void 0) return r;
    if (!this._data) return Vt.DEFAULT_XOFFSET;
    const n = this._data.getLayerXOffset(t, e, s);
    return this._spriteXOffsets[s] = n, n;
  }
  getLayerYOffset(t, e, s) {
    if (s === this._shadowLayerIndex) return Math.ceil(this._furnitureLift * (t / 2));
    const r = this._spriteYOffsets[s];
    if (r !== void 0) return r;
    if (!this._data) return Vt.DEFAULT_YOFFSET;
    const n = this._data.getLayerYOffset(t, e, s);
    return this._spriteYOffsets[s] = n, n;
  }
  getLayerZOffset(t, e, s) {
    const r = this._spriteZOffsets[s];
    if (r !== void 0) return r;
    if (!this._data) return Vt.DEFAULT_ZOFFSET;
    const n = this._data.getLayerZOffset(t, e, s);
    return this._spriteZOffsets[s] = n, n;
  }
  getValidSize(t) {
    return this._data ? this._data.getValidSize(t) : t;
  }
  setLayerCount(t) {
    this._layerCount = t, this._shadowLayerIndex = t - this.getAdditionalLayerCount();
  }
  setDirection(t) {
    this._direction !== t && (this._direction = t);
  }
  getAdditionalLayerCount() {
    return 1;
  }
  updateAnimation(t) {
    return 0;
  }
  getFrameNumber(t, e) {
    return 0;
  }
  getPostureForAsset(t, e) {
    return null;
  }
  getAsset(t, e = -1) {
    return this.asset ? this.asset.getAsset(t) : null;
  }
  getTexture(t, e, s) {
    return (s == null ? void 0 : s.texture) ?? null;
  }
  set lookThrough(t) {
    this._lookThrough != t && (this._lookThrough = t, this._needsLookThroughUpdate = !0);
  }
  get direction() {
    return this._direction;
  }
  get data() {
    return this._data;
  }
};
hu.DEPTH_MULTIPLIER = Math.sqrt(0.5), hu.TYPE = j.FURNITURE_STATIC;
let Xi = hu;
const yo = class yo extends Xi {
  constructor() {
    super(...arguments), this._state = -1, this._frameIncrease = 1, this._animationData = new BM(), this._animationScale = 0, this._animationChangeTime = 0, this._animatedLayerCount = 0, this._directionChanged = !1;
  }
  initialize(t) {
    return t instanceof TI ? super.initialize(t) : !1;
  }
  dispose() {
    super.dispose(), this._animationData && (this._animationData.dispose(), this._animationData = null);
  }
  get animatedLayerCount() {
    return this._animatedLayerCount;
  }
  get animationId() {
    return this._animationData.animationId;
  }
  getAnimationId(t) {
    return this.animationId !== yo.DEFAULT_ANIMATION_ID && this.data.hasAnimation(this._animationScale, this.animationId) ? this.animationId : yo.DEFAULT_ANIMATION_ID;
  }
  updateObject(t, e) {
    if (super.updateObject(t, e)) {
      const s = this.object.getState(0);
      return s !== this._state && (this.setAnimation(s), this._state = s, this._animationChangeTime = this.object.model.getValue(I.FURNITURE_STATE_UPDATE_TIME) || 0), !0;
    }
    return !1;
  }
  updateModel(t) {
    if (super.updateModel(t)) {
      if (this.usesAnimationResetting()) {
        const s = this.object.model.getValue(I.FURNITURE_STATE_UPDATE_TIME);
        s > this._animationChangeTime && (this._animationChangeTime = s, this.setAnimation(this._state));
      }
      const e = this.object.model.getValue(I.FURNITURE_AUTOMATIC_STATE_INDEX);
      if (!isNaN(e)) {
        const s = this.data.getAnimationId(this._animationScale, e);
        this.setAnimation(s);
      }
      return !0;
    }
    return !1;
  }
  isPlayingTransition(t, e) {
    return !(!xe.isTransitionFromAnimation(t.animationId) && !xe.isTransitionToAnimation(t.animationId) || e !== t.animationAfterTransitionId || t.animationOver);
  }
  getCurrentState(t) {
    const e = t.animationId;
    return !xe.isTransitionFromAnimation(e) && !xe.isTransitionToAnimation(e) ? e : t.animationAfterTransitionId;
  }
  setAnimation(t) {
    this.data && this.setSubAnimation(this._animationData, t, this._state >= 0);
  }
  setSubAnimation(t, e, s = !0) {
    const r = t.animationId;
    if (s) {
      if (this.isPlayingTransition(t, e)) return !1;
      const n = this.getCurrentState(t);
      if (e !== n) {
        if (!this.data.isImmediateChange(this._animationScale, e, n)) {
          let a = xe.getTransitionFromAnimationId(n);
          this.data.hasAnimation(this._animationScale, a) ? (t.animationAfterTransitionId = e, e = a) : (a = xe.getTransitionToAnimationId(e), this.data.hasAnimation(this._animationScale, a) && (t.animationAfterTransitionId = e, e = a));
        }
      } else if (xe.isTransitionFromAnimation(t.animationId)) {
        const a = xe.getTransitionToAnimationId(e);
        this.data.hasAnimation(this._animationScale, a) && (t.animationAfterTransitionId = e, e = a);
      } else if (!xe.isTransitionToAnimation(t.animationId) && this.usesAnimationResetting()) {
        const a = xe.getTransitionFromAnimationId(n);
        if (this.data.hasAnimation(this._animationScale, a))
          t.animationAfterTransitionId = e, e = a;
        else {
          const o = xe.getTransitionToAnimationId(e);
          this.data.hasAnimation(this._animationScale, o) && (t.animationAfterTransitionId = e, e = o);
        }
      }
    }
    return r !== e ? (t.animationId = e, !0) : !1;
  }
  getLastFramePlayed(t) {
    return this._animationData.getLastFramePlayed(t);
  }
  resetAllAnimationFrames() {
    this._animationData && this._animationData.setLayerCount(this._animatedLayerCount);
  }
  updateAnimation(t) {
    if (!this.data) return 0;
    t !== this._animationScale && (this._animationScale = t, this._animatedLayerCount = this.data.getLayerCount(t), this.resetAllAnimationFrames());
    const e = this.updateAnimations(t);
    return this._directionChanged = !1, e;
  }
  updateAnimations(t) {
    if (this._animationData.animationOver && !this._directionChanged) return 0;
    const e = this.updateFramesForAnimation(this._animationData, t);
    return this._animationData.animationOver && (xe.isTransitionFromAnimation(this._animationData.animationId) || xe.isTransitionToAnimation(this._animationData.animationId)) && (this.setAnimation(this._animationData.animationAfterTransitionId), this._animationData.animationOver = !1), e;
  }
  updateFramesForAnimation(t, e) {
    if (t.animationOver && !this._directionChanged) return 0;
    const s = this.getAnimationId(t);
    let r = t.frameCounter;
    r || (r = this.data.getStartFrame(e, s, this._direction)), r += this.frameIncrease, t.frameCounter = r, t.animationOver = !0;
    let n = !1, a = this._animatedLayerCount - 1, o = 0, h = 1 << this._animatedLayerCount - 1;
    for (; a >= 0; ) {
      let u = 0;
      if (n = t.getAnimationPlayed(a), !n || this._directionChanged) {
        let c = t.getLastFramePlayed(a), l = t.getFrame(a);
        l && l.isLastFrame && l.remainingFrameRepeats <= this.frameIncrease && (c = !0), (this._directionChanged || !l || l.remainingFrameRepeats >= 0 && (l.remainingFrameRepeats = l.remainingFrameRepeats - this.frameIncrease) <= 0) && (u = fn.SEQUENCE_NOT_DEFINED, l && (u = l.activeSequence), u === fn.SEQUENCE_NOT_DEFINED ? l = this.data.getFrame(e, s, this._direction, a, r) : l = this.data.getFrameFromSequence(e, s, this._direction, a, u, l.activeSequenceOffset + l.repeats, r), t.setFrame(a, l), o = o | h), !l || l.remainingFrameRepeats == fn.FRAME_REPEAT_FOREVER ? (c = !0, n = !0) : t.animationOver = !1, t.setLastFramePlayed(a, c), t.setAnimationPlayed(a, n);
      }
      h = h >> 1, a--;
    }
    return o;
  }
  getFrameNumber(t, e) {
    const s = this._animationData.getFrame(e);
    return s ? s.id : super.getFrameNumber(t, e);
  }
  getLayerXOffset(t, e, s) {
    const r = super.getLayerXOffset(t, e, s), n = this._animationData.getFrame(s);
    return n ? r + n.x : r;
  }
  getLayerYOffset(t, e, s) {
    const r = super.getLayerYOffset(t, e, s), n = this._animationData.getFrame(s);
    return n ? r + n.y : r;
  }
  usesAnimationResetting() {
    return !1;
  }
  setDirection(t) {
    this._direction !== t && (super.setDirection(t), this._directionChanged = !0);
  }
  get frameIncrease() {
    return this._frameIncrease;
  }
  get data() {
    return this._data;
  }
};
yo.TYPE = j.FURNITURE_ANIMATED, yo.DEFAULT_ANIMATION_ID = 0;
let Te = yo;
const Ys = class Ys extends Xi {
  constructor() {
    super(), this._imageUrl = null, this._shortUrl = null, this._imageReady = !1, this._offsetX = 0, this._offsetY = 0, this._offsetZ = 0, this._currentFrame = -1, this._totalFrames = -1;
  }
  dispose() {
    super.dispose(), this._imageUrl && this.asset && this.asset.disposeAsset(this._imageUrl);
  }
  updateObject(t, e) {
    return super.updateObject(t, e) ? (this._imageReady && this.checkAndCreateImageForCurrentState(), !0) : !1;
  }
  updateModel(t) {
    const e = super.updateModel(t);
    if (e && (this._offsetX = this.object.model.getValue(I.FURNITURE_BRANDING_OFFSET_X) || 0, this._offsetY = this.object.model.getValue(I.FURNITURE_BRANDING_OFFSET_Y) || 0, this._offsetZ = this.object.model.getValue(I.FURNITURE_BRANDING_OFFSET_Z) || 0), this._imageReady) {
      if (this.checkIfImageChanged())
        return this._imageReady = !1, this._imageUrl = null, !0;
    } else if (this._imageReady = this.checkIfImageReady(), this._imageReady)
      return this.checkAndCreateImageForCurrentState(), !0;
    return e;
  }
  checkIfImageChanged() {
    const t = this.object.model.getValue(I.FURNITURE_BRANDING_IMAGE_URL);
    return t && t === this._imageUrl ? !1 : (this.asset && this.asset.disposeAsset(this._imageUrl), !0);
  }
  checkIfImageReady() {
    if (!(this.object && this.object.model)) return !1;
    const e = this.object.model.getValue(I.FURNITURE_BRANDING_IMAGE_URL);
    if (!e || this._imageUrl && this._imageUrl === e) return !1;
    if (this.object.model.getValue(I.FURNITURE_BRANDING_IMAGE_STATUS) === 1) {
      let r = null;
      return r = Rt().getTexture(e), r ? (this.imageReady(r, e), !0) : !1;
    }
    return !1;
  }
  imageReady(t, e) {
    if (!t) {
      this._imageUrl = null;
      return;
    }
    this._imageUrl = e;
  }
  checkAndCreateImageForCurrentState() {
    if (!this._imageUrl) return;
    const t = Rt().getTexture(this._imageUrl);
    if (!t) return;
    const e = this.object.getState(0);
    this.addBackgroundAsset(t, e, 0);
  }
  addBackgroundAsset(t, e, s) {
    let r = 0, n = 0, a = !1, o = !1;
    switch (e) {
      case Ys.STATE_0:
        r = 0, n = 0, a = !1, o = !1;
        break;
      case Ys.STATE_1:
        r = -t.width, n = 0, a = !0, o = !1;
        break;
      case Ys.STATE_2:
        r = -t.width, n = -t.height, a = !0, o = !0;
        break;
      case Ys.STATE_3:
        r = 0, n = -t.height, a = !1, o = !0;
        break;
    }
    this.asset.addAsset(`${this._imageUrl}_${s}`, t, !0, r, n, a, o);
  }
  getSpriteAssetName(t, e) {
    return this.getLayerTag(t, this._direction, e) === Ys.BRANDED_IMAGE && this._imageUrl ? `${this._imageUrl}_${this.getFrameNumber(t, e)}` : super.getSpriteAssetName(t, e);
  }
};
Ys.BRANDED_IMAGE = "branded_image", Ys.STATE_0 = 0, Ys.STATE_1 = 1, Ys.STATE_2 = 2, Ys.STATE_3 = 3;
let Bu = Ys;
class kM extends Bu {
  getLayerXOffset(t, e, s) {
    return super.getLayerXOffset(t, e, s) + this._offsetX;
  }
  getLayerYOffset(t, e, s) {
    return super.getLayerYOffset(t, e, s) + this._offsetY;
  }
  getLayerZOffset(t, e, s) {
    return super.getLayerZOffset(t, e, s) + this._offsetZ;
  }
}
const vo = class vo extends Te {
  constructor() {
    super(...arguments), this._badgeId = "", this._badgeAssetNameNormalScale = "", this._badgeAssetNameSmallScale = "", this._badgeVisibleInState = -1;
  }
  updateModel(t) {
    let e = super.updateModel(t);
    const s = this.object.model.getValue(I.FURNITURE_BADGE_IMAGE_STATUS), r = this.object.model.getValue(I.FURNITURE_BADGE_ASSET_NAME);
    if (s === -1)
      this._badgeAssetNameNormalScale = "", this._badgeAssetNameSmallScale = "";
    else if (s === 1 && r !== this._badgeId) {
      this._badgeId = r, this._badgeAssetNameNormalScale = this._badgeId, this._badgeAssetNameSmallScale === "" && (this._badgeAssetNameSmallScale = this._badgeAssetNameNormalScale + "_32");
      const n = this.object.model.getValue(I.FURNITURE_BADGE_VISIBLE_IN_STATE);
      isNaN(n) || (this._badgeVisibleInState = n), e = !0;
    }
    return e;
  }
  getSpriteAssetName(t, e) {
    return this.getLayerTag(t, this.direction, e) !== vo.BADGE || this._badgeVisibleInState !== -1 && this.object.getState(0) !== this._badgeVisibleInState ? super.getSpriteAssetName(t, e) : t === 32 ? this._badgeAssetNameSmallScale : this._badgeAssetNameNormalScale;
  }
  getLayerXOffset(t, e, s) {
    let r = super.getLayerXOffset(t, e, s);
    if (this.getLayerTag(t, e, s) === vo.BADGE) {
      const n = this.getAsset(t === 32 ? this._badgeAssetNameSmallScale : this._badgeAssetNameNormalScale, s);
      n && (t === 64 ? r += (40 - n.width) / 2 : r += (20 - n.width) / 2);
    }
    return r;
  }
  getLayerYOffset(t, e, s) {
    let r = super.getLayerYOffset(t, e, s);
    if (this.getLayerTag(t, e, s) === vo.BADGE) {
      const n = this.getAsset(t === 32 ? this._badgeAssetNameSmallScale : this._badgeAssetNameNormalScale, s);
      n && (t === 64 ? r += (40 - n.height) / 2 : r += (20 - n.height) / 2);
    }
    return r;
  }
};
vo.BADGE = "BADGE";
let BE = vo;
const Xr = class Xr extends Te {
  constructor() {
    super(), this._stateQueue = [], this._running = !1;
  }
  setAnimation(t) {
    if (t === -1 && !this._running) {
      this._running = !0, this._stateQueue = [], this._stateQueue.push(Xr.ANIMATION_ID_ROLL);
      return;
    }
    if (t >= 0 && t <= 7) {
      if (this._running) {
        this._running = !1, this._stateQueue = [], this._stateQueue.push(Xr.ANIMATION_ID_OFFSET_SLOW1), this._stateQueue.push(Xr.ANIMATION_ID_OFFSET_SLOW2 + t), this._stateQueue.push(t);
        return;
      }
      super.setAnimation(t);
    }
  }
  updateAnimation(t) {
    return this.getLastFramePlayed(0) && this._stateQueue.length && super.setAnimation(this._stateQueue.shift()), super.updateAnimation(t);
  }
};
Xr.ANIMATION_ID_OFFSET_SLOW1 = 20, Xr.ANIMATION_ID_OFFSET_SLOW2 = 9, Xr.ANIMATION_ID_ROLL = -1;
let kE = Xr;
class Git extends Xi {
}
const Li = class Li extends Te {
  getFrameNumber(t, e) {
    const s = this.getLayerTag(t, this.direction, e), r = this.object.getState(0);
    switch (s) {
      case Li.SECONDS_SPRITE:
        return Math.floor(r % 60 % 10);
      case Li.TEN_SECONDS_SPRITE:
        return Math.floor(r % 60 / 10);
      case Li.MINUTES_SPRITE:
        return Math.floor(r / 60 % 10);
      case Li.TEN_MINUTES_SPRITE:
        return Math.floor(r / 60 / 10 % 10);
      default:
        return super.getFrameNumber(t, e);
    }
  }
  get animationId() {
    return 0;
  }
};
Li.SECONDS_SPRITE = "seconds_sprite", Li.TEN_SECONDS_SPRITE = "ten_seconds_sprite", Li.MINUTES_SPRITE = "minutes_sprite", Li.TEN_MINUTES_SPRITE = "ten_minutes_sprite";
let zE = Li;
class Bit extends Ko {
}
const uu = class uu extends Te {
  constructor() {
    super(), this._thumbnailAssetNameNormal = null, this._thumbnailImageNormal = null, this._thumbnailDirection = -1, this._thumbnailChanged = !1, this._hasOutline = !1;
  }
  get hasThumbnailImage() {
    return this._thumbnailImageNormal != null;
  }
  setThumbnailImages(t) {
    this._thumbnailImageNormal = t, this._thumbnailChanged = !0;
  }
  updateModel(t) {
    const e = super.updateModel(t);
    return !this._thumbnailChanged && this._thumbnailDirection === this.direction ? e : (this.refreshThumbnail(), !0);
  }
  refreshThumbnail() {
    this.asset != null && (this._thumbnailImageNormal ? this.addThumbnailAsset(this._thumbnailImageNormal, 64) : this.asset.disposeAsset(this.getThumbnailAssetName(64)), this._thumbnailChanged = !1, this._thumbnailDirection = this.direction);
  }
  addThumbnailAsset(t, e) {
    let s = 0;
    for (; s < this.totalSprites; ) {
      if (this.getLayerTag(e, this.direction, s) === uu.THUMBNAIL) {
        const r = this.cacheSpriteAssetName(e, s, !1) + this.getFrameNumber(e, s), n = this.getAsset(r, s);
        if (n) {
          const a = this.generateTransformedThumbnail(t, n), o = this.getThumbnailAssetName(e);
          this.asset.disposeAsset(o), this.asset.addAsset(o, a, !0, n.offsetX, n.offsetY, !1, !1);
        }
        return;
      }
      s++;
    }
  }
  generateTransformedThumbnail(t, e) {
    if (this._hasOutline) {
      const o = new Ft(), h = new Ft(W.WHITE);
      h.tint = 0, h.width = t.width + 40, h.height = t.height + 40;
      const u = new Ft(t), c = (h.width - u.width) / 2, l = (h.height - u.height) / 2;
      u.x = Math.floor(c), u.y = Math.floor(l), o.addChild(h, u), t = le.generateTexture(o);
    }
    const s = 1.1, r = new ot(), n = e.width / t.width;
    switch (this.direction) {
      case 2:
        r.a = n, r.b = -0.5 * n, r.c = 0, r.d = n * s, r.tx = 0, r.ty = 0.5 * n * t.width;
        break;
      case 0:
      case 4:
        r.a = n, r.b = 0.5 * n, r.c = 0, r.d = n * s, r.tx = 0, r.ty = 0;
        break;
      default:
        r.a = n, r.b = 0, r.c = 0, r.d = n, r.tx = 0, r.ty = 0;
    }
    const a = new Ft(t);
    return a.setFromMatrix(r), le.generateTexture(a);
  }
  getSpriteAssetName(t, e) {
    return this._thumbnailImageNormal && this.getLayerTag(t, this.direction, e) === uu.THUMBNAIL ? this.getThumbnailAssetName(t) : super.getSpriteAssetName(t, e);
  }
  getThumbnailAssetName(t) {
    return this._thumbnailAssetNameNormal = this.getFullThumbnailAssetName(this.object.id, 64), this._thumbnailAssetNameNormal;
  }
  getFullThumbnailAssetName(t, e) {
    return [this._type, t, "thumb", e].join("_");
  }
};
uu.THUMBNAIL = "THUMBNAIL";
let Hc = uu;
class zM extends Hc {
  constructor() {
    super(), this._cachedUrl = null, this._hasOutline = !0;
  }
  updateModel(t) {
    if (this.object) {
      const e = this.getThumbnailURL();
      if (this._cachedUrl !== e)
        if (this._cachedUrl = e, this._cachedUrl && this._cachedUrl !== "") {
          const s = new Image();
          s.src = e, s.crossOrigin = "*", s.onload = () => {
            const r = W.from(s);
            r.source.scaleMode = "linear", this.setThumbnailImages(r);
          };
        } else
          this.setThumbnailImages(null);
    }
    return super.updateModel(t);
  }
  getThumbnailURL() {
    throw new Error("This method must be overridden!");
  }
}
class kit extends zM {
  constructor() {
    super(), this._url = null, this._typePrefix = null;
  }
  getThumbnailURL() {
    if (!this.object) return null;
    if (this._url) return this._url;
    const t = this.object.model.getValue(I.FURNITURE_DATA);
    if (!t || t === "") return null;
    this.object.type.indexOf("") >= 0 && (this._typePrefix = this.object.type.indexOf("") >= 0 ? "" : "postcards/selfie/");
    let s = JSON.parse(t).w || "";
    return s = this.buildThumbnailUrl(s), this._url = s, this._url;
  }
  buildThumbnailUrl(t) {
    return t = t.replace(".png", "_small.png"), t.indexOf(".png") === -1 && (t = t + "_small.png"), t;
  }
}
class MR {
  constructor() {
    this._hasMoved = !1, this._age = 0, this._isEmitter = !1, this._fade = !1, this._alphaMultiplier = 1;
  }
  init(t, e, s, r, n, a, o, h = !1, u = null, c = !1) {
    this._x = t, this._y = e, this._z = s, this._particleDirection = new v(r.x, r.y, r.z), this._particleDirection.multiply(n), this._lastX = this._x - this._particleDirection.x * a, this._lastY = this._y - this._particleDirection.y * a, this._lastZ = this._z - this._particleDirection.z * a, this._age = 0, this._hasMoved = !1, this._lifeTime = o, this._isEmitter = h, this._frames = u, this._fade = c, this._alphaMultiplier = 1, this._fadeTime = 0.5 + Math.random() * 0.5;
  }
  dispose() {
    this._particleDirection = null;
  }
  update() {
    this._age++, this._age === this._lifeTime && this.ignite(), this._fade && this._age / this._lifeTime > this._fadeTime && (this._alphaMultiplier = (this._lifeTime - this._age) / (this._lifeTime * (1 - this._fadeTime)));
  }
  getAsset() {
    return this._frames && this._frames.length > 0 ? this._frames[this._age % this._frames.length] : null;
  }
  ignite() {
  }
  get fade() {
    return this._fade;
  }
  get alphaMultiplier() {
    return this._alphaMultiplier;
  }
  get direction() {
    return this._particleDirection;
  }
  get age() {
    return this._age;
  }
  get isEmitter() {
    return this._isEmitter;
  }
  get isAlive() {
    return this._age <= this._lifeTime;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t;
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t;
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t;
  }
  get lastX() {
    return this._lastX;
  }
  set lastX(t) {
    this._hasMoved = !0, this._lastX = t;
  }
  get lastY() {
    return this._lastY;
  }
  set lastY(t) {
    this._hasMoved = !0, this._lastY = t;
  }
  get lastZ() {
    return this._lastZ;
  }
  set lastZ(t) {
    this._hasMoved = !0, this._lastZ = t;
  }
  get hasMoved() {
    return this._hasMoved;
  }
  toString() {
    return [this._x, this._y, this._z].toString();
  }
  copy(t, e) {
    this._x = t._x * e, this._y = t._y * e, this._z = t._z * e, this._lastX = t._lastX * e, this._lastY = t._lastY * e, this._lastZ = t._lastZ * e, this._hasMoved = t.hasMoved, this._particleDirection = t._particleDirection, this._age = t._age, this._lifeTime = t._lifeTime, this._isEmitter = t._isEmitter, this._fade = t._fade, this._fadeTime = t._fadeTime, this._alphaMultiplier = t._alphaMultiplier;
  }
}
const Kr = class Kr extends MR {
  constructor(t = "", e = -1) {
    super(), this._roomObjectSpriteId = -1, this._timeStep = 0.1, this._fuseTime = 10, this._energy = 1, this._hasIgnited = !1, this._burstPulse = 1, this._particles = [], this._name = t, this._roomObjectSpriteId = e, this._particleConfigurations = [];
  }
  dispose() {
    for (const t of this._particles) t.dispose();
    this._particles = null, this._particleConfigurations = null, super.dispose();
  }
  setup(t, e, s, r, n, a, o, h, u, c) {
    this._maxNumberOfParticles = t, this._particlesPerFrame = e, this._force = s, this._emitterDirection = r, this._emitterDirection.normalize(), this._gravity = n, this._airFriction = a, this._explosionShape = o, this._fuseTime = u, this._energy = h, this._burstPulse = c, this.reset();
  }
  reset() {
    for (const t of this._particles) t.dispose();
    this._particles = [], this._emittedParticles = 0, this._hasIgnited = !1, this.init(0, 0, 0, this._emitterDirection, this._force, this._timeStep, this._fuseTime, !0);
  }
  copyStateFrom(t, e) {
    super.copy(t, e), this._force = t._force, this._emitterDirection = t._emitterDirection, this._gravity = t._gravity, this._airFriction = t._airFriction, this._explosionShape = t._explosionShape, this._fuseTime = t._fuseTime, this._energy = t._energy, this._burstPulse = t._burstPulse, this._timeStep = t._timeStep, this._hasIgnited = t._hasIgnited;
  }
  configureParticle(t, e, s, r) {
    const n = {};
    n.lifeTime = t, n.isEmitter = e, n.frames = s, n.fade = r, this._particleConfigurations.push(n);
  }
  ignite() {
    this._hasIgnited = !0, this._emittedParticles < this._maxNumberOfParticles && this.age > 1 && this.releaseParticles(this, this.direction);
  }
  releaseParticles(t, e = null) {
    e || (e = new v());
    const s = new v(), r = this.getRandomParticleConfiguration();
    let n = 0;
    for (; n < this._particlesPerFrame; ) {
      switch (this._explosionShape) {
        case Kr.CONE:
          s.x = this.randomBoolean(0.5) ? Math.random() : -Math.random(), s.y = -(Math.random() + 1), s.z = this.randomBoolean(0.5) ? Math.random() : -Math.random();
          break;
        case Kr.PLANE:
          s.x = this.randomBoolean(0.5) ? Math.random() : -Math.random(), s.y = 0, s.z = this.randomBoolean(0.5) ? Math.random() : -Math.random();
          break;
        case Kr.SPHERE:
          s.x = this.randomBoolean(0.5) ? Math.random() : -Math.random(), s.y = this.randomBoolean(0.5) ? Math.random() : -Math.random(), s.z = this.randomBoolean(0.5) ? Math.random() : -Math.random();
          break;
      }
      s.normalize();
      const a = new MR();
      let o = 0, h = !1, u = !1, c = [];
      r ? (o = Math.floor(Math.random() * r.lifeTime + 10), h = r.isEmitter, c = r.frames, u = r.fade) : (o = Math.trunc(Math.floor(Math.random() * 20 + 10)), h = !1, c = []), a.init(t.x, t.y, t.z, s, this._energy, this._timeStep, o, h, c, u), this._particles.push(a), this._emittedParticles++, n++;
    }
  }
  getRandomParticleConfiguration() {
    const t = Math.trunc(Math.floor(Math.random() * this._particleConfigurations.length));
    return this._particleConfigurations[t];
  }
  update() {
    super.update(), this.accumulateForces(), this.verlet(), this.satisfyConstraints(), !this.isAlive && this._emittedParticles < this._maxNumberOfParticles && this.age % this._burstPulse === 0 && this.releaseParticles(this, this.direction);
  }
  verlet() {
    if (this.isAlive || this._emittedParticles < this._maxNumberOfParticles) {
      const e = this.x, s = this.y, r = this.z;
      this.x = (2 - this._airFriction) * this.x - (1 - this._airFriction) * this.lastX, this.y = (2 - this._airFriction) * this.y - (1 - this._airFriction) * this.lastY + this._gravity * this._timeStep * this._timeStep, this.z = (2 - this._airFriction) * this.z - (1 - this._airFriction) * this.lastZ, this.lastX = e, this.lastY = s, this.lastZ = r;
    }
    const t = [];
    for (const e of this._particles) {
      e.update();
      const s = e.x, r = e.y, n = e.z;
      e.x = (2 - this._airFriction) * e.x - (1 - this._airFriction) * e.lastX, e.y = (2 - this._airFriction) * e.y - (1 - this._airFriction) * e.lastY + this._gravity * this._timeStep * this._timeStep, e.z = (2 - this._airFriction) * e.z - (1 - this._airFriction) * e.lastZ, e.lastX = s, e.lastY = r, e.lastZ = n, (e.y > 10 || !e.isAlive) && t.push(e);
    }
    for (const e of t)
      e.isEmitter, this._particles.splice(this._particles.indexOf(e), 1), e.dispose();
  }
  satisfyConstraints() {
  }
  accumulateForces() {
    for (const t of this._particles)
      ;
  }
  get particles() {
    return this._particles;
  }
  get hasIgnited() {
    return this._hasIgnited;
  }
  randomBoolean(t) {
    return Math.random() < t;
  }
  get roomObjectSpriteId() {
    return this._roomObjectSpriteId;
  }
};
Kr.CONE = "cone", Kr.PLANE = "plane", Kr.SPHERE = "sphere";
let VE = Kr;
class zit {
  constructor(t) {
    this._canvasId = -1, this._hasIgnited = !1, this._centerX = 0, this._centerY = 0, this._scaleMultiplier = 1, this._blend = 1, this._bgColor = 4278190080, this._isDone = !1, this._emitters = new be(), this._visualization = t, this._blackOverlayAlphaTransform = new Yl(), this._blackOverlayAlphaTransform.alpha = 1, this._particleColorTransform = new Yl(), this._identityMatrix = new ot(), this._translationMatrix = new ot(), this._particleSprite = new Ft();
  }
  dispose() {
    for (const t of this._emitters.getValues()) t.dispose();
    this._emitters = null, this._canvasTexture && (this._canvasTexture.destroy(), this._canvasTexture = null), this._blackOverlay && (this._blackOverlay.destroy(), this._blackOverlay = null), this._emptySprite && (this._emptySprite.destroy(), this._emptySprite = null), this._particleSprite && (this._particleSprite.destroy(), this._particleSprite = null), this._blackOverlayAlphaTransform = null, this._particleColorTransform = null, this._identityMatrix = null, this._translationMatrix = null;
  }
  reset() {
    this._currentEmitter && this._currentEmitter.reset(), this._currentEmitter = null, this._hasIgnited = !1, this._isDone = !1, this.updateCanvas();
  }
  setAnimation(t) {
    this._currentEmitter && this._currentEmitter.reset(), this._currentEmitter = this._emitters.getValue(t), this._hasIgnited = !1, this._isDone = !1, this.updateCanvas();
  }
  updateCanvas() {
    if (!(!this._currentEmitter || this._canvasId === -1) && (this._roomSprite = this._visualization.getSprite(this._canvasId), this._roomSprite && this._roomSprite.texture)) {
      if (this._roomSprite.width <= 1 || this._roomSprite.height <= 1) return;
      this._canvasTexture && (this._canvasTexture.width !== this._roomSprite.width || this._canvasTexture.height !== this._roomSprite.height) && (this._canvasTexture.destroy(), this._canvasTexture = null), this.clearCanvas(), this._centerX = -this._roomSprite.offsetX, this._centerY = -this._roomSprite.offsetY, this._roomSprite.texture = this._canvasTexture;
    }
  }
  getLayerYOffset(t, e, s) {
    return this._currentEmitter && this._currentEmitter.roomObjectSpriteId === s ? this._currentEmitter.y * this._scaleMultiplier : 0;
  }
  controlsSprite(t) {
    return this._currentEmitter ? this._currentEmitter.roomObjectSpriteId == t : !1;
  }
  updateSprites() {
    !this._currentEmitter || !this._roomSprite || (this._canvasTexture && this._roomSprite.texture !== this._canvasTexture && (this._roomSprite.texture = this._canvasTexture), this._hasIgnited && this._currentEmitter.roomObjectSpriteId >= 0 && (this._visualization.getSprite(this._currentEmitter.roomObjectSpriteId).visible = !1));
  }
  updateAnimation() {
    if (!this._currentEmitter || !this._roomSprite || this._isDone) return;
    const t = 10;
    !this._hasIgnited && this._currentEmitter.hasIgnited && (this._hasIgnited = !0);
    const e = this._offsetY * this._scaleMultiplier;
    if (this._currentEmitter.update(), this._hasIgnited) {
      this._currentEmitter.roomObjectSpriteId >= 0 && (this._visualization.getSprite(this._currentEmitter.roomObjectSpriteId).visible = !1), this._canvasTexture || this.updateCanvas(), this.clearCanvas();
      for (const s of this._currentEmitter.particles) {
        const r = this._centerX + (s.x - s.z) * t / 10 * this._scaleMultiplier, n = this._centerY - e + (s.y + (s.x + s.z) / 2) * t / 10 * this._scaleMultiplier, a = s.getAsset();
        if (this._particleSprite.texture = null, this._particleSprite.tint = 16777215, this._particleSprite.width = 1, this._particleSprite.height = 1, this._particleSprite.x = 0, this._particleSprite.y = 0, this._particleSprite.filters = [], a && a.texture)
          if (this._particleSprite.texture = a.texture, this._particleSprite.width = a.texture.width, this._particleSprite.height = a.texture.height, s.fade && s.alphaMultiplier < 1)
            this._translationMatrix.identity(), this._translationMatrix.translate(r + a.offsetX, n + a.offsetY), this._particleColorTransform.alpha = s.alphaMultiplier, this._particleSprite.filters = [this._particleColorTransform], le.writeToTexture(this._particleSprite, this._canvasTexture, !1, this._translationMatrix);
          else {
            const o = new st(r + a.offsetX, n + a.offsetY);
            this._particleSprite.x = o.x, this._particleSprite.y = o.y, le.writeToTexture(this._particleSprite, this._canvasTexture, !1);
          }
        else
          this._particleSprite.tint = 16777215, this._particleSprite.x = r - 1, this._particleSprite.y = n - 1, this._particleSprite.width = 2, this._particleSprite.height = 2, le.writeToTexture(this._particleSprite, this._canvasTexture, !1);
      }
      if (!this._currentEmitter.particles.length) {
        this._isDone = !0;
        return;
      }
    }
  }
  parseData(t) {
    this._size = t.size, this._canvasId = t.canvasId !== void 0 ? t.canvasId : -1, this._offsetY = t.offsetY !== void 0 ? t.offsetY : 10, this._scaleMultiplier = this._size / 64, this._blend = t.blend !== void 0 ? t.blend : 1, this._blend = Math.min(this._blend, 1), this._blackOverlayAlphaTransform.alpha = this._blend;
    const e = t.bgColor !== void 0 ? t.bgColor : "0";
    if (this._bgColor = parseInt(e, 16) || 0, !(!t.emitters || !t.emitters.length))
      for (const s of t.emitters) {
        const r = s.id, n = s.name, a = s.spriteId, o = new VE(n, a);
        this._emitters.add(r, o);
        const h = s.maxNumParticles, u = s.particlesPerFrame, c = s.burstPulse !== void 0 ? s.burstPulse : 1, l = s.fuseTime, _ = s.simulation.force, d = s.simulation.direction, f = s.simulation.gravity, p = s.simulation.airFriction, g = s.simulation.shape, m = s.simulation.energy;
        for (const O of s.particles) {
          const y = O.lifeTime, C = O.isEmitter || !1, b = O.fade || !1, D = [];
          for (const P of O.frames) D.push(this._visualization.asset.getAsset(P));
          o.configureParticle(y, C, D, b);
        }
        o.setup(h, u, _, new v(0, d, 0), f, p, g, m, l, c);
      }
  }
  copyStateFrom(t) {
    let e = 0;
    t._emitters && t._currentEmitter && (e = t._emitters.getKey(t._emitters.getValues().indexOf(t._currentEmitter))), this.setAnimation(e), this._currentEmitter && this._currentEmitter.copyStateFrom(t._currentEmitter, t._size / this._size), this._canvasTexture && (this._canvasTexture.destroy(), this._canvasTexture = null);
  }
  clearCanvas() {
    this._emptySprite || (this._emptySprite = new Ft(W.EMPTY), this._emptySprite.alpha = 0), this._canvasTexture ? le.writeToTexture(this._emptySprite, this._canvasTexture, !0) : this._canvasTexture = le.createRenderTexture(this._roomSprite.width, this._roomSprite.height);
  }
}
class VM extends Te {
  dispose() {
    if (super.dispose(), this._currentParticleSystem = null, this._particleSystems) {
      for (const t of this._particleSystems.getValues()) t.dispose();
      this._particleSystems = null;
    }
  }
  updateObject(t, e) {
    if (super.updateObject(t, e)) {
      if (!this._particleSystems)
        this.readDefinition(), this._particleSystems ? this._currentParticleSystem = this._particleSystems.getValue(t) : rt.log("ERROR Particle systems could not be read!", this.object.type);
      else if (t !== this._scale || this._particleSystems.getValue(t) !== this._currentParticleSystem) {
        const s = this._particleSystems.getValue(t);
        if (!s) return !1;
        s.copyStateFrom(this._currentParticleSystem), this._currentParticleSystem && this._currentParticleSystem.reset(), this._currentParticleSystem = s;
      }
      return !0;
    }
    return !1;
  }
  updateSprites(t, e, s) {
    super.updateSprites(t, e, s), this._currentParticleSystem && this._currentParticleSystem.updateSprites();
  }
  updateAnimation(t) {
    return this._currentParticleSystem && this._currentParticleSystem.updateAnimation(), super.updateAnimation(t);
  }
  setAnimation(t) {
    this._currentParticleSystem && this._currentParticleSystem.setAnimation(t), super.setAnimation(t);
  }
  getLayerYOffset(t, e, s) {
    return this._currentParticleSystem && this._currentParticleSystem.controlsSprite(s) ? this._currentParticleSystem.getLayerYOffset(t, e, s) : super.getLayerYOffset(t, e, s);
  }
  readDefinition() {
    if (!this.object || !this.object.model) return !1;
    const t = this.object.model.getValue(I.FURNITURE_FIREWORKS_DATA);
    if (!t || !t.length) return !1;
    this._particleSystems = new be();
    for (const e of t) {
      const s = e.size, r = new zit(this);
      r.parseData(e), this._particleSystems.add(s, r);
    }
    return !0;
  }
}
const qr = class qr extends VM {
  constructor() {
    super(...arguments), this._packetType = 0, this._ribbonType = 0, this._lastAnimationId = 0;
  }
  update(t, e, s, r) {
    this.updatePresentWrap(), super.update(t, e, s, r);
  }
  updatePresentWrap() {
    if (!this.object) return;
    const t = 1e3, e = this.object.model.getValue(I.FURNITURE_EXTRAS), s = parseInt(e), r = Math.floor(s / t), n = s % t;
    this._packetType = r > qr.MAX_PACKET_TYPE_VALUE ? 0 : r, this._ribbonType = n > qr.MAX_RIBBON_TYPE_VALUE ? 0 : n;
  }
  getFrameNumber(t, e) {
    if (this._lastAnimationId === qr.PRESENT_DEFAULT_STATE) {
      if (e <= 1) return this._packetType;
      if (e === 2) return this._ribbonType;
    }
    return super.getFrameNumber(t, e);
  }
  getSpriteAssetName(t, e) {
    const s = this.getValidSize(t);
    let r = this._type, n = "";
    e < this.spriteCount - 1 ? n = String.fromCharCode(97 + e) : n = "sd";
    const a = this.getFrameNumber(t, e);
    return r = r + ("_" + s + "_" + n + "_" + this.direction), r = r + ("_" + a), r;
  }
  setAnimation(t) {
    this._lastAnimationId = t, super.setAnimation(t);
  }
};
qr.PRESENT_DEFAULT_STATE = 0, qr.MAX_PACKET_TYPE_VALUE = 9, qr.MAX_RIBBON_TYPE_VALUE = 11;
let HE = qr;
class Vit extends Xi {
  constructor() {
    super(...arguments), this._packetType = 0, this._ribbonType = 0;
  }
  update(t, e, s, r) {
    this.updatePresentWrap(), super.update(t, e, s, r);
  }
  updatePresentWrap() {
    if (!this.object) return;
    const t = this.object.model.getValue(I.FURNITURE_EXTRAS), e = 1e3, s = parseInt(t);
    this._packetType = Math.floor(s / e), this._ribbonType = s % e;
  }
  getFrameNumber(t, e) {
    return e <= 1 ? this._packetType : this._ribbonType;
  }
  getSpriteAssetName(t, e) {
    const s = this.getValidSize(t);
    let r = this._type, n = "";
    e < this.spriteCount - 1 ? n = String.fromCharCode(97 + e) : n = "sd";
    const a = this.getFrameNumber(t, e);
    return r = r + ("_" + s + "_" + n + "_" + this.direction), r = r + ("_" + a), r;
  }
}
const ss = class ss extends Te {
  constructor() {
    super(), this._color1 = ss.DEFAULT_COLOR_1, this._color2 = ss.DEFAULT_COLOR_2, this._badgeAssetNameNormalScale = "", this._badgeAssetNameSmallScale = "";
  }
  updateModel(t) {
    const e = super.updateModel(t);
    if (this._badgeAssetNameNormalScale === "") {
      const n = this.object.model.getValue(I.FURNITURE_GUILD_CUSTOMIZED_ASSET_NAME);
      n && (this._badgeAssetNameNormalScale = n, this._badgeAssetNameSmallScale = this._badgeAssetNameNormalScale + "_32");
    }
    const s = this.object.model.getValue(I.FURNITURE_GUILD_CUSTOMIZED_COLOR_1);
    this._color1 = s || ss.DEFAULT_COLOR_1;
    const r = this.object.model.getValue(I.FURNITURE_GUILD_CUSTOMIZED_COLOR_2);
    return this._color2 = r || ss.DEFAULT_COLOR_2, e;
  }
  getLayerColor(t, e, s) {
    switch (this.getLayerTag(t, this._direction, e)) {
      case ss.PRIMARY_COLOUR_SPRITE_TAG:
        return this._color1;
      case ss.SECONDARY_COLOUR_SPRITE_TAG:
        return this._color2;
    }
    return super.getLayerColor(t, e, s);
  }
  getSpriteAssetName(t, e) {
    return this.getLayerTag(t, this._direction, e) === ss.BADGE ? t === 32 ? this._badgeAssetNameSmallScale : this._badgeAssetNameNormalScale : super.getSpriteAssetName(t, e);
  }
  getLibraryAssetNameForSprite(t, e) {
    return e.tag === ss.BADGE ? "%group.badge.url%" + e.libraryAssetName.replace("badge_", "") : super.getLibraryAssetNameForSprite(t, e);
  }
};
ss.PRIMARY_COLOUR_SPRITE_TAG = "COLOR1", ss.SECONDARY_COLOUR_SPRITE_TAG = "COLOR2", ss.BADGE = "BADGE", ss.DEFAULT_COLOR_1 = 15658734, ss.DEFAULT_COLOR_2 = 4934475;
let YE = ss;
const oi = class oi extends Hc {
  updateModel(t) {
    const e = super.updateModel(t);
    if (!this.hasThumbnailImage) {
      const n = this.object.model.getValue(I.FURNITURE_GUILD_CUSTOMIZED_ASSET_NAME);
      n && n.length && this.setThumbnailImages(this.getBitmapAsset(n));
    }
    const s = this.object.model.getValue(I.FURNITURE_GUILD_CUSTOMIZED_COLOR_1);
    this._color1 = s || oi.DEFAULT_COLOR_1;
    const r = this.object.model.getValue(I.FURNITURE_GUILD_CUSTOMIZED_COLOR_2);
    return this._color2 = r || oi.DEFAULT_COLOR_2, e;
  }
  generateTransformedThumbnail(t, e) {
    const r = new ot(), n = e.width / t.width;
    switch (this.direction) {
      case 2:
        r.a = n, r.b = -0.5 * n, r.c = 0, r.d = n * 1.1, r.tx = 0, r.ty = 0.5 * n * t.width;
        break;
      case 0:
      case 4:
        r.a = n, r.b = 0.5 * n, r.c = 0, r.d = n * 1.1, r.tx = 0, r.ty = 0;
        break;
      default:
        r.a = n, r.b = 0, r.c = 0, r.d = n, r.tx = 0, r.ty = 0;
    }
    const a = new Ft(t);
    return a.setFromMatrix(r), a.x = 0, a.y = 0, le.generateTexture(a);
  }
  getLayerColor(t, e, s) {
    switch (this.getLayerTag(t, this._direction, e)) {
      case oi.PRIMARY_COLOUR_SPRITE_TAG:
        return this._color1;
      case oi.SECONDARY_COLOUR_SPRITE_TAG:
        return this._color2;
    }
    return super.getLayerColor(t, e, s);
  }
  getLibraryAssetNameForSprite(t, e) {
    return e.tag === oi.THUMBNAIL && this.object && this.object.model.getValue(I.FURNITURE_GUILD_CUSTOMIZED_ASSET_NAME) ? "%group.badge.url%" + this.object.model.getValue(I.FURNITURE_GUILD_CUSTOMIZED_ASSET_NAME) : super.getLibraryAssetNameForSprite(t, e);
  }
  getBitmapAsset(t) {
    const e = this.asset.getAsset(t);
    return !e || !e.texture ? null : e.texture;
  }
};
oi.PRIMARY_COLOUR_SPRITE_TAG = "COLOR1", oi.SECONDARY_COLOUR_SPRITE_TAG = "COLOR2", oi.DEFAULT_COLOR_1 = 15658734, oi.DEFAULT_COLOR_2 = 4934475;
let WE = oi;
const hi = class hi extends Te {
  constructor() {
    super(), this._stateQueue = [], this._running = !1;
  }
  setAnimation(t) {
    if (t === -1 && !this._running) {
      this._running = !0, this._stateQueue = [], this._stateQueue.push(hi.ANIMATION_ID_START_ROLL), this._stateQueue.push(hi.ANIMATION_ID_ROLL);
      return;
    }
    if (t > 0 && t <= hi.ANIMATION_ID_OFFSET_SLOW1) {
      if (this._running) {
        this._running = !1, this._stateQueue = [], this._stateQueue.push(hi.ANIMATION_ID_OFFSET_SLOW1 + t), this._stateQueue.push(hi.ANIMATION_ID_OFFSET_SLOW2 + t), this._stateQueue.push(t);
        return;
      }
      super.setAnimation(t);
    }
  }
  updateAnimation(t) {
    return this.getLastFramePlayed(1) && this.getLastFramePlayed(2) && this.getLastFramePlayed(3) && this._stateQueue.length && super.setAnimation(this._stateQueue.shift()), super.updateAnimation(t);
  }
};
hi.ANIMATION_ID_OFFSET_SLOW1 = 10, hi.ANIMATION_ID_OFFSET_SLOW2 = 20, hi.ANIMATION_ID_START_ROLL = 31, hi.ANIMATION_ID_ROLL = 32;
let jE = hi;
class Hit extends kM {
  constructor() {
    super(...arguments), this._needsTransform = !0;
  }
  generateTransformedImage(t, e) {
    const r = new ot(), n = e.width / t.width;
    switch (this.direction) {
      case 2:
        r.a = n, r.b = -0.5 * n, r.c = 0, r.d = n * 1.1, r.tx = 0, r.ty = 0.5 * n * t.width;
        break;
      case 0:
      case 4:
        r.a = n, r.b = 0.5 * n, r.c = 0, r.d = n * 1.1, r.tx = 0, r.ty = 0;
        break;
      default:
        r.a = n, r.b = 0, r.c = 0, r.d = n, r.tx = 0, r.ty = 0;
    }
    const a = new Ft(t), o = le.createAndWriteRenderTexture(e.width + r.tx, e.height + r.ty, a, r);
    this.asset.disposeAsset(`${this._imageUrl}_0`), this.asset.addAsset(`${this._imageUrl}_0`, o, !0, a.x, a.y, e.flipH, e.flipV), this._needsTransform = !1;
  }
  checkAndCreateImageForCurrentState() {
    super.checkAndCreateImageForCurrentState(), this._needsTransform = !0;
  }
  getSpriteAssetName(t, e) {
    return this.getLayerTag(t, this._direction, e) === Bu.BRANDED_IMAGE && this._imageUrl ? (this._needsTransform && this.generateTransformedImage(Rt().getTexture(this._imageUrl), this.getAsset(super.getSpriteAssetName(t, e))), `${this._imageUrl}_${this.getFrameNumber(t, e)}`) : super.getSpriteAssetName(t, e);
  }
}
class HM extends Yi {
  constructor() {
    super(), this._avatarData = new EI();
  }
  dispose() {
    super.dispose(), this._avatarData && (this._avatarData.dispose(), this._avatarData = null);
  }
  createAvatarImage(t, e, s = null, r = null, n = null) {
    return this._avatarData.createAvatarImage(t, e, s, r, n);
  }
}
const Co = class Co extends Xi {
  constructor() {
    super(...arguments), this._mannequinScale = -1, this._figure = null, this._gender = null, this._avatarImage = null, this._avatarWidth = 90, this._avatarHeight = 130, this._needsUpdate = !1, this._placeHolderFigure = "hd-99999-99998", this._disposed = !1;
  }
  initialize(t) {
    return t instanceof HM ? super.initialize(t) : !1;
  }
  dispose() {
    this._disposed || (this._disposed = !0, this._avatarImage && (this._avatarImage.dispose(), this._avatarImage = null), super.dispose());
  }
  updateObject(t, e) {
    const s = super.updateObject(t, e);
    return s && this._mannequinScale !== t && (this._mannequinScale = t, this.updateAvatar()), s;
  }
  updateModel(t) {
    let e = super.updateModel(t);
    if (e) {
      const s = this.object.model.getValue(I.FURNITURE_MANNEQUIN_FIGURE) || null;
      s && (this._figure = `${s}.${this._placeHolderFigure}`, this._gender = this.object.model.getValue(I.FURNITURE_MANNEQUIN_GENDER) || null, this.updateAvatar());
    }
    return e = e || this._needsUpdate, this._needsUpdate = !1, e;
  }
  updateAvatar() {
    this._avatarImage && (this._avatarImage.dispose(), this._avatarImage = null), this._avatarImage = this.data.createAvatarImage(this._figure, this._mannequinScale, this._gender, this);
  }
  resetFigure(t) {
    this.updateAvatar(), this._needsUpdate = !0;
  }
  getLayerXOffset(t, e, s) {
    return this.getLayerTag(t, e, s) === Co.AVATAR_IMAGE_SPRITE_TAG && this._avatarImage ? -this._avatarWidth / 3 : super.getLayerXOffset(t, e, s);
  }
  getLayerYOffset(t, e, s) {
    return this.getLayerTag(t, e, s) === Co.AVATAR_IMAGE_SPRITE_TAG && this._avatarImage ? -this._avatarHeight / 3 : super.getLayerYOffset(t, e, s);
  }
  getTexture(t, e, s) {
    return this.getLayerTag(t, this.direction, e) === Co.AVATAR_IMAGE_SPRITE_TAG && this._avatarImage ? (this._avatarImage.setDirection(gs.FULL, this.direction), this._avatarImage.processAsTexture(gs.FULL, !1)) : super.getTexture(t, e, s);
  }
  get disposed() {
    return this._disposed;
  }
  get data() {
    return this._data;
  }
};
Co.AVATAR_IMAGE_SPRITE_TAG = "avatar_image";
let XE = Co;
const Cs = class Cs extends Te {
  constructor() {
    super(), this._animOffsetIndex = [];
  }
  updateAnimation(t) {
    this._animSpeedIndex || this.initItems(t);
    let e = this.getSprite(2);
    return e && (this._animOffsetIndex[0] = this.getNewPoint(t, 0)), e = this.getSprite(3), e && (this._animOffsetIndex[1] = this.getNewPoint(t, 1)), super.updateAnimation(t);
  }
  getNewPoint(t, e) {
    let s = 0, r = this._animPhaseIndex[e], n = this._animDirectionIndex[e];
    const a = this._animSpeedIndex[e], o = this._animFactorIndex[e];
    let h = 1;
    t == 32 ? (s = Cs.AREA_DIAMETER_SMALL, h = 0.5) : s = Cs.AREA_DIAMETER_LARGE;
    const u = r + n * a;
    Math.abs(u) >= s && (n > 0 ? r = r - (u - s) : r = r + (-s - u), n = -n, this._animDirectionIndex[e] = n);
    const c = (s - Math.abs(r)) * o;
    let l = n * Math.sin(Math.abs(r / 4)) * c;
    return n > 0 ? l = l - c : l = l + c, r = r + n * a * h, this._animPhaseIndex[e] = r, Math.trunc(l) == 0 && (this._animFactorIndex[e] = this.getRandomAmplitudeFactor()), new st(r, l);
  }
  initItems(t) {
    let e;
    t === 32 ? e = Cs.AREA_DIAMETER_SMALL : e = Cs.AREA_DIAMETER_LARGE, this._animPhaseIndex = [], this._animPhaseIndex.push(Math.random() * e * 1.5), this._animPhaseIndex.push(Math.random() * e * 1.5), this._animDirectionIndex = [], this._animDirectionIndex.push(1), this._animDirectionIndex.push(-1), this._animSpeedIndex = [], this._animSpeedIndex.push(Cs.ANIM_SPEED_FAST), this._animSpeedIndex.push(Cs.ANIM_SPEED_SLOW), this._animFactorIndex = [], this._animFactorIndex.push(this.getRandomAmplitudeFactor()), this._animFactorIndex.push(this.getRandomAmplitudeFactor());
  }
  getLayerXOffset(t, e, s) {
    return (s === 2 || s === 3) && this._animOffsetIndex.length == 2 ? this._animOffsetIndex[s - 2].x : super.getLayerXOffset(t, e, s);
  }
  getLayerYOffset(t, e, s) {
    return (s === 2 || s === 3) && this._animOffsetIndex.length == 2 ? this._animOffsetIndex[s - 2].y : super.getLayerYOffset(t, e, s);
  }
  getRandomAmplitudeFactor() {
    return Math.random() * 30 / 100 + 0.15;
  }
};
Cs.UPDATE_INTERVAL = 2, Cs.AREA_DIAMETER_SMALL = 15, Cs.AREA_DIAMETER_LARGE = 31, Cs.ANIM_SPEED_FAST = 2, Cs.ANIM_SPEED_SLOW = 1;
let KE = Cs;
const Rd = class Rd {
  constructor(t, e, s, r, n, a) {
    this._name = t, this._index = e, this._radius = s, this._arcSpeed = r * Math.PI * 2 / 360, this._arcOffset = n * Math.PI * 2 / 360, this._height = a, this._position = 0, this._positionVector = new v(0, 0, 0), this._children = [];
  }
  dispose() {
    for (; this._children.length > 0; )
      this._children.shift().dispose();
  }
  update(t, e, s) {
    this._position = this._position + this._arcSpeed / Rd.SYSTEM_TEMPO, t[this._index] = this.getPositionVector(e, s);
    for (const r of this._children) r.update(t, this._positionVector, s);
  }
  getPositionVector(t, e) {
    const s = this._radius * Math.cos(this._position + this._arcOffset), r = this._radius * Math.sin(this._position + this._arcOffset);
    return this._positionVector.x = (s - r) * (e / 2), this._positionVector.y = (r + s) * (e / 2) * 0.5 - this._height * (e / 2), this._positionVector.z = -Math.trunc(4 * (s + r) - 0.7), t && this._positionVector.add(t), this._positionVector;
  }
  addChild(t) {
    this._children.indexOf(t) >= 0 || this._children.push(t);
  }
  hasChild(t) {
    return !!this.getChild(t);
  }
  getChild(t) {
    for (const e of this._children) {
      if (e.name === t) return e;
      if (e.hasChild(t)) return e.getChild(t);
    }
    return null;
  }
  get name() {
    return this._name;
  }
};
Rd.SYSTEM_TEMPO = 30;
let qE = Rd;
class Yit extends Te {
  constructor() {
    super(), this._offsetArray = [], this._rootPosition = new v();
  }
  dispose() {
    if (this._planetIndex)
      for (; this._planetIndex.length > 0; )
        this._planetIndex.shift().dispose();
    this._planetIndex = null, this._planetNameIndex = null;
  }
  updateAnimation(t) {
    if (!this._planetIndex && this.spriteCount > 0 && !this.processPlanets())
      return 0;
    if (this._planetIndex) {
      for (const e of this._planetIndex) e.update(this._offsetArray, this._rootPosition, t);
      return super.updateAnimation(t);
    }
    return 0;
  }
  getLayerXOffset(t, e, s) {
    return this._offsetArray[s] ? this._offsetArray[s].x : super.getLayerXOffset(t, e, s);
  }
  getLayerYOffset(t, e, s) {
    return this._offsetArray[s] ? this._offsetArray[s].y : super.getLayerYOffset(t, e, s);
  }
  getLayerZOffset(t, e, s) {
    return this._offsetArray[s] ? this._offsetArray[s].z : super.getLayerZOffset(t, e, s);
  }
  processPlanets() {
    if (!this.object || !this.object.model) return;
    const t = this.object.model.getValue(I.FURNITURE_PLANETSYSTEM_DATA);
    if (!t) return !1;
    this._planetIndex = [], this._planetNameIndex = [];
    for (const e of t)
      this.getSprite(e.id) && this.addPlanet(e.name, e.id, e.parent, e.radius || 0, e.arcSpeed || 0, e.arcOffset || 0, e.height || 0);
    return !0;
  }
  addPlanet(t, e, s, r, n, a, o) {
    if (!this._planetIndex) return;
    const h = new qE(t, e, r, n, a, o), u = this.getPlanet(s);
    u ? u.addChild(h) : (this._planetIndex.push(h), this._planetNameIndex.push(t));
  }
  getPlanet(t) {
    for (const e of this._planetIndex) {
      if (e.name === t) return e;
      if (e.hasChild(t)) return e.getChild(t);
    }
    return null;
  }
}
class Wit extends Te {
}
const cr = class cr extends Te {
  constructor() {
    super(), this._stateQueue = [], this._animationCounter = -1;
  }
  setAnimation(t) {
    return t === cr.ANIMATION_ID_ROLL_ONCE && (this._stateQueue = [], this._stateQueue.push(cr.ANIMATION_ID_NORMAL), this._animationCounter = cr.ANIMATION_DURATION), super.setAnimation(t);
  }
  updateAnimation(t) {
    return this._animationCounter > 0 && this._animationCounter--, this._animationCounter || this._stateQueue.length && super.setAnimation(this._stateQueue.shift()), super.updateAnimation(t);
  }
  usesAnimationResetting() {
    return !0;
  }
};
cr.ANIMATION_ID_ROLL = 3, cr.ANIMATION_ID_ROLL_ONCE = 2, cr.ANIMATION_ID_NORMAL = 1, cr.ANIMATION_DURATION = 15;
let $E = cr;
class jit extends Te {
  usesAnimationResetting() {
    return !0;
  }
}
class Xit extends Bu {
  imageReady(t, e) {
    super.imageReady(t, e), t && this.setImageOffset(t.width, t.height);
  }
  setImageOffset(t, e) {
    const s = new GM();
    s.setDirection(1, 0, -e), s.setDirection(3, 0, 0), s.setDirection(5, -t, 0), s.setDirection(7, -t, -e), s.setDirection(4, -t / 2, -e / 2), this._imageOffset = s;
  }
  getLayerXOffset(t, e, s) {
    if (this._imageOffset) {
      const r = this._imageOffset.getXOffset(e, 0);
      if (r !== void 0) return r + this._offsetX;
    }
    return super.getLayerXOffset(t, e, s) + this._offsetX;
  }
  getLayerYOffset(t, e, s) {
    if (this._imageOffset) {
      const r = this._imageOffset.getYOffset(e, 0);
      if (r !== void 0) return r + this._offsetY;
    }
    return super.getLayerYOffset(t, e, s) + this._offsetY;
  }
  getLayerZOffset(t, e, s) {
    return super.getLayerZOffset(t, e, s) + -this._offsetZ;
  }
  getLayerIgnoreMouse(t, e, s) {
    return !0;
  }
}
const Fi = class Fi extends Te {
  getFrameNumber(t, e) {
    const s = this.getLayerTag(t, this.direction, e), r = this.object.getState(0);
    switch (s) {
      case Fi.ONES_SPRITE:
        return Math.floor(r % 10);
      case Fi.TENS_SPRITE:
        return Math.floor(r / 10 % 10);
      case Fi.HUNDREDS_SPRITE:
        return Math.floor(r / 100 % 10);
      case Fi.THOUSANDS_SPRITE:
        return Math.floor(r / 1e3 % 10);
      default:
        return super.getFrameNumber(t, e);
    }
  }
};
Fi.ONES_SPRITE = "ones_sprite", Fi.TENS_SPRITE = "tens_sprite", Fi.HUNDREDS_SPRITE = "hundreds_sprite", Fi.THOUSANDS_SPRITE = "thousands_sprite";
let ZE = Fi;
class Kit extends Te {
  constructor() {
    super(...arguments), this._internalFrameIncreaseCounter = 0;
  }
  updateAnimations(t) {
    return this._internalFrameIncreaseCounter = this._internalFrameIncreaseCounter + this.object.model.getValue(I.FURNITURE_SOUNDBLOCK_RELATIVE_ANIMATION_SPEED), this._frameIncrease = this._internalFrameIncreaseCounter, this._internalFrameIncreaseCounter = this._internalFrameIncreaseCounter - this._frameIncrease, super.updateAnimations(t);
  }
}
class qit extends Xi {
  getLayerColor(t, e, s) {
    return this._data ? this._data.getLayerColor(t, e, s) : Aa.DEFAULT_COLOR;
  }
}
const He = class He extends Te {
  constructor() {
    super(), this._stateQueue = [], this._running = !1, super.setAnimation(He.ANIMATION_ID_OFF);
  }
  setAnimation(t) {
    if (t === 0 && !this._running) {
      this._running = !0, this._stateQueue = [], this._stateQueue.push(He.ANIMATION_ID_START_ROLL), this._stateQueue.push(He.ANIMATION_ID_ROLL);
      return;
    }
    if (t > 0 && t <= He.ANIMATION_ID_OFFSET_SLOW2) {
      if (this._running) {
        this._running = !1, this._stateQueue = [], this.direction === 2 ? (this._stateQueue.push(He.ANIMATION_ID_OFFSET_SLOW1 + 5), this._stateQueue.push(He.ANIMATION_ID_OFFSET_SLOW2 + 5)) : (this._stateQueue.push(He.ANIMATION_ID_OFFSET_SLOW1 + t), this._stateQueue.push(He.ANIMATION_ID_OFFSET_SLOW2 + t)), this._stateQueue.push(He.ANIMATION_ID_OFF);
        return;
      }
      super.setAnimation(He.ANIMATION_ID_OFF);
    }
  }
  updateAnimation(t) {
    return this.getLastFramePlayed(11) && this._stateQueue.length && super.setAnimation(this._stateQueue.shift()), super.updateAnimation(t);
  }
};
He.ANIMATION_ID_OFFSET_SLOW1 = 20, He.ANIMATION_ID_OFFSET_SLOW2 = 10, He.ANIMATION_ID_START_ROLL = 31, He.ANIMATION_ID_ROLL = 32, He.ANIMATION_ID_OFF = 30;
let QE = He;
const xs = class xs extends Te {
  updateObject(t, e) {
    return super.updateObject(t, e), !0;
  }
  getFrameNumber(t, e) {
    const s = this.object.model.getValue(I.FURNITURE_VOTE_COUNTER_COUNT);
    switch (this.getLayerTag(t, this.direction, e)) {
      case xs.ONES_SPRITE:
        return s % 10;
      case xs.TENS_SPRITE:
        return s / 10 % 10;
      case xs.HUNDREDS_SPRITE:
        return s / 100 % 10;
      default:
        return super.getFrameNumber(t, e);
    }
  }
  getLayerAlpha(t, e, s) {
    if (this.object.model.getValue(I.FURNITURE_VOTE_COUNTER_COUNT) === xs.HIDE_COUNTER_SCORE)
      switch (this.getLayerTag(t, e, s)) {
        case xs.ONES_SPRITE:
        case xs.TENS_SPRITE:
        case xs.HUNDREDS_SPRITE:
          return 0;
      }
    return super.getLayerAlpha(t, e, s);
  }
};
xs.ONES_SPRITE = "ones_sprite", xs.TENS_SPRITE = "tens_sprite", xs.HUNDREDS_SPRITE = "hundreds_sprite", xs.HIDE_COUNTER_SCORE = -1;
let JE = xs;
const is = class is extends Te {
  getFrameNumber(t, e) {
    const s = this.object.model.getValue(I.FURNITURE_VOTE_MAJORITY_RESULT);
    switch (this.getLayerTag(t, this.direction, e)) {
      case is.ONES_SPRITE:
        return s % 10;
      case is.TENS_SPRITE:
        return s / 10 % 10;
      case is.HUNDREDS_SPRITE:
        return s / 100 % 10;
      default:
        return super.getFrameNumber(t, e);
    }
  }
  getLayerAlpha(t, e, s) {
    const r = this.object.model.getValue(I.FURNITURE_VOTE_MAJORITY_RESULT);
    if (is.HIDE_RESULTS_STATES.indexOf(this.object.getState(0)) !== -1 || r === is.HIDE_RESULTS_VALUE)
      switch (this.getLayerTag(t, e, s)) {
        case is.ONES_SPRITE:
        case is.TENS_SPRITE:
        case is.HUNDREDS_SPRITE:
          return 0;
      }
    return super.getLayerAlpha(t, e, s);
  }
};
is.ONES_SPRITE = "ones_sprite", is.TENS_SPRITE = "tens_sprite", is.HUNDREDS_SPRITE = "hundreds_sprite", is.HIDE_RESULTS_STATES = [-1, 1], is.HIDE_RESULTS_VALUE = -1;
let tT = is;
class $it extends Te {
}
const Od = class Od extends zM {
  getThumbnailURL() {
    if (!this.object) return null;
    const t = this.object.model.getValue(I.FURNITURE_DATA);
    return t && t[Od.THUMBNAIL_URL] || null;
  }
};
Od.THUMBNAIL_URL = "THUMBNAIL_URL";
let eT = Od;
class Zit {
  constructor(t) {
    this._sprite = new Ft(t), this._texture = null, this._amount = -1, this._alpha = 0;
  }
  renderBubble(t) {
    if (!this._sprite || this._amount === t) return null;
    const e = new Qt();
    e.addChild(this._sprite);
    const s = new OD({
      text: "+" + t,
      style: new ga({
        fontFamily: "Arial",
        fontSize: 9,
        fill: 16777215,
        align: "center"
      })
    });
    return s.anchor.x = 0.5, s.x = this._sprite.width / 2, s.y = 19, e.addChild(s), this._texture ? le.writeToTexture(e, this._texture, !0) : this._texture = le.generateTexture(e), this._texture;
  }
  get amount() {
    return this._amount;
  }
  set amount(t) {
    this._amount = t;
  }
  get alpha() {
    return this._alpha;
  }
  set alpha(t) {
    this._alpha = t;
  }
}
class YM extends TI {
  constructor() {
    super(), this._isAllowedToTurnHead = !0;
  }
  createSizeData(t, e, s) {
    return t > 1 ? new Fn(e, s) : new zc(e, s);
  }
  defineVisualizations(t) {
    return this._isAllowedToTurnHead = !0, super.defineVisualizations(t);
  }
  processVisualElement(t, e, s) {
    if (!t || !e || !s) return !1;
    switch (e) {
      case "postures":
        if (!(t instanceof Fn) || !t.processPostures(s)) return !1;
        break;
      case "gestures":
        if (!(t instanceof Fn) || !t.processGestures(s)) return !1;
        break;
      default:
        if (!super.processVisualElement(t, e, s)) return !1;
        break;
    }
    return !0;
  }
  postureToAnimation(t, e) {
    const s = this.getSizeData(t);
    return s ? s.postureToAnimation(e) : Fn.DEFAULT;
  }
  getGestureDisabled(t, e) {
    const s = this.getSizeData(t);
    return s ? s.getGestureDisabled(e) : !1;
  }
  gestureToAnimation(t, e) {
    const s = this.getSizeData(t);
    return s ? s.gestureToAnimation(e) : Fn.DEFAULT;
  }
  animationToPosture(t, e, s) {
    const r = this.getSizeData(t);
    return r ? r.animationToPosture(e, s) : null;
  }
  animationToGesture(t, e) {
    const s = this.getSizeData(t);
    return s ? s.animationToGesture(e) : null;
  }
  getGestureForAnimationId(t, e) {
    const s = this.getSizeData(t);
    return s ? s.getGestureForAnimationId(e) : null;
  }
  totalPostures(t) {
    const e = this.getSizeData(t);
    return e ? e.totalPostures : 0;
  }
  totalGestures(t) {
    const e = this.getSizeData(t);
    return e ? e.totalGestures : 0;
  }
  get isAllowedToTurnHead() {
    return this._isAllowedToTurnHead;
  }
}
const te = class te extends Te {
  constructor() {
    for (super(), this._posture = "", this._gesture = "", this._isSleeping = !1, this._headDirection = -1, this._headOnly = !1, this._nonHeadSprites = [], this._headSprites = [], this._saddleSprites = [], this._animationOver = !1, this._paletteIndex = -1, this._paletteName = "", this._customLayerIds = [], this._customPartIds = [], this._customPaletteIds = [], this._isRiding = !1, this._color = 16777215, this._experience = 0, this._experienceTimestamp = 0, this._experienceData = null, this._previousAnimationDirection = -1, this._animationStates = []; this._animationStates.length < te.ANIMATION_INDEX_COUNT; ) this._animationStates.push(new BM());
  }
  initialize(t) {
    if (!(t instanceof YM)) return !1;
    const e = Rt().getTexture(te.PET_EXPERIENCE_BUBBLE);
    return e && (this._experienceData = new Zit(e)), super.initialize(t);
  }
  dispose() {
    if (super.dispose(), this._animationStates) {
      for (; this._animationStates.length; ) {
        const t = this._animationStates[0];
        t && t.dispose(), this._animationStates.pop();
      }
      this._animationStates = null;
    }
  }
  getAnimationId(t) {
    return t.animationId;
  }
  update(t, e, s, r) {
    super.update(t, e, s, r), this.updateExperienceBubble(e);
  }
  updateExperienceBubble(t) {
    if (this._experienceData && (this._experienceData.alpha = 0, this._experienceTimestamp)) {
      const e = t - this._experienceTimestamp;
      e < te.EXPERIENCE_BUBBLE_VISIBLE_IN_MS ? this._experienceData.alpha = Math.sin(e / te.EXPERIENCE_BUBBLE_VISIBLE_IN_MS * Math.PI) * 255 : this._experienceTimestamp = 0;
      const s = this.getSprite(this.totalSprites - 1);
      if (s) {
        if (this._experienceData.alpha > 0) {
          const r = this._experienceData.renderBubble(this._experience);
          if (r) {
            s.texture = r, s.offsetX = -20, s.offsetY = -80, s.alpha = this._experienceData.alpha, s.visible = !0, s.relativeDepth = -0.2;
            return;
          }
        }
        s.texture = null, s.visible = !1;
      }
    }
  }
  updateModel(t) {
    const e = this.object && this.object.model;
    if (!e || this.updateModelCounter === e.updateCounter) return !1;
    const s = e.getValue(I.FIGURE_POSTURE), r = e.getValue(I.FIGURE_GESTURE);
    this.setPostureAndGesture(s, r);
    let n = e.getValue(I.FURNITURE_ALPHA_MULTIPLIER) || null;
    (n === null || isNaN(n)) && (n = 1), this._alphaMultiplier !== n && (this._alphaMultiplier = n, this._alphaChanged = !0), this._isSleeping = e.getValue(I.FIGURE_SLEEP) > 0;
    const a = e.getValue(I.HEAD_DIRECTION);
    !isNaN(a) && this.data.isAllowedToTurnHead ? this._headDirection = a : this._headDirection = this.object.getDirection().x, this._experience = e.getValue(I.FIGURE_GAINED_EXPERIENCE), this._experienceTimestamp = e.getValue(I.FIGURE_EXPERIENCE_TIMESTAMP);
    const o = e.getValue(I.PET_PALETTE_INDEX), h = e.getValue(I.PET_CUSTOM_LAYER_IDS), u = e.getValue(I.PET_CUSTOM_PARTS_IDS), c = e.getValue(I.PET_CUSTOM_PALETTE_IDS), l = e.getValue(I.PET_IS_RIDING), _ = e.getValue(I.PET_HEAD_ONLY), d = e.getValue(I.PET_COLOR);
    return o !== this._paletteIndex && (this._paletteIndex = o, this._paletteName = this._paletteIndex.toString()), this._customLayerIds = h || [], this._customPartIds = u || [], this._customPaletteIds = c || [], this._isRiding = !isNaN(l) && l > 0, this._headOnly = !isNaN(_) && _ > 0, !isNaN(d) && this._color !== d && (this._color = d), this.updateModelCounter = e.updateCounter, !0;
  }
  updateAnimation(t) {
    if (this.object) {
      const e = this.object.getDirection().x;
      e !== this._previousAnimationDirection && (this._previousAnimationDirection = e, this.resetAllAnimationFrames());
    }
    return super.updateAnimation(t);
  }
  setPostureAndGesture(t, e) {
    this.data && (t !== this._posture && (this._posture = t, this.setAnimationForIndex(te.POSTURE_ANIMATION_INDEX, this.data.postureToAnimation(this._scale, t))), this.data.getGestureDisabled(this._scale, t) && (e = null), e !== this._gesture && (this._gesture = e, this.setAnimationForIndex(te.GESTURE_ANIMATION_INDEX, this.data.gestureToAnimation(this._scale, e))));
  }
  getAnimationStateData(t) {
    return t >= 0 && t < this._animationStates.length ? this._animationStates[t] : null;
  }
  setAnimationForIndex(t, e) {
    const s = this.getAnimationStateData(t);
    s && this.setSubAnimation(s, e) && (this._animationOver = !1);
  }
  resetAllAnimationFrames() {
    this._animationOver = !1;
    let t = this._animationStates.length - 1;
    for (; t >= 0; ) {
      const e = this._animationStates[t];
      e && e.setLayerCount(this.animatedLayerCount), t--;
    }
  }
  updateAnimations(t) {
    if (this._animationOver) return 0;
    let e = !0, s = 0, r = 0;
    for (; r < this._animationStates.length; ) {
      const n = this._animationStates[r];
      if (n && !n.animationOver) {
        const a = this.updateFramesForAnimation(n, t);
        s = s | a, n.animationOver ? (xe.isTransitionFromAnimation(n.animationId) || xe.isTransitionToAnimation(n.animationId)) && (this.setAnimationForIndex(r, n.animationAfterTransitionId), e = !1) : e = !1;
      }
      r++;
    }
    return this._animationOver = e, s;
  }
  getSpriteAssetName(t, e) {
    if (this._headOnly && this.isNonHeadSprite(e) || this._isRiding && this._parser3(e)) return null;
    const s = this.totalSprites;
    if (e < s - te.ADDITIONAL_SPRITE_COUNT) {
      const r = this.getValidSize(t);
      if (e < s - (1 + te.ADDITIONAL_SPRITE_COUNT)) {
        if (e >= Yi.LAYER_LETTERS.length) return null;
        const n = Yi.LAYER_LETTERS[e];
        return r === 1 ? this._type + "_icon_" + n : this._type + "_" + r + "_" + n + "_" + this.getDirection(t, e) + "_" + this.getFrameNumber(r, e);
      }
      return this._type + "_" + r + "_sd_" + this.getDirection(t, e) + "_0";
    }
    return null;
  }
  getLayerColor(t, e, s) {
    return e < this.totalSprites - te.ADDITIONAL_SPRITE_COUNT ? this._color : 16777215;
  }
  getLayerXOffset(t, e, s) {
    let r = super.getLayerXOffset(t, e, s), n = this._animationStates.length - 1;
    for (; n >= 0; ) {
      const a = this._animationStates[n];
      if (a) {
        const o = a.getFrame(s);
        o && (r += o.x);
      }
      n--;
    }
    return r;
  }
  getLayerYOffset(t, e, s) {
    let r = super.getLayerYOffset(t, e, s), n = this._animationStates.length - 1;
    for (; n >= 0; ) {
      const a = this._animationStates[n];
      if (a) {
        const o = a.getFrame(s);
        o && (r += o.y);
      }
      n--;
    }
    return r;
  }
  getLayerZOffset(t, e, s) {
    return this.data ? this.data.getLayerZOffset(t, this.getDirection(t, s), s) : Vt.DEFAULT_ZOFFSET;
  }
  getDirection(t, e) {
    return this.isHeadSprite(e) ? this.data.getValidDirection(t, this._headDirection) : this._direction;
  }
  getFrameNumber(t, e) {
    let s = this._animationStates.length - 1;
    for (; s >= 0; ) {
      const r = this._animationStates[s];
      if (r) {
        const n = r.getFrame(e);
        if (n) return n.id;
      }
      s--;
    }
    return super.getFrameNumber(t, e);
  }
  isHeadSprite(t) {
    if (this._headSprites[t] === void 0) {
      const e = this.data.getLayerTag(this._scale, an.USE_DEFAULT_DIRECTION, t) === te.HEAD, s = this.data.getLayerTag(this._scale, an.USE_DEFAULT_DIRECTION, t) === te.HAIR;
      e || s ? this._headSprites[t] = !0 : this._headSprites[t] = !1;
    }
    return this._headSprites[t];
  }
  isNonHeadSprite(t) {
    if (this._nonHeadSprites[t] === void 0)
      if (t < this.totalSprites - (1 + te.ADDITIONAL_SPRITE_COUNT)) {
        const e = this.data.getLayerTag(this._scale, an.USE_DEFAULT_DIRECTION, t);
        e && e.length > 0 && e !== te.HEAD && e !== te.HAIR ? this._nonHeadSprites[t] = !0 : this._nonHeadSprites[t] = !1;
      } else
        this._nonHeadSprites[t] = !0;
    return this._nonHeadSprites[t];
  }
  _parser3(t) {
    return this._saddleSprites[t] === void 0 && (this.data.getLayerTag(this._scale, an.USE_DEFAULT_DIRECTION, t) === te.SADDLE ? this._saddleSprites[t] = !0 : this._saddleSprites[t] = !1), this._saddleSprites[t];
  }
  getAsset(t, e = -1) {
    if (!this.asset) return null;
    const s = this._customLayerIds.indexOf(e);
    let r = this._paletteName, n = -1, a = -1;
    return s > -1 && (n = this._customPartIds[s], a = this._customPaletteIds[s], r = a > -1 ? a.toString() : this._paletteName), !isNaN(n) && n > -1 && (t = t + "_" + n), this.asset.getAssetWithPalette(t, r);
  }
  getAdditionalLayerCount() {
    return super.getAdditionalLayerCount() + te.ADDITIONAL_SPRITE_COUNT;
  }
  setLayerCount(t) {
    super.setLayerCount(t), this._headSprites = [];
  }
  getPostureForAsset(t, e) {
    const s = e.split("_");
    let r = s.length, n = 0;
    for (; n < s.length; ) {
      if (s[n] === "64" || s[n] === "32") {
        r = n + 3;
        break;
      }
      n++;
    }
    let a = null;
    if (r < s.length) {
      let o = s[r];
      o = o.split("@")[0], a = this.data.animationToPosture(t, parseInt(o) / 100, !1), a || (a = this.data.getGestureForAnimationId(t, parseInt(o) / 100));
    }
    return a;
  }
  get data() {
    return this._data;
  }
};
te.TYPE = j.PET_ANIMATED, te.HEAD = "head", te.SADDLE = "saddle", te.HAIR = "hair", te.ADDITIONAL_SPRITE_COUNT = 1, te.EXPERIENCE_BUBBLE_VISIBLE_IN_MS = 1e3, te.PET_EXPERIENCE_BUBBLE = "avatar_addition_pet_experience_bubble", te.POSTURE_ANIMATION_INDEX = 0, te.GESTURE_ANIMATION_INDEX = 1, te.ANIMATION_INDEX_COUNT = 2;
let sT = te;
class cnt {
  constructor(t = null, e = 0, s = !1) {
    this._assetNames = [], this._maskAssetNames = [], this._maskAssetLocations = [], this._maskAssetFlipHs = [], this._maskAssetFlipVs = [], t != null && (this._maskAssetNames = t._maskAssetNames, this._maskAssetLocations = t._maskAssetLocations, this._maskAssetFlipHs = t._maskAssetFlipHs, this._maskAssetFlipVs = t._maskAssetFlipVs), this._color = e, this._alignBottom = s;
  }
  addMask(t, e, s, r) {
    this._maskAssetNames.push(t), this._maskAssetLocations.push(e), this._maskAssetFlipHs.push(s), this._maskAssetFlipVs.push(r);
  }
  addAssetColumn(t) {
    this._assetNames.push(t);
  }
  set z(t) {
    this._z = t;
  }
  get z() {
    return this._z;
  }
  set cornerPoints(t) {
    this._points = t;
  }
  get cornerPoints() {
    return this._points;
  }
  get color() {
    return this._color;
  }
  get maskAssetNames() {
    return this._maskAssetNames;
  }
  get maskAssetLocations() {
    return this._maskAssetLocations;
  }
  get maskAssetFlipHs() {
    return this._maskAssetFlipHs;
  }
  get maskAssetFlipVs() {
    return this._maskAssetFlipVs;
  }
  isBottomAligned() {
    return this._alignBottom;
  }
  get assetNameColumns() {
    return this._assetNames;
  }
}
class Qit {
  constructor(t, e, s) {
    this._type = t, this._leftSideLoc = e, this._rightSideLoc = s;
  }
  get type() {
    return this._type;
  }
  get leftSideLoc() {
    return this._leftSideLoc;
  }
  get rightSideLoc() {
    return this._rightSideLoc;
  }
}
class Jit {
  constructor(t, e, s, r) {
    this._leftSideLoc = t, this._rightSideLoc = e, this._leftSideLength = s, this._rightSideLength = r;
  }
  get leftSideLoc() {
    return this._leftSideLoc;
  }
  get rightSideLoc() {
    return this._rightSideLoc;
  }
  get leftSideLength() {
    return this._leftSideLength;
  }
  get rightSideLength() {
    return this._rightSideLength;
  }
}
class _nt {
  constructor(t, e) {
    this._texture = t, this._timeStamp = e;
  }
  dispose() {
    this._texture = null;
  }
  get texture() {
    return this._texture;
  }
  get timeStamp() {
    return this._timeStamp;
  }
}
const Re = class Re {
  constructor() {
    this._seed = 1, this._modulus = 16777216, this._multiplier = 69069, this._increment = 5;
  }
  static setSeed(t = 1) {
    Re._randomizer || (Re._randomizer = new Re()), Re._randomizer.seed = t;
  }
  static setModulus(t = 16777216) {
    Re._randomizer || (Re._randomizer = new Re()), Re._randomizer.modulus = t;
  }
  static getValues(t, e, s) {
    return Re._randomizer || (Re._randomizer = new Re()), Re._randomizer.getRandomValues(t, e, s);
  }
  static getArray(t, e) {
    return Re._randomizer || (Re._randomizer = new Re()), Re._randomizer.getRandomArray(t, e);
  }
  set seed(t) {
    this._seed = t;
  }
  set modulus(t) {
    t < 1 && (t = 1), this._modulus = t;
  }
  dispose() {
  }
  getRandomValues(t, e, s) {
    const r = [];
    let n = 0;
    for (; n < t; )
      r.push(this.iterateScaled(e, s - e)), n++;
    return r;
  }
  getRandomArray(t, e) {
    if (t > e || e > 1e3) return null;
    const s = [];
    let r = 0;
    for (; r <= e; )
      s.push(r), r++;
    const n = [];
    let a = 0;
    for (; a < t; ) {
      const o = this.iterateScaled(0, s.length - 1);
      n.push(s[o]), s.splice(o, 1), a++;
    }
    return n;
  }
  iterate() {
    let t = sy(Math.trunc(this._multiplier * this._seed) + this._increment);
    return t < 0 && (t = -t), t = t % this._modulus, this._seed = t, t;
  }
  iterateScaled(t, e) {
    let s = this.iterate();
    return e < 1 ? t : (s = Math.trunc(t + s / this._modulus * e), s);
  }
};
Re.DEFAULT_SEED = 1, Re.DEFAULT_MODULUS = 16777216, Re._randomizer = null;
let iT = Re;
const se = class se {
  constructor(t, e, s, r, n, a, o, h, u = 0, c = 0, l = 0, _ = 0) {
    if (this._disposed = !1, this._origin = new v(), this._location = new v(), this._leftSide = new v(), this._rightSide = new v(), this._normal = null, this._secondaryNormals = [], this._isVisible = !1, this._offset = new st(), this._relativeDepth = 0, this._color = 0, this._maskManager = null, this._id = null, this._cornerA = new v(), this._cornerB = new v(), this._cornerC = new v(), this._cornerD = new v(), this._width = 0, this._height = 0, this._hasTexture = !0, this._canBeVisible = !0, this._geometryUpdateId = -1, this._extraDepth = 0, this._isHighlighter = !1, this._bitmapMasks = [], this._rectangleMasks = [], this._maskChanged = !1, this._bitmapMasksOld = [], this._rectangleMasksOld = [], this._planeSprite = null, this._planeTexture = null, this._maskFilter = null, this._randomSeed = h, this._origin.assign(t), this._location.assign(e), this._leftSide.assign(s), this._rightSide.assign(r), this._normal = v.crossProduct(this._leftSide, this._rightSide), this._normal.length > 0 && this._normal.multiply(1 / this._normal.length), o != null)
      for (const d of o) {
        if (!d) continue;
        const f = new v();
        f.assign(d), this._secondaryNormals.push(f);
      }
    this._type = n, this._textureOffsetX = u, this._textureOffsetY = c, this._textureMaxX = l, this._textureMaxY = _, this._useMask = a, this._uniqueId = ++se._uniqueIdCounter;
  }
  dispose() {
    this._location = null, this._origin = null, this._leftSide = null, this._rightSide = null, this._normal = null, this._cornerA = null, this._cornerB = null, this._cornerC = null, this._cornerD = null, this._planeSprite && this._planeSprite.destroy(), this._planeTexture && (on().putTexture(this._planeTexture), this._planeTexture = null), this._disposed = !0;
  }
  update(t, e, s = !1) {
    if (!t || this._disposed || (this._geometryUpdateId !== t.updateId && (this._geometryUpdateId = t.updateId, s = !0), (!s || !this._canBeVisible) && !this.visible))
      return !1;
    if (s) {
      let r = 0;
      if (r = v.cosAngle(t.directionAxis, this.normal), r > -1e-3)
        return this._isVisible ? (this._isVisible = !1, !0) : !1;
      let n = 0;
      for (; n < this._secondaryNormals.length; ) {
        if (r = v.cosAngle(t.directionAxis, this._secondaryNormals[n]), r > -1e-3)
          return this._isVisible ? (this._isVisible = !1, !0) : !1;
        n++;
      }
      this.updateCorners(t);
      let a = Math.max(this._cornerA.z, this._cornerB.z, this._cornerC.z, this._cornerD.z) - t.getScreenPosition(this._origin).z;
      switch (this._type) {
        case se.TYPE_FLOOR:
          a = a - (this._location.z + Math.min(0, this._leftSide.z, this._rightSide.z)) * 8;
          break;
        case se.TYPE_LANDSCAPE:
          a = a + 0.02;
          break;
      }
      this._relativeDepth = a, this._isVisible = !0, iT.setSeed(this._randomSeed);
      const o = se.PLANE_GEOMETRY[t.scale];
      let h = this._leftSide.length * t.scale, u = this._rightSide.length * t.scale;
      t.getCoordinatePosition(this._normal);
      const l = ((d, f) => {
        var M, U, k, ft, K, Y, ut, Gt, V, Mt;
        const p = f === se.TYPE_FLOOR ? "floorData" : f === se.TYPE_WALL ? "wallData" : "landscapeData", g = Rt().getCollection("room"), m = (U = (M = g == null ? void 0 : g.data) == null ? void 0 : M.roomVisualization) == null ? void 0 : U[p], O = (k = m == null ? void 0 : m.planes) == null ? void 0 : k.find((X) => X.id === d), y = ((ft = p === "landscapeData" ? O == null ? void 0 : O.animatedVisualization : O == null ? void 0 : O.visualizations) == null ? void 0 : ft.find((X) => X.size === o.scale)) ?? null, C = (K = y == null ? void 0 : y.allLayers) == null ? void 0 : K[0], b = C == null ? void 0 : C.materialId, D = C == null ? void 0 : C.color, P = (V = (Gt = (ut = (Y = m == null ? void 0 : m.textures) == null ? void 0 : Y.find((X) => X.id === b)) == null ? void 0 : ut.bitmaps) == null ? void 0 : Gt[0]) == null ? void 0 : V.assetName;
        return { texture: (Mt = Rt().getAsset(P)) == null ? void 0 : Mt.texture, color: D };
      })(this._id, this._type), _ = this._hasTexture ? l.texture ?? W.WHITE : W.WHITE;
      switch (this._type) {
        case se.TYPE_FLOOR: {
          const d = o.getScreenPoint(new v(0, 0, 0)), f = o.getScreenPoint(new v(0, u / o.scale, 0)), p = o.getScreenPoint(new v(h / o.scale, 0, 0));
          let g = 0, m = 0;
          if (d && f && p) {
            h = Math.round(Math.abs(d.x - p.x)), u = Math.round(Math.abs(d.x - f.x));
            const O = d.x - o.getScreenPoint(new v(1, 0, 0)).x;
            g = this._textureOffsetX * Math.trunc(Math.abs(O)), m = this._textureOffsetY * Math.trunc(Math.abs(O));
          }
          if (g !== 0 || m !== 0) {
            for (; g < 0; ) g += _.width;
            for (; m < 0; ) m += _.height;
          }
          this._planeSprite = new hl({
            texture: _,
            width: h,
            height: u,
            tint: l.color,
            tilePosition: {
              x: g % _.width + this._textureOffsetX * _.width,
              y: m % _.height + this._textureOffsetY * _.height
            }
          });
          break;
        }
        case se.TYPE_WALL: {
          const d = o.getScreenPoint(new v(0, 0, 0)), f = o.getScreenPoint(new v(0, 0, u / o.scale)), p = o.getScreenPoint(new v(0, h / o.scale, 0));
          d && f && p && (h = Math.round(Math.abs(d.x - p.x)), u = Math.round(Math.abs(d.y - f.y))), this._planeSprite = new hl({
            texture: _,
            width: h,
            height: u,
            tint: l.color,
            tilePosition: {
              x: this._textureOffsetX * _.width,
              y: this._textureOffsetY * _.height
            }
          });
          break;
        }
        case se.TYPE_LANDSCAPE: {
          const d = o.getScreenPoint(new v(0, 0, 0)), f = o.getScreenPoint(new v(0, 0, 1)), p = o.getScreenPoint(new v(0, 1, 0));
          d && f && p && (h = Math.round(Math.abs((d.x - p.x) * h / o.scale)), u = Math.round(Math.abs((d.y - f.y) * u / o.scale))), Math.trunc(this._textureMaxX * Math.abs(d.x - p.x)), Math.trunc(this._textureMaxY * Math.abs(d.y - f.y));
          const g = Math.trunc(this._textureOffsetX * Math.abs(d.x - p.x)), m = Math.trunc(this._textureOffsetY * Math.abs(d.y - f.y));
          this._planeSprite = new hl({
            texture: _,
            width: h,
            height: u,
            tilePosition: {
              x: g,
              y: m
            },
            tint: se.LANDSCAPE_COLOR
          });
          break;
        }
        default:
          this._planeSprite = new hl({
            texture: W.WHITE,
            width: h,
            height: u
          });
      }
      this._planeSprite.allowChildren = !0;
    }
    return (s || this._maskChanged) && (this.updateMask(this._planeSprite, t), s = !0), this._planeTexture && (this._planeTexture.width !== this._width || this._planeTexture.height !== this._height) && (on().putTexture(this._planeTexture), this._planeTexture = null), this._planeTexture || (this._planeTexture = on().getTexture(this._width, this._height)), this._planeTexture.source.label = `room_plane_${this._uniqueId.toString()}`, s && ma().render({
      target: this._planeTexture,
      container: this._planeSprite,
      transform: this.getMatrixForDimensions(this._planeSprite.width, this._planeSprite.height),
      clear: !0
    }), !0;
  }
  updateCorners(t) {
    this._cornerA.assign(t.getScreenPosition(this._location)), this._cornerB.assign(t.getScreenPosition(v.sum(this._location, this._rightSide))), this._cornerC.assign(t.getScreenPosition(v.sum(v.sum(this._location, this._leftSide), this._rightSide))), this._cornerD.assign(t.getScreenPosition(v.sum(this._location, this._leftSide))), this._offset = t.getScreenPoint(this._origin), this._cornerA.x = Math.round(this._cornerA.x), this._cornerA.y = Math.round(this._cornerA.y), this._cornerB.x = Math.round(this._cornerB.x), this._cornerB.y = Math.round(this._cornerB.y), this._cornerC.x = Math.round(this._cornerC.x), this._cornerC.y = Math.round(this._cornerC.y), this._cornerD.x = Math.round(this._cornerD.x), this._cornerD.y = Math.round(this._cornerD.y), this._offset.x = Math.round(this._offset.x), this._offset.y = Math.round(this._offset.y);
    const e = Math.min(this._cornerA.x, this._cornerB.x, this._cornerC.x, this._cornerD.x), s = Math.max(this._cornerA.x, this._cornerB.x, this._cornerC.x, this._cornerD.x) - e, r = Math.min(this._cornerA.y, this._cornerB.y, this._cornerC.y, this._cornerD.y), n = Math.max(this._cornerA.y, this._cornerB.y, this._cornerC.y, this._cornerD.y) - r;
    this._offset.x = this._offset.x - e, this._cornerA.x = this._cornerA.x - e, this._cornerB.x = this._cornerB.x - e, this._cornerC.x = this._cornerC.x - e, this._cornerD.x = this._cornerD.x - e, this._offset.y = this._offset.y - r, this._cornerA.y = this._cornerA.y - r, this._cornerB.y = this._cornerB.y - r, this._cornerC.y = this._cornerC.y - r, this._cornerD.y = this._cornerD.y - r, this._width = s, this._height = n;
  }
  getMatrixForDimensions(t, e) {
    let s = this._cornerD.x - this._cornerC.x, r = this._cornerD.y - this._cornerC.y, n = this._cornerB.x - this._cornerC.x, a = this._cornerB.y - this._cornerC.y;
    (this._type === se.TYPE_WALL || this._type === se.TYPE_LANDSCAPE) && (Math.abs(n - t) <= 1 && (n = t), Math.abs(a - t) <= 1 && (a = t), Math.abs(s - e) <= 1 && (s = e), Math.abs(r - e) <= 1 && (r = e));
    const o = n / t, h = a / t, u = s / e, c = r / e, l = new ot(o, h, u, c);
    return l.translate(this._cornerC.x, this._cornerC.y), l;
  }
  resetBitmapMasks() {
    this._disposed || !this._useMask || !this._bitmapMasks.length || (this._maskChanged = !0, this._bitmapMasks = []);
  }
  addBitmapMask(t, e, s) {
    if (!this._useMask) return !1;
    for (const n of this._bitmapMasks)
      if (n && n.type === t && n.leftSideLoc === e && n.rightSideLoc === s)
        return !1;
    const r = new Qit(t, e, s);
    return this._bitmapMasks.push(r), this._maskChanged = !0, !0;
  }
  resetRectangleMasks() {
    !this._useMask || !this._rectangleMasks.length || (this._maskChanged = !0, this._rectangleMasks = []);
  }
  addRectangleMask(t, e, s, r) {
    if (this._useMask) {
      for (const n of this._rectangleMasks)
        if (n && n.leftSideLoc === t && n.rightSideLoc === e && n.leftSideLength === s && n.rightSideLength === r)
          return !1;
      return this._rectangleMasks.push(new Jit(t, e, s, r)), this._maskChanged = !0, !0;
    }
    return !1;
  }
  updateMask(t, e) {
    var h;
    if ((h = t.children) != null && h.length && t.removeChildren(), !t || !e || !this._useMask || !this._bitmapMasks.length && !this._rectangleMasks.length || !this._maskManager) return !1;
    const s = e.getCoordinatePosition(this._normal);
    let r = null, n = 0, a = 0, o = 0;
    for (; o < this._bitmapMasks.length; ) {
      const u = this._bitmapMasks[o];
      u && (r = u.type, n = t.width - t.width * u.leftSideLoc / this._leftSide.length, a = t.height - t.height * u.rightSideLoc / this._rightSide.length, this._maskManager.addMaskToContainer(t, r, e.scale, s, n, a)), o++;
    }
    for (o = 0; o < this._rectangleMasks.length; ) {
      const u = this._rectangleMasks[o];
      if (u) {
        n = t.width - t.width * u.leftSideLoc / this._leftSide.length, a = t.height - t.height * u.rightSideLoc / this._rightSide.length;
        const c = t.width * u.leftSideLength / this._leftSide.length, l = t.height * u.rightSideLength / this._rightSide.length, _ = new Ft(W.WHITE);
        _.tint = 0, _.width = c, _.height = l, _.position.set(Math.trunc(n - c), Math.trunc(a - l)), t.addChild(_);
      }
      o++;
    }
    return this._maskChanged = !1, this._maskFilter || (this._maskFilter = new qg({})), t.filters || (t.filters = [this._maskFilter]), !0;
  }
  get canBeVisible() {
    return this._canBeVisible;
  }
  set canBeVisible(t) {
    t !== this._canBeVisible && (this._canBeVisible = t);
  }
  get visible() {
    return this._isVisible && this._canBeVisible;
  }
  get offset() {
    return this._offset;
  }
  get relativeDepth() {
    return this._relativeDepth + this._extraDepth;
  }
  set extraDepth(t) {
    this._extraDepth = t;
  }
  get color() {
    return this._color;
  }
  set color(t) {
    this._color = t;
  }
  get type() {
    return this._type;
  }
  get leftSide() {
    return this._leftSide;
  }
  get rightSide() {
    return this._rightSide;
  }
  get location() {
    return this._location;
  }
  get normal() {
    return this._normal;
  }
  set id(t) {
    t !== this._id && (this._id = t);
  }
  set maskManager(t) {
    this._maskManager = t;
  }
  get uniqueId() {
    return this._uniqueId;
  }
  get planeTexture() {
    return this._planeTexture;
  }
  set hasTexture(t) {
    this._hasTexture = t;
  }
  get isHighlighter() {
    return this._isHighlighter;
  }
  set isHighlighter(t) {
    this._isHighlighter = t;
  }
};
se.HORIZONTAL_ANGLE_DEFAULT = 45, se.VERTICAL_ANGLE_DEFAULT = 30, se.PLANE_GEOMETRY = {
  32: new $s(32, new v(se.HORIZONTAL_ANGLE_DEFAULT, se.VERTICAL_ANGLE_DEFAULT), new v(-10, 0, 0)),
  64: new $s(64, new v(se.HORIZONTAL_ANGLE_DEFAULT, se.VERTICAL_ANGLE_DEFAULT), new v(-10, 0, 0))
}, se.LANDSCAPE_COLOR = 33520, se.TYPE_UNDEFINED = 0, se.TYPE_WALL = 1, se.TYPE_FLOOR = 2, se.TYPE_LANDSCAPE = 3, se._uniqueIdCounter = 1;
let Yt = se;
const yd = class yd {
  constructor(t, e = -1, s = 1, r = -1, n = 1) {
    this._normalMinX = e, this._normalMaxX = s, this._normalMinY = r, this._normalMaxY = n, this._asset = t;
  }
  get asset() {
    return this._asset;
  }
  get normalMinX() {
    return this._normalMinX;
  }
  get normalMaxX() {
    return this._normalMaxX;
  }
  get normalMinY() {
    return this._normalMinY;
  }
  get normalMaxY() {
    return this._normalMaxY;
  }
  dispose() {
    this._asset = null;
  }
};
yd.MIN_NORMAL_COORDINATE_VALUE = -1, yd.MAX_NORMAL_COORDINATE_VALUE = 1;
let rT = yd;
const vd = class vd {
  constructor() {
    this._bitmaps = [];
  }
  dispose() {
    for (const t of this._bitmaps)
      t && t.dispose();
    this._bitmaps = null;
  }
  addBitmap(t, e = -1, s = 1, r = -1, n = 1) {
    this._bitmaps.push(new rT(t, e, s, r, n));
  }
  getAsset(t) {
    if (!t) return null;
    for (const e of this._bitmaps)
      if (e && t.x >= e.normalMinX && t.x <= e.normalMaxX && t.y >= e.normalMinY && t.y <= e.normalMaxY)
        return e.asset;
    return null;
  }
};
vd.MIN_NORMAL_COORDINATE_VALUE = -1, vd.MAX_NORMAL_COORDINATE_VALUE = 1;
let ua = vd;
class trt {
  constructor() {
    this._sizes = [], this._maskVisualizations = /* @__PURE__ */ new Map(), this._assetNames = /* @__PURE__ */ new Map(), this._lastMaskVisualization = null, this._lastSize = -1;
  }
  dispose() {
    if (this._maskVisualizations) {
      for (const t of this._maskVisualizations.values())
        t && t.dispose();
      this._maskVisualizations = null;
    }
    this._lastMaskVisualization = null, this._sizes = null;
  }
  createMaskVisualization(t) {
    if (this._maskVisualizations.get(t)) return null;
    const s = new ua();
    return this._maskVisualizations.set(t, s), this._sizes.push(t), this._sizes.sort(), s;
  }
  getSizeIndex(t) {
    let e = 0, s = 1;
    for (; s < this._sizes.length; ) {
      if (this._sizes[s] > t) {
        this._sizes[s] - t < t - this._sizes[s - 1] && (e = s);
        break;
      }
      e = s, s++;
    }
    return e;
  }
  getMaskVisualization(t) {
    if (t === this._lastSize) return this._lastMaskVisualization;
    const e = this.getSizeIndex(t);
    return e < this._sizes.length ? this._lastMaskVisualization = this._maskVisualizations.get(this._sizes[e]) : this._lastMaskVisualization = null, this._lastSize = t, this._lastMaskVisualization;
  }
  getGraphicAsset(t, e) {
    const s = this.getMaskVisualization(t);
    return s ? s.getAsset(e) : null;
  }
  getAssetName(t) {
    return this._assetNames && this._assetNames.get(t) || null;
  }
  setAssetName(t, e) {
    this._assetNames && this._assetNames.set(t, e);
  }
}
class ert {
  constructor() {
    this._assetCollection = null, this._masks = /* @__PURE__ */ new Map(), this._data = null;
  }
  get data() {
    return this._data;
  }
  dispose() {
    if (this._assetCollection = null, this._data = null, this._masks && this._masks.size) {
      for (const t of this._masks.values())
        t && t.dispose();
      this._masks.clear();
    }
  }
  initialize(t) {
    this._data = t;
  }
  initializeAssetCollection(t) {
    this.data && (this._assetCollection = t, this.parseMasks(this.data, t));
  }
  parseMasks(t, e) {
    if (!(!t || !e) && t.masks && t.masks.length) {
      let s = 0;
      for (; s < t.masks.length; ) {
        const r = t.masks[s];
        if (r) {
          const n = r.id;
          if (this._masks.get(n)) continue;
          const o = new trt();
          if (r.visualizations && r.visualizations.length) {
            let h = 0;
            for (; h < r.visualizations.length; ) {
              const u = r.visualizations[h];
              if (u) {
                const c = u.size, l = o.createMaskVisualization(c);
                if (l) {
                  const _ = this.parseMaskBitmaps(u.bitmaps, l, e);
                  o.setAssetName(c, _);
                }
              }
              h++;
            }
          }
          this._masks.set(n, o);
        }
        s++;
      }
    }
  }
  parseMaskBitmaps(t, e, s) {
    if (!t || !t.length) return null;
    let r = null;
    for (const n of t) {
      if (!n) continue;
      const a = n.assetName, o = s.getAsset(a);
      if (!o) continue;
      let h = ua.MIN_NORMAL_COORDINATE_VALUE, u = ua.MAX_NORMAL_COORDINATE_VALUE, c = ua.MIN_NORMAL_COORDINATE_VALUE, l = ua.MAX_NORMAL_COORDINATE_VALUE;
      n.normalMinX !== void 0 && (h = n.normalMinX), n.normalMaxX !== void 0 && (u = n.normalMaxX), n.normalMinY !== void 0 && (c = n.normalMinY), n.normalMaxY !== void 0 && (l = n.normalMaxY), o.flipH || (r = a), e.addBitmap(o, h, u, c, l);
    }
    return r;
  }
  addMaskToContainer(t, e, s, r, n, a) {
    const o = this._masks.get(e);
    if (!o) return !0;
    const h = o.getGraphicAsset(s, r);
    if (!h) return !0;
    const u = h.texture;
    if (!u) return !0;
    const c = new st(n + h.offsetX, a + h.offsetY), l = new ot();
    let _ = 1, d = 1, f = 0, p = 0, g = c.x + f, m = c.y + p;
    h.flipH && (_ = -1, f = u.width, g = c.x + f - u.width), h.flipV && (d = -1, p = u.height, m = c.y + p - u.height), l.scale(_, d), l.translate(g, m);
    const O = new Ft(u);
    return O.setFromMatrix(l), t.addChild(O), !0;
  }
  writeMaskToTexture(t, e, s, r, n, a) {
    const o = this._masks.get(e);
    if (!o) return !0;
    const h = o.getGraphicAsset(s, r);
    if (!h) return !0;
    const u = h.texture;
    if (!u) return !0;
    const c = new st(n + h.offsetX, a + h.offsetY), l = new ot();
    let _ = 1, d = 1, f = 0, p = 0, g = c.x + f, m = c.y + p;
    return h.flipH && (_ = -1, f = u.width, g = c.x + f - u.width), h.flipV && (d = -1, p = u.height, m = c.y + p - u.height), l.scale(_, d), l.translate(g, m), ma().render({
      target: t,
      container: new Ft(u),
      clear: !1,
      transform: l
    }), !0;
  }
  getMask(t) {
    return !this._masks || !this._masks.size ? null : this._masks.get(t) || null;
  }
}
class WM {
  constructor() {
    this._maskManager = new ert(), this._initialized = !1;
  }
  initialize(t) {
    if (!t.roomVisualization) return !1;
    const e = t.roomVisualization.maskData;
    return e && this._maskManager.initialize(e), !0;
  }
  dispose() {
    this._maskManager && (this._maskManager.dispose(), this._maskManager = null);
  }
  setGraphicAssetCollection(t) {
    this._initialized || (this._maskManager.initializeAssetCollection(t), this._initialized = !0);
  }
  clearCache() {
  }
  get maskManager() {
    return this._maskManager;
  }
}
const re = class re extends Ko {
  constructor() {
    super(), this._data = null, this._roomPlaneParser = new ye(), this._roomPlaneBitmapMaskParser = new mM(), this._geometryUpdateId = -1, this._boundingRectangle = null, this._directionX = 0, this._directionY = 0, this._directionZ = 0, this._floorThickness = 1, this._wallThickness = 1, this._holeUpdateTime = NaN, this._planes = [], this._visiblePlanes = [], this._visiblePlaneSpriteNumbers = [], this._roomScale = 0, this._colorBackgroundOnly = !0, this._color = 16777215, this._redColor = 16777215, this._greenColor = 16777215, this._blueColor = 16777215, this._wallType = null, this._floorType = null, this._landscapeType = null, this._typeVisibility = [], this._assetUpdateCounter = 0, this._maskData = null, this._isPlaneSet = !1, this._highlightAreaX = 0, this._highlightAreaY = 0, this._highlightAreaWidth = 0, this._highlightAreaHeight = 0, this._highlightFilter = null, this._highlightPlaneOffsets = [], this._typeVisibility[Yt.TYPE_UNDEFINED] = !1, this._typeVisibility[Yt.TYPE_FLOOR] = !0, this._typeVisibility[Yt.TYPE_WALL] = !0, this._typeVisibility[Yt.TYPE_LANDSCAPE] = !0;
  }
  initialize(t) {
    return t instanceof WM ? (this._data = t, super.initialize(t), this._data.setGraphicAssetCollection(this.asset), !0) : !1;
  }
  dispose() {
    super.dispose(), this.clearPlanes(), this._planes = null, this._visiblePlanes = null, this._visiblePlaneSpriteNumbers = null, this._highlightPlaneOffsets = [], this._roomPlaneParser && (this._roomPlaneParser.dispose(), this._roomPlaneParser = null), this._roomPlaneBitmapMaskParser && (this._roomPlaneBitmapMaskParser.dispose(), this._roomPlaneBitmapMaskParser = null), this._data && (this._data.clearCache(), this._data = null);
  }
  reset() {
    super.reset(), this._floorType = null, this._wallType = null, this._landscapeType = null, this._maskData = null, this._geometryUpdateId = -1, this._roomScale = 0;
  }
  update(t, e, s, r) {
    if (!this.object || !t) return;
    const n = this.updateGeometry(t), a = this.object.model;
    let o = n;
    if (this.updateThickness(a) && (o = !0), this.updateHole(a) && (o = !0), this.initializeRoomPlanes(), this.updateMasks(a) && (o = !0), this.updatePlaneTexturesAndVisibilities(a) && (o = !0), this.updatePlanes(t, n, e, o) && (o = !0), o) {
      let h = 0;
      for (; h < this._visiblePlanes.length; ) {
        const u = this._visiblePlaneSpriteNumbers[h], c = this.getSprite(u), l = this._visiblePlanes[h];
        if (c && l && l.type !== Yt.TYPE_LANDSCAPE)
          if (this._colorBackgroundOnly) {
            let _ = l.color;
            const d = (_ & 255) * this._redColor / 255, f = (_ >> 8 & 255) * this._greenColor / 255, p = (_ >> 16 & 255) * this._blueColor / 255;
            _ = (_ >> 24 << 24) + (p << 16) + (f << 8) + d, c.color = _;
          } else
            c.color = l.color;
        h++;
      }
    }
    this.updateSpriteCounter++, this.updateModelCounter = a.updateCounter;
  }
  updateGeometry(t) {
    if (!t || this._geometryUpdateId === t.updateId) return !1;
    this._geometryUpdateId = t.updateId, this._boundingRectangle = null;
    const e = t.direction;
    return e && (e.x !== this._directionX || e.y !== this._directionY || e.z !== this._directionZ || t.scale !== this._roomScale) ? (this._directionX = e.x, this._directionY = e.y, this._directionZ = e.z, this._roomScale = t.scale, !0) : !1;
  }
  updateThickness(t) {
    if (this.updateModelCounter === t.updateCounter) return !1;
    const e = t.getValue(I.ROOM_FLOOR_THICKNESS), s = t.getValue(I.ROOM_WALL_THICKNESS);
    return !isNaN(e) && !isNaN(s) && (e !== this._floorThickness || s !== this._wallThickness) ? (this._floorThickness = e, this._wallThickness = s, this.clearPlanes(), !0) : !1;
  }
  updateHole(t) {
    if (this.updateModelCounter === t.updateCounter) return !1;
    const e = t.getValue(I.ROOM_FLOOR_HOLE_UPDATE_TIME);
    return !isNaN(e) && e !== this._holeUpdateTime ? (this._holeUpdateTime = e, this.clearPlanes(), !0) : !1;
  }
  updatePlaneTexturesAndVisibilities(t) {
    if (this.updateModelCounter === t.updateCounter) return !1;
    const e = t.getValue(I.ROOM_FLOOR_TYPE), s = t.getValue(I.ROOM_WALL_TYPE), r = t.getValue(I.ROOM_LANDSCAPE_TYPE), n = t.getValue(I.ROOM_FLOOR_VISIBILITY) === 1, a = t.getValue(I.ROOM_WALL_VISIBILITY) === 1, o = t.getValue(I.ROOM_LANDSCAPE_VISIBILITY) === 1;
    let h = !1;
    return h = this.updatePlaneTypes(e, s, r), h = this.updatePlaneVisibility(n, a, o) ? !0 : h, h;
  }
  updateMasks(t) {
    if (this.updateModelCounter === t.updateCounter) return !1;
    let e = !1;
    const s = t.getValue(I.ROOM_PLANE_MASK_XML);
    s !== this._maskData && (this.updatePlaneMasks(s), this._maskData = s, e = !0);
    const r = t.getValue(I.ROOM_BACKGROUND_COLOR);
    r !== this._color && (this._color = r, this._redColor = this._color & 255, this._greenColor = this._color >> 8 & 255, this._blueColor = this._color >> 16 & 255, e = !0);
    const n = t.getValue(I.ROOM_COLORIZE_BG_ONLY) || !1;
    return n !== this._colorBackgroundOnly && (this._colorBackgroundOnly = n, e = !0), e;
  }
  clearPlanes() {
    if (this._planes) {
      for (; this._planes.length; ) {
        const t = this._planes[0];
        t && t.dispose(), this._planes.shift();
      }
      this._planes = [], this._highlightPlaneOffsets = [];
    }
    this._isPlaneSet = !1, this._assetUpdateCounter = this._assetUpdateCounter + 1, this.reset();
  }
  initializeRoomPlanes() {
    if (!this.object || this._isPlaneSet) return;
    isNaN(this._floorThickness) || (this._roomPlaneParser.floorThicknessMultiplier = this._floorThickness), isNaN(this._wallThickness) || (this._roomPlaneParser.wallThicknessMultiplier = this._wallThickness), this._roomPlaneParser.clearHighlightArea();
    const t = this.object.model.getValue(I.ROOM_MAP_DATA);
    this._roomPlaneParser.initializeFromMapData(t) && (this._roomPlaneParser.initializeHighlightArea(this._highlightAreaX, this._highlightAreaY, this._highlightAreaWidth, this._highlightAreaHeight), this.createPlanesAndSprites());
  }
  createPlanesAndSprites(t = 0) {
    const e = this.getLandscapeWidth(), s = this.getLandscapeHeight();
    let r = 0, n = this.object.model.getValue(I.ROOM_RANDOM_SEED), a = t;
    for (; a < this._roomPlaneParser.planeCount; ) {
      this._highlightPlaneOffsets[a] = -1;
      const o = this._roomPlaneParser.getPlaneLocation(a), h = this._roomPlaneParser.getPlaneLeftSide(a), u = this._roomPlaneParser.getPlaneRightSide(a), c = this._roomPlaneParser.getPlaneSecondaryNormals(a), l = this._roomPlaneParser.getPlaneType(a);
      let _ = null;
      if (o && h && u) {
        const d = v.crossProduct(h, u);
        if (n = sy(Math.trunc(n * 7613 + 517) >>> 0), _ = null, l === ue.PLANE_FLOOR) {
          const f = o.x + h.x + 0.5, p = o.y + u.y + 0.5, g = Math.trunc(f) - f, m = Math.trunc(p) - p;
          _ = new Yt(this.object.getLocation(), o, h, u, Yt.TYPE_FLOOR, !0, c, n, -g, -m), _.color = d.z !== 0 ? re.FLOOR_COLOR : d.x !== 0 ? re.FLOOR_COLOR_RIGHT : re.FLOOR_COLOR_LEFT;
        } else l === ue.PLANE_WALL ? (_ = new Yt(this.object.getLocation(), o, h, u, Yt.TYPE_WALL, !0, c, n), (h.length < 1 || u.length < 1) && (_.hasTexture = !1), _.color = d.x === 0 && d.y === 0 ? re.WALL_COLOR_BORDER : d.y > 0 ? re.WALL_COLOR_TOP : d.y === 0 ? re.WALL_COLOR_SIDE : re.WALL_COLOR_BOTTOM) : l === ue.PLANE_LANDSCAPE && (_ = new Yt(this.object.getLocation(), o, h, u, Yt.TYPE_LANDSCAPE, !0, c, n, r, 0, e, s), (h.length < 1 || u.length < 1) && (_.hasTexture = !1), _.color = d.y > 0 ? re.LANDSCAPE_COLOR_TOP : d.y === 0 ? re.LANDSCAPE_COLOR_SIDE : re.LANDSCAPE_COLOR_BOTTOM, r = r + h.length);
        if (_) {
          _.maskManager = this._data.maskManager;
          let f = 0;
          for (; f < this._roomPlaneParser.getPlaneMaskCount(a); ) {
            const p = this._roomPlaneParser.getPlaneMaskLeftSideLoc(a, f), g = this._roomPlaneParser.getPlaneMaskRightSideLoc(a, f), m = this._roomPlaneParser.getPlaneMaskLeftSideLength(a, f), O = this._roomPlaneParser.getPlaneMaskRightSideLength(a, f);
            _.addRectangleMask(p, g, m, O), f++;
          }
          this._highlightPlaneOffsets[a] = this._planes.length, this._planes.push(_);
        }
      } else
        return;
      a++;
    }
    this._isPlaneSet = !0, this.defineSprites();
  }
  initializeHighlightArea(t, e, s, r, n) {
    this.clearHighlightArea(), this._highlightAreaX = t, this._highlightAreaY = e, this._highlightAreaWidth = s, this._highlightAreaHeight = r, this._highlightFilter = n, this._roomPlaneParser.initializeHighlightArea(t, e, s, r), this.createPlanesAndSprites(this._planes.length), this.reset();
  }
  clearHighlightArea() {
    this._highlightAreaX = 0, this._highlightAreaY = 0, this._highlightAreaWidth = 0, this._highlightAreaHeight = 0;
    const t = this._roomPlaneParser.clearHighlightArea();
    let e = 0, s = this._roomPlaneParser.planeCount;
    for (; s < this._roomPlaneParser.planeCount + t; )
      this._highlightPlaneOffsets[s] !== -1 && (e = e + 1, this._highlightPlaneOffsets[s] = -1), s = s + 1;
    this._planes = this._planes.slice(0, this._planes.length - e), this.createSprites(this._planes.length), this.reset();
  }
  defineSprites() {
    this.createSprites(this._planes.length);
    let t = 0;
    for (; t < this._planes.length; ) {
      const e = this._planes[t], s = this.getSprite(t);
      e && s && e.leftSide && e.rightSide && (e.type === Yt.TYPE_WALL && (e.leftSide.length < 1 || e.rightSide.length < 1) ? s.alphaTolerance = _i.MATCH_NOTHING : s.alphaTolerance = _i.MATCH_OPAQUE_PIXELS, e.type === Yt.TYPE_WALL ? s.tag = "plane.wall@" + (t + 1) : e.type === Yt.TYPE_FLOOR ? s.tag = "plane.floor@" + (t + 1) : s.tag = "plane@" + (t + 1), s.spriteType = Us.ROOM_PLANE, this._roomPlaneParser.isPlaneTemporaryHighlighter(t) ? (this._highlightFilter && (s.filters = [this._highlightFilter]), s.skipMouseHandling = !0, e.extraDepth = -100, e.isHighlighter = !0) : (s.filters = [], s.skipMouseHandling = !1, e.extraDepth = 0, e.isHighlighter = !1)), t++;
    }
  }
  getLandscapeWidth() {
    let t = 0, e = 0;
    for (; e < this._roomPlaneParser.planeCount; ) {
      if (this._roomPlaneParser.getPlaneType(e) === ue.PLANE_LANDSCAPE) {
        const r = this._roomPlaneParser.getPlaneLeftSide(e);
        t += r.length;
      }
      e++;
    }
    return t;
  }
  getLandscapeHeight() {
    let t = 0, e = 0;
    for (; e < this._roomPlaneParser.planeCount; ) {
      if (this._roomPlaneParser.getPlaneType(e) === ue.PLANE_LANDSCAPE) {
        const r = this._roomPlaneParser.getPlaneRightSide(e);
        r.length > t && (t = r.length);
      }
      e++;
    }
    return t > 5 && (t = 5), t;
  }
  updatePlaneTypes(t, e, s) {
    if (t !== this._floorType ? this._floorType = t : t = null, e !== this._wallType ? this._wallType = e : e = null, s !== this._landscapeType ? this._landscapeType = s : s = null, !t && !e && !s) return !1;
    let r = 0;
    for (; r < this._planes.length; ) {
      const n = this._planes[r];
      n && (n.type === Yt.TYPE_FLOOR && t ? n.id = t : n.type === Yt.TYPE_WALL && e ? n.id = e : n.type === Yt.TYPE_LANDSCAPE && s && (n.id = s)), r++;
    }
    return !0;
  }
  updatePlaneVisibility(t, e, s) {
    return t === this._typeVisibility[Yt.TYPE_FLOOR] && e === this._typeVisibility[Yt.TYPE_WALL] && s === this._typeVisibility[Yt.TYPE_LANDSCAPE] ? !1 : (this._typeVisibility[Yt.TYPE_FLOOR] = t, this._typeVisibility[Yt.TYPE_WALL] = e, this._typeVisibility[Yt.TYPE_LANDSCAPE] = s, this._visiblePlanes = [], this._visiblePlaneSpriteNumbers = [], !0);
  }
  updatePlanes(t, e, s, r = !1) {
    if (!t || !this.object) return !1;
    this._assetUpdateCounter++, e && (this._visiblePlanes = [], this._visiblePlaneSpriteNumbers = []);
    const n = this._visiblePlanes.length > 0;
    let a = this._visiblePlanes;
    this._visiblePlanes.length || (a = this._planes);
    let o = 0, h = !1, u = 0;
    for (; u < a.length; ) {
      let c = u;
      n && (c = this._visiblePlaneSpriteNumbers[u]);
      const l = this.getSprite(c);
      if (l) {
        const _ = a[u];
        _ ? (l.id = _.uniqueId, _.update(t, s, r) && (_.visible && (o = _.relativeDepth + this.floorRelativeDepth + c / 1e3, _.type !== Yt.TYPE_FLOOR && (o = _.relativeDepth + this.wallRelativeDepth + c / 1e3, (_.leftSide.length < 1 || _.rightSide.length < 1) && (o = o + re.ROOM_DEPTH_OFFSET * 0.5)), this.updateSprite(l, t, _, `plane ${c} ${t.scale}`, o)), h = !0), l.visible != (_.visible && this._typeVisibility[_.type]) && (l.visible = !l.visible, h = !0), l.visible && (n || (this._visiblePlanes.push(_), this._visiblePlaneSpriteNumbers.push(u)))) : (l.id = 0, l.visible && (l.visible = !1, h = !0));
      }
      u++;
    }
    return h;
  }
  updatePlaneMasks(t) {
    if (!t) return;
    this._roomPlaneBitmapMaskParser.initialize(t);
    const e = [], s = [];
    let r = !1, n = 0;
    for (; n < this._planes.length; ) {
      const a = this._planes[n];
      a && (a.resetBitmapMasks(), a.type === Yt.TYPE_LANDSCAPE && e.push(n)), n++;
    }
    for (const a of this._roomPlaneBitmapMaskParser.masks.values()) {
      const o = this._roomPlaneBitmapMaskParser.getMaskType(a), h = this._roomPlaneBitmapMaskParser.getMaskLocation(a), u = this._roomPlaneBitmapMaskParser.getMaskCategory(a);
      if (h) {
        let c = 0;
        for (; c < this._planes.length; ) {
          const l = this._planes[c];
          if ((l.type === Yt.TYPE_WALL || l.type === Yt.TYPE_LANDSCAPE) && l && l.location && l.normal) {
            const _ = v.dif(h, l.location);
            if (Math.abs(v.scalarProjection(_, l.normal)) < 0.01 && l.leftSide && l.rightSide) {
              const f = v.scalarProjection(_, l.leftSide), p = v.scalarProjection(_, l.rightSide);
              l.type === Yt.TYPE_WALL || l.type === Yt.TYPE_LANDSCAPE && u === Ia.HOLE ? l.addBitmapMask(o, f, p) : l.type === Yt.TYPE_LANDSCAPE && (l.canBeVisible || (r = !0), l.canBeVisible = !0, s.push(c));
            }
          }
          c++;
        }
      }
    }
    for (n = 0; n < e.length; ) {
      const a = e[n];
      if (s.indexOf(a) < 0) {
        const o = this._planes[a];
        o.canBeVisible = !1, r = !0;
      }
      n++;
    }
    r && (this._visiblePlanes = [], this._visiblePlaneSpriteNumbers = []);
  }
  updateSprite(t, e, s, r, n) {
    const a = s.offset;
    t.offsetX = -a.x, t.offsetY = -a.y, t.relativeDepth = n, t.color = s.color, t.texture = s.planeTexture ?? W.EMPTY, t.name = r + "_" + this._assetUpdateCounter;
  }
  getBoundingRectangle() {
    return this._boundingRectangle || (this._boundingRectangle = super.getBoundingRectangle()), new Kt(this._boundingRectangle.x, this._boundingRectangle.y, this._boundingRectangle.width, this._boundingRectangle.height);
  }
  get planes() {
    const t = [];
    for (const e of this._visiblePlanes) t.push(e);
    return t;
  }
  get floorRelativeDepth() {
    return re.ROOM_DEPTH_OFFSET + 0.1;
  }
  get wallRelativeDepth() {
    return re.ROOM_DEPTH_OFFSET + 0.5;
  }
};
re.FLOOR_COLOR = 16777215, re.FLOOR_COLOR_LEFT = 14540253, re.FLOOR_COLOR_RIGHT = 12303291, re.WALL_COLOR_TOP = 16777215, re.WALL_COLOR_SIDE = 13421772, re.WALL_COLOR_BOTTOM = 10066329, re.WALL_COLOR_BORDER = 10066329, re.LANDSCAPE_COLOR_TOP = 16777215, re.LANDSCAPE_COLOR_SIDE = 13421772, re.LANDSCAPE_COLOR_BOTTOM = 10066329, re.ROOM_DEPTH_OFFSET = 1e3;
let nT = re;
class srt extends Te {
  constructor() {
    super(), this._tileHeight = 0;
  }
  getLayerYOffset(t, e, s) {
    return s === 1 ? (this._tileHeight = this.object.model.getValue(I.TILE_CURSOR_HEIGHT), -this._tileHeight * 32) : super.getLayerYOffset(t, e, s);
  }
}
class irt {
  constructor() {
    this._events = x(), this._cachedEvents = /* @__PURE__ */ new Map(), this._registeredEvents = /* @__PURE__ */ new Map(), this._functions = [];
  }
  getLogic(t) {
    const e = this.getLogicType(t);
    if (!e) return null;
    const s = new e();
    if (!s) return null;
    if (s.eventDispatcher = this._events, !this._cachedEvents.get(t)) {
      this._cachedEvents.set(t, !0);
      const r = s.getEventTypes();
      for (const n of r)
        n && this.registerEventType(n);
    }
    return s;
  }
  registerEventType(t) {
    if (!this._registeredEvents.get(t)) {
      this._registeredEvents.set(t, !0);
      for (const e of this._functions)
        e && this._events.addEventListener(t, e);
    }
  }
  registerEventFunction(t) {
    if (t && !(this._functions.indexOf(t) >= 0)) {
      this._functions.push(t);
      for (const e of this._registeredEvents.keys())
        e && this._events.addEventListener(e, t);
    }
  }
  removeEventFunction(t) {
    if (!t) return;
    const e = this._functions.indexOf(t);
    if (e !== -1) {
      this._functions.splice(e, 1);
      for (const s of this._registeredEvents.keys())
        s && this._events.removeEventListener(s, t);
    }
  }
  getLogicType(t) {
    if (!t) return null;
    let e = null;
    switch (t) {
      case tt.ROOM:
        e = Pst;
        break;
      case tt.TILE_CURSOR:
        e = SE;
        break;
      case tt.SELECTION_ARROW:
        e = Nst;
        break;
      case tt.USER:
      case tt.BOT:
      case tt.RENTABLE_BOT:
        e = IE;
        break;
      case tt.PET:
        e = bst;
        break;
      case tt.FURNITURE_BASIC:
        e = wt;
        break;
      case tt.FURNITURE_BADGE_DISPLAY:
        e = LM;
        break;
      case tt.FURNITURE_CHANGE_STATE_WHEN_STEP_ON:
        e = Dst;
        break;
      case tt.FURNITURE_COUNTER_CLOCK:
        e = Fst;
        break;
      case tt.FURNITURE_CRACKABLE:
        e = wst;
        break;
      case tt.FURNITURE_CREDIT:
        e = Bst;
        break;
      case tt.FURNITURE_CUSTOM_STACK_HEIGHT:
        e = zst;
        break;
      case tt.FURNITURE_DICE:
        e = Vst;
        break;
      case tt.FURNITURE_EDITABLE_INTERNAL_LINK:
        e = Yst;
        break;
      case tt.FURNITURE_EDITABLE_ROOM_LINK:
        e = Wst;
        break;
      case tt.FURNITURE_EXTERNAL_IMAGE_WALLITEM:
        e = Xst;
        break;
      case tt.FURNITURE_FIREWORKS:
        e = Kst;
        break;
      case tt.FURNITURE_FLOOR_HOLE:
        e = RE;
        break;
      case tt.FURNITURE_GUILD_CUSTOMIZED:
        e = wc;
        break;
      case tt.FURNITURE_HIGH_SCORE:
        e = OE;
        break;
      case tt.FURNITURE_HOCKEY_SCORE:
        e = Zst;
        break;
      case tt.FURNITURE_ES:
        e = Jst;
        break;
      case tt.FURNITURE_MANNEQUIN:
        e = yE;
        break;
      case tt.FURNITURE_MULTIHEIGHT:
        e = rit;
        break;
      case tt.FURNITURE_MULTISTATE:
        e = _e;
        break;
      case tt.FURNITURE_ONE_WAY_DOOR:
        e = oit;
        break;
      case tt.FURNITURE_PET_CUSTOMIZATION:
        e = hit;
        break;
      case tt.FURNITURE_PRESENT:
        e = vE;
        break;
      case tt.FURNITURE_PURCHASABLE_CLOTHING:
        e = cit;
        break;
      case tt.FURNITURE_PUSHABLE:
        e = CE;
        break;
      case tt.FURNITURE_BACKGROUND_COLOR:
        e = git;
        break;
      case tt.FURNITURE_BG:
        e = pit;
        break;
      case tt.FURNITURE_BB:
        e = mit;
        break;
      case tt.FURNITURE_ROOMDIMMER:
        e = Eit;
        break;
      case tt.FURNITURE_SCORE:
        e = xE;
        break;
      case tt.FURNITURE_SOUNDBLOCK:
        e = ME;
        break;
      case tt.FURNITURE_STICKIE:
        e = bE;
        break;
      case tt.FURNITURE_TROPHY:
        e = Sit;
        break;
      case tt.FURNITURE_VOTE_COUNTER:
        e = PE;
        break;
      case tt.FURNITURE_VOTE_MAJORITY:
        e = Ait;
        break;
      case tt.FURNITURE_WINDOW:
        e = Oit;
        break;
      case tt.FURNITURE_LOVELOCK:
        e = sit;
        break;
      case tt.FURNITURE_YOUTUBE:
        e = yit;
        break;
      case tt.FURNITURE_CRAFTING_GIZMO:
        e = Gst;
        break;
      case tt.FURNITURE_RENTABLE_SPACE:
        e = fit;
        break;
      case tt.FURNITURE_EFFECTBOX:
        e = jst;
        break;
      case tt.FURNITURE_MONSTERPLANT_SEED:
        e = iit;
        break;
      case tt.FURNITURE_MYSTERYBOX:
        e = nit;
        break;
      case tt.FURNITURE_MYSTERYTROPHY:
        e = ait;
        break;
      case tt.FURNITURE_RANDOM_TELEPORT:
        e = dit;
        break;
      case tt.FURNITURE_CLOTHING_CHANGE:
        e = Lst;
        break;
      case tt.FURNITURE_CUCKOO_CLOCK:
        e = kst;
        break;
      case tt.FURNITURE_ECOTRON_BOX:
        e = Hst;
        break;
      case tt.FURNITURE_GROUP_FORUM_TERMINAL:
        e = qst;
        break;
      case tt.FURNITURE_HWEEN_LOVELOCK:
        e = Qst;
        break;
      case tt.FURNITURE_INTERNAL_LINK:
        e = tit;
        break;
      case tt.FURNITURE_JUKEBOX:
        e = eit;
        break;
      case tt.FURNITURE_PLACEHOLDER:
        e = uit;
        break;
      case tt.FURNITURE_PLANET_SYSTEM:
        e = lit;
        break;
      case tt.FURNITURE_RANDOMSTATE:
        e = _it;
        break;
      case tt.FURNITURE_SONG_DISK:
        e = Tit;
        break;
      case tt.FURNITURE_SOUND_MACHINE:
        e = Iit;
        break;
      case tt.FURNITURE_WELCOME_GIFT:
        e = Rit;
        break;
      case tt.FURNITURE_ACHIEVEMENT_RESOLUTION:
        e = AE;
        break;
      case tt.FURNITURE_HABBOWHEEL:
        e = $st;
        break;
      case tt.FURNITURE_AREA_HIDE:
        e = Ust;
        break;
      default:
        e = wt;
        break;
    }
    return e || (rt.warn("Unknown Logic", t), null);
  }
  get events() {
    return this._events;
  }
}
const rrt = new irt(), aT = () => rrt, Cd = class Cd {
  constructor() {
    this._visualizationDatas = /* @__PURE__ */ new Map();
  }
  getVisualization(t) {
    const e = this.getVisualizationType(t);
    return e ? new e() : null;
  }
  getVisualizationType(t) {
    if (!t) return null;
    let e = null;
    switch (t) {
      case j.ROOM:
        e = nT;
        break;
      case j.TILE_CURSOR:
        e = srt;
        break;
      case j.USER:
      case j.BOT:
      case j.RENTABLE_BOT:
        e = FE;
        break;
      case j.PET_ANIMATED:
        e = sT;
        break;
      case j.FURNITURE_STATIC:
        e = Xi;
        break;
      case j.FURNITURE_ANIMATED:
        e = Te;
        break;
      case j.FURNITURE_RESETTING_ANIMATED:
        e = jit;
        break;
      case j.FURNITURE_BADGE_DISPLAY:
        e = BE;
        break;
      case j.FURNITURE_BG:
        e = Xit;
        break;
      case j.FURNITURE_BB:
        e = kM;
        break;
      case j.FURNITURE_ISOMETRIC_BB:
        e = Hit;
        break;
      case j.FURNITURE_BOTTLE:
        e = kE;
        break;
      case j.FURNITURE_BUILDER_PLACEHOLDER:
        e = Git;
        break;
      case j.FURNITURE_COUNTER_CLOCK:
        e = zE;
        break;
      case j.FURNITURE_CUBOID:
        e = Bit;
        break;
      case j.FURNITURE_EXTERNAL_IMAGE:
        e = kit;
        break;
      case j.FURNITURE_FIREWORKS:
        e = VM;
        break;
      case j.FURNITURE_GIFT_WRAPPED_FIREWORKS:
        e = HE;
        break;
      case j.FURNITURE_GIFT_WRAPPED:
        e = Vit;
        break;
      case j.FURNITURE_GUILD_CUSTOMIZED:
        e = YE;
        break;
      case j.FURNITURE_GUILD_ISOMETRIC_BADGE:
        e = WE;
        break;
      case j.FURNITURE_HABBOWHEEL:
        e = jE;
        break;
      case j.FURNITURE_MANNEQUIN:
        e = XE;
        break;
      case j.FURNITURE_PARTY_BEAMER:
        e = KE;
        break;
      case j.FURNITURE_PLANET_SYSTEM:
        e = Yit;
        break;
      case j.FURNITURE_POSTER:
        e = Wit;
        break;
      case j.FURNITURE_QUEUE_TILE:
        e = $E;
        break;
      case j.FURNITURE_SCORE_BOARD:
        e = ZE;
        break;
      case j.FURNITURE_SOUNDBLOCK:
        e = Kit;
        break;
      case j.FURNITURE_STICKIE:
        e = qit;
        break;
      case j.FURNITURE_VAL_RANDOMIZER:
        e = QE;
        break;
      case j.FURNITURE_VOTE_COUNTER:
        e = JE;
        break;
      case j.FURNITURE_VOTE_MAJORITY:
        e = tT;
        break;
      case j.FURNITURE_WATER_AREA:
        e = $it;
        break;
      case j.FURNITURE_YOUTUBE:
        e = eT;
        break;
    }
    return e || (rt.log("Unknown Visualization", t), null);
  }
  getVisualizationData(t, e, s) {
    const r = this._visualizationDatas.get(t);
    if (r) return r;
    let n = null;
    switch (e) {
      case j.FURNITURE_STATIC:
      case j.FURNITURE_GIFT_WRAPPED:
      case j.FURNITURE_BB:
      case j.FURNITURE_ISOMETRIC_BB:
      case j.FURNITURE_BG:
      case j.FURNITURE_STICKIE:
      case j.FURNITURE_BUILDER_PLACEHOLDER:
        n = new Yi();
        break;
      case j.FURNITURE_ANIMATED:
      case j.FURNITURE_RESETTING_ANIMATED:
      case j.FURNITURE_POSTER:
      case j.FURNITURE_HABBOWHEEL:
      case j.FURNITURE_VAL_RANDOMIZER:
      case j.FURNITURE_BOTTLE:
      case j.FURNITURE_PLANET_SYSTEM:
      case j.FURNITURE_QUEUE_TILE:
      case j.FURNITURE_PARTY_BEAMER:
      case j.FURNITURE_COUNTER_CLOCK:
      case j.FURNITURE_WATER_AREA:
      case j.FURNITURE_SCORE_BOARD:
      case j.FURNITURE_FIREWORKS:
      case j.FURNITURE_GIFT_WRAPPED_FIREWORKS:
      case j.FURNITURE_GUILD_CUSTOMIZED:
      case j.FURNITURE_GUILD_ISOMETRIC_BADGE:
      case j.FURNITURE_VOTE_COUNTER:
      case j.FURNITURE_VOTE_MAJORITY:
      case j.FURNITURE_SOUNDBLOCK:
      case j.FURNITURE_BADGE_DISPLAY:
      case j.FURNITURE_EXTERNAL_IMAGE:
      case j.FURNITURE_YOUTUBE:
      case j.TILE_CURSOR:
        n = new TI();
        break;
      case j.FURNITURE_MANNEQUIN:
        n = new HM();
        break;
      case j.ROOM:
        n = new WM();
        break;
      case j.USER:
      case j.BOT:
      case j.RENTABLE_BOT:
        n = new EI();
        break;
      case j.PET_ANIMATED:
        n = new YM();
        break;
    }
    return n ? n.initialize(s) ? (Cd.CACHING_ENABLED && this._visualizationDatas.set(t, n), n) : (n.dispose(), null) : null;
  }
};
Cd.CACHING_ENABLED = !0;
let oT = Cd;
const nrt = new oT(), ml = () => nrt;
class art {
  constructor(t, e) {
    this._renderer = null, this._managers = /* @__PURE__ */ new Map(), this._updateCategories = [], this._model = new pM(), this._id = t, this._container = e;
  }
  dispose() {
    this.removeAllManagers(), this.destroyRenderer(), this._container = null, this._model.dispose();
  }
  setRenderer(t) {
    if (t !== this._renderer && (this._renderer && this.destroyRenderer(), this._renderer = t, !!this._renderer && (this._renderer.reset(), this._managers.size)))
      for (const e of this._managers.values()) {
        if (!e) continue;
        const s = e.objects;
        if (s.length)
          for (const r of s.getValues())
            r && this._renderer.addObject(r);
      }
  }
  destroyRenderer() {
    this._renderer && (this._renderer.dispose(), this._renderer = null);
  }
  getManager(t) {
    const e = this._managers.get(t);
    return e || null;
  }
  getManagerOrCreate(t) {
    let e = this.getManager(t);
    return e || (e = this._container.createRoomObjectManager(t), e ? (this._managers.set(t, e), e) : null);
  }
  getTotalObjectsForManager(t) {
    const e = this.getManager(t);
    return e ? e.totalObjects : 0;
  }
  getRoomObject(t, e) {
    const s = this.getManager(e);
    if (!s) return null;
    const r = s.getObject(t);
    return r || null;
  }
  getRoomObjectsForCategory(t) {
    const e = this.getManager(t);
    return e ? e.objects.getValues() : [];
  }
  getRoomObjectByIndex(t, e) {
    const s = this.getManager(e);
    if (!s) return null;
    const r = s.getObjectByIndex(t);
    return r || null;
  }
  createRoomObject(t, e, s, r) {
    const n = this.getManagerOrCreate(r);
    if (!n) return null;
    const a = n.createObject(t, e, s);
    return a ? (this._renderer && this._renderer.addObject(a), a) : null;
  }
  createRoomObjectAndInitalize(t, e, s) {
    return this._container ? this._container.createRoomObjectAndInitalize(this._id, t, e, s) : null;
  }
  removeRoomObject(t, e) {
    const s = this.getManager(e);
    if (!s) return;
    const r = s.getObject(t);
    r && (r.tearDown(), this._renderer && this._renderer.removeObject(r), s.removeObject(t));
  }
  removeAllManagers() {
    for (const t of this._managers.values())
      if (t) {
        if (this._renderer) {
          const e = t.objects;
          if (e.length)
            for (const s of e.getValues())
              s && this._renderer.removeObject(s);
        }
        t.dispose();
      }
    this._managers.clear();
  }
  addUpdateCategory(t) {
    this._updateCategories.indexOf(t) >= 0 || this._updateCategories.push(t);
  }
  removeUpdateCategory(t) {
    const e = this._updateCategories.indexOf(t);
    e !== -1 && this._updateCategories.splice(e, 1);
  }
  update(t, e = !1) {
    for (const s of this._updateCategories) {
      const r = this.getManager(s);
      if (!r) continue;
      const n = r.objects;
      if (n.length)
        for (const a of n.getValues()) {
          if (!a) continue;
          const o = a.logic;
          o && o.update(t);
        }
    }
    this._renderer && this._renderer.update(t, e);
  }
  hasUninitializedObjects() {
    for (const t of this._managers.values())
      if (t) {
        for (const e of t.objects.getValues())
          if (e && !e.isReady)
            return !0;
      }
    return !1;
  }
  get id() {
    return this._id;
  }
  get container() {
    return this._container;
  }
  get renderer() {
    return this._renderer;
  }
  get managers() {
    return this._managers;
  }
  get model() {
    return this._model;
  }
}
class ort {
  constructor() {
    this._objects = new be(), this._objectsPerType = new be();
  }
  dispose() {
    this.removeAllObjects();
  }
  getObject(t) {
    const e = this._objects.getValue(t);
    return e || null;
  }
  getObjectByIndex(t) {
    const e = this._objects.getWithIndex(t);
    return e || null;
  }
  createObject(t, e, s) {
    const r = new TE(t, e, s);
    return this.addObject(t, s, r);
  }
  addObject(t, e, s) {
    if (this._objects.getValue(t))
      return s.dispose(), null;
    this._objects.add(t, s);
    const r = this.getTypeMap(e);
    return r && r.add(t, s), s;
  }
  removeObject(t) {
    const e = this._objects.remove(t);
    if (e) {
      const s = this.getTypeMap(e.type);
      s && s.remove(e.id), e.dispose();
    }
  }
  removeAllObjects() {
    let t = 0;
    for (; t < this._objects.length; ) {
      const e = this._objects.getWithIndex(t);
      e && e.dispose(), t++;
    }
    for (this._objects.reset(), t = 0; t < this._objectsPerType.length; ) {
      const e = this._objectsPerType.getWithIndex(t);
      e && e.dispose(), t++;
    }
    this._objectsPerType.reset();
  }
  getTypeMap(t, e = !0) {
    let s = this._objectsPerType.getValue(t);
    return !s && e && (s = new be(), this._objectsPerType.add(t, s)), s;
  }
  get objects() {
    return this._objects;
  }
  get totalObjects() {
    return this._objects.length;
  }
}
class hrt {
  constructor() {
    this._rooms = /* @__PURE__ */ new Map(), this._updateCategories = [], this._pendingContentTypes = [], this._skipContentProcessing = !1;
  }
  async init(t) {
    this._listener = t;
    const e = (s) => {
      if (!si()) return;
      const r = s.contentType;
      this._pendingContentTypes.indexOf(r) >= 0 || this._pendingContentTypes.push(r);
    };
    x().addEventListener(bs.RCLE_SUCCESS, e), x().addEventListener(bs.RCLE_FAILURE, e), x().addEventListener(bs.RCLE_CANCEL, e);
  }
  getRoomInstance(t) {
    const e = this._rooms.get(t);
    return e || null;
  }
  createRoomInstance(t) {
    if (this._rooms.get(t)) return null;
    const e = new art(t, this);
    if (this._rooms.set(e.id, e), this._updateCategories.length)
      for (const s of this._updateCategories)
        e.addUpdateCategory(s);
    return e;
  }
  removeRoomInstance(t) {
    const e = this._rooms.get(t);
    return e ? (this._rooms.delete(t), e.dispose(), !0) : !1;
  }
  createRoomObjectAndInitalize(t, e, s, r) {
    const n = this.getRoomInstance(t);
    if (!n) return null;
    let a = s, o = s, h = s, u = null, c = !1;
    if (si().isLoaderType(s)) {
      if (u = si().getCollection(s), !u && (c = !0, si().downloadAssetSync(s), h = si().getPlaceholderName(s), u = si().getCollection(h), !u))
        return null;
      a = u.data.visualizationType, o = u.data.logicType;
    }
    const l = n.createRoomObject(e, 1, s, r);
    if (!l) return null;
    const _ = ml().getVisualization(a);
    if (!_)
      return n.removeRoomObject(e, r), null;
    _.asset = u;
    const d = ml().getVisualizationData(h, a, u && u.data || null);
    if (!d || !_.initialize(d))
      return n.removeRoomObject(e, r), null;
    l.setVisualization(_);
    const f = aT().getLogic(o);
    return l.setLogic(f), f && f.initialize(u && u.data || null), c || (l.isReady = !0), si().setRoomObjectRoomId(l, t), l;
  }
  reinitializeRoomObjectsByType(t) {
    if (!t || !si()) return;
    const e = si().getCollection(t);
    if (!e) return;
    const s = e.data.visualizationType, r = e.data.logicType, n = ml().getVisualizationData(t, s, e.data);
    for (const a of this._rooms.values())
      if (a) {
        for (const [o, h] of a.managers.entries())
          if (h)
            for (const u of h.objects.getValues()) {
              if (!u || u.type !== t) continue;
              const c = ml().getVisualization(s);
              if (c)
                if (c.asset = e, !n || !c.initialize(n))
                  h.removeObject(u.id);
                else {
                  u.setVisualization(c);
                  const l = aT().getLogic(r);
                  u.setLogic(l), l && l.initialize(e.data), u.isReady = !0, this._listener && this._listener.objectInitialized(a.id, u.id, o);
                }
              else
                h.removeObject(u.id);
            }
      }
  }
  addUpdateCategory(t) {
    if (!(this._updateCategories.indexOf(t) >= 0) && (this._updateCategories.push(t), !!this._rooms.size))
      for (const s of this._rooms.values())
        s && s.addUpdateCategory(t);
  }
  removeUpdateCategory(t) {
    const e = this._updateCategories.indexOf(t);
    if (e !== -1 && (this._updateCategories.splice(e, 1), !!this._rooms.size))
      for (const s of this._rooms.values())
        s && s.removeUpdateCategory(t);
  }
  processPendingContentTypes(t) {
    if (this._skipContentProcessing) {
      this._skipContentProcessing = !1;
      return;
    }
    for (; this._pendingContentTypes.length; ) {
      const e = this._pendingContentTypes.shift();
      if (!si().getCollection(e)) {
        this._listener && this._listener.initalizeTemporaryObjectsByType(e, !1), rt.log("Invalid Collection", e);
        continue;
      }
      this.reinitializeRoomObjectsByType(e), this._listener && this._listener.initalizeTemporaryObjectsByType(e, !0);
    }
  }
  update(t, e = !1) {
    if (this.processPendingContentTypes(t), !!this._rooms.size)
      for (const s of this._rooms.values()) s && s.update(t, e);
  }
  createRoomObjectManager(t) {
    return new ort();
  }
  get rooms() {
    return this._rooms;
  }
}
const urt = new hrt(), lrt = () => urt, wi = class wi {
};
wi.ROOM_MIN_X = "room_min_x", wi.ROOM_MAX_X = "room_max_x", wi.ROOM_MIN_Y = "room_min_y", wi.ROOM_MAX_Y = "room_max_y", wi.ROOM_IS_PUBLIC = "room_is_public", wi.ROOM_Z_SCALE = "room_z_scale", wi.AD_DISPLAY_DELAY = "ad_display_delay", wi.IS_PLAYING_GAME = "is_playing_game";
let Ye = wi;
class crt {
  constructor() {
    this._connection = null, this._roomEngine = null, this._planeParser = new ye(), this._latestEntryTileEvent = null, this._currentRoomId = 0, this._ownUserId = 0, this._initialConnection = !0, this._guideId = -1, this._requesterId = -1;
  }
  async init() {
    this._connection = G().connection, this._roomEngine = SI(), this._connection.addMessageEvent(new Mc(this.onUserInfoEvent.bind(this))), this._connection.addMessageEvent(new jo(this.onRoomReadyMessageEvent.bind(this))), this._connection.addMessageEvent(new Km(this.onRoomPaintEvent.bind(this))), this._connection.addMessageEvent(new Ym(this.onRoomModelEvent.bind(this))), this._connection.addMessageEvent(new jm(this.onRoomHeightMapEvent.bind(this))), this._connection.addMessageEvent(new Xm(this.onRoomHeightMapUpdateEvent.bind(this))), this._connection.addMessageEvent(new qm(this.onRoomThicknessEvent.bind(this))), this._connection.addMessageEvent(new Wm(this.onRoomDoorEvent.bind(this))), this._connection.addMessageEvent(new Mm(this.onRoomRollingEvent.bind(this))), this._connection.addMessageEvent(new xm(this.onObjectsDataUpdateEvent.bind(this))), this._connection.addMessageEvent(new Nm(this.onFurnitureAliasesEvent.bind(this))), this._connection.addMessageEvent(new Fm(this.onFurnitureFloorAddEvent.bind(this))), this._connection.addMessageEvent(new wm(this.onFurnitureFloorEvent.bind(this))), this._connection.addMessageEvent(new Gm(this.onFurnitureFloorRemoveEvent.bind(this))), this._connection.addMessageEvent(new Bm(this.onFurnitureFloorUpdateEvent.bind(this))), this._connection.addMessageEvent(new km(this.onFurnitureWallAddEvent.bind(this))), this._connection.addMessageEvent(new zm(this.onFurnitureWallEvent.bind(this))), this._connection.addMessageEvent(new Vm(this.onFurnitureWallRemoveEvent.bind(this))), this._connection.addMessageEvent(new Hm(this.onFurnitureWallUpdateEvent.bind(this))), this._connection.addMessageEvent(new Um(this.onFurnitureDataEvent.bind(this))), this._connection.addMessageEvent(new Dm(this.onItemDataUpdateMessageEvent.bind(this))), this._connection.addMessageEvent(new Lm(this.onOneWayDoorStatusMessageEvent.bind(this))), this._connection.addMessageEvent(new bm(this.onAreaHideMessageEvent.bind(this))), this._connection.addMessageEvent(new yc(this.onRoomUnitDanceEvent.bind(this))), this._connection.addMessageEvent(new Zm(this.onRoomUnitEffectEvent.bind(this))), this._connection.addMessageEvent(new vc(this.onRoomUnitEvent.bind(this))), this._connection.addMessageEvent(new Qm(this.onRoomUnitExpressionEvent.bind(this))), this._connection.addMessageEvent(new Jm(this.onRoomUnitHandItemEvent.bind(this))), this._connection.addMessageEvent(new tE(this.onRoomUnitIdleEvent.bind(this))), this._connection.addMessageEvent(new Cc(this.onRoomUnitInfoEvent.bind(this))), this._connection.addMessageEvent(new eE(this.onRoomUnitNumberEvent.bind(this))), this._connection.addMessageEvent(new xc(this.onRoomUnitRemoveEvent.bind(this))), this._connection.addMessageEvent(new sE(this.onRoomUnitStatusEvent.bind(this))), this._connection.addMessageEvent(new uI(this.onRoomUnitChatEvent.bind(this))), this._connection.addMessageEvent(new Rc(this.onRoomUnitChatEvent.bind(this))), this._connection.addMessageEvent(new Oc(this.onRoomUnitChatEvent.bind(this))), this._connection.addMessageEvent(new $m(this.onRoomUnitTypingEvent.bind(this))), this._connection.addMessageEvent(new Ac(this.onPetFigureUpdateEvent.bind(this))), this._connection.addMessageEvent(new mC(this.onPetExperienceEvent.bind(this))), this._connection.addMessageEvent(new IC(this.onYouArePlayingGameEvent.bind(this))), this._connection.addMessageEvent(new Pm(this.onDiceValueMessageEvent.bind(this))), this._connection.addMessageEvent(new cI(this.onIgnoreResultEvent.bind(this))), this._connection.addMessageEvent(new qv(this.onGuideSessionStartedMessageEvent.bind(this))), this._connection.addMessageEvent(new Xv(this.onGuideSessionEndedMessageEvent.bind(this))), this._connection.addMessageEvent(new Kv(this.onGuideSessionErrorMessageEvent.bind(this)));
  }
  setRoomId(t) {
    this._currentRoomId !== 0 && this._roomEngine && this._roomEngine.destroyRoom(this._currentRoomId), this._currentRoomId = t, this._latestEntryTileEvent = null;
  }
  clearRoomId() {
    this._currentRoomId = 0, this._latestEntryTileEvent = null;
  }
  onUserInfoEvent(t) {
    if (!(t instanceof Mc) || !t.connection) return;
    const e = t.getParser();
    e && (this._ownUserId = e.userInfo.userId);
  }
  onRoomReadyMessageEvent(t) {
    const e = t.getParser();
    if (this._currentRoomId !== e.roomId && this.setRoomId(e.roomId), this._roomEngine && this._roomEngine.setRoomInstanceModelName(e.roomId, e.name), this._initialConnection) {
      t.connection.send(new xx()), this._initialConnection = !1;
      return;
    }
    t.connection.send(new gE());
  }
  onRoomPaintEvent(t) {
    if (!(t instanceof Km)) return;
    const e = t.getParser();
    if (!e) return;
    const s = e.floorType, r = e.wallType, n = e.landscapeType;
    this._roomEngine && this._roomEngine.updateRoomInstancePlaneType(this._currentRoomId, s, r, n);
  }
  onRoomModelEvent(t) {
    if (!(t instanceof Ym) || !t.connection || !this._roomEngine) return;
    const e = t.getParser();
    if (!e) return;
    const s = this._roomEngine.getLegacyWallGeometry(this._currentRoomId);
    if (!s) return;
    this._planeParser.reset();
    const r = e.width, n = e.height;
    this._planeParser.initializeTileMap(r, n);
    let a = null;
    this._latestEntryTileEvent && (a = this._latestEntryTileEvent.getParser());
    let o = -1, h = -1, u = 0, c = 0, l = 0;
    for (; l < n; ) {
      let f = 0;
      for (; f < r; ) {
        const p = e.getHeight(f, l);
        (l > 0 && l < n - 1 || f > 0 && f < r - 1) && p != ye.TILE_BLOCKED && (a == null || f == a.x && l == a.y) && (e.getHeight(f, l - 1) == ye.TILE_BLOCKED && e.getHeight(f - 1, l) == ye.TILE_BLOCKED && e.getHeight(f, l + 1) == ye.TILE_BLOCKED && (o = f + 0.5, h = l, u = p, c = 90), e.getHeight(f, l - 1) == ye.TILE_BLOCKED && e.getHeight(f - 1, l) == ye.TILE_BLOCKED && e.getHeight(f + 1, l) == ye.TILE_BLOCKED && (o = f, h = l + 0.5, u = p, c = 180)), this._planeParser.setTileHeight(f, l, p), f++;
      }
      l++;
    }
    this._planeParser.setTileHeight(Math.floor(o), Math.floor(h), u), this._planeParser.initializeFromTileData(e.wallHeight), this._planeParser.setTileHeight(Math.floor(o), Math.floor(h), u + this._planeParser.wallHeight), s.scale = Gu.DEFAULT_SCALE, s.initialize(r, n, this._planeParser.floorHeight);
    let _ = e.height - 1;
    for (; _ >= 0; ) {
      let f = e.width - 1;
      for (; f >= 0; )
        s.setHeight(f, _, this._planeParser.getTileHeight(f, _)), f--;
      _--;
    }
    const d = this._planeParser.getMapData();
    d.doors.push({
      x: o,
      y: h,
      z: u,
      dir: c
    }), this._roomEngine.createRoomInstance(this._currentRoomId, d);
  }
  onRoomHeightMapEvent(t) {
    if (!(t instanceof jm) || !t.connection || !this._roomEngine) return;
    const e = t.getParser();
    if (!e) return;
    const s = e.width, r = e.height, n = new Uit(s, r);
    let a = 0;
    for (; a < r; ) {
      let o = 0;
      for (; o < s; )
        n.setTileHeight(o, a, e.getTileHeight(o, a)), n.setStackingBlocked(o, a, e.getStackingBlocked(o, a)), n.setIsRoomTile(o, a, e.isRoomTile(o, a)), o++;
      a++;
    }
    this._roomEngine.setFurnitureStackingHeightMap(this._currentRoomId, n);
  }
  onRoomHeightMapUpdateEvent(t) {
    if (!(t instanceof Xm) || !t.connection || !this._roomEngine) return;
    const e = t.getParser();
    if (!e) return;
    const s = this._roomEngine.getFurnitureStackingHeightMap(this._currentRoomId);
    if (s) {
      for (; e.next(); )
        s.setTileHeight(e.x, e.y, e.tileHeight()), s.setStackingBlocked(e.x, e.y, e.isStackingBlocked()), s.setIsRoomTile(e.x, e.y, e.isRoomTile());
      this._roomEngine.refreshTileObjectMap(this._currentRoomId, "RoomMessageHandler.onRoomHeightMapUpdateEvent()");
    }
  }
  onRoomThicknessEvent(t) {
    if (!(t instanceof qm)) return;
    const e = t.getParser();
    if (!e) return;
    const s = !e.hideWalls, r = !0, n = e.thicknessWall, a = e.thicknessFloor;
    this._roomEngine && (this._roomEngine.updateRoomInstancePlaneVisibility(this._currentRoomId, s, r), this._roomEngine.updateRoomInstancePlaneThickness(this._currentRoomId, n, a));
  }
  onRoomDoorEvent(t) {
    t instanceof Wm && (this._latestEntryTileEvent = t);
  }
  onRoomRollingEvent(t) {
    if (!(t instanceof Mm) || !t.connection || !this._roomEngine) return;
    const e = t.getParser();
    this._roomEngine.updateRoomObjectFloor(this._currentRoomId, e.rollerId, null, null, 1, null), this._roomEngine.updateRoomObjectFloor(this._currentRoomId, e.rollerId, null, null, 2, null);
    const s = e.itemsRolling;
    if (s && s.length)
      for (const n of s)
        n && this._roomEngine.rollRoomObjectFloor(this._currentRoomId, n.id, n.location, n.targetLocation);
    const r = e.unitRolling;
    if (r) {
      this._roomEngine.updateRoomObjectUserLocation(this._currentRoomId, r.id, r.location, r.targetLocation);
      const n = this._roomEngine.getRoomObjectUser(this._currentRoomId, r.id);
      if (n && n.type !== Xt.MONSTER_PLANT) {
        let a = "std";
        switch (r.movementType) {
          case fr.MOVE:
            a = "mv";
            break;
          case fr.SLIDE:
            a = "std";
            break;
        }
        this._roomEngine.updateRoomObjectUserPosture(this._currentRoomId, r.id, a);
      }
    }
  }
  onObjectsDataUpdateEvent(t) {
    if (!(t instanceof xm) || !t.connection || !this._roomEngine) return;
    const e = t.getParser();
    if (e)
      for (const s of e.objects)
        this._roomEngine.updateRoomObjectFloor(this._currentRoomId, s.id, null, null, s.state, s.data);
  }
  onFurnitureAliasesEvent(t) {
    !(t instanceof Nm) || !t.connection || !this._roomEngine || (t.getParser().aliases, this._connection.send(new gE()));
  }
  onFurnitureFloorAddEvent(t) {
    if (!(t instanceof Fm) || !t.connection || !this._roomEngine) return;
    const e = t.getParser().item;
    e && this.addRoomObjectFurnitureFloor(this._currentRoomId, e);
  }
  onFurnitureFloorEvent(t) {
    if (!(t instanceof wm) || !t.connection || !this._roomEngine) return;
    const e = t.getParser();
    if (!e) return;
    const s = e.items.length;
    let r = 0;
    for (; r < s; ) {
      const n = e.items[r];
      n && this.addRoomObjectFurnitureFloor(this._currentRoomId, n), r++;
    }
  }
  onFurnitureFloorRemoveEvent(t) {
    if (!(t instanceof Gm) || !t.connection || !this._roomEngine) return;
    const e = t.getParser();
    e && (e.delay > 0 ? setTimeout(() => {
      this._roomEngine.removeRoomObjectFloor(this._currentRoomId, e.itemId, e.isExpired ? -1 : e.userId, !0);
    }, e.delay) : this._roomEngine.removeRoomObjectFloor(this._currentRoomId, e.itemId, e.isExpired ? -1 : e.userId, !0));
  }
  onFurnitureFloorUpdateEvent(t) {
    if (!(t instanceof Bm) || !t.connection || !this._roomEngine) return;
    const e = t.getParser().item;
    if (!e) return;
    const s = new v(e.x, e.y, e.z), r = new v(e.direction);
    this._roomEngine.updateRoomObjectFloor(this._currentRoomId, e.itemId, s, r, e.data.state, e.data, e.extra), this._roomEngine.updateRoomObjectFloorHeight(this._currentRoomId, e.itemId, e.stackHeight), this._roomEngine.updateRoomObjectFloorExpiration(this._currentRoomId, e.itemId, e.expires);
  }
  onFurnitureWallAddEvent(t) {
    if (!(t instanceof km) || !t.connection || !this._roomEngine) return;
    const e = t.getParser().item;
    e && this.addRoomObjectFurnitureWall(this._currentRoomId, e);
  }
  onFurnitureWallEvent(t) {
    if (!(t instanceof zm) || !t.connection || !this._roomEngine) return;
    const e = t.getParser();
    if (!e) return;
    const s = e.items.length;
    let r = 0;
    for (; r < s; ) {
      const n = e.items[r];
      n && this.addRoomObjectFurnitureWall(this._currentRoomId, n), r++;
    }
  }
  onFurnitureWallRemoveEvent(t) {
    if (!(t instanceof Vm) || !t.connection || !this._roomEngine) return;
    const e = t.getParser();
    e && this._roomEngine.removeRoomObjectWall(this._currentRoomId, e.itemId, e.userId);
  }
  onFurnitureWallUpdateEvent(t) {
    if (!(t instanceof Hm) || !t.connection || !this._roomEngine) return;
    const e = this._roomEngine.getLegacyWallGeometry(this._currentRoomId);
    if (!e) return;
    const s = t.getParser().item;
    if (!s) return;
    const r = e.getLocation(s.width, s.height, s.localX, s.localY, s.direction), n = new v(e.getDirection(s.direction));
    this._roomEngine.updateRoomObjectWall(this._currentRoomId, s.itemId, r, n, s.state, s.stuffData), this._roomEngine.updateRoomObjectWallExpiration(this._currentRoomId, s.itemId, s.secondsToExpiration);
  }
  onFurnitureDataEvent(t) {
    if (!(t instanceof Um) || !t.connection || !this._roomEngine) return;
    const e = t.getParser();
    this._roomEngine.updateRoomObjectFloor(this._currentRoomId, e.furnitureId, null, null, e.objectData.state, e.objectData);
  }
  onItemDataUpdateMessageEvent(t) {
    if (!(t instanceof Dm) || !t.connection || !this._roomEngine) return;
    const e = t.getParser();
    this._roomEngine.updateRoomObjectWallItemData(this._currentRoomId, e.furnitureId, e.data);
  }
  onOneWayDoorStatusMessageEvent(t) {
    if (!(t instanceof Lm) || !t.connection || !this._roomEngine) return;
    const e = t.getParser();
    this._roomEngine.updateRoomObjectFloor(this._currentRoomId, e.itemId, null, null, e.state, new ns());
  }
  onAreaHideMessageEvent(t) {
    if (!(t instanceof bm) || !t.connection || !this._roomEngine) return;
    const s = t.getParser().areaData;
    this._roomEngine.updateAreaHide(this._currentRoomId, s.furniId, s.on, s.rootX, s.rootY, s.width, s.length, s.invert);
  }
  onDiceValueMessageEvent(t) {
    if (!(t instanceof Pm) || !t.connection || !this._roomEngine) return;
    const e = t.getParser();
    this._roomEngine.updateRoomObjectFloor(this._currentRoomId, e.itemId, null, null, e.value, new ns());
  }
  onRoomUnitDanceEvent(t) {
    !(t instanceof yc) || !t.connection || !this._roomEngine || this._roomEngine.updateRoomObjectUserAction(this._currentRoomId, t.getParser().unitId, I.FIGURE_DANCE, t.getParser().danceId);
  }
  onRoomUnitEffectEvent(t) {
    !(t instanceof Zm) || !t.connection || !this._roomEngine || this._roomEngine.updateRoomObjectUserEffect(this._currentRoomId, t.getParser().unitId, t.getParser().effectId, t.getParser().delay);
  }
  onRoomUnitEvent(t) {
    if (!(t instanceof vc) || !t.connection || !this._roomEngine) return;
    const e = t.getParser().users;
    if (!(!e || !e.length)) {
      for (const s of e) {
        if (!s) continue;
        const r = new v(s.x, s.y, s.z), n = new v(s.dir);
        this._roomEngine.addRoomObjectUser(this._currentRoomId, s.roomIndex, r, n, s.dir, s.userType, s.figure), s.webID === this._ownUserId && (this._roomEngine.setRoomSessionOwnUser(this._currentRoomId, s.roomIndex), this._roomEngine.updateRoomObjectUserOwn(this._currentRoomId, s.roomIndex)), this._roomEngine.updateRoomObjectUserFigure(this._currentRoomId, s.roomIndex, s.figure, s.sex, s.subType, s.isRiding), Xt.getTypeString(s.userType) === Xt.PET && this._roomEngine.getPetTypeId(s.figure) === Eu.MONSTERPLANT && this._roomEngine.updateRoomObjectUserPosture(this._currentRoomId, s.roomIndex, s.petPosture), this._roomEngine.updateRoomObjectUserAction(this._currentRoomId, s.roomIndex, I.FIGURE_IS_MUTED, Xo().isUserIgnored(s.name) ? 1 : 0);
      }
      this.updateGuideMarker();
    }
  }
  onRoomUnitExpressionEvent(t) {
    !(t instanceof Qm) || !t.connection || !this._roomEngine || this._roomEngine.updateRoomObjectUserAction(this._currentRoomId, t.getParser().unitId, I.FIGURE_EXPRESSION, t.getParser().expression);
  }
  onRoomUnitHandItemEvent(t) {
    !(t instanceof Jm) || !t.connection || !this._roomEngine || this._roomEngine.updateRoomObjectUserAction(this._currentRoomId, t.getParser().unitId, I.FIGURE_CARRY_OBJECT, t.getParser().handId);
  }
  onRoomUnitIdleEvent(t) {
    !(t instanceof tE) || !t.connection || !this._roomEngine || this._roomEngine.updateRoomObjectUserAction(this._currentRoomId, t.getParser().unitId, I.FIGURE_SLEEP, t.getParser().isIdle ? 1 : 0);
  }
  onRoomUnitInfoEvent(t) {
    !(t instanceof Cc) || !t.connection || !this._roomEngine || this._roomEngine.updateRoomObjectUserFigure(this._currentRoomId, t.getParser().unitId, t.getParser().figure, t.getParser().gender);
  }
  onRoomUnitNumberEvent(t) {
    if (!(t instanceof eE) || !t.connection || !this._roomEngine) return;
    const e = t.getParser();
    e && this._roomEngine.updateRoomObjectUserAction(this._currentRoomId, e.unitId, I.FIGURE_NUMBER_VALUE, e.value);
  }
  onRoomUnitRemoveEvent(t) {
    !(t instanceof xc) || !t.connection || !this._roomEngine || (this._roomEngine.removeRoomObjectUser(this._currentRoomId, t.getParser().unitId), this.updateGuideMarker());
  }
  onRoomUnitStatusEvent(t) {
    if (!(t instanceof sE) || !t.connection || !this._roomEngine) return;
    const e = t.getParser().statuses;
    if (!e || !e.length) return;
    const s = this._roomEngine.getRoomInstance(this._currentRoomId);
    if (!s) return;
    const r = s.model.getValue(Ye.ROOM_Z_SCALE) || 1;
    for (const n of e) {
      if (!n) continue;
      let a = n.height;
      a && (a = a / r);
      const o = new v(n.x, n.y, n.z + a), h = new v(n.direction);
      let u = null;
      n.didMove && (u = new v(n.targetX, n.targetY, n.targetZ)), this._roomEngine.updateRoomObjectUserLocation(this._currentRoomId, n.id, o, u, n.canStandUp, a, h, n.headDirection), this._roomEngine.updateRoomObjectUserFlatControl(this._currentRoomId, n.id, null);
      let c = !0, l = !1, _ = I.STD, d = "", f = !1, p = !1;
      if (n.actions && n.actions.length) {
        for (const g of n.actions)
          if (g)
            switch (g.action) {
              case "flatctrl":
                this._roomEngine.updateRoomObjectUserFlatControl(this._currentRoomId, n.id, g.value);
                break;
              case "sign":
                n.actions.length === 1 && (c = !1), this._roomEngine.updateRoomObjectUserAction(this._currentRoomId, n.id, I.FIGURE_SIGN, parseInt(g.value));
                break;
              case "gst":
                n.actions.length === 1 && (c = !1), this._roomEngine.updateRoomObjectUserPetGesture(this._currentRoomId, n.id, g.value);
                break;
              case "wav":
              case "mv":
                f = !0, l = !0, _ = g.action, d = g.value;
                break;
              case "swim":
                p = !0, l = !0, _ = g.action, d = g.value;
                break;
              case "trd":
                break;
              default:
                l = !0, _ = g.action, d = g.value;
                break;
            }
      }
      !f && p && (l = !0, _ = "float"), l ? this._roomEngine.updateRoomObjectUserPosture(this._currentRoomId, n.id, _, d) : c && this._roomEngine.updateRoomObjectUserPosture(this._currentRoomId, n.id, I.STD, "");
    }
    this.updateGuideMarker();
  }
  onRoomUnitChatEvent(t) {
    if (!t.connection || !this._roomEngine) return;
    const e = t.getParser();
    e && (this._roomEngine.updateRoomObjectUserGesture(this._currentRoomId, e.roomIndex, e.gesture), this._roomEngine.updateRoomObjectUserAction(this._currentRoomId, e.roomIndex, I.FIGURE_TALK, e.message.length / 10));
  }
  onRoomUnitTypingEvent(t) {
    !(t instanceof $m) || !t.connection || !this._roomEngine || this._roomEngine.updateRoomObjectUserAction(this._currentRoomId, t.getParser().unitId, I.FIGURE_IS_TYPING, t.getParser().isTyping ? 1 : 0);
  }
  onPetFigureUpdateEvent(t) {
    if (!(t instanceof Ac) || !t.connection || !this._roomEngine) return;
    const e = t.getParser();
    e && this._roomEngine.updateRoomObjectUserFigure(this._currentRoomId, e.roomIndex, e.figureData.figuredata, "", "", e.isRiding);
  }
  onPetExperienceEvent(t) {
    const e = t.getParser();
    e && this._roomEngine.updateRoomObjectUserAction(this._currentRoomId, e.roomIndex, I.FIGURE_GAINED_EXPERIENCE, e.gainedExperience);
  }
  onYouArePlayingGameEvent(t) {
    if (!t) return;
    const e = t.getParser();
    e && this._roomEngine.setRoomEngineGameMode(this._currentRoomId, e.isPlaying);
  }
  addRoomObjectFurnitureFloor(t, e) {
    if (!e || !this._roomEngine) return;
    const s = new v(e.x, e.y, e.z), r = new v(e.direction);
    e.spriteName ? this._roomEngine.addFurnitureFloorByTypeName(t, e.itemId, e.spriteName, s, r, e.state, e.data, e.extra, e.expires, e.usagePolicy, e.userId, e.username, !0, !0, e.stackHeight) : this._roomEngine.addFurnitureFloor(t, e.itemId, e.spriteId, s, r, e.state, e.data, e.extra, e.expires, e.usagePolicy, e.userId, e.username, !0, !0, e.stackHeight);
  }
  addRoomObjectFurnitureWall(t, e) {
    if (!e || !this._roomEngine) return;
    const s = this._roomEngine.getLegacyWallGeometry(t);
    if (!s) return;
    let r = null;
    e.isOldFormat || (r = s.getLocation(e.width, e.height, e.localX, e.localY, e.direction));
    const n = new v(s.getDirection(e.direction));
    this._roomEngine.addFurnitureWall(t, e.itemId, e.spriteId, r, n, e.state, e.stuffData, e.secondsToExpiration, e.usagePolicy, e.userId, e.username);
  }
  onIgnoreResultEvent(t) {
    if (!t) return;
    const e = t.getParser();
    if (!e) return;
    const s = Zr().getSession(this._currentRoomId);
    if (!s) return;
    const r = s.userDataManager.getUserDataByName(e.name);
    if (r)
      switch (e.result) {
        case 1:
        case 2:
          this._roomEngine.updateRoomObjectUserAction(this._currentRoomId, r.roomIndex, I.FIGURE_IS_MUTED, 1);
          return;
        case 3:
          this._roomEngine.updateRoomObjectUserAction(this._currentRoomId, r.roomIndex, I.FIGURE_IS_MUTED, 0);
          return;
      }
  }
  onGuideSessionStartedMessageEvent(t) {
    const e = t.getParser();
    this._guideId = e.guideUserId, this._requesterId = e.requesterUserId, this.updateGuideMarker();
  }
  onGuideSessionEndedMessageEvent(t) {
    this.removeGuideMarker();
  }
  onGuideSessionErrorMessageEvent(t) {
    this.removeGuideMarker();
  }
  updateGuideMarker() {
    const t = Xo().userId;
    this.setUserGuideStatus(this._guideId, this._requesterId === t ? Gi.GUIDE : Gi.NONE), this.setUserGuideStatus(this._requesterId, this._guideId === t ? Gi.REQUESTER : Gi.NONE);
  }
  removeGuideMarker() {
    this.setUserGuideStatus(this._guideId, Gi.NONE), this.setUserGuideStatus(this._requesterId, Gi.NONE), this._guideId = -1, this._requesterId = -1;
  }
  setUserGuideStatus(t, e) {
    const s = Zr().getSession(this._currentRoomId);
    if (!s) return;
    const r = s.userDataManager.getDataByType(t, pr.USER);
    r && this._roomEngine.updateRoomObjectUserAction(this._currentRoomId, r.roomIndex, I.FIGURE_GUIDE_STATUS, e);
  }
  // public _SafeStr_10580(event:_SafeStr_2242): void
  // {
  //     var arrayIndex: number;
  //     var discoColours:Array;
  //     var discoTimer:Timer;
  //     var eventParser:_SafeStr_4576 = (event.parser as _SafeStr_4576);
  //     switch (eventParser._SafeStr_7025)
  //     {
  //         case 0:
  //             _SafeStr_4588.init(250, 5000);
  //             _SafeStr_4588._SafeStr_6766();
  //             return;
  //         case 1:
  //             _SafeStr_4231.init(250, 5000);
  //             _SafeStr_4231._SafeStr_6766();
  //             return;
  //         case 2:
  //             NitroEventDispatcher.dispatchEvent(new _SafeStr_2821(this._SafeStr_10593, -1, true));
  //             return;
  //         case 3:
  //             arrayIndex = 0;
  //             discoColours = [29371, 16731195, 16764980, 0x99FF00, 29371, 16731195, 16764980, 0x99FF00, 0];
  //             discoTimer = new Timer(1000, (discoColours.length + 1));
  //             discoTimer.addEventListener(TimerEvent.TIMER, function (k:TimerEvent): void
  //             {
  //                 if (arrayIndex == discoColours.length)
  //                 {
  //                     _SafeStr_10592._SafeStr_21164(_SafeStr_10593, discoColours[arrayIndex++], 176, true);
  //                 } else
  //                 {
  //                     _SafeStr_10592._SafeStr_21164(_SafeStr_10593, discoColours[arrayIndex++], 176, false);
  //                 };
  //             });
  //             discoTimer.start();
  //             return;
  //     };
  // }
  get currentRoomId() {
    return this._currentRoomId;
  }
}
const _rt = new crt(), tg = () => _rt;
class El {
  constructor(t = 0, e = null, s = null) {
    this.id = t, this.data = e, this.image = s;
  }
  async getImage() {
    return this.image ? this.image : this.data ? await le.generateImage(this.data) : null;
  }
}
class drt {
  constructor(t) {
    this._roomEngine = t, this._eventIds = /* @__PURE__ */ new Map(), this._selectedAvatarId = -1, this._selectedObjectId = -1, this._selectedObjectCategory = -2, this._whereYouClickIsWhereYouGo = !0, this._objectPlacementSource = null, x().addEventListener(lt.ADDED, (e) => this.onRoomEngineObjectEvent(e));
  }
  onRoomEngineObjectEvent(t) {
    let e = this.getSelectedRoomObjectData(t.roomId);
    if (e && e.operation === yt.OBJECT_PLACE && e.id === t.objectId) {
      const s = this._roomEngine.getRoomObject(t.roomId, e.id, e.category);
      if (s && s.model && e.category === L.FLOOR) {
        const r = s.model.getValue(I.FURNITURE_ALLOWED_DIRECTIONS);
        if (r && r.length) {
          const n = new v(r[0]);
          if (s.setDirection(n), this.updateSelectedObjectData(t.roomId, e.id, e.category, e.loc, n, e.operation, e.typeId, e.instanceData, e.stuffData, e.state, e.animFrame, e.posture), e = this.getSelectedRoomObjectData(t.roomId), !e) return;
        }
      }
      this.setFurnitureAlphaMultiplier(s, 0.5);
    }
  }
  processRoomCanvasMouseEvent(t, e, s) {
    if (!t || !e || zi.isRunning()) return;
    const r = e.type;
    let n = this._roomEngine.getRoomObjectCategoryForType(r);
    if (n !== L.ROOM && (!this._roomEngine.isPlayingGame() || n !== L.UNIT) && (n = L.MINIMUM), this.getMouseEventId(n, t.type) === t.eventId) {
      if (t.type === J.MOUSE_CLICK || t.type === J.DOUBLE_CLICK || t.type === J.MOUSE_DOWN || t.type === J.MOUSE_UP || t.type === J.MOUSE_MOVE) return;
    } else
      t.eventId && this.setMouseEventId(n, t.type, t.eventId);
    e.mouseHandler && e.mouseHandler.mouseEvent(t, s);
  }
  processRoomObjectPlacement(t, e, s, r, n, a = null, o = null, h = -1, u = -1, c = null) {
    this._objectPlacementSource = t;
    const l = new v(-100, -100), _ = new v(0);
    return this.setSelectedRoomObjectData(e, s, r, l, _, yt.OBJECT_PLACE, n, a, o, h, u, c), this._roomEngine && (this._roomEngine.setObjectMoverIconSprite(n, r, !1, a, o, h, u, c), this._roomEngine.setObjectMoverIconSpriteVisible(!1)), !0;
  }
  cancelRoomObjectInsert(t) {
    return this.resetSelectedObjectData(t), !0;
  }
  getMouseEventId(t, e) {
    const s = this._eventIds.get(t);
    return s && s.get(e) || null;
  }
  setMouseEventId(t, e, s) {
    let r = this._eventIds.get(t);
    r || (r = /* @__PURE__ */ new Map(), this._eventIds.set(t, r)), r.delete(e), r.set(e, s);
  }
  handleRoomObjectEvent(t, e) {
    if (t) {
      if (t instanceof at) {
        this.handleRoomObjectMouseEvent(t, e);
        return;
      }
      switch (t.type) {
        case At.STATE_CHANGE:
        case At.STATE_RANDOM:
          this.onRoomObjectStateChangedEvent(t, e);
          return;
        case _a.DIMMER_STATE:
          this.onRoomObjectDimmerStateUpdateEvent(t, e);
          return;
        case $e.POSITION_CHANGED:
        case $e.OBJECT_REMOVED:
          this.handleSelectedObjectRemove(t, e);
          return;
        case N.OPEN_WIDGET:
        case N.CLOSE_WIDGET:
        case N.OPEN_FURNI_CONTEXT_MENU:
        case N.CLOSE_FURNI_CONTEXT_MENU:
        case N.PLACEHOLDER:
        case N.CREDITFURNI:
        case N.STACK_HEIGHT:
        case N.EXTERNAL_IMAGE:
        case N.STICKIE:
        case N.PRESENT:
        case N.TROPHY:
        case N.TEASER:
        case N.ECOTRONBOX:
        case N.DIMMER:
        case N.WIDGET_REMOVE_DIMMER:
        case N.CLOTHING_CHANGE:
        case N.JUKEBOX_PLAYLIST_EDITOR:
        case N.MANNEQUIN:
        case N.PET_PRODUCT_MENU:
        case N.GUILD_FURNI_CONTEXT_MENU:
        case N.MONSTERPLANT_SEED_PLANT_CONFIRMATION_DIALOG:
        case N.PURCHASABLE_CLOTHING_CONFIRMATION_DIALOG:
        case N.BACKGROUND_COLOR:
        case N.AREA_HIDE:
        case N.MYSTERYBOX_OPEN_DIALOG:
        case N.EFFECTBOX_OPEN_DIALOG:
        case N.MYSTERYTROPHY_OPEN_DIALOG:
        case N.ACHIEVEMENT_RESOLUTION_OPEN:
        case N.ACHIEVEMENT_RESOLUTION_ENGRAVING:
        case N.ACHIEVEMENT_RESOLUTION_FAILED:
        case N.FRIEND_FURNITURE_CONFIRM:
        case N.FRIEND_FURNITURE_ENGRAVING:
        case N.BADGE_DISPLAY_ENGRAVING:
        case N.HIGH_SCORE_DISPLAY:
        case N.HIDE_HIGH_SCORE_DISPLAY:
        case N.INERNAL_LINK:
        case N.ROOM_LINK:
        case N.YOUTUBE:
          this.onRoomObjectWidgetRequestEvent(t, e);
          return;
        case z.DICE_ACTIVATE:
        case z.DICE_OFF:
        case z.USE_HABBOWHEEL:
        case z.STICKIE:
        case z.ENTER_ONEWAYDOOR:
          this.onRoomObjectFurnitureActionEvent(t, e);
          return;
        case z.SOUND_MACHINE_INIT:
        case z.SOUND_MACHINE_START:
        case z.SOUND_MACHINE_STOP:
        case z.SOUND_MACHINE_DISPOSE:
          this.handleObjectSoundMachineEvent(t, e);
          return;
        case z.JUKEBOX_INIT:
        case z.JUKEBOX_START:
        case z.JUKEBOX_MACHINE_STOP:
        case z.JUKEBOX_DISPOSE:
          this.handleObjectJukeboxEvent(t, e);
          return;
        case Ke.ADD_HOLE:
        case Ke.REMOVE_HOLE:
          this.onRoomObjectFloorHoleEvent(t, e);
          return;
        case ee.ROOM_AD_FURNI_CLICK:
        case ee.ROOM_AD_FURNI_DOUBLE_CLICK:
        case ee.ROOM_AD_TOOLTIP_SHOW:
        case ee.ROOM_AD_TOOLTIP_HIDE:
        case ee.ROOM_AD_LOAD_IMAGE:
          this.onRoomObjectRoomAdEvent(t, e);
          return;
        case di.LOAD_BADGE:
          this.onRoomObjectBadgeAssetEvent(t, e);
          return;
        case z.MOUSE_ARROW:
        case z.MOUSE_BUTTON:
          this.handleMousePointer(t, e);
          return;
        case Er.PLAY_SOUND:
        case Er.PLAY_SOUND_AT_PITCH:
          this.handleRoomObjectPlaySoundEvent(t, e);
          return;
        case Ie.ROOM_OBJECT_INITIALIZED:
        case Ie.ROOM_OBJECT_DISPOSED:
        case Ie.PLAY_SAMPLE:
        case Ie.CHANGE_PITCH:
          this.handleRoomObjectSamplePlaybackEvent(t, e);
          return;
        case gr.ROOM_BACKGROUND_COLOR:
          this.onHSLColorEnableEvent(t, e);
          return;
        case qs.RODRE_CURRENT_USER_ID:
        case qs.RODRE_URL_PREFIX:
          this.onRoomObjectDataRequestEvent(t, e);
          return;
        default:
          rt.warn("Unhandled Event", t.constructor.name, "Object ID", t.object.id);
          return;
      }
    }
  }
  handleRoomObjectMouseEvent(t, e) {
    if (!(!t || !t.type))
      switch (t instanceof Ii && this._roomEngine.areaSelectionManager.handleTileMouseEvent(t), t.type) {
        case at.CLICK:
          this.handleRoomObjectMouseClickEvent(t, e);
          return;
        case at.DOUBLE_CLICK:
          this.handleRoomObjectMouseDoubleClickEvent(t, e);
          return;
        case at.MOUSE_MOVE:
          this.handleRoomObjectMouseMoveEvent(t, e);
          return;
        case at.MOUSE_DOWN:
          this.handleRoomObjectMouseDownEvent(t, e);
          return;
        case at.MOUSE_DOWN_LONG:
          this.handleRoomObjectMouseDownLongEvent(t, e);
          return;
        case at.MOUSE_ENTER:
          this.handleRoomObjectMouseEnterEvent(t, e);
          return;
        case at.MOUSE_LEAVE:
          this.handleRoomObjectMouseLeaveEvent(t, e);
          return;
      }
  }
  clickRoomObject(t) {
    if (!t || t.altKey || t.ctrlKey || t.shiftKey) return;
    const e = t.objectId, s = t.objectType, r = this._roomEngine.getRoomObjectCategoryForType(s);
    if (r === L.FLOOR) {
      G().connection.send(new _E(e, r));
      return;
    }
    if (r === L.WALL) {
      G().connection.send(new _E(-Math.abs(e), r));
      return;
    }
  }
  handleRoomObjectMouseClickEvent(t, e) {
    if (!t) return;
    this.clickRoomObject(t);
    let s = yt.OBJECT_UNDEFINED;
    const r = this.getSelectedRoomObjectData(e);
    r && (s = r.operation);
    let n = !1, a = !1;
    this.whereYouClickIsWhereYouGo() && (!s || s === yt.OBJECT_UNDEFINED) && (n = this.handleMoveTargetFurni(e, t));
    const o = this._roomEngine.getRoomObjectCategoryForType(t.objectType);
    switch (s) {
      case yt.OBJECT_MOVE:
        o === L.ROOM ? r && this.modifyRoomObject(e, r.id, r.category, yt.OBJECT_MOVE_TO) : o === L.UNIT && (r && t.objectType === Xt.MONSTER_PLANT && this.modifyRoomObject(e, r.id, r.category, yt.OBJECT_MOVE_TO), t.eventId && this.setMouseEventId(L.ROOM, J.MOUSE_CLICK, t.eventId), this.placeObjectOnUser(e, t.objectId, o)), a = !0, t.objectId !== -1 && this.setSelectedObject(e, t.objectId, o);
        break;
      case yt.OBJECT_PLACE:
        if (o === L.ROOM)
          this.placeObject(e, t instanceof Ii, t instanceof La);
        else if (o === L.UNIT)
          switch (t.objectType) {
            case Xt.MONSTER_PLANT:
            case Xt.RENTABLE_BOT:
              this.placeObject(e, t instanceof Ii, t instanceof La);
              break;
            default:
              t.eventId && this.setMouseEventId(L.ROOM, J.MOUSE_CLICK, t.eventId), this.placeObjectOnUser(e, t.objectId, o);
              break;
          }
        break;
      case yt.OBJECT_UNDEFINED:
        o === L.ROOM ? !n && t instanceof Ii && this.handleClickOnTile(e, t) : (!this._roomEngine.isAreaSelectionMode() || o === L.UNIT ? this.setSelectedObject(e, t.objectId, o) : (this.deselectObject(e), x().dispatchEvent(new lt(lt.DESELECTED, e, -1, L.MINIMUM))), a = !1, o === L.UNIT ? (t.ctrlKey && !t.altKey && !t.shiftKey && t.objectType === Xt.RENTABLE_BOT ? this.modifyRoomObject(e, t.objectId, o, yt.OBJECT_PICKUP_BOT) : t.ctrlKey && !t.altKey && !t.shiftKey && t.objectType === Xt.MONSTER_PLANT ? this.modifyRoomObject(e, t.objectId, o, yt.OBJECT_PICKUP_PET) : !t.ctrlKey && !t.altKey && t.shiftKey && t.objectType === Xt.MONSTER_PLANT && this.modifyRoomObject(e, t.objectId, o, yt.OBJECT_ROTATE_POSITIVE), this._roomEngine.isPlayingGame() ? a = !0 : n = !0) : (o === L.FLOOR || o === L.WALL) && (t.altKey || t.ctrlKey || t.shiftKey) && (!t.ctrlKey && !t.altKey && t.shiftKey ? o === L.FLOOR && x() && x().dispatchEvent(new lt(lt.REQUEST_ROTATE, e, t.objectId, o)) : t.ctrlKey && !t.altKey && !t.shiftKey && this.modifyRoomObject(e, t.objectId, o, yt.OBJECT_PICKUP), this._roomEngine.isPlayingGame() ? a = !0 : n = !0), t.eventId && (n && this.setMouseEventId(L.ROOM, J.MOUSE_CLICK, t.eventId), a && this.setMouseEventId(L.MINIMUM, J.MOUSE_CLICK, t.eventId)));
        break;
    }
    if (o === L.ROOM) {
      const h = this.getMouseEventId(L.MINIMUM, J.MOUSE_CLICK), u = this.getMouseEventId(L.UNIT, J.MOUSE_CLICK);
      h !== t.eventId && u !== t.eventId && !a && (this.deselectObject(e), x() && x().dispatchEvent(new lt(lt.DESELECTED, e, -1, L.MINIMUM)), this.setSelectedAvatar(e, 0, !1));
    }
  }
  handleRoomObjectMouseDoubleClickEvent(t, e) {
    const s = t.objectId, r = t.objectType, n = this._roomEngine.getRoomObjectCategoryForType(r);
    x() && x().dispatchEvent(new lt(lt.DOUBLE_CLICK, e, s, n));
  }
  handleRoomObjectMouseMoveEvent(t, e) {
    if (!t) return;
    let s = yt.OBJECT_UNDEFINED;
    const r = this.getSelectedRoomObjectData(e);
    r && (s = r.operation);
    const n = this._roomEngine.getRoomObjectCategoryForType(t.objectType);
    if (this._roomEngine) {
      const a = this._roomEngine.getRoomObjectCursor(e);
      if (a && a.logic) {
        let o = null;
        t instanceof Ii ? o = this.handleMouseOverTile(t, e) : t.object && t.object.id !== -1 ? this.whereYouClickIsWhereYouGo() && (o = this.handleMouseOverObject(n, e, t)) : o = new ka(null, 0, !1, t.eventId), a.processUpdateMessage(o);
      }
    }
    switch (s) {
      case yt.OBJECT_MOVE:
        n === L.ROOM && this.handleObjectMove(t, e);
        return;
      case yt.OBJECT_PLACE:
        n === L.ROOM && this.handleObjectPlace(t, e);
        return;
    }
  }
  handleRoomObjectMouseDownEvent(t, e) {
    if (!t) return;
    let s = yt.OBJECT_UNDEFINED;
    const r = this.getSelectedRoomObjectData(e);
    r && (s = r.operation);
    const n = this._roomEngine.getRoomObjectCategoryForType(t.objectType);
    switch (s) {
      case yt.OBJECT_UNDEFINED:
        (n === L.FLOOR || n === L.WALL || t.objectType === Xt.MONSTER_PLANT) && (t.altKey && !t.ctrlKey && !t.shiftKey || this.decorateModeMove(t)) && x() && x().dispatchEvent(new lt(lt.REQUEST_MOVE, e, t.objectId, n));
        return;
    }
  }
  handleRoomObjectMouseDownLongEvent(t, e) {
    if (!t) return;
    let s = yt.OBJECT_UNDEFINED;
    const r = this.getSelectedRoomObjectData(e);
    r && (s = r.operation);
    const n = this._roomEngine.getRoomObjectCategoryForType(t.objectType);
    switch (s) {
      case yt.OBJECT_UNDEFINED:
        (n === L.FLOOR || n === L.WALL || t.objectType === Xt.MONSTER_PLANT) && (!t.ctrlKey && !t.shiftKey || this.decorateModeMove(t)) && x() && x().dispatchEvent(new lt(lt.REQUEST_MANIPULATION, e, t.objectId, n));
        return;
    }
  }
  handleRoomObjectMouseEnterEvent(t, e) {
    const s = t.objectId, r = t.objectType, n = this._roomEngine.getRoomObjectCategoryForType(r);
    x() && x().dispatchEvent(new lt(lt.MOUSE_ENTER, e, s, n));
  }
  handleRoomObjectMouseLeaveEvent(t, e) {
    const s = t.objectId, r = t.objectType, n = this._roomEngine.getRoomObjectCategoryForType(r);
    if (n !== L.ROOM && n === L.UNIT) {
      const a = this._roomEngine.getRoomObjectCursor(e);
      a && a.processUpdateMessage(new Ht(0, null));
    }
    x() && x().dispatchEvent(new lt(lt.MOUSE_LEAVE, e, s, n));
  }
  onRoomObjectStateChangedEvent(t, e) {
    if (t)
      switch (t.type) {
        case At.STATE_CHANGE:
          this.changeObjectState(e, t.object.id, t.object.type, t.state, !1);
          return;
        case At.STATE_RANDOM:
          this.changeObjectState(e, t.object.id, t.object.type, t.state, !0);
          return;
      }
  }
  onRoomObjectDimmerStateUpdateEvent(t, e) {
    if (t)
      switch (t.type) {
        case _a.DIMMER_STATE:
          x().dispatchEvent(new rp(e, t.state, t.presetId, t.effectId, t.color, t.brightness));
          return;
      }
  }
  handleSelectedObjectRemove(t, e) {
    if (!(!t || !this._roomEngine))
      switch (t.type) {
        case $e.POSITION_CHANGED: {
          const s = t.objectId, r = t.objectType, n = this._roomEngine.getRoomObjectCategoryForType(r), a = this._roomEngine.getRoomObject(e, s, n), o = this._roomEngine.getRoomObjectSelectionArrow(e);
          if (a && o && o.logic) {
            const h = a.getLocation();
            o.logic.processUpdateMessage(new Ce(h, null));
          }
          return;
        }
        case $e.OBJECT_REMOVED:
          this.setSelectedAvatar(e, 0, !1);
          return;
      }
  }
  onRoomObjectWidgetRequestEvent(t, e) {
    if (!t || !this._roomEngine) return;
    const s = t.objectId, r = t.objectType, n = this._roomEngine.getRoomObjectCategoryForType(r);
    if (!rc.isRoomPreviewerId(e))
      switch (t.type) {
        case N.OPEN_WIDGET:
          x().dispatchEvent(new Q(Q.OPEN_WIDGET, e, s, n, t.object.logic.widget));
          return;
        case N.CLOSE_WIDGET:
          x().dispatchEvent(new Q(Q.CLOSE_WIDGET, e, s, n, t.object.logic.widget));
          return;
        case N.OPEN_FURNI_CONTEXT_MENU:
          x().dispatchEvent(new Q(Q.OPEN_FURNI_CONTEXT_MENU, e, s, n, t.object.logic.contextMenu));
          return;
        case N.CLOSE_FURNI_CONTEXT_MENU:
          x().dispatchEvent(new Q(Q.CLOSE_FURNI_CONTEXT_MENU, e, s, n));
          return;
        case N.PLACEHOLDER:
          x().dispatchEvent(new Q(Q.REQUEST_PLACEHOLDER, e, s, n));
          return;
        case N.CREDITFURNI:
          x().dispatchEvent(new Q(Q.REQUEST_CREDITFURNI, e, s, n));
          return;
        case N.STACK_HEIGHT:
          x().dispatchEvent(new Q(Q.REQUEST_STACK_HEIGHT, e, s, n));
          return;
        case N.EXTERNAL_IMAGE:
          x().dispatchEvent(new Q(Q.REQUEST_EXTERNAL_IMAGE, e, s, n));
          return;
        case N.STICKIE:
          x().dispatchEvent(new Q(Q.REQUEST_STICKIE, e, s, n));
          return;
        case N.PRESENT:
          x().dispatchEvent(new Q(Q.REQUEST_PRESENT, e, s, n));
          return;
        case N.TROPHY:
          x().dispatchEvent(new Q(Q.REQUEST_TROPHY, e, s, n));
          return;
        case N.TEASER:
          x().dispatchEvent(new Q(Q.REQUEST_TEASER, e, s, n));
          return;
        case N.ECOTRONBOX:
          x().dispatchEvent(new Q(Q.REQUEST_ECOTRONBOX, e, s, n));
          return;
        case N.DIMMER:
          x().dispatchEvent(new Q(Q.REQUEST_DIMMER, e, s, n));
          return;
        case N.WIDGET_REMOVE_DIMMER:
          x().dispatchEvent(new Q(Q.REMOVE_DIMMER, e, s, n));
          return;
        case N.CLOTHING_CHANGE:
          x().dispatchEvent(new Q(Q.REQUEST_CLOTHING_CHANGE, e, s, n));
          return;
        case N.JUKEBOX_PLAYLIST_EDITOR:
          x().dispatchEvent(new Q(Q.REQUEST_PLAYLIST_EDITOR, e, s, n));
          return;
        case N.MANNEQUIN:
          x().dispatchEvent(new Q(Q.REQUEST_MANNEQUIN, e, s, n));
          return;
        case N.PET_PRODUCT_MENU:
          x().dispatchEvent(new hc(hc.USE_PRODUCT_FROM_ROOM, e, s, n));
          return;
        case N.GUILD_FURNI_CONTEXT_MENU:
          G().connection.send(new Mx(t.objectId, t.object.model.getValue(I.FURNITURE_GUILD_CUSTOMIZED_GUILD_ID)));
          return;
        case N.MONSTERPLANT_SEED_PLANT_CONFIRMATION_DIALOG:
          x().dispatchEvent(new Q(Q.REQUEST_MONSTERPLANT_SEED_PLANT_CONFIRMATION_DIALOG, e, s, n));
          return;
        case N.PURCHASABLE_CLOTHING_CONFIRMATION_DIALOG:
          x().dispatchEvent(new Q(Q.REQUEST_PURCHASABLE_CLOTHING_CONFIRMATION_DIALOG, e, s, n));
          return;
        case N.BACKGROUND_COLOR:
          x().dispatchEvent(new Q(Q.REQUEST_BACKGROUND_COLOR, e, s, n));
          return;
        case N.AREA_HIDE:
          x().dispatchEvent(new Q(Q.REQUEST_AREA_HIDE, e, s, n));
          return;
        case N.MYSTERYBOX_OPEN_DIALOG:
          x().dispatchEvent(new Q(Q.REQUEST_MYSTERYBOX_OPEN_DIALOG, e, s, n));
          return;
        case N.EFFECTBOX_OPEN_DIALOG:
          x().dispatchEvent(new Q(Q.REQUEST_EFFECTBOX_OPEN_DIALOG, e, s, n));
          return;
        case N.MYSTERYTROPHY_OPEN_DIALOG:
          x().dispatchEvent(new Q(Q.REQUEST_MYSTERYTROPHY_OPEN_DIALOG, e, s, n));
          return;
        case N.ACHIEVEMENT_RESOLUTION_OPEN:
          G().connection.send(new VC(t.objectId, 0));
          return;
        case N.ACHIEVEMENT_RESOLUTION_ENGRAVING:
          x().dispatchEvent(new Q(Q.REQUEST_ACHIEVEMENT_RESOLUTION_ENGRAVING, e, s, n));
          return;
        case N.ACHIEVEMENT_RESOLUTION_FAILED:
          x().dispatchEvent(new Q(Q.REQUEST_ACHIEVEMENT_RESOLUTION_FAILED, e, s, n));
          return;
        case N.FRIEND_FURNITURE_CONFIRM:
          x().dispatchEvent(new Q(Q.REQUEST_FRIEND_FURNITURE_CONFIRM, e, s, n));
          return;
        case N.FRIEND_FURNITURE_ENGRAVING:
          x().dispatchEvent(new Q(Q.REQUEST_FRIEND_FURNITURE_ENGRAVING, e, s, n));
          return;
        case N.BADGE_DISPLAY_ENGRAVING:
          x().dispatchEvent(new Q(Q.REQUEST_BADGE_DISPLAY_ENGRAVING, e, s, n));
          return;
        case N.HIGH_SCORE_DISPLAY:
          x().dispatchEvent(new Q(Q.REQUEST_HIGH_SCORE_DISPLAY, e, s, n));
          return;
        case N.HIDE_HIGH_SCORE_DISPLAY:
          x().dispatchEvent(new Q(Q.REQUEST_HIDE_HIGH_SCORE_DISPLAY, e, s, n));
          return;
        case N.INERNAL_LINK:
          x().dispatchEvent(new Q(Q.REQUEST_INTERNAL_LINK, e, s, n));
          return;
        case N.ROOM_LINK:
          x().dispatchEvent(new Q(Q.REQUEST_ROOM_LINK, e, s, n));
          return;
        case N.YOUTUBE:
          x().dispatchEvent(new Q(Q.REQUEST_YOUTUBE, e, s, n));
          return;
      }
  }
  onRoomObjectFurnitureActionEvent(t, e) {
    t && this.useObject(e, t.object.id, t.object.type, t.type);
  }
  handleObjectSoundMachineEvent(t, e) {
    if (!t) return;
    const s = this._roomEngine.getRoomObjectCategoryForType(t.objectType), r = this.getSelectedRoomObjectData(e);
    if (!(r && r.category === s && r.id === t.objectId && r.operation === yt.OBJECT_PLACE))
      switch (t.type) {
        case z.SOUND_MACHINE_INIT:
          x().dispatchEvent(new ne(ne.SOUND_MACHINE_INIT, e, t.objectId, s));
          return;
        case z.SOUND_MACHINE_START:
          x().dispatchEvent(new ne(ne.SOUND_MACHINE_SWITCHED_ON, e, t.objectId, s));
          return;
        case z.SOUND_MACHINE_STOP:
          x().dispatchEvent(new ne(ne.SOUND_MACHINE_SWITCHED_OFF, e, t.objectId, s));
          return;
        case z.SOUND_MACHINE_DISPOSE:
          x().dispatchEvent(new ne(ne.SOUND_MACHINE_DISPOSE, e, t.objectId, s));
          return;
      }
  }
  handleObjectJukeboxEvent(t, e) {
    if (!t) return;
    const s = this._roomEngine.getRoomObjectCategoryForType(t.objectType), r = this.getSelectedRoomObjectData(e);
    if (!(r && r.category === s && r.id === t.objectId && r.operation === yt.OBJECT_PLACE))
      switch (t.type) {
        case z.JUKEBOX_INIT:
          x().dispatchEvent(new ne(ne.JUKEBOX_INIT, e, t.objectId, s));
          return;
        case z.JUKEBOX_START:
          x().dispatchEvent(new ne(ne.JUKEBOX_SWITCHED_ON, e, t.objectId, s));
          return;
        case z.JUKEBOX_MACHINE_STOP:
          x().dispatchEvent(new ne(ne.JUKEBOX_SWITCHED_OFF, e, t.objectId, s));
          return;
        case z.JUKEBOX_DISPOSE:
          x().dispatchEvent(new ne(ne.JUKEBOX_DISPOSE, e, t.objectId, s));
          return;
      }
  }
  onRoomObjectFloorHoleEvent(t, e) {
    if (t)
      switch (t.type) {
        case Ke.ADD_HOLE:
          this._roomEngine.addRoomInstanceFloorHole(e, t.objectId);
          return;
        case Ke.REMOVE_HOLE:
          this._roomEngine.removeRoomInstanceFloorHole(e, t.objectId);
          return;
      }
  }
  onRoomObjectRoomAdEvent(t, e) {
    if (!t) return;
    let s = null;
    switch (t.type) {
      case ee.ROOM_AD_FURNI_CLICK:
        x().dispatchEvent(t), t.clickUrl && t.clickUrl.length > 0 && wg(t.clickUrl), s = Ya.FURNI_CLICK;
        break;
      case ee.ROOM_AD_FURNI_DOUBLE_CLICK:
        if (t.clickUrl && t.clickUrl.length > 0) {
          const r = "CATALOG_PAGE";
          t.clickUrl.indexOf(r) === 0 && wg(t.clickUrl.substr(r.length));
        }
        s = Ya.FURNI_DOUBLE_CLICK;
        break;
      case ee.ROOM_AD_TOOLTIP_SHOW:
        s = Ya.TOOLTIP_SHOW;
        break;
      case ee.ROOM_AD_TOOLTIP_HIDE:
        s = Ya.TOOLTIP_HIDE;
        break;
    }
    s && x().dispatchEvent(new lt(s, e, t.objectId, this._roomEngine.getRoomObjectCategoryForType(t.objectType)));
  }
  onRoomObjectBadgeAssetEvent(t, e) {
    if (!(!t || !this._roomEngine))
      switch (t.type) {
        case di.LOAD_BADGE: {
          const s = t.objectId, r = t.objectType, n = this._roomEngine.getRoomObjectCategoryForType(r);
          this._roomEngine.loadRoomObjectBadgeImage(e, s, n, t.badgeId, t.groupBadge);
          return;
        }
      }
  }
  handleMousePointer(t, e) {
    t && this._roomEngine.updateMousePointer(t.type, t.objectId, t.objectType);
  }
  handleRoomObjectPlaySoundEvent(t, e) {
    const s = this._roomEngine.getRoomObjectCategoryForType(t.objectType);
    switch (t.type) {
      case Er.PLAY_SOUND:
        x().dispatchEvent(new Ha(Ha.PLAY_SOUND, e, t.objectId, s, t.soundId, t.pitch));
        return;
      case Er.PLAY_SOUND_AT_PITCH:
        x().dispatchEvent(new Ha(Ha.PLAY_SOUND_AT_PITCH, e, t.objectId, s, t.soundId, t.pitch));
        return;
    }
  }
  handleRoomObjectSamplePlaybackEvent(t, e) {
    if (!t) return;
    const s = this._roomEngine.getRoomObjectCategoryForType(t.objectType);
    switch (t.type) {
      case Ie.ROOM_OBJECT_INITIALIZED:
        x().dispatchEvent(new Ws(Ws.ROOM_OBJECT_INITIALIZED, e, t.objectId, s, t.sampleId, t.pitch));
        break;
      case Ie.ROOM_OBJECT_DISPOSED:
        x().dispatchEvent(new Ws(Ws.ROOM_OBJECT_DISPOSED, e, t.objectId, s, t.sampleId, t.pitch));
        break;
      case Ie.PLAY_SAMPLE:
        x().dispatchEvent(new Ws(Ws.PLAY_SAMPLE, e, t.objectId, s, t.sampleId, t.pitch));
        break;
      case Ie.CHANGE_PITCH:
        x().dispatchEvent(new Ws(Ws.CHANGE_PITCH, e, t.objectId, s, t.sampleId, t.pitch));
        break;
    }
  }
  onHSLColorEnableEvent(t, e) {
    if (!(!t || !this._roomEngine))
      switch (t.type) {
        case gr.ROOM_BACKGROUND_COLOR:
          x().dispatchEvent(new uc(uc.ROOM_BACKGROUND_COLOR, e, t.enable, t.hue, t.saturation, t.lightness));
          return;
      }
  }
  onRoomObjectDataRequestEvent(t, e) {
    if (!(!t || !this._roomEngine || !t.object))
      switch (t.type) {
        case qs.RODRE_CURRENT_USER_ID:
          t.object.model.setValue(I.SESSION_CURRENT_USER_ID, Xo().userId);
          return;
        case qs.RODRE_URL_PREFIX:
          t.object.model.setValue(I.SESSION_URL_PREFIX, Ct().getValue("url.prefix"));
          return;
      }
  }
  handleClickOnTile(t, e) {
    if (!this._roomEngine || this._roomEngine.isDecorating) return;
    const s = Zr().getSession(t);
    !s || s.isSpectator || this._roomEngine.moveBlocked || this.sendWalkUpdate(e.tileXAsInt, e.tileYAsInt);
  }
  handleObjectMove(t, e) {
    if (!t || !this._roomEngine || !x()) return;
    const r = this.getSelectedRoomObjectData(e);
    if (!r) return;
    const n = this._roomEngine.getRoomObject(e, r.id, r.category);
    if (!n) return;
    let a = !0;
    if (r.category === L.FLOOR || r.category === L.UNIT) {
      const o = this._roomEngine.getFurnitureStackingHeightMap(e);
      t instanceof Ii && this.handleFurnitureMove(n, r, Math.trunc(t.tileX + 0.5), Math.trunc(t.tileY + 0.5), o) || (this.handleFurnitureMove(n, r, r.loc.x, r.loc.y, o), a = !1);
    } else if (r.category === L.WALL) {
      if (a = !1, t instanceof La) {
        const o = t.wallLocation, h = t.wallWidth, u = t.wallHeight, c = t.x, l = t.y, _ = t.direction;
        this.handleWallItemMove(n, r, o, h, u, c, l, _) && (a = !0);
      }
      a || (n.setLocation(r.loc), n.setDirection(r.dir)), this._roomEngine.updateRoomObjectMask(e, r.id, a);
    }
    a ? (this.setFurnitureAlphaMultiplier(n, 0.5), this._roomEngine.setObjectMoverIconSpriteVisible(!1)) : (this.setFurnitureAlphaMultiplier(n, 0), this._roomEngine.setObjectMoverIconSpriteVisible(!0));
  }
  handleObjectPlace(t, e) {
    if (!t || !this._roomEngine || !x()) return;
    let r = this.getSelectedRoomObjectData(e);
    if (!r) return;
    let n = this._roomEngine.getRoomObject(e, r.id, r.category);
    if (!n) {
      if (t instanceof Ii) {
        if (r.category === L.FLOOR)
          this._roomEngine.addFurnitureFloor(e, r.id, r.typeId, r.loc, r.dir, 0, r.stuffData, parseFloat(r.instanceData), -1, 0, 0, "", !1);
        else if (r.category === L.UNIT) {
          this._roomEngine.addRoomObjectUser(e, r.id, new v(), new v(180), 180, r.typeId, r.instanceData);
          const a = this._roomEngine.getRoomObject(e, r.id, r.category);
          a && r.posture && a.model.setValue(I.FIGURE_POSTURE, r.posture);
        }
      } else t instanceof La && r.category === L.WALL && this._roomEngine.addFurnitureWall(e, r.id, r.typeId, r.loc, r.dir, 0, r.instanceData, 0);
      if (n = this._roomEngine.getRoomObject(e, r.id, r.category), n && r.category === L.FLOOR) {
        const a = n.model.getValue(I.FURNITURE_ALLOWED_DIRECTIONS);
        if (a && a.length) {
          const o = new v(a[0]);
          if (n.setDirection(o), this.updateSelectedObjectData(e, r.id, r.category, r.loc, o, r.operation, r.typeId, r.instanceData, r.stuffData, r.state, r.animFrame, r.posture), r = this.getSelectedRoomObjectData(e), !r) return;
        }
      }
      this.setFurnitureAlphaMultiplier(n, 0.5), this._roomEngine.setObjectMoverIconSpriteVisible(!0);
    }
    if (n) {
      let a = !0;
      const o = this._roomEngine.getFurnitureStackingHeightMap(e);
      if (r.category === L.FLOOR)
        t instanceof Ii && this.handleFurnitureMove(n, r, Math.trunc(t.tileX + 0.5), Math.trunc(t.tileY + 0.5), o) || (this._roomEngine.removeRoomObjectFloor(e, r.id), a = !1);
      else if (r.category === L.WALL) {
        if (a = !1, t instanceof La) {
          const h = t.wallLocation, u = t.wallWidth, c = t.wallHeight, l = t.x, _ = t.y, d = t.direction;
          this.handleWallItemMove(n, r, h, u, c, l, _, d) && (a = !0);
        }
        a || this._roomEngine.removeRoomObjectWall(e, r.id), this._roomEngine.updateRoomObjectMask(e, r.id, a);
      } else r.category === L.UNIT && (t instanceof Ii && this.handleUserPlace(n, Math.trunc(t.tileX + 0.5), Math.trunc(t.tileY + 0.5), this._roomEngine.getLegacyWallGeometry(e)) || (this._roomEngine.removeRoomObjectUser(e, r.id), a = !1));
      this._roomEngine.setObjectMoverIconSpriteVisible(!a);
    }
  }
  handleFurnitureMove(t, e, s, r, n) {
    if (!t || !e) return !1;
    const a = new v();
    a.assign(t.getDirection()), t.setDirection(e.dir);
    const o = new v(s, r, 0), h = new v();
    h.assign(t.getDirection());
    let u = this.validateFurnitureLocation(t, o, e.loc, e.dir, n);
    return u || (h.x = this.getValidRoomObjectDirection(t, !0), t.setDirection(h), u = this.validateFurnitureLocation(t, o, e.loc, e.dir, n)), u ? (t.setLocation(u), h && t.setDirection(h), !0) : (t.setDirection(a), !1);
  }
  handleWallItemMove(t, e, s, r, n, a, o, h) {
    if (!t || !e) return !1;
    const u = new v(h), c = this.validateWallItemLocation(t, s, r, n, a, o, e);
    return c ? (t.setLocation(c), t.setDirection(u), !0) : !1;
  }
  validateFurnitureLocation(t, e, s, r, n) {
    if (!t || !t.model || !e) return null;
    let a = null;
    const o = t.getDirection();
    if (!o || !s || !r) return null;
    if (e.x === s.x && e.y === s.y && o.x === r.x)
      return a = new v(), a.assign(s), a;
    let h = t.model.getValue(I.FURNITURE_SIZE_X), u = t.model.getValue(I.FURNITURE_SIZE_Y);
    h < 1 && (h = 1), u < 1 && (u = 1);
    const c = s.x, l = s.y;
    let _ = h, d = u, f = 0, p = Math.trunc(Math.trunc(o.x + 45) % 360 / 90);
    if ((p === 1 || p === 3) && (f = h, h = u, u = f), p = Math.trunc(Math.trunc(r.x + 45) % 360 / 90), (p === 1 || p === 3) && (f = _, _ = d, d = f), n && e) {
      const g = t.model.getValue(I.FURNITURE_ALWAYS_STACKABLE) === 1;
      return n.validateLocation(e.x, e.y, h, u, c, l, _, d, g) ? new v(e.x, e.y, n.getTileHeight(e.x, e.y)) : null;
    }
    return null;
  }
  validateWallItemLocation(t, e, s, r, n, a, o) {
    if (t == null || t.model == null || e == null || s == null || r == null || o == null) return null;
    const h = t.model.getValue(I.FURNITURE_SIZE_X), u = t.model.getValue(I.FURNITURE_SIZE_Z), c = t.model.getValue(I.FURNITURE_CENTER_Z);
    if ((n < h / 2 || n > s.length - h / 2 || a < c || a > r.length - (u - c)) && (n < h / 2 && n <= s.length - h / 2 ? n = h / 2 : n >= h / 2 && n > s.length - h / 2 && (n = s.length - h / 2), a < c && a <= r.length - (u - c) ? a = c : a >= c && a > r.length - (u - c) && (a = r.length - (u - c))), n < h / 2 || n > s.length - h / 2 || a < c || a > r.length - (u - c))
      return null;
    let l = v.sum(v.product(s, n / s.length), v.product(r, a / r.length));
    return l = v.sum(e, l), l;
  }
  changeObjectState(t, e, s, r, n) {
    const a = this._roomEngine.getRoomObjectCategoryForType(s);
    this.changeRoomObjectState(t, e, a, r, n);
  }
  useObject(t, e, s, r) {
    if (!(!this._roomEngine || !G().connection))
      switch (r) {
        case z.DICE_ACTIVATE:
          G().connection.send(new Dx(e));
          return;
        case z.DICE_OFF:
          G().connection.send(new Lx(e));
          return;
        case z.USE_HABBOWHEEL:
          G().connection.send(new Ux(e));
          return;
        case z.STICKIE:
          G().connection.send(new mx(e));
          return;
        case z.ENTER_ONEWAYDOOR:
          G().connection.send(new Fx(e));
          return;
      }
  }
  changeRoomObjectState(t, e, s, r, n) {
    return !this._roomEngine || !G().connection || (s === L.FLOOR ? n ? G().connection.send(new wx(e, r)) : G().connection.send(new _I(e, r)) : s === L.WALL && G().connection.send(new Gx(e, r))), !0;
  }
  sendWalkUpdate(t, e) {
    !this._roomEngine || !G().connection || G().connection.send(new Jx(t, e));
  }
  handleMouseOverObject(t, e, s) {
    if (t !== L.FLOOR) return null;
    const r = this._roomEngine.getRoomObject(e, s.objectId, L.FLOOR);
    if (!r) return null;
    const n = this.getActiveSurfaceLocation(r, s);
    if (!n || !this._roomEngine.getFurnitureStackingHeightMap(e)) return null;
    const o = n.x, h = n.y, u = n.z;
    return new ka(new v(o, h, r.getLocation().z), u, !0, s.eventId);
  }
  handleMoveTargetFurni(t, e) {
    const s = this._roomEngine.getRoomObject(t, e.objectId, L.FLOOR), r = this.getActiveSurfaceLocation(s, e);
    return r && !this._roomEngine.moveBlocked ? (this.sendWalkUpdate(r.x, r.y), !0) : !1;
  }
  getActiveSurfaceLocation(t, e) {
    if (!t || !e) return null;
    const s = Xo().getFloorItemDataByName(t.type);
    if (!s || !s.canStandOn && !s.canSitOn && !s.canLayOn) return null;
    const r = t.model;
    if (!r) return null;
    const n = t.getLocation(), a = t.getDirection();
    let o = r.getValue(I.FURNITURE_SIZE_X), h = r.getValue(I.FURNITURE_SIZE_Y);
    const u = r.getValue(I.FURNITURE_SIZE_Z);
    (a.x === 90 || a.x === 270) && ([o, h] = [h, o]), o < 1 && (o = 1), h < 1 && (h = 1);
    const c = this._roomEngine.getActiveRoomInstanceRenderingCanvas();
    if (!c) return null;
    const l = c.geometry.scale, _ = s.canSitOn ? 0.5 : 0, d = (l / 2 + e.spriteOffsetX + e.localX) / (l / 4), f = (e.spriteOffsetY + e.localY + (u - _) * l / 2) / (l / 4), p = (d + 2 * f) / 4, g = (d - 2 * f) / 4, m = Math.floor(n.x + p), O = Math.floor(n.y - g + 1);
    let y = !1;
    (m < n.x || m >= n.x + o || O < n.y || O >= n.y + h) && (y = !0);
    const C = s.canSitOn ? u - 0.5 : u;
    return y ? null : new v(m, O, C);
  }
  handleMouseOverTile(t, e) {
    if (this.whereYouClickIsWhereYouGo())
      return new ka(new v(t.tileXAsInt, t.tileYAsInt, t.tileZAsInt), 0, !0, t.eventId);
    const s = this._roomEngine.getRoomObjectCursor(e);
    if (s && s.visualization) {
      const r = t.tileXAsInt, n = t.tileYAsInt, a = t.tileZAsInt;
      if (this._roomEngine.getRoomInstance(e)) {
        const h = this._roomEngine.getRoomTileObjectMap(e);
        if (h) {
          const u = h.getObjectIntTile(r, n), c = this._roomEngine.getFurnitureStackingHeightMap(e);
          if (c) {
            if (u && u.model && u.model.getValue(I.FURNITURE_IS_VARIABLE_HEIGHT) > 0) {
              const l = c.getTileHeight(r, n), _ = this._roomEngine.getLegacyWallGeometry(e).getHeight(r, n);
              return new ka(new v(r, n, a), l - _, !0, t.eventId);
            }
            return new ka(new v(r, n, a), 0, !0, t.eventId);
          }
        }
      }
    }
    return null;
  }
  placeObject(t, e, s) {
    const r = this.getSelectedRoomObjectData(t);
    if (!r) return;
    let n = null, a = r.id;
    const o = r.category;
    let h = 0, u = 0, c = 0, l = 0, _ = "";
    if (this._roomEngine && G().connection && (n = this._roomEngine.getRoomObject(t, a, o), n)) {
      const d = n.getLocation();
      if (l = n.getDirection().x, o === L.FLOOR || o === L.UNIT)
        h = d.x, u = d.y, c = d.z;
      else if (o === L.WALL) {
        h = d.x, u = d.y, c = d.z;
        const f = this._roomEngine.getLegacyWallGeometry(t);
        f && (_ = f.getOldLocationString(d, l));
      }
      l = (l / 45 % 8 + 8) % 8, a < 0 && o === L.UNIT && (a = a * -1), this._objectPlacementSource !== Pg.CATALOG && (o === L.UNIT ? r.typeId === pr.PET ? G().connection.send(new Tx(a, Math.trunc(h), Math.trunc(u))) : r.typeId === pr.RENTABLE_BOT && G().connection.send(new dx(a, Math.trunc(h), Math.trunc(u))) : n.model.getValue(I.FURNITURE_IS_STICKIE) !== void 0 ? G().connection.send(new Nx(a, _)) : G().connection.send(new Px(a, o, _, Math.trunc(h), Math.trunc(u), l)));
    }
    if (this._roomEngine.setPlacedRoomObjectData(t, new Jf(r.id, r.category, null, r.dir, null)), this.resetSelectedObjectData(t), this._roomEngine && x()) {
      const d = n && n.id === r.id;
      x().dispatchEvent(new kF(lt.PLACED, t, a, o, _, h, u, c, l, d, e, s, r.instanceData));
    }
  }
  modifyRoomObject(t, e, s, r) {
    if (!this._roomEngine) return !1;
    const n = this._roomEngine.getRoomObject(t, e, s);
    if (!n) return !1;
    let a = !0;
    switch (r) {
      case yt.OBJECT_ROTATE_POSITIVE:
      case yt.OBJECT_ROTATE_NEGATIVE:
        if (G().connection) {
          let o = 0;
          r == yt.OBJECT_ROTATE_NEGATIVE ? o = this.getValidRoomObjectDirection(n, !1) : o = this.getValidRoomObjectDirection(n, !0);
          const h = n.getLocation().x, u = n.getLocation().y;
          if (this.isValidLocation(n, new v(o), this._roomEngine.getFurnitureStackingHeightMap(t)))
            if (o = Math.trunc(o / 45), n.type === Xt.MONSTER_PLANT) {
              const c = Zr().getSession(t);
              if (c) {
                const l = c.userDataManager.getUserDataByIndex(e);
                l && G().connection.send(new dE(l.webID, Math.trunc(h), Math.trunc(u), o));
              }
            } else
              G().connection.send(new fE(e, h, u, o));
        }
        break;
      case yt.OBJECT_EJECT:
      case yt.OBJECT_PICKUP:
        G().connection && G().connection.send(new bx(s, e));
        break;
      case yt.OBJECT_PICKUP_PET:
        if (G().connection) {
          const o = Zr().getSession(t);
          if (o) {
            const h = o.userDataManager.getUserDataByIndex(e);
            o.pickupPet(h.webID);
          }
        }
        break;
      case yt.OBJECT_PICKUP_BOT:
        if (G().connection) {
          const o = Zr().getSession(t);
          if (o) {
            const h = o.userDataManager.getUserDataByIndex(e);
            o.pickupBot(h.webID);
          }
        }
        break;
      case yt.OBJECT_MOVE:
        a = !1, this.setFurnitureAlphaMultiplier(n, 0.5), this.setSelectedRoomObjectData(t, n.id, s, n.getLocation(), n.getDirection(), r), this._roomEngine.setObjectMoverIconSprite(n.id, s, !0), this._roomEngine.setObjectMoverIconSpriteVisible(!1);
        break;
      case yt.OBJECT_MOVE_TO: {
        const o = this.getSelectedRoomObjectData(t);
        if (this.updateSelectedObjectData(t, o.id, o.category, o.loc, o.dir, yt.OBJECT_MOVE_TO, o.typeId, o.instanceData, o.stuffData, o.state, o.animFrame, o.posture), this.setFurnitureAlphaMultiplier(n, 1), this._roomEngine.removeObjectMoverIconSprite(), G().connection) {
          if (s === L.FLOOR) {
            const h = n.getDirection().x % 360, u = n.getLocation(), c = h / 45;
            G().connection.send(new fE(e, u.x, u.y, c));
          } else if (s === L.WALL) {
            const h = n.getDirection().x % 360, u = this._roomEngine.getLegacyWallGeometry(t);
            if (u) {
              const c = u.getOldLocationString(n.getLocation(), h);
              c && G().connection.send(new zx(e, c));
            }
          } else if (s === L.UNIT) {
            const h = n.getDirection().x % 360, u = n.getLocation(), c = h / 45;
            parseInt(n.model.getValue(I.RACE));
            const l = Zr().getSession(t);
            if (l) {
              const _ = l.userDataManager.getUserDataByIndex(e);
              _ && G().connection.send(new dE(_.webID, u.x, u.y, c));
            }
          }
        }
        break;
      }
    }
    return a && this.resetSelectedObjectData(t), !0;
  }
  modifyRoomObjectDataWithMap(t, e, s, r, n) {
    if (!this._roomEngine || !this._roomEngine.getRoomObject(t, e, s)) return !1;
    switch (r) {
      case yt.OBJECT_SAVE_STUFF_DATA:
        G().connection && G().connection.send(new Ox(e, n));
        break;
    }
    return !0;
  }
  modifyWallItemData(t, e, s, r) {
    return !this._roomEngine || !G().connection ? !1 : (G().connection.send(new Rx(e, s, r)), !0);
  }
  deleteWallItem(t, e) {
    return !this._roomEngine || !G().connection ? !1 : (G().connection.send(new Sx(e)), !0);
  }
  getValidRoomObjectDirection(t, e) {
    if (!t || !t.model) return 0;
    let s = 0, r = 0, n = [];
    t.type === Xt.MONSTER_PLANT ? n = t.model.getValue(I.PET_ALLOWED_DIRECTIONS) : n = t.model.getValue(I.FURNITURE_ALLOWED_DIRECTIONS);
    let a = t.getDirection().x;
    if (n && n.length) {
      if (s = n.indexOf(a), s < 0) {
        for (s = 0, r = 0; r < n.length && !(a <= n[r]); )
          s++, r++;
        s = s % n.length;
      }
      e ? s = (s + 1) % n.length : s = (s - 1 + n.length) % n.length, a = n[s];
    }
    return a;
  }
  isValidLocation(t, e, s) {
    if (!t || !t.model || !e) return !1;
    const r = t.getDirection(), n = t.getLocation();
    if (!r || !n) return !1;
    if (r.x % 180 === e.x % 180) return !0;
    let a = t.model.getValue(I.FURNITURE_SIZE_X), o = t.model.getValue(I.FURNITURE_SIZE_Y);
    a < 1 && (a = 1), o < 1 && (o = 1);
    let h = a, u = o, c = Math.trunc(Math.trunc(e.x + 45) % 360 / 90);
    if ((c === 1 || c === 3) && ([a, o] = [o, a]), c = Math.trunc(Math.trunc(r.x + 45) % 360 / 90), (c === 1 || c === 3) && ([h, u] = [u, h]), s && n) {
      const l = t.model.getValue(I.FURNITURE_ALWAYS_STACKABLE) === 1;
      if (s.validateLocation(n.x, n.y, a, o, n.x, n.y, h, u, l, n.z)) return !0;
    }
    return !1;
  }
  placeObjectOnUser(t, e, s) {
    const r = this.getSelectedRoomObjectData(t);
    !r || !this._roomEngine.getRoomObject(t, e, s) || !this._roomEngine || !x() || x().dispatchEvent(new zF(lt.PLACED_ON_USER, t, e, s, r.id, r.category));
  }
  setSelectedObject(t, e, s) {
    if (!(!this._roomEngine || !x()))
      switch (s) {
        case L.UNIT:
        case L.FLOOR:
        case L.WALL:
          if (s === L.UNIT)
            this.deselectObject(t), this.setSelectedAvatar(t, e, !0);
          else if (this.setSelectedAvatar(t, 0, !1), e !== this._selectedObjectId) {
            this.deselectObject(t);
            const n = this._roomEngine.getRoomObject(t, e, s);
            n && n.logic && (n.logic.processUpdateMessage(new wu(!0)), this._selectedObjectId = e, this._selectedObjectCategory = s);
          }
          x().dispatchEvent(new lt(lt.SELECTED, t, e, s));
          return;
      }
  }
  deselectObject(t) {
    if (this._selectedObjectId === -1) return;
    const e = this._roomEngine.getRoomObject(t, this._selectedObjectId, this._selectedObjectCategory);
    e && e.logic && (e.logic.processUpdateMessage(new wu(!1)), this._selectedObjectId = -1, this._selectedObjectCategory = L.MINIMUM);
  }
  setSelectedAvatar(t, e, s) {
    if (!this._roomEngine) return;
    const r = L.UNIT, n = this._roomEngine.getRoomObject(t, this._selectedAvatarId, r);
    n && n.logic && (n.logic.processUpdateMessage(new Uc(!1)), this._selectedAvatarId = -1);
    let a = !1;
    if (s) {
      const h = this._roomEngine.getRoomObject(t, e, r);
      if (h && h.logic) {
        h.logic.processUpdateMessage(new Uc(!0)), a = !0, this._selectedAvatarId = e;
        const u = h.getLocation();
        u && G().connection.send(new $x(~~u.x, ~~u.y));
      }
    }
    const o = this._roomEngine.getRoomObjectSelectionArrow(t);
    o && o.logic && (a && !this._roomEngine.isPlayingGame() ? o.logic.processUpdateMessage(new Sr(Sr.ENABLED)) : o.logic.processUpdateMessage(new Sr(Sr.DISABLED)));
  }
  resetSelectedObjectData(t) {
    if (!this._roomEngine) return;
    this._roomEngine.removeObjectMoverIconSprite();
    const e = this.getSelectedRoomObjectData(t);
    if (e) {
      if (e.operation === yt.OBJECT_MOVE || e.operation === yt.OBJECT_MOVE_TO) {
        const s = this._roomEngine.getRoomObject(t, e.id, e.category);
        s && e.operation !== yt.OBJECT_MOVE_TO && (s.setLocation(e.loc), s.setDirection(e.dir)), this.setFurnitureAlphaMultiplier(s, 1), e.category === L.WALL && this._roomEngine.updateRoomObjectMask(t, e.id, !0), this.updateSelectedObjectData(t, e.id, e.category, e.loc, e.dir, yt.OBJECT_MOVE, e.typeId, e.instanceData, e.stuffData, e.state, e.animFrame, e.posture);
      } else if (e.operation === yt.OBJECT_PLACE) {
        const s = e.id;
        switch (e.category) {
          case L.FLOOR:
            this._roomEngine.removeRoomObjectFloor(t, s);
            break;
          case L.WALL:
            this._roomEngine.removeRoomObjectWall(t, s);
            break;
          case L.UNIT:
            this._roomEngine.removeRoomObjectUser(t, s);
            break;
        }
      }
      this._roomEngine.setSelectedRoomObjectData(t, null);
    }
  }
  getSelectedRoomObjectData(t) {
    return this._roomEngine ? this._roomEngine.getSelectedRoomObjectData(t) : null;
  }
  setFurnitureAlphaMultiplier(t, e) {
    !t || !t.model || t.model.setValue(I.FURNITURE_ALPHA_MULTIPLIER, e);
  }
  decorateModeMove(t) {
    return this._roomEngine.isDecorating && !(t.ctrlKey || t.shiftKey);
  }
  cancelRoomObjectPlacement(t) {
    return this.resetSelectedObjectData(t), !0;
  }
  setSelectedRoomObjectData(t, e, s, r, n, a, o = 0, h = null, u = null, c = -1, l = -1, _ = null) {
    if (this.resetSelectedObjectData(t), !this._roomEngine) return;
    const d = new Jf(e, s, a, r, n, o, h, u, c, l, _);
    this._roomEngine.setSelectedRoomObjectData(t, d);
  }
  updateSelectedObjectData(t, e, s, r, n, a, o = 0, h = null, u = null, c = -1, l = -1, _ = null) {
    if (!this._roomEngine) return null;
    const d = new Jf(e, s, a, r, n, o, h, u, c, l, _);
    this._roomEngine.setSelectedRoomObjectData(t, d);
  }
  handleUserPlace(t, e, s, r) {
    return r.isRoomTile(e, s) ? (t.setLocation(new v(e, s, r.getHeight(e, s))), !0) : !1;
  }
  get engine() {
    return this._roomEngine;
  }
  get selectedAvatarId() {
    return this._selectedAvatarId;
  }
  whereYouClickIsWhereYouGo() {
    return this._roomEngine.whereYouClickIsWhereYouGo();
  }
}
class frt {
  constructor(t) {
    this._roomObjectVariableAccurateZ = t || "", this._location = new v(), this._screenLocation = new v(), this._locationChanged = !1, this._geometryUpdateId = -1, this._objectUpdateId = -1;
  }
  dispose() {
    this._screenLocation = null;
  }
  updateLocation(t, e) {
    if (!t || !e) return null;
    let s = !1;
    const r = t.getLocation();
    if ((e.updateId !== this._geometryUpdateId || t.updateCounter !== this._objectUpdateId) && (this._objectUpdateId = t.updateCounter, (e.updateId !== this._geometryUpdateId || r.x !== this._location.x || r.y !== this._location.y || r.z !== this._location.z) && (this._geometryUpdateId = e.updateId, this._location.assign(r), s = !0)), this._locationChanged = s, this._locationChanged) {
      const n = e.getScreenPosition(r);
      if (!n) return null;
      const a = t.model.getValue(this._roomObjectVariableAccurateZ);
      if (isNaN(a) || a === 0) {
        const o = new v(Math.round(r.x), Math.round(r.y), r.z);
        if (o.x !== r.x || o.y !== r.y) {
          const h = e.getScreenPosition(o);
          this._screenLocation.assign(n), h && (this._screenLocation.z = h.z);
        } else
          this._screenLocation.assign(n);
      } else
        this._screenLocation.assign(n);
      this._screenLocation.x = Math.round(this._screenLocation.x), this._screenLocation.y = Math.round(this._screenLocation.y);
    }
    return this._screenLocation;
  }
  get locationChanged() {
    return this._locationChanged;
  }
}
class grt {
  constructor() {
    this._sprites = [], this._updateId1 = -1, this._updateId2 = -1, this._isEmpty = !1;
  }
  dispose() {
    this.setSpriteCount(0);
  }
  addSprite(t) {
    this._sprites.push(t);
  }
  getSprite(t) {
    return this._sprites[t];
  }
  needsUpdate(t, e) {
    return t === this._updateId1 && e === this._updateId2 ? !1 : (this._updateId1 = t, this._updateId2 = e, !0);
  }
  setSpriteCount(t) {
    var e;
    if (t < this._sprites.length) {
      let s = t;
      for (; s < this._sprites.length; )
        (e = this._sprites[s]) == null || e.dispose(), s++;
      this._sprites.splice(t, this._sprites.length - t);
    }
    this._isEmpty = !this._sprites.length;
  }
  get sprites() {
    return this._sprites;
  }
  get spriteCount() {
    return this._sprites.length;
  }
  get isEmpty() {
    return this._isEmpty;
  }
}
class prt {
  constructor(t) {
    this._location = new frt(t), this._sprites = new grt();
  }
  dispose() {
    this._location && (this._location.dispose(), this._location = null), this._sprites && (this._sprites.dispose(), this._sprites = null);
  }
  get objectId() {
    return this._objectId;
  }
  set objectId(t) {
    this._objectId = t;
  }
  get location() {
    return this._location;
  }
  get sprites() {
    return this._sprites;
  }
}
const lu = class lu {
  constructor(t) {
    this._data = /* @__PURE__ */ new Map(), this._roomObjectVariableAccurateZ = t;
  }
  dispose() {
    if (this._data) {
      for (const [t, e] of this._data.entries())
        e && (this._data.delete(t), e.dispose());
      this._data = null;
    }
  }
  getObjectCache(t) {
    let e = this._data.get(t);
    return e || (e = new prt(this._roomObjectVariableAccurateZ), this._data.set(t, e)), e;
  }
  removeObjectCache(t) {
    const e = this._data.get(t);
    e && (this._data.delete(t), e.dispose());
  }
  getSortableSpriteList() {
    const t = [];
    for (const e of this._data.values()) {
      if (!e) continue;
      const s = e.sprites && e.sprites.sprites;
      if (!(!s || !s.length)) {
        for (const r of s)
          if (r && r.sprite.spriteType !== Us.ROOM_PLANE && r.sprite.name !== "") {
            const n = new C1();
            n.objectId = e.objectId, n.x = r.x, n.y = r.y, n.z = r.z, n.name = r.sprite.name || "", n.flipH = r.sprite.flipH, n.alpha = r.sprite.alpha, n.color = r.sprite.color.toString(), n.blendMode = r.sprite.blendMode.toString(), n.width = r.sprite.width, n.height = r.sprite.height, n.type = r.sprite.type, n.posture = r.sprite.posture;
            const a = this.isSkewedSprite(r.sprite);
            a && (n.skew = r.sprite.direction % 4 === 0 ? -0.5 : 0.5), (a || r.name.indexOf("%image.library.url%") >= 0 || r.name.indexOf("%group.badge.url%") >= 0) && n.width <= lu.MAX_SIZE_FOR_AVG_COLOR && n.height <= lu.MAX_SIZE_FOR_AVG_COLOR && r.sprite.name.indexOf("external_image_wallitem") === 0 && (n.frame = !0), t.push(n);
          }
      }
    }
    return !t || !t.length ? null : t;
  }
  isSkewedSprite(t) {
    return t.type ? t.type.indexOf("external_image_wallitem") === 0 && t.tag === "THUMBNAIL" || t.type.indexOf("guild_forum") === 0 && t.tag === "THUMBNAIL" : !1;
  }
  getPlaneSortableSprites() {
    const t = [];
    for (const e of this._data.values())
      for (const s of e.sprites.sprites)
        s.sprite.spriteType === Us.ROOM_PLANE && t.push(s);
    return t;
  }
};
lu.MAX_SIZE_FOR_AVG_COLOR = 200;
let hT = lu;
const mrt = 4;
class II extends Ft {
  constructor() {
    super(...arguments), this._offsetX = 0, this._offsetY = 0, this._tag = "", this._alphaTolerance = _i.MATCH_OPAQUE_PIXELS, this._varyingDepth = !1, this._clickHandling = !1, this._skipMouseHandling = !1, this._updateId1 = -1, this._updateId2 = -1;
  }
  needsUpdate(t, e) {
    return this._updateId1 === t && this._updateId2 === e ? !1 : (this._updateId1 = t, this._updateId2 = e, !0);
  }
  setTexture(t) {
    t || (t = W.EMPTY), t !== this.texture && (t === W.EMPTY && (this._updateId1 = -1, this._updateId2 = -1), this.texture = t);
  }
  containsPoint(t) {
    if (!t || this.alphaTolerance > 255 || !this.texture || this.texture === W.EMPTY || (t = new st(t.x * this.scale.x, t.y * this.scale.y), !super.containsPoint(t))) return !1;
    const e = this.texture, s = this.texture.source;
    if ((!s || !s.hitMap) && !II.generateHitMapForTextureSource(s)) return !1;
    const r = s.hitMap;
    if (!r) return !1;
    let n = t.x + e.frame.x, a = t.y + e.frame.y;
    this.texture.trim && (n -= e.trim.x, a -= e.trim.y), n = Math.round(n) * s.resolution, a = Math.round(a) * s.resolution;
    const o = (n + a * s.width) * 4;
    return r[o + 3] >= this.alphaTolerance;
  }
  static generateHitMapForTextureSource(t) {
    var a;
    if (!t) return !1;
    const e = ma(), s = Math.max(Math.round(t.width * t.resolution), 1), r = Math.max(Math.round(t.height * t.resolution), 1);
    let n = null;
    if (e instanceof ty)
      n = ((a = le.getPixels(new W(t))) == null ? void 0 : a.pixels) ?? null;
    else if (e.type === Or.WEBGL) {
      n = new Uint8ClampedArray(mrt * s * r);
      const o = e.renderTarget.getRenderTarget(t), h = e.renderTarget.getGpuRenderTarget(o), u = e.gl;
      u.bindFramebuffer(u.FRAMEBUFFER, h.resolveTargetFramebuffer), u.readPixels(
        0,
        0,
        s,
        r,
        u.RGBA,
        u.UNSIGNED_BYTE,
        n
      );
    }
    return n ? (t.hitMap = n, !0) : !1;
  }
  get offsetX() {
    return this._offsetX;
  }
  set offsetX(t) {
    this._offsetX = t;
  }
  get offsetY() {
    return this._offsetY;
  }
  set offsetY(t) {
    this._offsetY = t;
  }
  get tag() {
    return this._tag;
  }
  set tag(t) {
    this._tag = t;
  }
  get alphaTolerance() {
    return this._alphaTolerance;
  }
  set alphaTolerance(t) {
    this._alphaTolerance = t;
  }
  get varyingDepth() {
    return this._varyingDepth;
  }
  set varyingDepth(t) {
    this._varyingDepth = t;
  }
  get clickHandling() {
    return this._clickHandling;
  }
  set clickHandling(t) {
    this._clickHandling = t;
  }
  get skipMouseHandling() {
    return this._skipMouseHandling;
  }
  set skipMouseHandling(t) {
    this._skipMouseHandling = t;
  }
}
class Ert {
  constructor() {
    this._objectId = "", this._spriteTag = "";
  }
  get objectId() {
    return this._objectId;
  }
  set objectId(t) {
    this._objectId = t;
  }
  get spriteTag() {
    return this._spriteTag;
  }
  set spriteTag(t) {
    this._spriteTag = t;
  }
}
const xd = class xd {
  constructor() {
    this._name = "", this._sprite = null, this._x = 0, this._y = 0, this._z = 0;
  }
  dispose() {
    this._z = -xd.Z_INFINITY, this._sprite = null;
  }
  get name() {
    return this._name;
  }
  set name(t) {
    this._name = t;
  }
  get sprite() {
    return this._sprite;
  }
  set sprite(t) {
    this._sprite = t;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t;
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t;
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t;
  }
};
xd.Z_INFINITY = 1e8;
let uT = xd;
class Trt {
  constructor(t, e, s, r, n) {
    this._id = t, this._container = e, this._renderTimestamp = 0, this._totalTimeRunning = 0, this._lastFrame = 0, this._master = null, this._display = null, this._mask = null, this._sortableSprites = [], this._spriteCount = 0, this._activeSpriteCount = 0, this._spritePool = [], this._skipObjectUpdate = !1, this._runningSlow = !1, this._width = 0, this._height = 0, this._renderedWidth = 0, this._renderedHeight = 0, this._screenOffsetX = 0, this._screenOffsetY = 0, this._mouseLocation = new st(), this._mouseOldX = 0, this._mouseOldY = 0, this._mouseCheckCount = 0, this._mouseSpriteWasHit = !1, this._mouseActiveObjects = /* @__PURE__ */ new Map(), this._eventCache = /* @__PURE__ */ new Map(), this._eventId = 0, this._scale = 1, this._SafeStr_4507 = !1, this._rotation = 0, this._rotationOrigin = null, this._rotationRodLength = 0, this._SafeStr_795 = 0, this._noSpriteVisibilityChecking = !1, this._usesExclusionRectangles = !1, this._usesMask = !0, this._canvasUpdated = !1, this._mouseListener = null, this._geometry = new $s(n, new v(-135, 30, 0), new v(11, 11, 5), new v(-135, 0.5, 0)), this._animationFPS = Ct().getValue("system.fps.animation", 24), this._objectCache = new hT(this._container.roomObjectVariableAccurateZ), this.setupCanvas(), this.initialize(s, r);
  }
  setupCanvas() {
    if (this._master || (this._master = new Qt()), this._master.cullableChildren = !1, !this._display) {
      const t = new Qt();
      t.isRenderGroup = !1, t.cullableChildren = !1, this._master.addChild(t), this._display = t;
    }
  }
  dispose() {
    if (this.cleanSprites(0, !0), this._geometry && (this._geometry.dispose(), this._geometry = null), this._mask && (this._mask = null), this._objectCache && (this._objectCache.dispose(), this._objectCache = null), this._master) {
      for (; this._master.children.length; )
        this._master.removeChildAt(0).destroy();
      this._master.parent && this._master.parent.removeChild(this._master), this._master.destroy(), this._master = null;
    }
    if (this._display = null, this._sortableSprites = [], this._mouseActiveObjects && (this._mouseActiveObjects.clear(), this._mouseActiveObjects = null), this._spritePool) {
      for (const t of this._spritePool)
        this.cleanSprite(t, !0);
      this._spritePool = [];
    }
    this._eventCache && (this._eventCache.clear(), this._eventCache = null), this._mouseListener = null;
  }
  initialize(t, e) {
    if (t = t < 1 ? 1 : t, e = e < 1 ? 1 : e, this._usesMask && (this._mask ? (this._mask.width = t, this._mask.height = e) : (this._mask = new Ft(W.WHITE), this._mask.tint = 16711680, this._mask.width = t, this._mask.height = e, this._master && (this._master.addChild(this._mask), this._display && (this._display.mask = this._mask)))), this._master)
      if (this._master.filterArea) {
        const s = this._master.filterArea;
        s.width = t, s.height = e;
      } else
        this._master.filterArea = new Kt(0, 0, t, e);
    this._width = t, this._height = e;
  }
  setMask(t) {
    t && !this._usesMask ? (this._usesMask = !0, this._mask && this._mask.parent !== this._master && (this._master.addChild(this._mask), this._display.mask = this._mask)) : !t && this._usesMask && (this._usesMask = !1, this._mask && this._mask.parent === this._master && (this._master.removeChild(this._mask), this._display.mask = null));
  }
  setScale(t, e = null, s = null, r = !1) {
    !this._master || !this._display || (e || (e = new st(this._width / 2, this._height / 2)), s || (s = e), e = this._display.toLocal(e), this._scale = t, this.screenOffsetX = s.x - e.x * this._scale, this.screenOffsetY = s.y - e.y * this._scale);
  }
  render(t, e = !1) {
    if (this._canvasUpdated = !1, this._totalTimeRunning += VT().deltaTime, this._totalTimeRunning === this._renderTimestamp || (t === -1 && (t = this._renderTimestamp + 1), !this._container || !this._geometry)) return;
    (this._width !== this._renderedWidth || this._height !== this._renderedHeight) && (e = !0), (this._display.x !== this._screenOffsetX || this._display.y !== this._screenOffsetY) && (this._display.x = Math.floor(this._screenOffsetX), this._display.y = Math.floor(this._screenOffsetY), e = !0), this._display.scale.x !== this._scale && (this._display.scale.set(this._scale), e = !0), this.doMagic();
    const s = Math.round(this._totalTimeRunning / (60 / this._animationFPS));
    let r = !1;
    s !== this._lastFrame && (this._lastFrame = s, r = !0);
    let n = 0;
    const a = this._container.objects;
    if (a.size)
      for (const h of a.values())
        h && (n = n + this.renderObject(h, h.instanceId.toString(), t, e, r, n));
    this._sortableSprites.sort((h, u) => u.z - h.z), n < this._sortableSprites.length && this._sortableSprites.splice(n);
    let o = 0;
    for (; o < n; ) {
      const h = this._sortableSprites[o];
      h && h.sprite && this.renderSprite(o, h), o++;
    }
    this.cleanSprites(n), (e || r) && (this._canvasUpdated = !0), this._renderTimestamp = this._totalTimeRunning, this._renderedWidth = this._width, this._renderedHeight = this._height;
  }
  skipSpriteVisibilityChecking() {
    this._noSpriteVisibilityChecking = !0, this.render(-1, !0);
  }
  resumeSpriteVisibilityChecking() {
    this._noSpriteVisibilityChecking = !1;
  }
  getSortableSpriteList() {
    return this._objectCache.getSortableSpriteList();
  }
  getPlaneSortableSprites() {
    return this._objectCache.getPlaneSortableSprites();
  }
  removeFromCache(t) {
    this._objectCache.removeObjectCache(t);
  }
  renderObject(t, e, s, r, n, a) {
    if (!t) return 0;
    const o = t.visualization;
    if (!o)
      return this.removeFromCache(e), 0;
    const h = this.getCacheItem(e);
    h.objectId = t.instanceId;
    const u = h.location, c = h.sprites, l = u.updateLocation(t, this._geometry);
    if (!l)
      return this.removeFromCache(e), 0;
    if (n && o.update(this._geometry, s, !c.isEmpty || r, this._skipObjectUpdate && this._runningSlow), u.locationChanged && (r = !0), !c.needsUpdate(o.instanceId, o.updateSpriteCounter) && !r)
      return c.spriteCount;
    let _ = l.x, d = l.y, f = l.z;
    _ > 0 ? f = f + _ * 12e-8 : f = f + -_ * 12e-8, _ = _ + Math.trunc(this._width / 2), d = d + Math.trunc(this._height / 2);
    let p = 0;
    for (const g of o.sprites.values()) {
      if (!g || !g.visible) continue;
      const m = g.texture, O = m && m.source;
      if (!m || !O) continue;
      const y = _ + g.offsetX + this._screenOffsetX, C = d + g.offsetY + this._screenOffsetY;
      if (g.flipH) {
        const D = _ + -(m.width + -g.offsetX) + this._screenOffsetX;
        if (!this.isSpriteVisible(D, C, m.width, m.height)) continue;
      } else if (g.flipV) {
        const D = d + -(m.height + -g.offsetY) + this._screenOffsetY;
        if (!this.isSpriteVisible(y, D, m.width, m.height)) continue;
      } else if (!this.isSpriteVisible(y, C, m.width, m.height)) continue;
      let b = c.getSprite(p);
      b || (b = new uT(), c.addSprite(b), this._sortableSprites.push(b), b.name = e), b.sprite = g, (g.spriteType === Us.AVATAR || g.spriteType === Us.AVATAR_OWN) && (b.sprite.libraryAssetName = "avatar_" + t.id), b.x = y - this._screenOffsetX, b.y = C - this._screenOffsetY, b.z = f + g.relativeDepth + 37e-12 * a, p++, a++;
    }
    return c.setSpriteCount(p), this._canvasUpdated = !0, p;
  }
  getExtendedSprite(t) {
    if (t < 0 || t >= this._spriteCount) return null;
    const e = this._display.getChildAt(t);
    return e || null;
  }
  getExtendedSpriteIdentifier(t) {
    return t ? t.label : "";
  }
  renderSprite(t, e) {
    if (t >= this._spriteCount)
      return this.createAndAddSprite(e), !0;
    if (!e) return !1;
    const s = e.sprite, r = this.getExtendedSprite(t);
    if (!s || !r) return !1;
    if (r.varyingDepth !== s.varyingDepth)
      return r.varyingDepth && !s.varyingDepth ? (this._display.removeChildAt(t), this._spritePool.push(r), this.renderSprite(t, e)) : (this.createAndAddSprite(e, t), !0);
    if (r.needsUpdate(s.id, s.updateCounter) || zi.isVisualizationOn()) {
      r.tag = s.tag, r.alphaTolerance = s.alphaTolerance, r.label = e.name, r.varyingDepth = s.varyingDepth, r.clickHandling = s.clickHandling, r.skipMouseHandling = s.skipMouseHandling, r.filters = s.filters;
      const n = s.alpha / 255;
      r.alpha !== n && (r.alpha = n), r.tint !== s.color && (r.tint = s.color), r.blendMode !== s.blendMode && (r.blendMode = s.blendMode), r.texture !== s.texture && r.setTexture(s.texture), s.flipH ? r.scale.x !== -1 && (r.scale.x = -1) : r.scale.x !== 1 && (r.scale.x = 1), s.flipV ? r.scale.y !== -1 && (r.scale.y = -1) : r.scale.y !== 1 && (r.scale.y = 1), this.updateEnterRoomEffect(r, s);
    }
    return r.x = Math.round(e.x), r.y = Math.round(e.y), r.offsetX = s.offsetX, r.offsetY = s.offsetY, !0;
  }
  createAndAddSprite(t, e = -1) {
    const s = t.sprite;
    if (!s) return;
    let r = null;
    this._spritePool.length > 0 && (r = this._spritePool.pop());
    let n = !1;
    r || (r = new II({
      texture: s.texture
    }), n = !0), r.children.length && r.removeChildren(), r.tag = s.tag, r.alphaTolerance = s.alphaTolerance, r.alpha = s.alpha / 255, r.tint = s.color, r.x = t.x, r.y = t.y, r.offsetX = s.offsetX, r.offsetY = s.offsetY, r.label = s.name, r.varyingDepth = s.varyingDepth, r.clickHandling = s.clickHandling, r.skipMouseHandling = s.skipMouseHandling, r.blendMode = s.blendMode, r.filters = s.filters, n || r.setTexture(s.texture), s.flipH && (r.scale.x = -1), s.flipV && (r.scale.y = -1), this.updateEnterRoomEffect(r, s), e < 0 || e >= this._spriteCount ? (this._display.addChild(r), this._spriteCount++) : this._display.addChildAt(r, e), this._activeSpriteCount++;
  }
  cleanSprites(t, e = !1) {
    if (this._display) {
      if (t < 0 && (t = 0), t < this._activeSpriteCount || !this._activeSpriteCount) {
        let s = this._spriteCount - 1;
        for (; s >= t; )
          this.cleanSprite(this.getExtendedSprite(s), e), s--;
      }
      this._activeSpriteCount = t;
    }
  }
  updateEnterRoomEffect(t, e) {
    if (!(!zi.isVisualizationOn() || !e))
      switch (e.spriteType) {
        case Us.AVATAR_OWN:
          return;
        case Us.ROOM_PLANE:
          t.alpha = zi.getDelta(0.9);
          return;
        case Us.AVATAR:
          t.alpha = zi.getDelta(0.5);
          return;
        default:
          t.alpha = zi.getDelta(0.1);
      }
  }
  cleanSprite(t, e) {
    t && (e ? (t.parent && t.parent.removeChild(t), t.destroy({
      children: !0
    })) : t.setTexture(null));
  }
  update() {
    this._mouseCheckCount, this._mouseCheckCount = 0, this._eventId++;
  }
  setMouseListener(t) {
    this._mouseListener = t;
  }
  getCacheItem(t) {
    return this._objectCache.getObjectCache(t);
  }
  isSpriteVisible(t, e, s, r) {
    return !!(this._noSpriteVisibilityChecking || (t = (t - this._screenOffsetX) * this._scale + this._screenOffsetX, e = (e - this._screenOffsetY) * this._scale + this._screenOffsetY, s = s * this._scale, r = r * this._scale, t < this._width && t + s >= 0 && e < this._height && e + r >= 0 && !this._usesExclusionRectangles));
  }
  handleMouseEvent(t, e, s, r, n, a, o) {
    return t = t - this._screenOffsetX, e = e - this._screenOffsetY, this._mouseLocation.x = t / this._scale, this._mouseLocation.y = e / this._scale, this._mouseCheckCount > 0 && s == J.MOUSE_MOVE ? this._mouseSpriteWasHit : (this._mouseSpriteWasHit = this.checkMouseHits(Math.trunc(t / this._scale), Math.trunc(e / this._scale), s, r, n, a, o), this._mouseCheckCount++, this._mouseSpriteWasHit);
  }
  checkMouseHits(t, e, s, r = !1, n = !1, a = !1, o = !1) {
    const h = [];
    let u = !1, c = null, l = this._activeSpriteCount - 1;
    for (; l >= 0; ) {
      const f = this.getExtendedSprite(l);
      if (f && f.containsPoint(new st(t - f.x, e - f.y)) && !f.skipMouseHandling && !(f.clickHandling && (s === J.MOUSE_CLICK || s === J.DOUBLE_CLICK))) {
        const p = this.getExtendedSpriteIdentifier(f);
        if (h.indexOf(p) === -1) {
          const g = f.tag;
          let m = this._mouseActiveObjects.get(p);
          m && m.spriteTag !== g && (c = this.createMouseEvent(0, 0, 0, 0, J.ROLL_OUT, m.spriteTag, r, n, a, o), this.bufferMouseEvent(c, p)), s === J.MOUSE_MOVE && (!m || m.spriteTag !== g) ? c = this.createMouseEvent(t, e, t - f.x, e - f.y, J.ROLL_OVER, g, r, n, a, o) : (c = this.createMouseEvent(t, e, t - f.x, e - f.y, s, g, r, n, a, o), c.spriteOffsetX = f.offsetX, c.spriteOffsetY = f.offsetY), m || (m = new Ert(), m.objectId = p, this._mouseActiveObjects.set(p, m)), m.spriteTag = g, (s !== J.MOUSE_MOVE || t !== this._mouseOldX || e !== this._mouseOldY) && this.bufferMouseEvent(c, p), h.push(p);
        }
        u = !0;
      }
      l--;
    }
    const _ = [];
    for (const f of this._mouseActiveObjects.keys()) f && _.push(f);
    let d = 0;
    for (; d < _.length; ) {
      const f = _[d];
      h.indexOf(f) >= 0 && (_[d] = null), d++;
    }
    for (d = 0; d < _.length; ) {
      const f = _[d];
      if (f !== null) {
        const p = this._mouseActiveObjects.get(f);
        p && this._mouseActiveObjects.delete(f);
        const g = this.createMouseEvent(0, 0, 0, 0, J.ROLL_OUT, p.spriteTag, r, n, a, o);
        this.bufferMouseEvent(g, f);
      }
      d++;
    }
    return this.processMouseEvents(), this._mouseOldX = t, this._mouseOldY = e, u;
  }
  createMouseEvent(t, e, s, r, n, a, o, h, u, c) {
    const l = t - this._width / 2, _ = e - this._height / 2, d = `canvas_${this._id}`;
    return new VF(n, d + "_" + this._eventId, d, a, l, _, s, r, h, o, u, c);
  }
  bufferMouseEvent(t, e) {
    !t || !this._eventCache || (this._eventCache.delete(e), this._eventCache.set(e, t));
  }
  processMouseEvents() {
    if (!(!this._container || !this._eventCache)) {
      for (const [t, e] of this._eventCache.entries()) {
        if (!this._eventCache) return;
        if (!e) continue;
        const s = this._container.getRoomObject(parseInt(t));
        if (s)
          if (this._mouseListener)
            this._mouseListener.processRoomCanvasMouseEvent(e, s, this._geometry);
          else {
            const r = s.mouseHandler;
            r && r.mouseEvent(e, this._geometry);
          }
      }
      this._eventCache && this._eventCache.clear();
    }
  }
  getDisplayAsTexture() {
    this._noSpriteVisibilityChecking = !0;
    const t = this._scale, e = this._screenOffsetX, s = this._screenOffsetY;
    this.setScale(1), this._screenOffsetX = 0, this._screenOffsetY = 0, this.render(-1, !0), this._display.mask = null;
    const r = this._display.getBounds(), n = le.createAndWriteRenderTexture(this._display.width, this._display.height, this._display, new ot(1, 0, 0, 1, -r.x, -r.y));
    return this._display.mask = this._mask, this._noSpriteVisibilityChecking = !1, this.setScale(t), this._screenOffsetX = e, this._screenOffsetY = s, n;
  }
  doMagic() {
    const t = this.geometry;
    if (this._rotation !== 0) {
      let e = this._effectDirection;
      t.direction = new v(e.x + this._rotation, e.y, e.z), e = t.direction, t.setDepthVector(new v(e.x, e.y, 5));
      const s = new v();
      s.assign(this._rotationOrigin), s.x = s.x + this._rotationRodLength * Math.cos((e.x + 180) / 180 * Math.PI) * Math.cos(e.y / 180 * Math.PI), s.y = s.y + this._rotationRodLength * Math.sin((e.x + 180) / 180 * Math.PI) * Math.cos(e.y / 180 * Math.PI), s.z = s.z + this._rotationRodLength * Math.sin(e.y / 180 * Math.PI), t.location = s, this._effectLocation = new v(), this._effectLocation.assign(s), this._effectDirection = new v(), this._effectDirection.assign(t.direction);
    }
    if (Vc.isVisualizationOn() && !this._SafeStr_4507 ? this.changeShaking() : !Vc.isVisualizationOn() && this._SafeStr_4507 && this.changeShaking(), GE.isVisualizationOn() && this.changeRotation(), this._SafeStr_4507) {
      this._SafeStr_795++;
      const e = this._effectDirection, s = v.sum(e, new v(Math.sin(this._SafeStr_795 * 5 / 180 * Math.PI) * 2, Math.sin(this._SafeStr_795 / 180 * Math.PI) * 5, Math.sin(this._SafeStr_795 * 10 / 180 * Math.PI) * 2));
      t.direction = s;
    } else
      this._SafeStr_795 = 0, t.direction = this._effectDirection;
  }
  changeShaking() {
    if (this._SafeStr_4507 = !this._SafeStr_4507, this._SafeStr_4507) {
      const t = this.geometry.direction;
      this._effectDirection = new v(t.x, t.y, t.z);
    }
  }
  changeRotation() {
    if (this._SafeStr_4507) return;
    const t = this.geometry;
    if (t) {
      if (this._rotation === 0) {
        const e = t.location, s = t.directionAxis;
        this._effectLocation = new v(), this._effectLocation.assign(e), this._effectDirection = new v(), this._effectDirection.assign(t.direction);
        const r = $s.getIntersectionVector(e, s, new v(0, 0, 0), new v(0, 0, 1));
        r !== null && (this._rotationOrigin = new v(r.x, r.y, r.z), this._rotationRodLength = v.dif(r, e).length, this._rotation = 1);
        return;
      }
      this._rotation = 0, t.location = this._effectLocation, t.direction = this._effectDirection, t.setDepthVector(new v(this._effectDirection.x, this._effectDirection.y, 5));
    }
  }
  moveLeft() {
    if (this._rotation !== 0) {
      this._rotation === 1 ? this._rotation = -1 : this._rotation = this._rotation - 1;
      return;
    }
    const t = this.geometry, e = (t.direction.x - 90) / 180 * Math.PI;
    t.location = v.sum(t.location, new v(Math.cos(e) * Math.sqrt(2), Math.sin(e) * Math.sqrt(2)));
  }
  moveRight() {
    if (this._rotation !== 0) {
      this._rotation === -1 ? this._rotation = 1 : this._rotation = this._rotation + 1;
      return;
    }
    const t = this.geometry, e = (t.direction.x + 90) / 180 * Math.PI;
    t.location = v.sum(t.location, new v(Math.cos(e) * Math.sqrt(2), Math.sin(e) * Math.sqrt(2)));
  }
  moveUp() {
    if (this._rotation !== 0) return;
    const t = this.geometry, e = t.direction.x / 180 * Math.PI;
    t.location = v.sum(t.location, new v(Math.cos(e) * Math.sqrt(2), Math.sin(e) * Math.sqrt(2)));
  }
  moveDown() {
    if (this._rotation !== 0) return;
    const t = this.geometry, e = (t.direction.x + 180) / 180 * Math.PI;
    t.location = v.sum(t.location, new v(Math.cos(e) * Math.sqrt(2), Math.sin(e) * Math.sqrt(2)));
  }
  get id() {
    return this._id;
  }
  get geometry() {
    return this._geometry;
  }
  get master() {
    return this._master;
  }
  get display() {
    return this._display;
  }
  get screenOffsetX() {
    return this._screenOffsetX;
  }
  set screenOffsetX(t) {
    t = Math.trunc(t), this._mouseLocation.x = this._mouseLocation.x - (t - this._screenOffsetX), this._screenOffsetX = t;
  }
  get screenOffsetY() {
    return this._screenOffsetY;
  }
  set screenOffsetY(t) {
    t = Math.trunc(t), this._mouseLocation.y = this._mouseLocation.y - (t - this._screenOffsetY), this._screenOffsetY = t;
  }
  get scale() {
    return this._scale;
  }
  get width() {
    return this._width * this._scale;
  }
  get height() {
    return this._height * this._scale;
  }
  get canvasUpdated() {
    return this._canvasUpdated;
  }
  set canvasUpdated(t) {
    this._canvasUpdated = t;
  }
}
class Irt {
  constructor() {
    this._objects = /* @__PURE__ */ new Map(), this._canvases = /* @__PURE__ */ new Map(), this._disposed = !1, this._roomObjectVariableAccurateZ = null;
  }
  dispose() {
    if (!this._disposed) {
      if (this._canvases) {
        for (const [t, e] of this._canvases.entries())
          this._canvases.delete(t), e && e.dispose();
        this._canvases = null;
      }
      this._objects && (this._objects = null), this._disposed = !0;
    }
  }
  reset() {
    this._objects.clear();
  }
  getInstanceId(t) {
    return t ? t.instanceId : -1;
  }
  getRoomObject(t) {
    return this._objects.get(t);
  }
  addObject(t) {
    t && this._objects.set(this.getInstanceId(t), t);
  }
  removeObject(t) {
    const e = this.getInstanceId(t);
    this._objects.delete(e);
    for (const s of this._canvases.values()) {
      if (!s) continue;
      s.removeFromCache(e.toString());
    }
  }
  render(t, e = !1) {
    if (!(!this._canvases || !this._canvases.size))
      for (const s of this._canvases.values()) s && s.render(t, e);
  }
  update(t, e = !1) {
    if (!(!this._canvases || !this._canvases.size)) {
      this.render(t, e);
      for (const s of this._canvases.values()) s && s.update();
    }
  }
  getCanvas(t) {
    const e = this._canvases.get(t);
    return e || null;
  }
  createCanvas(t, e, s, r) {
    const n = this._canvases.get(t);
    if (n)
      return n.initialize(e, s), n.geometry && (n.geometry.scale = r), n;
    const a = this.createSpriteCanvas(t, e, s, r);
    if (a)
      return this._canvases.set(t, a), a;
  }
  createSpriteCanvas(t, e, s, r) {
    return new Trt(t, this, e, s, r);
  }
  removeCanvas(t) {
    const e = this._canvases.get(t);
    e && (this._canvases.delete(t), e.dispose());
  }
  get objects() {
    return this._objects;
  }
  get disposed() {
    return this._disposed;
  }
  get roomObjectVariableAccurateZ() {
    return this._roomObjectVariableAccurateZ;
  }
  set roomObjectVariableAccurateZ(t) {
    this._roomObjectVariableAccurateZ = t;
  }
}
const Tt = class Tt {
  constructor() {
    this._roomContentLoader = si(), this._roomSessionManager = Zr(), this._sessionDataManager = Xo(), this._roomManager = lrt(), this._roomObjectEventHandler = new drt(this), this._imageObjectIdBank = new tR(1e3), this._imageCallbacks = /* @__PURE__ */ new Map(), this._thumbnailObjectIdBank = new tR(1e3), this._thumbnailCallbacks = /* @__PURE__ */ new Map(), this._activeRoomId = -1, this._activeRoomActiveCanvas = -1, this._activeRoomActiveCanvasMouseX = 0, this._activeRoomActiveCanvasMouseY = 0, this._activeRoomIsDragged = !1, this._activeRoomWasDragged = !1, this._activeRoomDragStartX = 0, this._activeRoomDragStartY = 0, this._activeRoomDragX = 0, this._activeRoomDragY = 0, this._moveBlocked = !1, this._roomDraggingAlwaysCenters = !1, this._roomAllowsDragging = !0, this._roomDatas = /* @__PURE__ */ new Map(), this._roomInstanceDatas = /* @__PURE__ */ new Map(), this._skipFurnitureCreationForNextFrame = !1, this._mouseCursorUpdate = !1, this._badgeListenerObjects = /* @__PURE__ */ new Map(), this._areaSelectionManager = new bh(this);
  }
  async init() {
    aT().registerEventFunction((t) => this.processRoomObjectEvent(t)), x().addEventListener(mt.STARTED, (t) => this.onRoomSessionEvent(t)), x().addEventListener(mt.ENDED, (t) => this.onRoomSessionEvent(t)), await tg().init(), await this._roomContentLoader.init(), await this._roomManager.init(this);
    for (const t of this._roomDatas.values())
      t && this.createRoomInstance(t.roomId, t.data);
    this._roomContentLoader.setIconListener(this), this._roomManager.addUpdateCategory(L.FLOOR), this._roomManager.addUpdateCategory(L.WALL), this._roomManager.addUpdateCategory(L.UNIT), this._roomManager.addUpdateCategory(L.CURSOR), this._roomManager.addUpdateCategory(L.ROOM);
  }
  onRoomSessionEvent(t) {
    if (t instanceof mt)
      switch (t.type) {
        case mt.STARTED:
          tg().setRoomId(t.session.roomId);
          return;
        case mt.ENDED:
          tg().clearRoomId(), this.removeRoomInstance(t.session.roomId);
          return;
      }
  }
  setActiveRoomId(t) {
    this._activeRoomId = t;
  }
  destroyRoom(t) {
    this.removeRoomInstance(t);
  }
  getRoomInstance(t) {
    return this._roomManager && this._roomManager.getRoomInstance(this.getRoomId(t)) || null;
  }
  removeRoomInstance(t) {
    this.getRoomInstance(t) && this._roomManager && this._roomManager.removeRoomInstance(this.getRoomId(t));
    const s = this._roomInstanceDatas.get(t);
    s && (this._roomInstanceDatas.delete(s.roomId), s.dispose()), x().dispatchEvent(new ae(ae.DISPOSED, t));
  }
  createRoomInstance(t, e) {
    let s = "111", r = "201", n = "1";
    if (!e) {
      rt.warn("Room property messages");
      return;
    }
    const a = this._roomDatas.get(t);
    a && (this._roomDatas.delete(t), a.floorType && (s = a.floorType), a.wallType && (r = a.wallType), a.landscapeType && (n = a.landscapeType)), this.setupRoomInstance(t, e, s, r, n, this.getRoomInstanceModelName(t)) && (this._roomAllowsDragging = !0, x().dispatchEvent(new ae(ae.INITIALIZED, t)));
  }
  setupRoomInstance(t, e, s, r, n, a) {
    if (!this._roomManager) return;
    const o = this._roomManager.createRoomInstance(this.getRoomId(t));
    if (!o) return null;
    const h = L.ROOM, u = o.createRoomObjectAndInitalize(Tt.ROOM_OBJECT_ID, Tt.ROOM_OBJECT_TYPE, h);
    if (o.model.setValue(Ye.ROOM_IS_PUBLIC, 0), o.model.setValue(Ye.ROOM_Z_SCALE, 1), e && e.dimensions) {
      const _ = e.dimensions.minX, d = e.dimensions.maxX, f = e.dimensions.minY, p = e.dimensions.maxY;
      o.model.setValue(Ye.ROOM_MIN_X, _), o.model.setValue(Ye.ROOM_MAX_X, d), o.model.setValue(Ye.ROOM_MIN_Y, f), o.model.setValue(Ye.ROOM_MAX_Y, p);
      const g = Math.trunc(_ * 423 + d * 671 + f * 913 + p * 7509);
      u && u.model && u.model.setValue(I.ROOM_RANDOM_SEED, g);
    }
    const c = u && u.logic || null;
    if (c && (c.initialize(e), s && (c.processUpdateMessage(new we(we.ROOM_FLOOR_UPDATE, s)), o.model.setValue(I.ROOM_FLOOR_TYPE, s)), r && (c.processUpdateMessage(new we(we.ROOM_WALL_UPDATE, r)), o.model.setValue(I.ROOM_WALL_TYPE, r)), n && (c.processUpdateMessage(new we(we.ROOM_LANDSCAPE_UPDATE, n)), o.model.setValue(I.ROOM_LANDSCAPE_TYPE, n))), e && e.doors.length) {
      let l = 0;
      for (; l < e.doors.length; ) {
        const _ = e.doors[l];
        if (_) {
          const d = _.x, f = _.y, p = _.z, g = _.dir, m = qe.DOOR, O = "door_" + l, y = new v(d, f, p);
          c.processUpdateMessage(new qe(qe.ADD_MASK, O, m, y, qe.HOLE)), (g === 90 || g === 180) && (g === 90 && (o.model.setValue(I.ROOM_DOOR_X, d - 0.5), o.model.setValue(I.ROOM_DOOR_Y, f)), g === 180 && (o.model.setValue(I.ROOM_DOOR_X, d), o.model.setValue(I.ROOM_DOOR_Y, f - 0.5)), o.model.setValue(I.ROOM_DOOR_Z, p), o.model.setValue(I.ROOM_DOOR_DIR, g));
        }
        l++;
      }
    }
    return o.createRoomObjectAndInitalize(Tt.CURSOR_OBJECT_ID, Tt.CURSOR_OBJECT_TYPE, L.CURSOR), Ct().getValue("enable.avatar.arrow", !1) && o.createRoomObjectAndInitalize(Tt.ARROW_OBJECT_ID, Tt.ARROW_OBJECT_TYPE, L.CURSOR), o;
  }
  getRoomInstanceDisplay(t, e, s, r, n) {
    const a = this.getRoomInstance(t);
    if (!a) return null;
    let o = a.renderer;
    if (!o && (o = new Irt(), !o))
      return null;
    o.roomObjectVariableAccurateZ = I.OBJECT_ACCURATE_Z_VALUE, a.setRenderer(o);
    const h = o.createCanvas(e, s, r, n);
    if (!h) return null;
    if (h.setMouseListener(this._roomObjectEventHandler), h.geometry) {
      h.geometry.z_scale = a.model.getValue(Ye.ROOM_Z_SCALE);
      const u = a.model.getValue(I.ROOM_DOOR_X), c = a.model.getValue(I.ROOM_DOOR_Y), l = a.model.getValue(I.ROOM_DOOR_Z), _ = a.model.getValue(I.ROOM_DOOR_DIR), d = new v(u, c, l);
      let f = null;
      _ === 90 && (f = new v(-2e3, 0, 0)), _ === 180 && (f = new v(0, -2e3, 0)), h.geometry.setDisplacement(d, f);
      const p = h.master;
      if (p) {
        const g = new Qt();
        g.label = Tt.OVERLAY, p.addChild(g);
      }
    }
    return h.master;
  }
  setRoomInstanceRenderingCanvasMask(t, e, s) {
    const r = this.getRoomInstanceRenderingCanvas(t, e);
    r && r.setMask(s);
  }
  setRoomInstanceRenderingCanvasScale(t, e, s, r = null, n = null, a = !1, o = !1) {
    if (!Ct().getValue("room.zoom.enabled", !0)) return;
    o || (s = a ? -1 : s < 1 ? 0.5 : Math.floor(s));
    const h = this.getRoomInstanceRenderingCanvas(t, e);
    h && (h.setScale(s, r, n, a), x().dispatchEvent(new ae(ae.ROOM_ZOOMED, t)));
  }
  getRoomInstanceRenderingCanvas(t, e = -1) {
    const s = this.getRoomInstance(t);
    if (!s) return null;
    const r = s.renderer;
    if (!r) return null;
    e === -1 && (e = this._activeRoomActiveCanvas);
    const n = r.getCanvas(e);
    return n || null;
  }
  getActiveRoomInstanceRenderingCanvas() {
    return this.getRoomInstanceRenderingCanvas(this._activeRoomId, this._activeRoomActiveCanvas);
  }
  getRoomInstanceRenderingCanvasOffset(t, e = -1) {
    e === -1 && (e = this._activeRoomActiveCanvas);
    const s = this.getRoomInstanceRenderingCanvas(t, e);
    return s ? new st(s.screenOffsetX, s.screenOffsetY) : null;
  }
  setRoomInstanceRenderingCanvasOffset(t, e, s) {
    const r = this.getRoomInstanceRenderingCanvas(t, e);
    if (!r || !s) return !1;
    const n = ~~s.x, a = ~~s.y;
    if (!(r.screenOffsetX === n && r.screenOffsetY === a))
      return x().dispatchEvent(new sp(t, -(r.screenOffsetX - n), -(r.screenOffsetY - a))), r.screenOffsetX = n, r.screenOffsetY = a, !0;
  }
  getRoomInstanceRenderingCanvasScale(t = -1e3, e = -1) {
    t === -1e3 && (t = this._activeRoomId), e === -1 && (e = this._activeRoomActiveCanvas);
    const s = this.getRoomInstanceRenderingCanvas(t, e);
    return s ? s.scale : 1;
  }
  initializeRoomInstanceRenderingCanvas(t, e, s, r) {
    const n = this.getRoomInstanceRenderingCanvas(t, e);
    n && n.initialize(s, r);
  }
  getRoomInstanceGeometry(t, e = -1) {
    const s = this.getRoomInstance(t);
    if (!s) return null;
    const r = s.renderer;
    if (!r) return null;
    e === -1 && (e = this._activeRoomActiveCanvas);
    const n = r.getCanvas(e);
    return n ? n.geometry : null;
  }
  getRoomInstanceVariable(t, e) {
    const s = this.getRoomInstance(t);
    return s && s.model && s.model.getValue(e) || null;
  }
  updateRoomInstancePlaneVisibility(t, e, s = !0) {
    const r = this.getRoomOwnObject(t);
    return r ? (r.processUpdateMessage(new Ir(Ir.WALL_VISIBILITY, e)), r.processUpdateMessage(new Ir(Ir.FLOOR_VISIBILITY, s)), !0) : !1;
  }
  updateRoomInstancePlaneThickness(t, e, s) {
    const r = this.getRoomOwnObject(t);
    return r ? (r.processUpdateMessage(new Tr(Tr.WALL_THICKNESS, e)), r.processUpdateMessage(new Tr(Tr.FLOOR_THICKNESS, s)), !0) : !1;
  }
  updateRoomInstancePlaneType(t, e = null, s = null, r = null, n = !1) {
    const a = this.getRoomOwnObject(t), o = this.getRoomInstance(t);
    if (!a) {
      let h = this._roomDatas.get(t);
      return h || (h = new Dit(t, null), this._roomDatas.set(t, h)), e && (h.floorType = e), s && (h.wallType = s), r && (h.landscapeType = r), !0;
    }
    return e && (o && !n && o.model.setValue(I.ROOM_FLOOR_TYPE, e), a.processUpdateMessage(new we(we.ROOM_FLOOR_UPDATE, e))), s && (o && !n && o.model.setValue(I.ROOM_WALL_TYPE, s), a.processUpdateMessage(new we(we.ROOM_WALL_UPDATE, s))), r && (o && !n && o.model.setValue(I.ROOM_LANDSCAPE_TYPE, r), a.processUpdateMessage(new we(we.ROOM_LANDSCAPE_UPDATE, r))), !0;
  }
  updateAreaHide(t, e, s, r, n, a, o, h) {
    const u = this.getRoomOwnObject(t);
    if (!u || !u.logic) return !1;
    x().dispatchEvent(new ip(t, e, L.FLOOR, s)), s ? u.logic.processUpdateMessage(new Ps(Ps.ADD, e, r, n, a, o, h)) : u.logic.processUpdateMessage(new Ps(Ps.REMOVE, e));
  }
  updateObjectRoomColor(t, e, s, r) {
    const n = this.getRoomOwnObject(t);
    if (!n || !n.logic) return !1;
    const a = new Fu(Fu.BACKGROUND_COLOR, e, s, r);
    return n.logic.processUpdateMessage(a), x().dispatchEvent(new ep(t, e, s, r)), !0;
  }
  addRoomInstanceFloorHole(t, e) {
    if (e < 0) return;
    const s = this.getRoomOwnObject(t), r = this.getRoomObjectFloor(t, e);
    if (s && s.logic && r && r.model) {
      const n = r.getLocation(), a = r.model.getValue(I.FURNITURE_SIZE_X), o = r.model.getValue(I.FURNITURE_SIZE_Y);
      s.processUpdateMessage(new Ps(Ps.ADD, e, n.x, n.y, a, o));
    }
  }
  removeRoomInstanceFloorHole(t, e) {
    if (e < 0) return;
    const s = this.getRoomOwnObject(t);
    s && s.processUpdateMessage(new Ps(Ps.REMOVE, e));
  }
  setRoomEngineGameMode(t, e) {
    const s = this.getRoomInstance(t);
    if (!s) return;
    const r = e ? 1 : 0;
    s.model.setValue(Ye.IS_PLAYING_GAME, r), r === 0 ? x().dispatchEvent(new ae(ae.NORMAL_MODE, t)) : x().dispatchEvent(new ae(ae.GAME_MODE, t));
  }
  isRoomIdPlayingGame(t) {
    const e = this.getRoomInstance(t);
    return e ? e.model.getValue(Ye.IS_PLAYING_GAME) > 0 : !1;
  }
  isPlayingGame() {
    return this.isRoomIdPlayingGame(this._activeRoomId);
  }
  update(t) {
    if (!this._roomManager) return;
    const e = t.lastTime, s = !1;
    zi.turnVisualizationOn(), this.processPendingFurniture(), this._roomManager.update(e, s), this.updateRoomCameras(e), this._mouseCursorUpdate && this.setPointer(), zi.turnVisualizationOff();
  }
  setPointer() {
    this._mouseCursorUpdate = !1;
    const t = this.getRoomInstanceData(this._activeRoomId);
    t && t.hasButtonMouseCursorOwners() ? document.body.style.cursor = "pointer" : document.body.style.cursor = "auto";
  }
  processPendingFurniture() {
    if (this._skipFurnitureCreationForNextFrame) {
      this._skipFurnitureCreationForNextFrame = !1;
      return;
    }
    const t = (/* @__PURE__ */ new Date()).valueOf(), e = 5;
    for (const s of this._roomInstanceDatas.values()) {
      if (!s) continue;
      let r = null, n = 0, a = !1;
      for (; r = s.getNextPendingFurnitureFloor(); )
        if (a = this.addObjectFurnitureFromData(s.roomId, r.id, r), !(++n % e) && (/* @__PURE__ */ new Date()).valueOf() - t >= 40) {
          this._skipFurnitureCreationForNextFrame = !0;
          break;
        }
      for (; !this._skipFurnitureCreationForNextFrame && (r = s.getNextPendingFurnitureWall()); )
        if (a = this.addObjectWallItemFromData(s.roomId, r.id, r), !(++n % e) && (/* @__PURE__ */ new Date()).valueOf() - t >= 40) {
          this._skipFurnitureCreationForNextFrame = !0;
          break;
        }
      if (a && this._roomManager && (this._roomManager.getRoomInstance(this.getRoomId(s.roomId)).hasUninitializedObjects() || this.objectsInitialized(s.roomId.toString())), this._skipFurnitureCreationForNextFrame) return;
    }
  }
  addObjectFurnitureFromData(t, e, s) {
    if (!s) {
      const h = this.getRoomInstanceData(t);
      if (h && (s = h.getPendingFurnitureFloor(e)), !s) return !1;
    }
    let r = s.type;
    r || (r = this.getFurnitureFloorName(s.typeId));
    const n = this.createRoomObjectFloor(t, e, r);
    if (!n) return !1;
    const a = n.model;
    if (a && (a.setValue(I.FURNITURE_COLOR, this.getFurnitureFloorColorIndex(s.typeId)), a.setValue(I.FURNITURE_TYPE_ID, s.typeId), a.setValue(I.FURNITURE_AD_URL, this.getRoomObjectAdUrl(s.type)), a.setValue(I.FURNITURE_REAL_ROOM_OBJECT, s.realRoomObject ? 1 : 0), a.setValue(I.FURNITURE_EXPIRY_TIME, s.expiryTime), a.setValue(I.FURNITURE_EXPIRTY_TIMESTAMP, Nt()), a.setValue(I.FURNITURE_USAGE_POLICY, s.usagePolicy), a.setValue(I.FURNITURE_OWNER_ID, s.ownerId), a.setValue(I.FURNITURE_OWNER_NAME, s.ownerName)), !this.updateRoomObjectFloor(t, e, s.location, s.direction, s.state, s.data, s.extra) || s.sizeZ >= 0 && !this.updateRoomObjectFloorHeight(t, e, s.sizeZ))
      return !1;
    x() && x().dispatchEvent(new lt(lt.ADDED, t, e, L.FLOOR));
    const o = this.getPlacedRoomObjectData(t);
    return o && o.id === e && o.category === L.FLOOR && this.selectRoomObject(t, e, L.FLOOR), n.isReady && s.synchronized && this.addObjectToTileMap(t, n), !0;
  }
  addObjectWallItemFromData(t, e, s) {
    if (!s) {
      const u = this.getRoomInstanceData(t);
      if (u && (s = u.getPendingFurnitureWall(e)), !s) return !1;
    }
    let r = "";
    s.data && (r = s.data.getLegacyString());
    let n = this.getFurnitureWallName(s.typeId, r);
    n || (n = "");
    const a = this.createRoomObjectWall(t, e, n);
    if (!a) return !1;
    const o = a.model;
    if (o && (o.setValue(I.FURNITURE_COLOR, this.getFurnitureWallColorIndex(s.typeId)), o.setValue(I.FURNITURE_TYPE_ID, s.typeId), o.setValue(I.FURNITURE_AD_URL, this.getRoomObjectAdUrl(s.type)), o.setValue(I.FURNITURE_REAL_ROOM_OBJECT, s.realRoomObject ? 1 : 0), o.setValue(I.OBJECT_ACCURATE_Z_VALUE, 1), o.setValue(I.FURNITURE_EXPIRY_TIME, s.expiryTime), o.setValue(I.FURNITURE_EXPIRTY_TIMESTAMP, Nt()), o.setValue(I.FURNITURE_USAGE_POLICY, s.usagePolicy), o.setValue(I.FURNITURE_OWNER_ID, s.ownerId), o.setValue(I.FURNITURE_OWNER_NAME, s.ownerName)), !this.updateRoomObjectWall(t, e, s.location, s.direction, s.state, r)) return !1;
    x() && x().dispatchEvent(new lt(lt.ADDED, t, e, L.WALL));
    const h = this.getPlacedRoomObjectData(t);
    return h && Math.abs(h.id) === e && h.category === L.WALL && this.selectRoomObject(t, e, L.WALL), !0;
  }
  setRoomSessionOwnUser(t, e) {
    const s = this._roomSessionManager.getSession(t);
    s && s.setOwnRoomIndex(e);
    const r = this.getRoomCamera(t);
    r && (r.targetId = e, r.targetCategory = L.UNIT, r.activateFollowing(this.cameraFollowDuration));
  }
  get cameraFollowDuration() {
    return 1e3;
  }
  updateRoomCameras(t) {
    for (const e of this._roomInstanceDatas.values()) {
      if (!e) continue;
      const s = e.roomCamera;
      if (!s) continue;
      let r = null;
      const n = this.getRoomObject(e.roomId, s.targetId, s.targetCategory);
      n && (r = n.getLocation()), r && (e.roomId !== this._activeRoomId || !this._activeRoomIsDragged) && this.updateRoomCamera(e.roomId, 1, r, t);
    }
    if (this._activeRoomWasDragged) {
      const e = this.getRoomInstanceRenderingCanvas(this._activeRoomId, 1);
      e && this.setRoomInstanceRenderingCanvasOffset(this._activeRoomId, 1, new st(e.screenOffsetX + this._activeRoomDragX, e.screenOffsetY + this._activeRoomDragY)), this._activeRoomDragX = 0, this._activeRoomDragY = 0;
    }
  }
  updateRoomCamera(t, e, s, r) {
    const n = this.getRoomInstanceRenderingCanvas(t, e), a = this.getRoomInstanceData(t);
    if (!n || !a || n.scale !== 1) return;
    const o = n.geometry, h = a.roomCamera, u = this.getRoomInstance(t);
    if (!o || !h || !u) return;
    const c = this.getRoomCanvasRectangle(t, e);
    if (!c) return;
    let l = Math.floor(s.z) + 1;
    const _ = Math.round(c.width), d = Math.round(c.height), f = this.getCanvasBoundingRectangle(e);
    if (f && (f.right < 0 || f.bottom < 0 || f.left >= _ || f.top >= d) && h.reset(), h.screenWd !== _ || h.screenHt !== d || h.scale !== o.scale || h.geometryUpdateId !== o.updateId || !v.isEqual(s, h.targetObjectLoc) || h.isMoving) {
      h.targetObjectLoc = s;
      const p = new v();
      p.assign(s), p.x = Math.round(p.x), p.y = Math.round(p.y);
      const g = u.model.getValue(Ye.ROOM_MIN_X) - 0.5, m = u.model.getValue(Ye.ROOM_MIN_Y) - 0.5, O = u.model.getValue(Ye.ROOM_MAX_X) + 0.5, y = u.model.getValue(Ye.ROOM_MAX_Y) + 0.5, C = Math.round((g + O) / 2), b = Math.round((m + y) / 2), D = 2;
      let P = new st(p.x - C, p.y - b);
      const F = o.scale / Math.sqrt(2), M = F / 2, U = new ot();
      U.rotate(-(o.direction.x + 90) / 180 * Math.PI), P = U.apply(P), P.y = P.y * (M / F);
      const k = c.width / 2 / F - 1, ft = c.height / 2 / M - 1;
      let K = 0, Y = 0, ut = 0, Gt = 0, V = o.getScreenPoint(new v(C, b, D));
      if (!V) return;
      if (V.x = V.x + Math.round(c.width / 2), V.y = V.y + Math.round(c.height / 2), f)
        if (f.x += -n.screenOffsetX, f.y += -n.screenOffsetY, f.width > 1 && f.height > 1)
          K = (f.left - V.x - o.scale * 0.25) / F, ut = (f.right - V.x + o.scale * 0.25) / F, Y = (f.top - V.y - o.scale * 0.5) / M, Gt = (f.bottom - V.y + o.scale * 0.5) / M;
        else {
          o.adjustLocation(new v(-30, -30), 25);
          return;
        }
      else {
        o.adjustLocation(new v(0, 0), 25);
        return;
      }
      let Mt = !1, X = !1, ht = !1, vr = !1;
      Math.round((ut - K) * F) < c.width ? (l = 2, P.x = (ut + K) / 2, ht = !0) : (P.x > ut - k && (P.x = ut - k, Mt = !0), P.x < K + k && (P.x = K + k, Mt = !0)), Math.round((Gt - Y) * M) < c.height ? (l = 2, P.y = (Gt + Y) / 2, vr = !0) : (P.y > Gt - ft && (P.y = Gt - ft, X = !0), P.y < Y + ft && (P.y = Y + ft, X = !0), X && (P.y = P.y / (M / F))), U.invert(), P = U.apply(P), P.x = P.x + C, P.y = P.y + b;
      let Ls = 0.35, As = 0.2, pi = 0.2;
      const ih = 10, In = 10;
      if (pi * _ > 100 && (pi = 100 / _), Ls * d > 150 && (Ls = 150 / d), As * d > 150 && (As = 150 / d), h.limitedLocationX && h.screenWd == _ && h.screenHt == d && (pi = 0), h.limitedLocationY && h.screenWd == _ && h.screenHt == d && (Ls = 0, As = 0), c.width = c.width * (1 - pi * 2), c.height = c.height * (1 - (Ls + As)), c.width < ih && (c.width = ih), c.height < In && (c.height = In), Ls + As > 0 ? (c.x += -c.width / 2, c.y += -c.height * (As / (Ls + As))) : (c.x += -c.width / 2, c.y += -c.height / 2), V = o.getScreenPoint(p), !V) return;
      if (V) {
        V.x = V.x + n.screenOffsetX, V.y = V.y + n.screenOffsetY, p.z = l, p.x = Math.round(P.x * 2) / 2, p.y = Math.round(P.y * 2) / 2, h.location || (o.location = p, this.useOffsetScrolling ? h.initializeLocation(new v(0, 0, 0)) : h.initializeLocation(p));
        const qi = o.getScreenPoint(p), xa = new v(0, 0, 0);
        qi && (xa.x = qi.x, xa.y = qi.y), (V.x < c.left || V.x > c.right) && !h.centeredLocX || (V.y < c.top || V.y > c.bottom) && !h.centeredLocY || ht && !h.centeredLocX && h.screenWd != _ || vr && !h.centeredLocY && h.screenHt != d || h.roomWd != f.width || h.roomHt != f.height || h.screenWd != _ || h.screenHt != d ? (h.limitedLocationX = Mt, h.limitedLocationY = X, this.useOffsetScrolling ? h.target = xa : h.target = p) : (Mt || (h.limitedLocationX = !1), X || (h.limitedLocationY = !1));
      }
      h.centeredLocX = ht, h.centeredLocY = vr, h.screenWd = _, h.screenHt = d, h.scale = o.scale, h.geometryUpdateId = o.updateId, h.roomWd = f.width, h.roomHt = f.height, this._sessionDataManager.isCameraFollowDisabled || (this.useOffsetScrolling ? h.update(r, 8) : h.update(r, 0.5)), this.useOffsetScrolling ? this.setRoomInstanceRenderingCanvasOffset(this.activeRoomId, 1, new st(-h.location.x, -h.location.y)) : o.adjustLocation(h.location, 25);
    } else
      h.limitedLocationX = !1, h.limitedLocationY = !1, h.centeredLocX = !1, h.centeredLocY = !1;
  }
  getRoomCanvasRectangle(t, e) {
    const s = this.getRoomInstanceRenderingCanvas(t, e);
    return s ? new Kt(0, 0, s.width, s.height) : null;
  }
  getRoomObjectBoundingRectangle(t, e, s, r) {
    const n = this.getRoomInstanceGeometry(t, r);
    if (!n) return null;
    const a = this.getRoomObject(t, e, s);
    if (!a) return null;
    const o = a.visualization;
    if (!o) return null;
    const h = o.getBoundingRectangle(), u = this.getRoomInstanceRenderingCanvas(t, r), c = u ? u.scale : 1, l = n.getScreenPoint(a.getLocation());
    return !l || (l.x = Math.round(l.x), l.y = Math.round(l.y), h.x = h.x * c, h.y = h.y * c, h.width = h.width * c, h.height = h.height * c, l.x = l.x * c, l.y = l.y * c, h.x += l.x, h.y += l.y, !u) ? null : (h.x += Math.round(u.width / 2) + u.screenOffsetX, h.y += Math.round(u.height / 2) + u.screenOffsetY, h);
  }
  getCanvasBoundingRectangle(t) {
    return this.getRoomObjectBoundingRectangle(this._activeRoomId, Tt.ROOM_OBJECT_ID, L.ROOM, t);
  }
  getFurnitureFloorName(t) {
    return this._roomContentLoader.getFurnitureFloorNameForTypeId(t);
  }
  getFurnitureWallName(t, e = null) {
    return this._roomContentLoader.getFurnitureWallNameForTypeId(t, e);
  }
  getFurnitureFloorColorIndex(t) {
    return this._roomContentLoader.getFurnitureFloorColorIndex(t);
  }
  getFurnitureWallColorIndex(t) {
    return this._roomContentLoader.getFurnitureWallColorIndex(t);
  }
  getRoomInstanceData(t) {
    const e = this._roomInstanceDatas.get(t);
    if (e) return e;
    const s = new Fit(t);
    return this._roomInstanceDatas.set(s.roomId, s), s;
  }
  getRoomInstanceModelName(t) {
    const e = this.getRoomInstanceData(t);
    return e ? e.modelName : null;
  }
  setRoomInstanceModelName(t, e) {
    const s = this.getRoomInstanceData(t);
    s && s.setModelName(e);
  }
  getRoomTileObjectMap(t) {
    const e = this.getRoomInstanceData(t);
    return e ? e.tileObjectMap : null;
  }
  getCurrentRoomCamera() {
    return this.getRoomCamera(this._activeRoomId);
  }
  getRoomCamera(t) {
    const e = this.getRoomInstanceData(t);
    return e ? e.roomCamera : null;
  }
  getSelectedRoomObjectData(t) {
    const e = this.getRoomInstanceData(t);
    return e ? e.selectedObject : null;
  }
  setSelectedRoomObjectData(t, e) {
    const s = this.getRoomInstanceData(t);
    if (!s) return null;
    s.setSelectedObject(e), e && s.setPlacedObject(null);
  }
  getPlacedRoomObjectData(t) {
    const e = this.getRoomInstanceData(t);
    return e ? e.placedObject : null;
  }
  setPlacedRoomObjectData(t, e) {
    const s = this.getRoomInstanceData(t);
    if (!s) return null;
    s.setPlacedObject(e);
  }
  cancelRoomObjectPlacement() {
    this._roomObjectEventHandler && this._roomObjectEventHandler.cancelRoomObjectPlacement(this._activeRoomId);
  }
  getFurnitureStackingHeightMap(t) {
    const e = this.getRoomInstanceData(t);
    return e ? e.furnitureStackingHeightMap : null;
  }
  setFurnitureStackingHeightMap(t, e) {
    const s = this.getRoomInstanceData(t);
    if (!s) return null;
    s.setFurnitureStackingHeightMap(e);
  }
  getLegacyWallGeometry(t) {
    const e = this.getRoomInstanceData(t);
    return e ? e.legacyGeometry : null;
  }
  createRoomObjectAndInitialize(t, e, s, r) {
    const n = this.getRoomInstance(t);
    return n ? n.createRoomObjectAndInitalize(e, s, r) : null;
  }
  getTotalObjectsForManager(t, e) {
    const s = this.getRoomInstance(t);
    return s ? s.getTotalObjectsForManager(e) : 0;
  }
  getRoomObject(t, e, s) {
    let r = this.getRoomId(t);
    return t === 0 && (r = Tt.TEMPORARY_ROOM), this.getObject(r, e, s);
  }
  getObject(t, e, s) {
    let r = null;
    if (this._roomManager && (r = this._roomManager.getRoomInstance(t)), !r) return null;
    let n = r.getRoomObject(e, s);
    if (!n)
      switch (s) {
        case L.FLOOR:
          this.addObjectFurnitureFromData(this.getRoomIdFromString(t), e, null), n = r.getRoomObject(e, s);
          break;
        case L.WALL:
          this.addObjectWallItemFromData(this.getRoomIdFromString(t), e, null), n = r.getRoomObject(e, s);
          break;
      }
    return n;
  }
  getRoomObjectByIndex(t, e, s) {
    const r = this.getRoomInstance(t);
    return r ? r.getRoomObjectByIndex(e, s) : null;
  }
  getRoomObjectCategoryForType(t) {
    return this._roomContentLoader.getCategoryForType(t);
  }
  getRoomObjectCursor(t) {
    return this.getObject(this.getRoomId(t), Tt.CURSOR_OBJECT_ID, L.CURSOR);
  }
  getRoomObjectSelectionArrow(t) {
    return this.getObject(this.getRoomId(t), Tt.ARROW_OBJECT_ID, L.CURSOR);
  }
  getRoomOwnObject(t) {
    return this.getObject(this.getRoomId(t), Tt.ROOM_OBJECT_ID, L.ROOM);
  }
  getRoomObjectUser(t, e) {
    return this.getObject(this.getRoomId(t), e, L.UNIT);
  }
  removeRoomObjectUser(t, e) {
    return this.removeRoomObject(t, e, L.UNIT);
  }
  createRoomObjectUser(t, e, s) {
    return this.createRoomObjectAndInitialize(t, e, s, L.UNIT);
  }
  getRoomObjectFloor(t, e) {
    return this.getObject(this.getRoomId(t), e, L.FLOOR);
  }
  createRoomObjectFloor(t, e, s) {
    return this.createRoomObjectAndInitialize(t, e, s, L.FLOOR);
  }
  removeRoomObjectFloor(t, e, s = -1, r = !1) {
    const n = this.getRoomInstanceData(t);
    if (n && n.removePendingFunitureFloor(e), this._sessionDataManager.userId === s && !Jl.isBuilderClubId(e)) {
      const a = this.getRoomObject(t, e, L.FLOOR);
      if (a) {
        const o = this.getRoomObjectScreenLocation(t, e, L.FLOOR, this._activeRoomActiveCanvas);
        if (o && !(a.model.getValue(I.FURNITURE_DISABLE_PICKING_ANIMATION) === 1)) {
          const u = a.model.getValue(I.FURNITURE_TYPE_ID), c = a.model.getValue(I.FURNITURE_EXTRAS), l = a.model.getValue(I.FURNITURE_DATA_FORMAT), _ = tn.getData(l), d = this.getFurnitureFloorIcon(u, null, c, _).data;
          d && (async () => {
            const f = await le.generateImage(d), p = new ac(f, o.x, o.y);
            p.iconName = Wl.INVENTORY, x().dispatchEvent(p);
          })();
        }
      }
    }
    this.removeRoomObject(t, e, L.FLOOR), this.setMouseDefault(t, L.FLOOR, e), r && this.refreshTileObjectMap(t, "RoomEngine.disposeObjectFurniture()");
  }
  getRoomObjectWall(t, e) {
    return this.getObject(this.getRoomId(t), e, L.WALL);
  }
  removeRoomObjectWall(t, e, s = -1) {
    if (this._sessionDataManager.userId === s && !Jl.isBuilderClubId(e)) {
      const r = this.getRoomObject(t, e, L.WALL);
      if (r && r.type.indexOf("post_it") === -1 && r.type.indexOf("external_image_wallitem") === -1) {
        const n = this.getRoomObjectScreenLocation(t, e, L.WALL, this._activeRoomActiveCanvas);
        if (n) {
          const a = r.model.getValue(I.FURNITURE_TYPE_ID), o = r.model.getValue(I.FURNITURE_DATA), h = this.getFurnitureWallIcon(a, null, o).data;
          h && (async () => {
            const u = await le.generateImage(h);
            if (x()) {
              const c = new ac(u, n.x, n.y);
              c.iconName = Wl.INVENTORY, x().dispatchEvent(c);
            }
          })();
        }
      }
    }
    this.removeRoomObject(t, e, L.WALL), this.updateRoomObjectMask(t, e, !1), this.setMouseDefault(t, L.WALL, e);
  }
  createRoomObjectWall(t, e, s) {
    return this.createRoomObjectAndInitialize(t, e, s, L.WALL);
  }
  removeRoomObject(t, e, s) {
    const r = this.getRoomInstance(t);
    if (!r) return null;
    r.removeRoomObject(e, s), x() && x().dispatchEvent(new lt(lt.REMOVED, t, e, s));
  }
  addFurnitureFloor(t, e, s, r, n, a, o, h = NaN, u = -1, c = 0, l = 0, _ = "", d = !0, f = !0, p = -1) {
    const g = this.getRoomInstanceData(t);
    if (!g) return !1;
    const m = new Qf(e, s, null, r, n, a, o, h, u, c, l, _, d, f, p);
    return g.addPendingFurnitureFloor(m), !0;
  }
  addFurnitureFloorByTypeName(t, e, s, r, n, a, o, h = NaN, u = -1, c = 0, l = 0, _ = "", d = !0, f = !0, p = -1) {
    const g = this.getRoomInstanceData(t);
    if (!g) return !1;
    const m = new Qf(e, 0, s, r, n, a, o, h, u, c, l, _, d, f, p);
    return g.addPendingFurnitureFloor(m), !0;
  }
  addFurnitureWall(t, e, s, r, n, a, o, h = -1, u = 0, c = 0, l = "", _ = !0) {
    const d = this.getRoomInstanceData(t);
    if (!d) return !1;
    const f = new ns();
    f.setString(o);
    const p = new Qf(e, s, null, r, n, a, f, NaN, h, u, c, l, !0, _);
    return d.addPendingFurnitureWall(p), !0;
  }
  updateRoomObjectFloor(t, e, s, r, n, a, o = null) {
    const h = this.getRoomObjectFloor(t, e);
    return h ? (h.processUpdateMessage(new Ce(s, r)), h.processUpdateMessage(new Ht(n, a, o)), !0) : !1;
  }
  updateRoomObjectWall(t, e, s, r, n, a = null) {
    const o = this.getRoomObjectWall(t, e);
    if (!o || !o.logic) return !1;
    const h = new Ce(s, r), u = new ns(), c = new Ht(n, u);
    return u.setString(a), o.logic.processUpdateMessage(h), o.logic.processUpdateMessage(c), this.updateRoomObjectMask(t, e), !0;
  }
  updateRoomObjectWallItemData(t, e, s) {
    const r = this.getRoomObjectWall(t, e);
    return !r || !r.logic ? !1 : (r.logic.processUpdateMessage(new mI(s)), !0);
  }
  updateRoomObjectFloorHeight(t, e, s) {
    const r = this.getRoomObjectFloor(t, e);
    return r ? (r.processUpdateMessage(new UM(null, null, s)), !0) : !1;
  }
  updateRoomObjectFloorExpiration(t, e, s) {
    const r = this.getRoomObjectFloor(t, e);
    return r ? (r.model.setValue(I.FURNITURE_EXPIRY_TIME, s), r.model.setValue(I.FURNITURE_EXPIRTY_TIMESTAMP, Nt()), !0) : !1;
  }
  updateRoomObjectWallExpiration(t, e, s) {
    const r = this.getRoomObjectWall(t, e);
    return r ? (r.model.setValue(I.FURNITURE_EXPIRY_TIME, s), r.model.setValue(I.FURNITURE_EXPIRTY_TIMESTAMP, Nt()), !0) : !1;
  }
  updateRoomObjectMask(t, e, s = !0) {
    const r = L.WALL + "_" + e, n = this.getRoomObjectWall(t, e);
    let a = null;
    if (n && n.model) {
      if (n.model.getValue(I.FURNITURE_USES_PLANE_MASK) > 0) {
        const h = n.model.getValue(I.FURNITURE_PLANE_MASK_TYPE), u = n.getLocation();
        s ? a = new qe(qe.ADD_MASK, r, h, u) : a = new qe(qe.REMOVE_MASK, r);
      }
    } else
      a = new qe(qe.REMOVE_MASK, r);
    const o = this.getRoomOwnObject(t);
    o && o.logic && a && o.logic.processUpdateMessage(a);
  }
  rollRoomObjectFloor(t, e, s, r) {
    const n = this.getRoomObjectFloor(t, e);
    n && n.processUpdateMessage(new _n(s, r, null, !!r));
  }
  updateRoomObjectWallLocation(t, e, s) {
    const r = this.getRoomObjectWall(t, e);
    return r ? (r.logic && r.logic.processUpdateMessage(new _n(s, null, null)), this.updateRoomObjectMask(t, e), !0) : !1;
  }
  addRoomObjectUser(t, e, s, r, n, a, o) {
    if (this.getRoomObjectUser(t, e)) return !1;
    let u = Xt.getTypeString(a);
    u === Xt.PET && (u = this.getPetType(o));
    const c = this.createRoomObjectUser(t, e, u);
    return c ? (c.processUpdateMessage(new Dc(this.fixedUserLocation(t, s), null, r, n, !1, 0)), o && c.processUpdateMessage(new Nc(o)), x() && x().dispatchEvent(new lt(lt.ADDED, t, e, L.UNIT)), !0) : !1;
  }
  updateRoomObjectUserLocation(t, e, s, r, n = !1, a = 0, o = null, h = NaN) {
    const u = this.getRoomObjectUser(t, e);
    if (!u) return !1;
    s || (s = u.getLocation()), o || (o = u.getDirection()), isNaN(h) && (h = u.model.getValue(I.HEAD_DIRECTION)), u.processUpdateMessage(new Dc(this.fixedUserLocation(t, s), this.fixedUserLocation(t, r), o, h, n, a));
    const c = this._roomSessionManager.getSession(t);
    return c && c.ownRoomIndex === e && x().dispatchEvent(new zo(zo.ROAME_MOVE_TO, r)), !0;
  }
  fixedUserLocation(t, e) {
    if (!e) return null;
    const s = this.getFurnitureStackingHeightMap(t), r = this.getLegacyWallGeometry(t);
    if (!s || !r) return e;
    let n = e.z;
    const a = s.getTileHeight(e.x, e.y), o = r.getHeight(e.x, e.y);
    return Math.abs(n - a) < 0.1 && Math.abs(a - o) < 0.1 && (n = r.getFloorAltitude(e.x, e.y)), new v(e.x, e.y, n);
  }
  updateRoomObjectUserAction(t, e, s, r, n = null) {
    const a = this.getRoomObjectUser(t, e);
    if (!a) return !1;
    let o = null;
    switch (s) {
      case I.FIGURE_TALK:
        o = new fI(r);
        break;
      case I.FIGURE_SLEEP:
        o = new pI(r === 1);
        break;
      case I.FIGURE_IS_TYPING:
        o = new PM(r === 1);
        break;
      case I.FIGURE_IS_MUTED:
        o = new yM(r === 1);
        break;
      case I.FIGURE_CARRY_OBJECT:
        o = new EM(r, n);
        break;
      case I.FIGURE_USE_OBJECT:
        o = new NM(r);
        break;
      case I.FIGURE_DANCE:
        o = new TM(r);
        break;
      case I.FIGURE_GAINED_EXPERIENCE:
        o = new SM(r);
        break;
      case I.FIGURE_NUMBER_VALUE:
        o = new xM(r);
        break;
      case I.FIGURE_SIGN:
        o = new bM(r);
        break;
      case I.FIGURE_EXPRESSION:
        o = new AM(r);
        break;
      case I.FIGURE_IS_PLAYING_GAME:
        o = new MM(r === 1);
        break;
      case I.FIGURE_GUIDE_STATUS:
        o = new Mst(r);
        break;
    }
    return o ? (a.processUpdateMessage(o), !0) : !1;
  }
  updateRoomObjectUserFigure(t, e, s, r = null, n = null, a = !1) {
    const o = this.getRoomObjectUser(t, e);
    return o ? (o.processUpdateMessage(new Nc(s, r, n, a)), !0) : !1;
  }
  updateRoomObjectUserFlatControl(t, e, s) {
    const r = this.getRoomObjectUser(t, e);
    return r ? (r.processUpdateMessage(new RM(parseInt(s))), !0) : !1;
  }
  updateRoomObjectUserEffect(t, e, s, r = 0) {
    const n = this.getRoomObjectUser(t, e);
    return n ? (n.processUpdateMessage(new IM(s, r)), !0) : !1;
  }
  updateRoomObjectUserGesture(t, e, s) {
    const r = this.getRoomObjectUser(t, e);
    return r ? (r.processUpdateMessage(new OM(s)), !0) : !1;
  }
  updateRoomObjectUserPetGesture(t, e, s) {
    const r = this.getRoomObjectUser(t, e);
    return r ? (r.processUpdateMessage(new CM(s)), !0) : !1;
  }
  updateRoomObjectUserPosture(t, e, s, r = null) {
    const n = this.getRoomObjectUser(t, e);
    return n ? (n.processUpdateMessage(new gI(s, r)), !0) : !1;
  }
  updateRoomObjectUserOwn(t, e) {
    const s = this.getRoomObjectUser(t, e);
    s && s.processUpdateMessage(new vM());
  }
  useRoomObject(t, e) {
    const s = this.getRoomObject(this._activeRoomId, t, e);
    if (s) {
      const r = s.logic;
      if (r)
        return r.useObject(), !0;
    }
    return !1;
  }
  objectInitialized(t, e, s) {
    const r = this.getRoomIdFromString(t);
    s === L.WALL && this.updateRoomObjectMask(r, e);
    const n = this.getRoomObject(r, e, s);
    if (n && n.model && n.logic) {
      const a = n.model.getValue(I.FURNITURE_DATA_FORMAT);
      if (!isNaN(a)) {
        const o = tn.getData(a);
        o.initializeFromRoomObjectModel(n.model), n.processUpdateMessage(new Ht(n.getState(0), o));
      }
      x().dispatchEvent(new lt(lt.CONTENT_UPDATED, r, e, s));
    }
    t !== Tt.TEMPORARY_ROOM && this.addObjectToTileMap(r, n);
  }
  changeObjectModelData(t, e, s, r, n) {
    const a = this.getObject(this.getRoomId(t), e, s);
    if (!a || !a.logic) return !1;
    const o = new DM(r, n);
    return a.processUpdateMessage(o), !0;
  }
  changeObjectState(t, e, s) {
    const r = this.getObject(this.getRoomId(t), e, s);
    if (!r || !r.model) return;
    let n = r.model.getValue(I.FURNITURE_AUTOMATIC_STATE_INDEX);
    isNaN(n) ? n = 1 : n = n + 1, r.model.setValue(I.FURNITURE_AUTOMATIC_STATE_INDEX, n);
    const a = r.model.getValue(I.FURNITURE_DATA_FORMAT), o = tn.getData(a);
    o.initializeFromRoomObjectModel(r.model), r.logic && r.logic.processUpdateMessage(new Ht(n, o));
  }
  loadRoomObjectBadgeImage(t, e, s, r, n = !0) {
    let a = null;
    if (t === 0) {
      const h = this._roomManager.getRoomInstance(Tt.TEMPORARY_ROOM);
      h && (a = h.getRoomObject(e, s));
    } else
      a = this.getRoomObjectFloor(t, e);
    if (!a || !a.logic) return;
    let o = n ? this._sessionDataManager.loadGroupBadgeImage(r) : this._sessionDataManager.loadBadgeImage(r);
    if (o)
      this.putBadgeInObjectAssets(a, r, n);
    else {
      if (o = "loading_icon", this._badgeListenerObjects || (this._badgeListenerObjects = /* @__PURE__ */ new Map()), !this._badgeListenerObjects.size) {
        const u = (c) => {
          const l = this._badgeListenerObjects && this._badgeListenerObjects.get(c.badgeId);
          if (l) {
            for (const _ of l) {
              if (!_) continue;
              this.putBadgeInObjectAssets(_.object, c.badgeId, _.groupBadge);
              const d = _.groupBadge ? this._sessionDataManager.loadGroupBadgeImage(c.badgeId) : this._sessionDataManager.loadBadgeImage(c.badgeId);
              _.object && _.object.logic && _.object.logic.processUpdateMessage(new Sa(c.badgeId, d));
            }
            this._badgeListenerObjects.delete(c.badgeId), this._badgeListenerObjects.size || x().removeEventListener(Vo.IMAGE_READY, u);
          }
        };
        x().addEventListener(Vo.IMAGE_READY, u);
      }
      let h = this._badgeListenerObjects.get(r);
      h || (h = []), h.push(new wit(a, n)), this._badgeListenerObjects.set(r, h);
    }
    a.logic.processUpdateMessage(new Sa(r, o));
  }
  putBadgeInObjectAssets(t, e, s = !1) {
    const r = s ? this._sessionDataManager.loadGroupBadgeImage(e) : this._sessionDataManager.loadBadgeImage(e), n = s ? this._sessionDataManager.getGroupBadgeImage(e) : this._sessionDataManager.getBadgeImage(e);
    n && this._roomContentLoader.addAssetToCollection(t.type, r, n, !1);
  }
  dispatchMouseEvent(t, e, s, r, n, a, o, h) {
    const u = this.getRoomInstanceRenderingCanvas(this._activeRoomId, t);
    if (!u) return;
    const c = this.getRenderingCanvasOverlay(u), l = this.getOverlayIconSprite(c, Tt.OBJECT_ICON_SPRITE);
    if (l) {
      const _ = l.getLocalBounds();
      l.x = e - _.width / 2, l.y = s - _.height / 2;
    }
    if (r === J.MOUSE_CLICK && this._areaSelectionManager.finishSelecting())
      this._areaSelectionManager.finishSelecting();
    else if (!this.handleRoomDragging(u, e, s, r, n, a, o) && !u.handleMouseEvent(e, s, r, n, a, o, h)) {
      let _ = null;
      r === J.MOUSE_CLICK ? (x().dispatchEvent(new lt(lt.DESELECTED, this._activeRoomId, -1, L.MINIMUM)), _ = at.CLICK) : r === J.MOUSE_MOVE ? _ = at.MOUSE_MOVE : r === J.MOUSE_DOWN ? _ = at.MOUSE_DOWN : r === J.MOUSE_DOWN_LONG ? _ = at.MOUSE_DOWN_LONG : r === J.MOUSE_UP && (_ = at.MOUSE_UP), this._roomObjectEventHandler.handleRoomObjectEvent(new at(_, this.getRoomObject(this._activeRoomId, Tt.ROOM_OBJECT_ID, L.ROOM), null, n), this._activeRoomId);
    }
    this._activeRoomActiveCanvas = t, this._activeRoomActiveCanvasMouseX = e, this._activeRoomActiveCanvasMouseY = s;
  }
  handleRoomDragging(t, e, s, r, n, a, o) {
    if (this.isPlayingGame()) return !1;
    if (this._areaSelectionManager.areaSelectionState === bh.SELECTING)
      return this._activeRoomIsDragged = !1, this._activeRoomWasDragged = !1, !1;
    let h = e - this._activeRoomActiveCanvasMouseX, u = s - this._activeRoomActiveCanvasMouseY;
    if (r === J.MOUSE_DOWN)
      !n && !a && !o && !this.isDecorating && this._roomAllowsDragging && (this._activeRoomIsDragged = !0, this._activeRoomWasDragged = !1, this._activeRoomDragStartX = this._activeRoomActiveCanvasMouseX, this._activeRoomDragStartY = this._activeRoomActiveCanvasMouseY);
    else if (r === J.MOUSE_UP) {
      if (this._activeRoomIsDragged && (this._activeRoomIsDragged = !1, this._activeRoomWasDragged)) {
        const c = this.getRoomInstanceData(this._activeRoomId);
        if (c) {
          const l = c.roomCamera;
          l && (this.useOffsetScrolling && (l.isMoving || (l.centeredLocX = !1, l.centeredLocY = !1), l.resetLocation(new v(-t.screenOffsetX, -t.screenOffsetY))), this._roomDraggingAlwaysCenters && l.reset());
        }
      }
    } else if (r === J.MOUSE_MOVE)
      this._activeRoomIsDragged && (this._activeRoomWasDragged || (h = e - this._activeRoomDragStartX, u = s - this._activeRoomDragStartY, (h <= -Tt.DRAG_THRESHOLD || h >= Tt.DRAG_THRESHOLD || u <= -Tt.DRAG_THRESHOLD || u >= Tt.DRAG_THRESHOLD) && (this._activeRoomWasDragged = !0), h = 0, u = 0), (h != 0 || u != 0) && (this._activeRoomDragX += h, this._activeRoomDragY += u, this._activeRoomWasDragged = !0));
    else if ((r === J.MOUSE_CLICK || r === J.DOUBLE_CLICK) && (this._activeRoomIsDragged = !1, this._activeRoomWasDragged))
      return this._activeRoomWasDragged = !1, !0;
    return !1;
  }
  updateMousePointer(t, e, s) {
    const r = this.getRoomObjectCategoryForType(s);
    switch (t) {
      case z.MOUSE_BUTTON:
        this.setMouseButton(this._activeRoomId, r, e);
        return;
      default:
        this.setMouseDefault(this._activeRoomId, r, e);
        return;
    }
  }
  setMouseButton(t, e, s) {
    const r = this._roomSessionManager.getSession(t);
    if (r && (e !== L.FLOOR && e !== L.WALL || r.controllerLevel >= mr.GUEST)) {
      const n = this.getRoomInstanceData(t);
      n && n.addButtonMouseCursorOwner(e + "_" + s) && (this._mouseCursorUpdate = !0);
    }
  }
  setMouseDefault(t, e, s) {
    const r = this.getRoomInstanceData(t);
    r && r.removeButtonMouseCursorOwner(e + "_" + s) && (this._mouseCursorUpdate = !0);
  }
  processRoomObjectOperation(t, e, s) {
    if (!this._roomObjectEventHandler) return !1;
    this._roomObjectEventHandler.modifyRoomObject(this._activeRoomId, t, e, s);
  }
  modifyRoomObjectDataWithMap(t, e, s, r) {
    if (!this._roomObjectEventHandler) return !1;
    e === L.FLOOR && this._roomObjectEventHandler.modifyRoomObjectDataWithMap(this._activeRoomId, t, e, s, r);
  }
  modifyRoomObjectData(t, e, s, r) {
    if (!this._roomObjectEventHandler) return !1;
    e === L.WALL && this._roomObjectEventHandler.modifyWallItemData(this._activeRoomId, t, s, r);
  }
  processRoomObjectEvent(t) {
    if (!this._roomObjectEventHandler) return;
    const e = this.getRoomObjectRoomId(t.object);
    if (!e) return;
    const s = this.getRoomIdFromString(e);
    this._roomObjectEventHandler.handleRoomObjectEvent(t, s);
  }
  processRoomObjectPlacement(t, e, s, r, n = null, a = null, o = -1, h = -1, u = null) {
    const c = this.getRoomInstance(this._activeRoomId);
    return !c || c.model.getValue(Ye.ROOM_IS_PUBLIC) !== 0 || !this._roomObjectEventHandler ? !1 : this._roomObjectEventHandler.processRoomObjectPlacement(t, this._activeRoomId, e, s, r, n, a, o, h, u);
  }
  getRoomObjectScreenLocation(t, e, s, r = -1) {
    r == -1 && (r = this._activeRoomActiveCanvas);
    const n = this.getRoomInstanceGeometry(t, r);
    if (!n) return null;
    const a = this.getRoomObject(t, e, s);
    if (!a) return null;
    const o = n.getScreenPoint(a.getLocation());
    if (!o) return null;
    const h = this.getRoomInstanceRenderingCanvas(t, r);
    return h ? (o.x = o.x * h.scale, o.y = o.y * h.scale, o.x += h.width / 2 + h.screenOffsetX, o.y += h.height / 2 + h.screenOffsetY, o.x = Math.round(o.x), o.y = Math.round(o.y), o) : null;
  }
  selectRoomObject(t, e, s) {
    this._roomObjectEventHandler && this._roomObjectEventHandler.setSelectedObject(t, e, s);
  }
  setSelectedAvatar(t, e) {
    this._roomObjectEventHandler || this._roomObjectEventHandler.setSelectedAvatar(t, e, !0);
  }
  cancelRoomObjectInsert() {
    this._roomObjectEventHandler && this._roomObjectEventHandler.cancelRoomObjectInsert(this._activeRoomId);
  }
  addOverlayIconSprite(t, e, s, r = 1) {
    if (!t || !s) return;
    let n = this.getOverlayIconSprite(t, e);
    return n ? null : (n = new Ft(s), n.label = e, n.scale.set(r), t.addChild(n), n);
  }
  onRoomContentLoaded(t, e, s) {
    if (t === -1) return;
    this._thumbnailObjectIdBank.freeNumber(t - 1);
    const r = this._thumbnailCallbacks.get(e);
    if (r) {
      this._thumbnailCallbacks.delete(e);
      const n = this._roomContentLoader.getImage(e);
      if (n)
        for (const a of r)
          a && a.imageReady(new El(t, null, n));
    }
  }
  setObjectMoverIconSprite(t, e, s, r = null, n = null, a = -1, o = -1, h = null) {
    let u = null, c = 0, l = null;
    const _ = 1;
    if (s)
      l = this.getRoomObjectImage(this._activeRoomId, t, e, new v(), 1, null);
    else if (e === L.FLOOR ? (u = this._roomContentLoader.getFurnitureFloorNameForTypeId(t), c = this._roomContentLoader.getFurnitureFloorColorIndex(t)) : e === L.WALL && (u = this._roomContentLoader.getFurnitureWallNameForTypeId(t, r), c = this._roomContentLoader.getFurnitureWallColorIndex(t)), e === L.UNIT)
      if (u = Xt.getTypeString(t), u === "pet") {
        u = this.getPetType(r);
        const g = new $l(r);
        l = this.getRoomObjectPetImage(g.typeId, g.paletteId, g.color, new v(180), 64, null, !0, 0, g.customParts, h);
      } else
        l = this.getGenericRoomObjectImage(u, r, new v(180), 64, null, 0, null, n, a, o, h);
    else
      l = this.getGenericRoomObjectImage(u, c.toString(), new v(), 1, null, 0, r, n, a, o, h);
    if (!l || !l.data) return;
    const d = this.getActiveRoomInstanceRenderingCanvas();
    if (!d) return;
    const f = this.getRenderingCanvasOverlay(d);
    this.removeOverlayIconSprite(f, Tt.OBJECT_ICON_SPRITE);
    const p = this.addOverlayIconSprite(f, Tt.OBJECT_ICON_SPRITE, l.data, _);
    p && (p.x = this._activeRoomActiveCanvasMouseX - l.data.width / 2, p.y = this._activeRoomActiveCanvasMouseY - l.data.height / 2);
  }
  getRoomObjectImage(t, e, s, r, n, a, o = 0) {
    if (!this._roomManager) return null;
    let h = -1, u = null, c = null, l = "", _ = null;
    const d = this.getRoomId(t), f = this._roomManager.getRoomInstance(d);
    if (f) {
      const p = f.getRoomObject(e, s);
      if (p && p.model)
        switch (h = p.id, u = p.type, s) {
          case L.FLOOR:
          case L.WALL: {
            l = p.model.getValue(I.FURNITURE_COLOR).toString(), _ = p.model.getValue(I.FURNITURE_EXTRAS);
            const g = p.model.getValue(I.FURNITURE_DATA_FORMAT);
            g !== ns.FORMAT_KEY && (c = tn.getData(g), c.initializeFromRoomObjectModel(p.model));
            break;
          }
          case L.UNIT:
            l = p.model.getValue(I.FIGURE);
            break;
        }
    }
    return this.getGenericRoomObjectImage(u, l, r, n, a, o, _, c, -1, -1, null, h);
  }
  getFurnitureFloorIconUrl(t) {
    const e = this._roomContentLoader.getFurnitureFloorNameForTypeId(t), s = this._roomContentLoader.getFurnitureFloorColorIndex(t).toString();
    return this._roomContentLoader.getAssetIconUrl(e, s);
  }
  getFurnitureFloorIcon(t, e, s = null, r = null) {
    return this.getFurnitureFloorImage(t, new v(), 1, e, 0, s, -1, -1, r);
  }
  getFurnitureWallIconUrl(t, e = null) {
    const s = this._roomContentLoader.getFurnitureWallNameForTypeId(t, e), r = this._roomContentLoader.getFurnitureWallColorIndex(t).toString();
    return this._roomContentLoader.getAssetIconUrl(s, r);
  }
  getFurnitureWallIcon(t, e, s = null) {
    return this.getFurnitureWallImage(t, new v(), 1, e, 0, s);
  }
  getFurnitureFloorImage(t, e, s, r, n = 0, a = null, o = -1, h = -1, u = null) {
    const c = this._roomContentLoader.getFurnitureFloorNameForTypeId(t), l = this._roomContentLoader.getFurnitureFloorColorIndex(t).toString();
    return s === 1 && r ? this.getGenericRoomObjectThumbnail(c, l, r, a, u) : this.getGenericRoomObjectImage(c, l, e, s, r, n, a, u, o, h);
  }
  getFurnitureWallImage(t, e, s, r, n = 0, a = null, o = -1, h = -1) {
    const u = this._roomContentLoader.getFurnitureWallNameForTypeId(t), c = this._roomContentLoader.getFurnitureWallColorIndex(t).toString();
    return s === 1 && r ? this.getGenericRoomObjectThumbnail(u, c, r, a, null) : this.getGenericRoomObjectImage(u, c, e, s, r, n, a, null, o, h);
  }
  getRoomObjectPetImage(t, e, s, r, n, a, o = !1, h = 0, u = null, c = null) {
    let l = null, _ = t + " " + e + " " + s.toString(16);
    if (o && (_ = _ + " head"), u) {
      _ = _ + (" " + u.length);
      for (const d of u)
        _ = _ + (" " + d.layerId + " " + d.partId + " " + d.paletteId);
    }
    return l = this._roomContentLoader.getPetNameForType(t), this.getGenericRoomObjectImage(l, _, r, n, a, h, null, null, -1, -1, c);
  }
  getGenericRoomObjectImage(t, e, s, r, n, a = 0, o = null, h = null, u = -1, c = -1, l = null, _ = -1) {
    if (!this._roomManager) return null;
    const d = new El();
    if (d.id = -1, !t) return d;
    let f = this._roomManager.getRoomInstance(Tt.TEMPORARY_ROOM);
    if (!f && (f = this._roomManager.createRoomInstance(Tt.TEMPORARY_ROOM), !f))
      return d;
    let p = this._imageObjectIdBank.reserveNumber();
    const g = this.getRoomObjectCategoryForType(t);
    if (p < 0) return d;
    p++;
    const m = f.createRoomObjectAndInitalize(p, t, g);
    if (!m || !m.model || !m.logic) return d;
    const O = m.model;
    switch (g) {
      case L.FLOOR:
      case L.WALL:
        O.setValue(I.FURNITURE_COLOR, parseInt(e)), O.setValue(I.FURNITURE_EXTRAS, o);
        break;
      case L.UNIT:
        if (t === Xt.USER || t === Xt.BOT || t === Xt.RENTABLE_BOT || t === Xt.PET)
          O.setValue(I.FIGURE, e);
        else {
          const D = new $l(e);
          O.setValue(I.PET_PALETTE_INDEX, D.paletteId), O.setValue(I.PET_COLOR, D.color), D.headOnly && O.setValue(I.PET_HEAD_ONLY, 1), D.hasCustomParts && (O.setValue(I.PET_CUSTOM_LAYER_IDS, D.customLayerIds), O.setValue(I.PET_CUSTOM_PARTS_IDS, D.customPartIds), O.setValue(I.PET_CUSTOM_PALETTE_IDS, D.customPaletteIds)), l && O.setValue(I.FIGURE_POSTURE, l);
        }
        break;
      case L.ROOM:
        break;
    }
    m.setDirection(s);
    const y = m.visualization;
    if (!y)
      return f.removeRoomObject(p, g), d;
    (u > -1 || h) && (h && h.getLegacyString() !== "" ? m.logic.processUpdateMessage(new Ht(parseInt(h.getLegacyString()), h)) : m.logic.processUpdateMessage(new Ht(u, h)));
    const C = new $s(r, new v(-135, 30, 0), new v(11, 11, 5));
    if (y.update(C, 0, !0, !1), c > 0) {
      let D = 0;
      for (; D < c; )
        y.update(C, 0, !0, !1), D++;
    }
    const b = y.getImage();
    if (d.data = b, d.id = p, !this.isRoomContentTypeLoaded(t) && n) {
      let D = this._imageCallbacks.get(p.toString());
      D || (D = [], this._imageCallbacks.set(p.toString(), D)), D.push(n), O.setValue(I.IMAGE_QUERY_SCALE, r);
    } else
      f.removeRoomObject(p, g), this._imageObjectIdBank.freeNumber(p - 1), d.id = 0;
    return C.dispose(), d;
  }
  getGenericRoomObjectThumbnail(t, e, s, r = null, n = null) {
    if (!this._roomManager) return null;
    const a = new El();
    if (a.id = -1, !t) return a;
    let o = this._roomManager.getRoomInstance(Tt.TEMPORARY_ROOM);
    if (!o && (o = this._roomManager.createRoomInstance(Tt.TEMPORARY_ROOM), !o))
      return a;
    let h = this._thumbnailObjectIdBank.reserveNumber();
    if (this.getRoomObjectCategoryForType(t), h < 0) return a;
    h++, a.id = h, a.data = null, a.image = null;
    const u = [t, e].join("_"), c = this._roomContentLoader.getImage(u);
    if (!c && s) {
      let l = this._thumbnailCallbacks.get(u);
      l || (l = [], this._thumbnailCallbacks.set(u, l), this._roomContentLoader.downloadImage(h, t, e, null)), l.push(s);
    } else
      c && (a.image = c), this._thumbnailObjectIdBank.freeNumber(h - 1), a.id = 0;
    return a;
  }
  initalizeTemporaryObjectsByType(t, e) {
    const s = this._roomManager.getRoomInstance(Tt.TEMPORARY_ROOM);
    if (!s) return;
    const r = this._roomContentLoader.getCategoryForType(t), n = s.getManager(r);
    let a = null, o = 0;
    if (n && n.objects.length) {
      for (const h of n.objects.getValues())
        if (h && h.model && h.type === t) {
          const u = h.id, c = h.visualization;
          let l = null;
          if (c) {
            const d = h.model.getValue(I.IMAGE_QUERY_SCALE);
            a && o !== d && (a.dispose(), a = null), a || (o = d, a = new $s(d, new v(-135, 30, 0), new v(11, 11, 5))), c.update(a, 0, !0, !1), l = c.image;
          }
          s.removeRoomObject(u, r), this._imageObjectIdBank.freeNumber(u - 1);
          const _ = this._imageCallbacks.get(u.toString());
          if (_) {
            this._imageCallbacks.delete(u.toString());
            for (const d of _)
              d && (l ? d.imageReady(new El(u, l)) : d.imageFailed(u));
          }
        }
    }
    a && a.dispose();
  }
  setObjectMoverIconSpriteVisible(t) {
    const e = this.getActiveRoomInstanceRenderingCanvas();
    if (!e) return;
    const s = this.getRenderingCanvasOverlay(e), r = this.getOverlayIconSprite(s, Tt.OBJECT_ICON_SPRITE);
    r && (r.visible = t);
  }
  removeObjectMoverIconSprite() {
    const t = this.getActiveRoomInstanceRenderingCanvas();
    if (!t) return;
    const e = this.getRenderingCanvasOverlay(t);
    this.removeOverlayIconSprite(e, Tt.OBJECT_ICON_SPRITE);
  }
  getRenderingCanvasOverlay(t) {
    if (!t) return null;
    const e = t.master;
    return e ? e.getChildByName(Tt.OVERLAY) ?? null : null;
  }
  removeOverlayIconSprite(t, e) {
    if (!t) return !1;
    let s = t.children.length - 1;
    for (; s >= 0; ) {
      const r = t.getChildAt(s);
      if (r && r.label === e) {
        if (t.removeChildAt(s), r.children.length) {
          const n = r.getChildAt(0);
          n.parent.removeChild(n), n.destroy();
        }
        return !0;
      }
      s--;
    }
    return !1;
  }
  getOverlayIconSprite(t, e) {
    if (!t) return null;
    let s = t.children.length - 1;
    for (; s >= 0; ) {
      const r = t.getChildAt(s);
      if (r && r.label === e)
        return r;
      s--;
    }
    return null;
  }
  getRoomObjects(t, e) {
    const s = this.getRoomId(t), r = this._roomManager.getRoomInstance(s);
    return r ? r.getRoomObjectsForCategory(e) : [];
  }
  addObjectToTileMap(t, e) {
    const s = this.getRoomInstanceData(t).tileObjectMap;
    s && s.addRoomObject(e);
  }
  refreshTileObjectMap(t, e) {
    const s = this.getRoomInstanceData(t).tileObjectMap;
    s && s.populate(this.getRoomObjects(t, L.FLOOR));
  }
  createTextureFromRoom(t, e = -1, s = null) {
    let r = null;
    e > -1 ? r = this.getRoomInstanceRenderingCanvas(this._activeRoomId, e) : r = this.getActiveRoomInstanceRenderingCanvas();
    let n = null;
    return s ? n = le.generateTexture({
      target: r.master,
      frame: s
    }) : n = r.getDisplayAsTexture(), n;
  }
  async saveTextureAsScreenshot(t, e = !1) {
    let s = null;
    e ? s = new nE() : s = new bc(), await s.assignBitmap(t), G().connection.send(s);
  }
  saveBase64AsScreenshot(t, e = !1) {
    let s = null;
    e ? s = new nE() : s = new bc(), s.assignBase64(t), G().connection.send(s);
  }
  objectsInitialized(t) {
    const e = this.getRoomIdFromString(t);
    x().dispatchEvent(new ae(ae.OBJECTS_INITIALIZED, e));
  }
  getRoomId(t) {
    return t.toString();
  }
  getRoomIdFromString(t) {
    if (!t) return -1;
    const e = t.split("_");
    return e.length <= 0 ? -1 : parseInt(e[0]) || 0;
  }
  getRoomObjectRoomId(t) {
    return !t || !t.model ? null : t.model.getValue(I.OBJECT_ROOM_ID);
  }
  getRoomObjectAdUrl(t) {
    return this._roomContentLoader.getRoomObjectAdUrl(t);
  }
  getPetTypeId(t) {
    let e = -1;
    if (t) {
      const s = t.split(" ");
      s.length > 1 && (e = parseInt(s[0]));
    }
    return e;
  }
  getPetType(t) {
    if (!t) return null;
    const e = t.split(" ");
    if (e.length > 1) {
      const s = parseInt(e[0]);
      return this._roomContentLoader.getPetNameForType(s);
    }
    return null;
  }
  isRoomContentTypeLoaded(t) {
    return !!this._roomContentLoader.getCollection(t);
  }
  getPetColorResult(t, e) {
    return this._roomContentLoader.getPetColorResult(t, e);
  }
  getPetColorResultsForTag(t, e) {
    return this._roomContentLoader.getPetColorResultsForTag(t, e);
  }
  deleteRoomObject(t, e) {
    return !this._roomObjectEventHandler || e !== L.WALL ? !1 : this._roomObjectEventHandler.deleteWallItem(this._activeRoomId, t);
  }
  get roomManager() {
    return this._roomManager;
  }
  set roomManager(t) {
    this._roomManager = t;
  }
  get areaSelectionManager() {
    return this._areaSelectionManager;
  }
  get objectEventHandler() {
    return this._roomObjectEventHandler;
  }
  get activeRoomId() {
    return this._activeRoomId;
  }
  get isDecorating() {
    const t = this._roomSessionManager.getSession(this._activeRoomId);
    return t && t.isDecorating || !1;
  }
  get useOffsetScrolling() {
    return !0;
  }
  get selectedAvatarId() {
    return this._roomObjectEventHandler ? this._roomObjectEventHandler.selectedAvatarId : -1;
  }
  getRoomObjectCount(t, e) {
    return this._roomManager == null ? 0 : this._roomManager.getRoomInstance(t.toString()).getRoomObjectsForCategory(e).length;
  }
  get moveBlocked() {
    return this._moveBlocked;
  }
  set moveBlocked(t) {
    this._moveBlocked = t;
  }
  isAreaSelectionMode() {
    return this._areaSelectionManager.areaSelectionState !== bh.NOT_ACTIVE;
  }
  whereYouClickIsWhereYouGo() {
    return !this.isAreaSelectionMode();
  }
};
Tt.ROOM_OBJECT_ID = -1, Tt.ROOM_OBJECT_TYPE = "room", Tt.CURSOR_OBJECT_ID = -2, Tt.CURSOR_OBJECT_TYPE = "tile_cursor", Tt.ARROW_OBJECT_ID = -3, Tt.ARROW_OBJECT_TYPE = "selection_arrow", Tt.OVERLAY = "overlay", Tt.OBJECT_ICON_SPRITE = "object_icon_sprite", Tt.DRAG_THRESHOLD = 15, Tt.TEMPORARY_ROOM = "temporary_room";
let Yc = Tt;
const Srt = new Yc(), SI = () => Srt, H = class H {
  constructor(t, e = 1) {
    this._previewRoomId = 1, this._currentPreviewObjectType = 0, this._currentPreviewObjectCategory = 0, this._currentPreviewObjectData = "", this._currentPreviewRectangle = null, this._currentPreviewCanvasWidth = 0, this._currentPreviewCanvasHeight = 0, this._currentPreviewScale = 64, this._backgroundColor = 0, this._backgroundSprite = null, this._disableUpdate = !1, this._roomEngine = t, this._planeParser = new ye(), this._previewRoomId = rc.makeRoomPreviewerId(e), this._addViewOffset = new st(0, 0), this.onRoomObjectAdded = this.onRoomObjectAdded.bind(this), this.onRoomInitializedonRoomInitialized = this.onRoomInitializedonRoomInitialized.bind(this), this.isRoomEngineReady && x() && (x().addEventListener(lt.ADDED, this.onRoomObjectAdded), x().addEventListener(lt.CONTENT_UPDATED, this.onRoomObjectAdded), x().addEventListener(ae.INITIALIZED, this.onRoomInitializedonRoomInitialized)), this.createRoomForPreview();
  }
  dispose() {
    this.reset(!0), this.isRoomEngineReady && x() && (x().removeEventListener(lt.ADDED, this.onRoomObjectAdded), x().removeEventListener(lt.CONTENT_UPDATED, this.onRoomObjectAdded), x().removeEventListener(ae.INITIALIZED, this.onRoomInitializedonRoomInitialized)), this._backgroundSprite && (this._backgroundSprite.destroy(), this._backgroundSprite = null), this._planeParser && (this._planeParser.dispose(), this._planeParser = null);
  }
  createRoomForPreview() {
    if (this.isRoomEngineReady) {
      const e = new ye();
      e.initializeTileMap(9, 9);
      let s = 1;
      for (; s < 8; ) {
        let r = 1;
        for (; r < 8; )
          e.setTileHeight(r, s, 0), r++;
        s++;
      }
      e.initializeFromTileData(), this._roomEngine.createRoomInstance(this._previewRoomId, e.getMapData()), e.dispose();
    }
  }
  reset(t) {
    this.isRoomEngineReady && (this._roomEngine.removeRoomObjectFloor(this._previewRoomId, H.PREVIEW_OBJECT_ID), this._roomEngine.removeRoomObjectWall(this._previewRoomId, H.PREVIEW_OBJECT_ID), this._roomEngine.removeRoomObjectUser(this._previewRoomId, H.PREVIEW_OBJECT_ID), t || this.updatePreviewRoomView()), this._currentPreviewObjectCategory = L.MINIMUM;
  }
  updatePreviewModel(t, e, s = !0) {
    const r = new Tc();
    r.flush(), r.parseModel(t, e, s);
    const n = this._roomEngine.getLegacyWallGeometry(this._previewRoomId);
    if (!n) return;
    this._planeParser.reset();
    const a = r.width, o = r.height;
    this._planeParser.initializeTileMap(a, o);
    const h = null;
    let u = -1, c = -1, l = 0, _ = 0, d = 0;
    for (; d < o; ) {
      let m = 0;
      for (; m < a; ) {
        const O = r.getHeight(m, d);
        (d > 0 && d < o - 1 || m > 0 && m < a - 1) && O != ye.TILE_BLOCKED && h == null && (r.getHeight(m, d - 1) == ye.TILE_BLOCKED && r.getHeight(m - 1, d) == ye.TILE_BLOCKED && r.getHeight(m, d + 1) == ye.TILE_BLOCKED && (u = m + 0.5, c = d, l = O, _ = 90), r.getHeight(m, d - 1) == ye.TILE_BLOCKED && r.getHeight(m - 1, d) == ye.TILE_BLOCKED && r.getHeight(m + 1, d) == ye.TILE_BLOCKED && (u = m, c = d + 0.5, l = O, _ = 180)), this._planeParser.setTileHeight(m, d, O), m++;
      }
      d++;
    }
    this._planeParser.setTileHeight(Math.floor(u), Math.floor(c), l), this._planeParser.initializeFromTileData(r.wallHeight), this._planeParser.setTileHeight(Math.floor(u), Math.floor(c), l + this._planeParser.wallHeight), n.scale = Gu.DEFAULT_SCALE, n.initialize(a, o, this._planeParser.floorHeight);
    let f = r.height - 1;
    for (; f >= 0; ) {
      let m = r.width - 1;
      for (; m >= 0; )
        n.setHeight(m, f, this._planeParser.getTileHeight(m, f)), m--;
      f--;
    }
    const p = this._planeParser.getMapData();
    p.doors.push({
      x: u,
      y: c,
      z: l,
      dir: _
    });
    const g = this.getRoomPreviewOwnRoomObject();
    g && g.processUpdateMessage(new Lc(p));
  }
  addFurnitureIntoRoom(t, e, s = null, r = null) {
    if (s || (s = new ns()), this.isRoomEngineReady && (this.reset(!1), this._currentPreviewObjectType = t, this._currentPreviewObjectCategory = L.FLOOR, this._currentPreviewObjectData = "", this._roomEngine.addFurnitureFloor(this._previewRoomId, H.PREVIEW_OBJECT_ID, t, new v(H.PREVIEW_OBJECT_LOCATION_X, H.PREVIEW_OBJECT_LOCATION_Y, 0), e, 0, s, NaN, -1, 0, -1, "", !0, !1))) {
      this._previousAutomaticStateChangeTime = Nt(), this._automaticStateChange = !0;
      const n = this._roomEngine.getRoomObject(this._previewRoomId, H.PREVIEW_OBJECT_ID, this._currentPreviewObjectCategory);
      return n && r && n.model.setValue(I.FURNITURE_EXTRAS, r), this.updatePreviewRoomView(), H.PREVIEW_OBJECT_ID;
    }
    return -1;
  }
  addWallItemIntoRoom(t, e, s) {
    if (this.isRoomEngineReady) {
      if (this._currentPreviewObjectCategory === L.WALL && this._currentPreviewObjectType === t && this._currentPreviewObjectData === s) return H.PREVIEW_OBJECT_ID;
      if (this.reset(!1), this._currentPreviewObjectType = t, this._currentPreviewObjectCategory = L.WALL, this._currentPreviewObjectData = s, this._roomEngine.addFurnitureWall(this._previewRoomId, H.PREVIEW_OBJECT_ID, t, new v(0.5, 2.3, 1.8), e, 0, s, 0, 0, -1, "", !1))
        return this._previousAutomaticStateChangeTime = Nt(), this._automaticStateChange = !0, this.updatePreviewRoomView(), H.PREVIEW_OBJECT_ID;
    }
    return -1;
  }
  addAvatarIntoRoom(t, e) {
    return this.isRoomEngineReady ? (this.reset(!1), this._currentPreviewObjectType = 1, this._currentPreviewObjectCategory = L.UNIT, this._currentPreviewObjectData = t, this._roomEngine.addRoomObjectUser(this._previewRoomId, H.PREVIEW_OBJECT_ID, new v(H.PREVIEW_OBJECT_LOCATION_X, H.PREVIEW_OBJECT_LOCATION_Y, 0), new v(90, 0, 0), 135, Xt.getTypeNumber(Xt.USER), t) && (this._previousAutomaticStateChangeTime = Nt(), this._automaticStateChange = !0, this.updateUserGesture(1), this.updateUserEffect(e), this.updateUserPosture("std")), this.updatePreviewRoomView(), H.PREVIEW_OBJECT_ID) : -1;
  }
  addPetIntoRoom(t) {
    return this.isRoomEngineReady ? (this.reset(!1), this._currentPreviewObjectType = 1, this._currentPreviewObjectCategory = L.UNIT, this._currentPreviewObjectData = t, this._roomEngine.addRoomObjectUser(this._previewRoomId, H.PREVIEW_OBJECT_ID, new v(H.PREVIEW_OBJECT_LOCATION_X, H.PREVIEW_OBJECT_LOCATION_Y, 0), new v(90, 0, 0), 90, Xt.getTypeNumber(Xt.PET), t) && (this._previousAutomaticStateChangeTime = Nt(), this._automaticStateChange = !1, this.updateUserGesture(1), this.updateUserPosture("std")), this.updatePreviewRoomView(), H.PREVIEW_OBJECT_ID) : -1;
  }
  updateUserPosture(t, e = "") {
    this.isRoomEngineReady && this._roomEngine.updateRoomObjectUserPosture(this._previewRoomId, H.PREVIEW_OBJECT_ID, t, e);
  }
  updateUserGesture(t) {
    this.isRoomEngineReady && this._roomEngine.updateRoomObjectUserGesture(this._previewRoomId, H.PREVIEW_OBJECT_ID, t);
  }
  updateUserEffect(t) {
    this.isRoomEngineReady && this._roomEngine.updateRoomObjectUserEffect(this._previewRoomId, H.PREVIEW_OBJECT_ID, t);
  }
  updateObjectUserFigure(t, e = null, s = null, r = !1) {
    return this.isRoomEngineReady ? this._roomEngine.updateRoomObjectUserFigure(this._previewRoomId, H.PREVIEW_OBJECT_ID, t, e, s, r) : !1;
  }
  updateObjectUserAction(t, e, s = null) {
    this.isRoomEngineReady && this._roomEngine.updateRoomObjectUserAction(this._previewRoomId, H.PREVIEW_OBJECT_ID, t, e, s);
  }
  updateObjectStuffData(t) {
    this.isRoomEngineReady && this._roomEngine.updateRoomObjectFloor(this._previewRoomId, H.PREVIEW_OBJECT_ID, null, null, t.state, t);
  }
  changeRoomObjectState() {
    this.isRoomEngineReady && (this._automaticStateChange = !1, this._currentPreviewObjectCategory !== L.UNIT && this._roomEngine.changeObjectState(this._previewRoomId, H.PREVIEW_OBJECT_ID, this._currentPreviewObjectCategory));
  }
  changeRoomObjectDirection() {
    if (this.isRoomEngineReady) {
      const t = this._roomEngine.getRoomObject(this._previewRoomId, H.PREVIEW_OBJECT_ID, this._currentPreviewObjectCategory);
      if (!t) return;
      const e = this._roomEngine.objectEventHandler.getValidRoomObjectDirection(t, !0);
      switch (this._currentPreviewObjectCategory) {
        case L.FLOOR: {
          const s = new v(H.PREVIEW_OBJECT_LOCATION_X, H.PREVIEW_OBJECT_LOCATION_Y), r = new v(e, e, e);
          this._roomEngine.updateRoomObjectFloor(this._previewRoomId, H.PREVIEW_OBJECT_ID, s, r, null, null);
          return;
        }
        case L.WALL:
          return;
      }
    }
  }
  checkAutomaticRoomObjectStateChange() {
    if (this._automaticStateChange) {
      const t = Nt();
      t > this._previousAutomaticStateChangeTime + H.AUTOMATIC_STATE_CHANGE_INTERVAL && (this._previousAutomaticStateChangeTime = t, this.isRoomEngineReady && this._roomEngine.changeObjectState(this._previewRoomId, H.PREVIEW_OBJECT_ID, this._currentPreviewObjectCategory));
    }
  }
  getRoomCanvas(t, e) {
    if (this.isRoomEngineReady) {
      const s = this._roomEngine.getRoomInstanceDisplay(this._previewRoomId, H.PREVIEW_CANVAS_ID, t, e, this._currentPreviewScale);
      if (s && this._backgroundColor !== null) {
        let n = this._backgroundSprite;
        n || (n = new Ft(W.WHITE), s.addChildAt(n, 0)), n.width = t, n.height = e, n.tint = this._backgroundColor;
      }
      this._roomEngine.setRoomInstanceRenderingCanvasMask(this._previewRoomId, H.PREVIEW_CANVAS_ID, !0);
      const r = this._roomEngine.getRoomInstanceGeometry(this._previewRoomId, H.PREVIEW_CANVAS_ID);
      return r && r.adjustLocation(new v(H.PREVIEW_OBJECT_LOCATION_X, H.PREVIEW_OBJECT_LOCATION_Y, 0), 30), this._currentPreviewCanvasWidth = t, this._currentPreviewCanvasHeight = e, s;
    }
    return null;
  }
  modifyRoomCanvas(t, e) {
    this.isRoomEngineReady && (this._currentPreviewCanvasWidth = t, this._currentPreviewCanvasHeight = e, this._backgroundSprite && (this._backgroundSprite.width = t, this._backgroundSprite.height = e), this._roomEngine.initializeRoomInstanceRenderingCanvas(this._previewRoomId, H.PREVIEW_CANVAS_ID, t, e));
  }
  set addViewOffset(t) {
    this._addViewOffset = t;
  }
  get addViewOffset() {
    return this._addViewOffset;
  }
  updatePreviewObjectBoundingRectangle(t = null) {
    t || (t = new st(0, 0));
    const e = this._roomEngine.getRoomObjectBoundingRectangle(this._previewRoomId, H.PREVIEW_OBJECT_ID, this._currentPreviewObjectCategory, H.PREVIEW_CANVAS_ID);
    if (e && t)
      if (e.x += -(this._currentPreviewCanvasWidth >> 1), e.y += -(this._currentPreviewCanvasHeight >> 1), e.x += -t.x, e.y += -t.y, !this._currentPreviewRectangle)
        this._currentPreviewRectangle = e;
      else {
        const s = this._currentPreviewRectangle.clone().enlarge(e);
        (s.width - this._currentPreviewRectangle.width > this._currentPreviewCanvasWidth - this._currentPreviewRectangle.width >> 1 || s.height - this._currentPreviewRectangle.height > this._currentPreviewCanvasHeight - this._currentPreviewRectangle.height >> 1 || this._currentPreviewRectangle.width < 1 || this._currentPreviewRectangle.height < 1) && (this._currentPreviewRectangle = s);
      }
  }
  validatePreviewSize(t) {
    if (this._currentPreviewRectangle.width < 1 || this._currentPreviewRectangle.height < 1)
      return t;
    if (this.isRoomEngineReady) {
      const e = this._roomEngine.getRoomInstanceGeometry(this._previewRoomId, H.PREVIEW_CANVAS_ID);
      this._currentPreviewRectangle.width > this._currentPreviewCanvasWidth * (1 + H.ALLOWED_IMAGE_CUT) || this._currentPreviewRectangle.height > this._currentPreviewCanvasHeight * (1 + H.ALLOWED_IMAGE_CUT) ? H.ZOOM_ENABLED ? this._roomEngine.getRoomInstanceRenderingCanvasScale(this._previewRoomId, H.PREVIEW_CANVAS_ID) !== 0.5 && (this._roomEngine.setRoomInstanceRenderingCanvasScale(this._previewRoomId, H.PREVIEW_CANVAS_ID, 0.5, null, null), this._currentPreviewScale = H.SCALE_SMALL, this._currentPreviewNeedsZoomOut = !0, t.x = t.x >> 1, t.y = t.y >> 1, this._currentPreviewRectangle.x = this._currentPreviewRectangle.x >> 2, this._currentPreviewRectangle.y = this._currentPreviewRectangle.y >> 2, this._currentPreviewRectangle.width = this._currentPreviewRectangle.width >> 2, this._currentPreviewRectangle.height = this._currentPreviewRectangle.height >> 2) : e.isZoomedIn() && (e.performZoomOut(), this._currentPreviewScale = H.SCALE_SMALL, this._currentPreviewNeedsZoomOut = !0) : this._currentPreviewNeedsZoomOut || (H.ZOOM_ENABLED ? this._roomEngine.getRoomInstanceRenderingCanvasScale(this._previewRoomId, H.PREVIEW_CANVAS_ID) !== 1 && (this._roomEngine.setRoomInstanceRenderingCanvasScale(this._previewRoomId, H.PREVIEW_CANVAS_ID, 1, null, null), this._currentPreviewScale = H.SCALE_NORMAL) : e.isZoomedIn() || (e.performZoomIn(), this._currentPreviewScale = H.SCALE_NORMAL));
    }
    return t;
  }
  zoomIn() {
    this.isRoomEngineReady && (H.ZOOM_ENABLED ? this._roomEngine.setRoomInstanceRenderingCanvasScale(this._previewRoomId, H.PREVIEW_CANVAS_ID, 1) : this._roomEngine.getRoomInstanceGeometry(this._previewRoomId, H.PREVIEW_CANVAS_ID).performZoomIn()), this._currentPreviewScale = H.SCALE_NORMAL;
  }
  zoomOut() {
    this.isRoomEngineReady && (H.ZOOM_ENABLED ? this._roomEngine.setRoomInstanceRenderingCanvasScale(this._previewRoomId, H.PREVIEW_CANVAS_ID, 0.5) : this._roomEngine.getRoomInstanceGeometry(this._previewRoomId, H.PREVIEW_CANVAS_ID).performZoomOut()), this._currentPreviewScale = H.SCALE_SMALL;
  }
  updateAvatarDirection(t, e) {
    this.isRoomEngineReady && this._roomEngine.updateRoomObjectUserLocation(this._previewRoomId, H.PREVIEW_OBJECT_ID, new v(H.PREVIEW_OBJECT_LOCATION_X, H.PREVIEW_OBJECT_LOCATION_Y, 0), new v(H.PREVIEW_OBJECT_LOCATION_X, H.PREVIEW_OBJECT_LOCATION_Y, 0), !1, 0, new v(t * 45, 0, 0), e * 45);
  }
  updateObjectRoom(t = null, e = null, s = null, r = !1) {
    return this.isRoomEngineReady ? this._roomEngine.updateRoomInstancePlaneType(this._previewRoomId, t, e, s, r) : !1;
  }
  updateRoomWallsAndFloorVisibility(t, e = !0) {
    this.isRoomEngineReady && this._roomEngine.updateRoomInstancePlaneVisibility(this._previewRoomId, t, e);
  }
  getCanvasOffset(t) {
    if (this._currentPreviewRectangle.width < 1 || this._currentPreviewRectangle.height < 1) return t;
    let e = -(this._currentPreviewRectangle.left + this._currentPreviewRectangle.right) >> 1, s = -(this._currentPreviewRectangle.top + this._currentPreviewRectangle.bottom) >> 1;
    const r = this._currentPreviewCanvasHeight - this._currentPreviewRectangle.height >> 1;
    r > 10 ? s = s + Math.min(15, r - 10) : this._currentPreviewObjectCategory !== L.UNIT ? s = s + (5 - Math.max(0, r / 2)) : s = s - (5 - Math.min(0, r / 2)), s = s + this._addViewOffset.y, e = e + this._addViewOffset.x;
    const n = e - t.x, a = s - t.y;
    if (n !== 0 || a !== 0) {
      const o = Math.sqrt(n * n + a * a);
      return o > 10 && (e = t.x + n * 10 / o, s = t.y + a * 10 / o), new st(e, s);
    }
    return null;
  }
  updatePreviewRoomView(t = !1) {
    if (!(this._disableUpdate && !t) && (this.checkAutomaticRoomObjectStateChange(), this.isRoomEngineReady)) {
      let e = this._roomEngine.getRoomInstanceRenderingCanvasOffset(this._previewRoomId, H.PREVIEW_CANVAS_ID);
      if (e && (this.updatePreviewObjectBoundingRectangle(e), this._currentPreviewRectangle)) {
        const s = this._currentPreviewScale;
        e = this.validatePreviewSize(e);
        const r = this.getCanvasOffset(e);
        r && this._roomEngine.setRoomInstanceRenderingCanvasOffset(this._previewRoomId, H.PREVIEW_CANVAS_ID, r), this._currentPreviewScale !== s && (this._currentPreviewRectangle = null);
      }
    }
  }
  onRoomInitializedonRoomInitialized(t) {
    if (t)
      switch (t.type) {
        case ae.INITIALIZED:
          t.roomId === this._previewRoomId && this.isRoomEngineReady && this._roomEngine.updateRoomInstancePlaneType(this._previewRoomId, "110", "99999");
          return;
      }
  }
  onRoomObjectAdded(t) {
    if (t.roomId === this._previewRoomId && t.objectId === H.PREVIEW_OBJECT_ID && t.category === this._currentPreviewObjectCategory) {
      this._currentPreviewRectangle = null, this._currentPreviewNeedsZoomOut = !1;
      const e = this._roomEngine.getRoomObject(t.roomId, t.objectId, t.category);
      if (e && e.model && t.category === L.WALL) {
        const s = e.model.getValue(I.FURNITURE_SIZE_Z), r = e.model.getValue(I.FURNITURE_CENTER_Z);
        (s !== null || r !== null) && this._roomEngine.updateRoomObjectWallLocation(t.roomId, t.objectId, new v(0.5, 2.3, (3.6 - s) / 2 + r));
      }
    }
  }
  getRenderingCanvas() {
    const t = this._roomEngine.getRoomInstanceRenderingCanvas(this._previewRoomId, H.PREVIEW_CANVAS_ID);
    return t || null;
  }
  getGenericRoomObjectImage(t, e, s, r, n, a = 0, o = null, h = null, u = -1, c = -1, l = null) {
    return this.isRoomEngineReady ? this._roomEngine.getGenericRoomObjectImage(t, e, s, r, n, a, o, h, u, c, l) : null;
  }
  getRoomObjectImage(t, e, s, r = 0) {
    return this.isRoomEngineReady ? this._roomEngine.getRoomObjectImage(this._previewRoomId, H.PREVIEW_OBJECT_ID, this._currentPreviewObjectCategory, t, e, s, r) : null;
  }
  getRoomObjectCurrentImage() {
    if (this.isRoomEngineReady) {
      const t = this._roomEngine.getRoomObject(this._previewRoomId, H.PREVIEW_OBJECT_ID, this._currentPreviewObjectCategory);
      if (t && t.visualization) return t.visualization.getImage();
    }
    return null;
  }
  getRoomPreviewObject() {
    if (this.isRoomEngineReady) {
      const t = this._roomEngine.getRoomObject(this._previewRoomId, H.PREVIEW_OBJECT_ID, this._currentPreviewObjectCategory);
      if (t) return t;
    }
    return null;
  }
  getRoomPreviewOwnRoomObject() {
    if (this.isRoomEngineReady) {
      const t = this._roomEngine.getRoomObject(this._previewRoomId, Yc.ROOM_OBJECT_ID, L.ROOM);
      if (t) return t;
    }
    return null;
  }
  get isRoomEngineReady() {
    return !0;
  }
  get roomId() {
    return this._previewRoomId;
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  set backgroundColor(t) {
    this._backgroundColor = t;
  }
  get width() {
    return this._currentPreviewCanvasWidth;
  }
  get height() {
    return this._currentPreviewCanvasHeight;
  }
};
H.SCALE_NORMAL = 64, H.SCALE_SMALL = 32, H.PREVIEW_COUNTER = 0, H.PREVIEW_CANVAS_ID = 1, H.PREVIEW_OBJECT_ID = 1, H.PREVIEW_OBJECT_LOCATION_X = 2, H.PREVIEW_OBJECT_LOCATION_Y = 2, H.ALLOWED_IMAGE_CUT = 0.25, H.AUTOMATIC_STATE_CHANGE_INTERVAL = 2500, H.ZOOM_ENABLED = !0;
let Wc = H;
const dnt = () => new Wc(SI(), ++Wc.PREVIEW_COUNTER);
class jM {
  constructor(t, e, s, r, n = "") {
    this.id = t, this.length = e, this.name = s, this.creator = r, this.songData = n, this._jukeboxDiskId = -1;
  }
  get diskId() {
    return this._jukeboxDiskId;
  }
  set diskId(t) {
    this._jukeboxDiskId = t;
  }
}
class Art {
  constructor(t, e, s, r, n) {
    this._songId = t, this._startPos = e, this._playLength = s, this._fadeInSeconds = r, this._fadeOutSeconds = n, this._playRequestTime = Date.now();
  }
  get songId() {
    return this._songId;
  }
  get startPos() {
    return this._startPos < 0 ? 0 : this._startPos + (Date.now() - this._playRequestTime) / 1e3;
  }
  get playLength() {
    return this._playLength;
  }
  get playRequestTime() {
    return this._playRequestTime;
  }
  get fadeInSeconds() {
    return this._fadeInSeconds;
  }
  get fadeOutSeconds() {
    return this._fadeOutSeconds;
  }
}
class Rrt {
  constructor(t) {
    this._id = t, this._items = [];
  }
  addChannelItem(t) {
    this._items.push(t);
  }
  get items() {
    return this._items;
  }
}
class Ort {
  constructor(t, e) {
    this._id = t, this._length = e;
  }
  get id() {
    return this._id;
  }
  get length() {
    return this._length;
  }
}
class lT {
  constructor(t) {
    this._channels = [], this._metaData = /* @__PURE__ */ new Map();
    let e = [];
    const s = t.split(":"), r = s[s.length - 1];
    if (r.indexOf("meta") > -1) {
      const n = r.split(";");
      for (const a of n) {
        const o = a.split(",");
        this._metaData.set(o[0], o[1]);
      }
      e = s.slice(0, s.length - 1);
    } else
      e = s;
    for (let n = 0; n < e.length / 2; n++)
      if (e[n * 2].length > 0) {
        const a = parseInt(e[n * 2]), o = e[n * 2 + 1].split(";"), h = new Rrt(a);
        for (const u of o) {
          const c = u.split(",");
          if (c.length !== 2) return;
          h.addChannelItem(new Ort(parseInt(c[0]), parseInt(c[1])));
        }
        this._channels.push(h);
      }
  }
  get channels() {
    return this._channels;
  }
  getSampleIds() {
    const t = [];
    for (const e of this._channels)
      for (const s of e.items)
        t.indexOf(s.id) === -1 && t.push(s.id);
    return t;
  }
  get hasMetaData() {
    return this._metaData.has("meta");
  }
  get metaCutMode() {
    return this._metaData.has("c");
  }
  get metaTempo() {
    const t = this._metaData.get("t");
    return t ? parseInt(t) : null;
  }
}
const ea = class ea {
};
ea.PRIORITY_ROOM_PLAYLIST = 0, ea.PRIORITY_USER_PLAYLIST = 1, ea.PRIORITY_SONG_PLAY = 2, ea.PRIORITY_PURCHASE_PREVIEW = 3, ea.PRIORITY_COUNT = 4;
let Ns = ea;
class yrt {
  constructor() {
    this._isPlaying = !1, this._currentSongId = -1, this._missingSongInfo = [], this._playPosition = -1, this._disposed = !1, this._messageEvents = [], this.onSongInfoReceivedEvent = this.onSongInfoReceivedEvent.bind(this);
  }
  init() {
    this._messageEvents = [
      new xC(this.onNowPlayingMessageEvent.bind(this)),
      new CC(this.onJukeboxSongDisksMessageEvent.bind(this)),
      new vC(this.onJukeboxPlayListFullMessageEvent.bind(this))
    ], this._messageEvents.forEach((t) => G().registerMessageEvent(t)), x().addEventListener(Ho.SIR_TRAX_SONG_INFO_RECEIVED, this.onSongInfoReceivedEvent);
  }
  dispose() {
    this._disposed || (this.stopPlaying(), x().removeEventListener(Ho.SIR_TRAX_SONG_INFO_RECEIVED, this.onSongInfoReceivedEvent), this._messageEvents.forEach((t) => G().removeMessageEvent(t)), this._disposed = !0);
  }
  onNowPlayingMessageEvent(t) {
    const e = t.getParser();
    this._isPlaying = e.currentSongId !== -1, e.currentSongId >= 0 ? (Dn().musicController.playSong(e.currentSongId, Ns.PRIORITY_ROOM_PLAYLIST, e.syncCount / 1e3, 0, 1, 1), this._currentSongId = e.currentSongId) : this.stopPlaying(), e.nextSongId >= 0 && Dn().musicController.addSongInfoRequest(e.nextSongId), this._playPosition = e.currentPosition, x().dispatchEvent(new nn(nn.NPE_SONG_CHANGED, Ns.PRIORITY_ROOM_PLAYLIST, e.currentSongId, e.currentPosition));
  }
  onJukeboxSongDisksMessageEvent(t) {
    const e = t.getParser();
    this._entries = [];
    for (let s = 0; s < e.songDisks.length; s++) {
      const r = e.songDisks.getWithIndex(s), n = e.songDisks.getKey(s);
      let a = Dn().musicController.getSongInfo(r);
      a || (a = new jM(r, -1, null, null, null), this._missingSongInfo.indexOf(r) < 0 && (this._missingSongInfo.push(r), Dn().musicController.requestSongInfoWithoutSamples(r))), a.diskId = n, this._entries.push(a);
    }
    this._missingSongInfo.length || x().dispatchEvent(new Nr(Nr.PLUE_PLAY_LIST_UPDATED));
  }
  onJukeboxPlayListFullMessageEvent(t) {
    x().dispatchEvent(new Nr(Nr.PLUE_PLAY_LIST_FULL));
  }
  onSongInfoReceivedEvent(t) {
    for (let s = 0; s < this.length; s++) {
      const r = this._entries[s];
      if (r.id === t.id) {
        const n = r.diskId, a = Dn().musicController.getSongInfo(t.id);
        a && (a.diskId = n, this._entries[s] = a);
        break;
      }
    }
    const e = this._missingSongInfo.indexOf(t.id);
    e >= 0 && this._missingSongInfo.splice(e, 1), this._missingSongInfo.length || x().dispatchEvent(new Nr(Nr.PLUE_PLAY_LIST_UPDATED));
  }
  stopPlaying() {
    Dn().musicController.stop(this.priority), this._currentSongId = -1, this._playPosition = -1, this._isPlaying = !1;
  }
  getEntry(t) {
    return t < 0 || t >= this._entries.length ? null : this._entries[t];
  }
  requestPlayList() {
    G().connection.send(new tM());
  }
  get priority() {
    return Ns.PRIORITY_ROOM_PLAYLIST;
  }
  get length() {
    return this._entries ? this._entries.length : 0;
  }
  get playPosition() {
    return this._playPosition;
  }
  get currentSongId() {
    return this._currentSongId;
  }
  get isPlaying() {
    return this._isPlaying;
  }
  get entries() {
    return this._entries;
  }
}
var Un = {};
/*!
 *  howler.js v2.2.4
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */
(function(i) {
  (function() {
    var t = function() {
      this.init();
    };
    t.prototype = {
      /**
       * Initialize the global Howler object.
       * @return {Howler}
       */
      init: function() {
        var l = this || e;
        return l._counter = 1e3, l._html5AudioPool = [], l.html5PoolSize = 10, l._codecs = {}, l._howls = [], l._muted = !1, l._volume = 1, l._canPlayEvent = "canplaythrough", l._navigator = typeof window < "u" && window.navigator ? window.navigator : null, l.masterGain = null, l.noAudio = !1, l.usingWebAudio = !0, l.autoSuspend = !0, l.ctx = null, l.autoUnlock = !0, l._setup(), l;
      },
      /**
       * Get/set the global volume for all sounds.
       * @param  {Float} vol Volume from 0.0 to 1.0.
       * @return {Howler/Float}     Returns self or current volume.
       */
      volume: function(l) {
        var _ = this || e;
        if (l = parseFloat(l), _.ctx || c(), typeof l < "u" && l >= 0 && l <= 1) {
          if (_._volume = l, _._muted)
            return _;
          _.usingWebAudio && _.masterGain.gain.setValueAtTime(l, e.ctx.currentTime);
          for (var d = 0; d < _._howls.length; d++)
            if (!_._howls[d]._webAudio)
              for (var f = _._howls[d]._getSoundIds(), p = 0; p < f.length; p++) {
                var g = _._howls[d]._soundById(f[p]);
                g && g._node && (g._node.volume = g._volume * l);
              }
          return _;
        }
        return _._volume;
      },
      /**
       * Handle muting and unmuting globally.
       * @param  {Boolean} muted Is muted or not.
       */
      mute: function(l) {
        var _ = this || e;
        _.ctx || c(), _._muted = l, _.usingWebAudio && _.masterGain.gain.setValueAtTime(l ? 0 : _._volume, e.ctx.currentTime);
        for (var d = 0; d < _._howls.length; d++)
          if (!_._howls[d]._webAudio)
            for (var f = _._howls[d]._getSoundIds(), p = 0; p < f.length; p++) {
              var g = _._howls[d]._soundById(f[p]);
              g && g._node && (g._node.muted = l ? !0 : g._muted);
            }
        return _;
      },
      /**
       * Handle stopping all sounds globally.
       */
      stop: function() {
        for (var l = this || e, _ = 0; _ < l._howls.length; _++)
          l._howls[_].stop();
        return l;
      },
      /**
       * Unload and destroy all currently loaded Howl objects.
       * @return {Howler}
       */
      unload: function() {
        for (var l = this || e, _ = l._howls.length - 1; _ >= 0; _--)
          l._howls[_].unload();
        return l.usingWebAudio && l.ctx && typeof l.ctx.close < "u" && (l.ctx.close(), l.ctx = null, c()), l;
      },
      /**
       * Check for codec support of specific extension.
       * @param  {String} ext Audio file extention.
       * @return {Boolean}
       */
      codecs: function(l) {
        return (this || e)._codecs[l.replace(/^x-/, "")];
      },
      /**
       * Setup various state values for global tracking.
       * @return {Howler}
       */
      _setup: function() {
        var l = this || e;
        if (l.state = l.ctx && l.ctx.state || "suspended", l._autoSuspend(), !l.usingWebAudio)
          if (typeof Audio < "u")
            try {
              var _ = new Audio();
              typeof _.oncanplaythrough > "u" && (l._canPlayEvent = "canplay");
            } catch {
              l.noAudio = !0;
            }
          else
            l.noAudio = !0;
        try {
          var _ = new Audio();
          _.muted && (l.noAudio = !0);
        } catch {
        }
        return l.noAudio || l._setupCodecs(), l;
      },
      /**
       * Check for browser support for various codecs and cache the results.
       * @return {Howler}
       */
      _setupCodecs: function() {
        var l = this || e, _ = null;
        try {
          _ = typeof Audio < "u" ? new Audio() : null;
        } catch {
          return l;
        }
        if (!_ || typeof _.canPlayType != "function")
          return l;
        var d = _.canPlayType("audio/mpeg;").replace(/^no$/, ""), f = l._navigator ? l._navigator.userAgent : "", p = f.match(/OPR\/(\d+)/g), g = p && parseInt(p[0].split("/")[1], 10) < 33, m = f.indexOf("Safari") !== -1 && f.indexOf("Chrome") === -1, O = f.match(/Version\/(.*?) /), y = m && O && parseInt(O[1], 10) < 15;
        return l._codecs = {
          mp3: !!(!g && (d || _.canPlayType("audio/mp3;").replace(/^no$/, ""))),
          mpeg: !!d,
          opus: !!_.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
          ogg: !!_.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
          oga: !!_.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
          wav: !!(_.canPlayType('audio/wav; codecs="1"') || _.canPlayType("audio/wav")).replace(/^no$/, ""),
          aac: !!_.canPlayType("audio/aac;").replace(/^no$/, ""),
          caf: !!_.canPlayType("audio/x-caf;").replace(/^no$/, ""),
          m4a: !!(_.canPlayType("audio/x-m4a;") || _.canPlayType("audio/m4a;") || _.canPlayType("audio/aac;")).replace(/^no$/, ""),
          m4b: !!(_.canPlayType("audio/x-m4b;") || _.canPlayType("audio/m4b;") || _.canPlayType("audio/aac;")).replace(/^no$/, ""),
          mp4: !!(_.canPlayType("audio/x-mp4;") || _.canPlayType("audio/mp4;") || _.canPlayType("audio/aac;")).replace(/^no$/, ""),
          weba: !!(!y && _.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
          webm: !!(!y && _.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
          dolby: !!_.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
          flac: !!(_.canPlayType("audio/x-flac;") || _.canPlayType("audio/flac;")).replace(/^no$/, "")
        }, l;
      },
      /**
       * Some browsers/devices will only allow audio to be played after a user interaction.
       * Attempt to automatically unlock audio on the first user interaction.
       * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
       * @return {Howler}
       */
      _unlockAudio: function() {
        var l = this || e;
        if (!(l._audioUnlocked || !l.ctx)) {
          l._audioUnlocked = !1, l.autoUnlock = !1, !l._mobileUnloaded && l.ctx.sampleRate !== 44100 && (l._mobileUnloaded = !0, l.unload()), l._scratchBuffer = l.ctx.createBuffer(1, 1, 22050);
          var _ = function(d) {
            for (; l._html5AudioPool.length < l.html5PoolSize; )
              try {
                var f = new Audio();
                f._unlocked = !0, l._releaseHtml5Audio(f);
              } catch {
                l.noAudio = !0;
                break;
              }
            for (var p = 0; p < l._howls.length; p++)
              if (!l._howls[p]._webAudio)
                for (var g = l._howls[p]._getSoundIds(), m = 0; m < g.length; m++) {
                  var O = l._howls[p]._soundById(g[m]);
                  O && O._node && !O._node._unlocked && (O._node._unlocked = !0, O._node.load());
                }
            l._autoResume();
            var y = l.ctx.createBufferSource();
            y.buffer = l._scratchBuffer, y.connect(l.ctx.destination), typeof y.start > "u" ? y.noteOn(0) : y.start(0), typeof l.ctx.resume == "function" && l.ctx.resume(), y.onended = function() {
              y.disconnect(0), l._audioUnlocked = !0, document.removeEventListener("touchstart", _, !0), document.removeEventListener("touchend", _, !0), document.removeEventListener("click", _, !0), document.removeEventListener("keydown", _, !0);
              for (var C = 0; C < l._howls.length; C++)
                l._howls[C]._emit("unlock");
            };
          };
          return document.addEventListener("touchstart", _, !0), document.addEventListener("touchend", _, !0), document.addEventListener("click", _, !0), document.addEventListener("keydown", _, !0), l;
        }
      },
      /**
       * Get an unlocked HTML5 Audio object from the pool. If none are left,
       * return a new Audio object and throw a warning.
       * @return {Audio} HTML5 Audio object.
       */
      _obtainHtml5Audio: function() {
        var l = this || e;
        if (l._html5AudioPool.length)
          return l._html5AudioPool.pop();
        var _ = new Audio().play();
        return _ && typeof Promise < "u" && (_ instanceof Promise || typeof _.then == "function") && _.catch(function() {
          console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
        }), new Audio();
      },
      /**
       * Return an activated HTML5 Audio object to the pool.
       * @return {Howler}
       */
      _releaseHtml5Audio: function(l) {
        var _ = this || e;
        return l._unlocked && _._html5AudioPool.push(l), _;
      },
      /**
       * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
       * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
       * @return {Howler}
       */
      _autoSuspend: function() {
        var l = this;
        if (!(!l.autoSuspend || !l.ctx || typeof l.ctx.suspend > "u" || !e.usingWebAudio)) {
          for (var _ = 0; _ < l._howls.length; _++)
            if (l._howls[_]._webAudio) {
              for (var d = 0; d < l._howls[_]._sounds.length; d++)
                if (!l._howls[_]._sounds[d]._paused)
                  return l;
            }
          return l._suspendTimer && clearTimeout(l._suspendTimer), l._suspendTimer = setTimeout(function() {
            if (l.autoSuspend) {
              l._suspendTimer = null, l.state = "suspending";
              var f = function() {
                l.state = "suspended", l._resumeAfterSuspend && (delete l._resumeAfterSuspend, l._autoResume());
              };
              l.ctx.suspend().then(f, f);
            }
          }, 3e4), l;
        }
      },
      /**
       * Automatically resume the Web Audio AudioContext when a new sound is played.
       * @return {Howler}
       */
      _autoResume: function() {
        var l = this;
        if (!(!l.ctx || typeof l.ctx.resume > "u" || !e.usingWebAudio))
          return l.state === "running" && l.ctx.state !== "interrupted" && l._suspendTimer ? (clearTimeout(l._suspendTimer), l._suspendTimer = null) : l.state === "suspended" || l.state === "running" && l.ctx.state === "interrupted" ? (l.ctx.resume().then(function() {
            l.state = "running";
            for (var _ = 0; _ < l._howls.length; _++)
              l._howls[_]._emit("resume");
          }), l._suspendTimer && (clearTimeout(l._suspendTimer), l._suspendTimer = null)) : l.state === "suspending" && (l._resumeAfterSuspend = !0), l;
      }
    };
    var e = new t(), s = function(l) {
      var _ = this;
      if (!l.src || l.src.length === 0) {
        console.error("An array of source files must be passed with any new Howl.");
        return;
      }
      _.init(l);
    };
    s.prototype = {
      /**
       * Initialize a new Howl group object.
       * @param  {Object} o Passed in properties for this group.
       * @return {Howl}
       */
      init: function(l) {
        var _ = this;
        return e.ctx || c(), _._autoplay = l.autoplay || !1, _._format = typeof l.format != "string" ? l.format : [l.format], _._html5 = l.html5 || !1, _._muted = l.mute || !1, _._loop = l.loop || !1, _._pool = l.pool || 5, _._preload = typeof l.preload == "boolean" || l.preload === "metadata" ? l.preload : !0, _._rate = l.rate || 1, _._sprite = l.sprite || {}, _._src = typeof l.src != "string" ? l.src : [l.src], _._volume = l.volume !== void 0 ? l.volume : 1, _._xhr = {
          method: l.xhr && l.xhr.method ? l.xhr.method : "GET",
          headers: l.xhr && l.xhr.headers ? l.xhr.headers : null,
          withCredentials: l.xhr && l.xhr.withCredentials ? l.xhr.withCredentials : !1
        }, _._duration = 0, _._state = "unloaded", _._sounds = [], _._endTimers = {}, _._queue = [], _._playLock = !1, _._onend = l.onend ? [{ fn: l.onend }] : [], _._onfade = l.onfade ? [{ fn: l.onfade }] : [], _._onload = l.onload ? [{ fn: l.onload }] : [], _._onloaderror = l.onloaderror ? [{ fn: l.onloaderror }] : [], _._onplayerror = l.onplayerror ? [{ fn: l.onplayerror }] : [], _._onpause = l.onpause ? [{ fn: l.onpause }] : [], _._onplay = l.onplay ? [{ fn: l.onplay }] : [], _._onstop = l.onstop ? [{ fn: l.onstop }] : [], _._onmute = l.onmute ? [{ fn: l.onmute }] : [], _._onvolume = l.onvolume ? [{ fn: l.onvolume }] : [], _._onrate = l.onrate ? [{ fn: l.onrate }] : [], _._onseek = l.onseek ? [{ fn: l.onseek }] : [], _._onunlock = l.onunlock ? [{ fn: l.onunlock }] : [], _._onresume = [], _._webAudio = e.usingWebAudio && !_._html5, typeof e.ctx < "u" && e.ctx && e.autoUnlock && e._unlockAudio(), e._howls.push(_), _._autoplay && _._queue.push({
          event: "play",
          action: function() {
            _.play();
          }
        }), _._preload && _._preload !== "none" && _.load(), _;
      },
      /**
       * Load the audio file.
       * @return {Howler}
       */
      load: function() {
        var l = this, _ = null;
        if (e.noAudio) {
          l._emit("loaderror", null, "No audio support.");
          return;
        }
        typeof l._src == "string" && (l._src = [l._src]);
        for (var d = 0; d < l._src.length; d++) {
          var f, p;
          if (l._format && l._format[d])
            f = l._format[d];
          else {
            if (p = l._src[d], typeof p != "string") {
              l._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
              continue;
            }
            f = /^data:audio\/([^;,]+);/i.exec(p), f || (f = /\.([^.]+)$/.exec(p.split("?", 1)[0])), f && (f = f[1].toLowerCase());
          }
          if (f || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), f && e.codecs(f)) {
            _ = l._src[d];
            break;
          }
        }
        if (!_) {
          l._emit("loaderror", null, "No codec support for selected audio sources.");
          return;
        }
        return l._src = _, l._state = "loading", window.location.protocol === "https:" && _.slice(0, 5) === "http:" && (l._html5 = !0, l._webAudio = !1), new r(l), l._webAudio && a(l), l;
      },
      /**
       * Play a sound or resume previous playback.
       * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
       * @param  {Boolean} internal Internal Use: true prevents event firing.
       * @return {Number}          Sound ID.
       */
      play: function(l, _) {
        var d = this, f = null;
        if (typeof l == "number")
          f = l, l = null;
        else {
          if (typeof l == "string" && d._state === "loaded" && !d._sprite[l])
            return null;
          if (typeof l > "u" && (l = "__default", !d._playLock)) {
            for (var p = 0, g = 0; g < d._sounds.length; g++)
              d._sounds[g]._paused && !d._sounds[g]._ended && (p++, f = d._sounds[g]._id);
            p === 1 ? l = null : f = null;
          }
        }
        var m = f ? d._soundById(f) : d._inactiveSound();
        if (!m)
          return null;
        if (f && !l && (l = m._sprite || "__default"), d._state !== "loaded") {
          m._sprite = l, m._ended = !1;
          var O = m._id;
          return d._queue.push({
            event: "play",
            action: function() {
              d.play(O);
            }
          }), O;
        }
        if (f && !m._paused)
          return _ || d._loadQueue("play"), m._id;
        d._webAudio && e._autoResume();
        var y = Math.max(0, m._seek > 0 ? m._seek : d._sprite[l][0] / 1e3), C = Math.max(0, (d._sprite[l][0] + d._sprite[l][1]) / 1e3 - y), b = C * 1e3 / Math.abs(m._rate), D = d._sprite[l][0] / 1e3, P = (d._sprite[l][0] + d._sprite[l][1]) / 1e3;
        m._sprite = l, m._ended = !1;
        var F = function() {
          m._paused = !1, m._seek = y, m._start = D, m._stop = P, m._loop = !!(m._loop || d._sprite[l][2]);
        };
        if (y >= P) {
          d._ended(m);
          return;
        }
        var M = m._node;
        if (d._webAudio) {
          var U = function() {
            d._playLock = !1, F(), d._refreshBuffer(m);
            var Y = m._muted || d._muted ? 0 : m._volume;
            M.gain.setValueAtTime(Y, e.ctx.currentTime), m._playStart = e.ctx.currentTime, typeof M.bufferSource.start > "u" ? m._loop ? M.bufferSource.noteGrainOn(0, y, 86400) : M.bufferSource.noteGrainOn(0, y, C) : m._loop ? M.bufferSource.start(0, y, 86400) : M.bufferSource.start(0, y, C), b !== 1 / 0 && (d._endTimers[m._id] = setTimeout(d._ended.bind(d, m), b)), _ || setTimeout(function() {
              d._emit("play", m._id), d._loadQueue();
            }, 0);
          };
          e.state === "running" && e.ctx.state !== "interrupted" ? U() : (d._playLock = !0, d.once("resume", U), d._clearTimer(m._id));
        } else {
          var k = function() {
            M.currentTime = y, M.muted = m._muted || d._muted || e._muted || M.muted, M.volume = m._volume * e.volume(), M.playbackRate = m._rate;
            try {
              var Y = M.play();
              if (Y && typeof Promise < "u" && (Y instanceof Promise || typeof Y.then == "function") ? (d._playLock = !0, F(), Y.then(function() {
                d._playLock = !1, M._unlocked = !0, _ ? d._loadQueue() : d._emit("play", m._id);
              }).catch(function() {
                d._playLock = !1, d._emit("playerror", m._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), m._ended = !0, m._paused = !0;
              })) : _ || (d._playLock = !1, F(), d._emit("play", m._id)), M.playbackRate = m._rate, M.paused) {
                d._emit("playerror", m._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                return;
              }
              l !== "__default" || m._loop ? d._endTimers[m._id] = setTimeout(d._ended.bind(d, m), b) : (d._endTimers[m._id] = function() {
                d._ended(m), M.removeEventListener("ended", d._endTimers[m._id], !1);
              }, M.addEventListener("ended", d._endTimers[m._id], !1));
            } catch (ut) {
              d._emit("playerror", m._id, ut);
            }
          };
          M.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" && (M.src = d._src, M.load());
          var ft = window && window.ejecta || !M.readyState && e._navigator.isCocoonJS;
          if (M.readyState >= 3 || ft)
            k();
          else {
            d._playLock = !0, d._state = "loading";
            var K = function() {
              d._state = "loaded", k(), M.removeEventListener(e._canPlayEvent, K, !1);
            };
            M.addEventListener(e._canPlayEvent, K, !1), d._clearTimer(m._id);
          }
        }
        return m._id;
      },
      /**
       * Pause playback and save current position.
       * @param  {Number} id The sound ID (empty to pause all in group).
       * @return {Howl}
       */
      pause: function(l) {
        var _ = this;
        if (_._state !== "loaded" || _._playLock)
          return _._queue.push({
            event: "pause",
            action: function() {
              _.pause(l);
            }
          }), _;
        for (var d = _._getSoundIds(l), f = 0; f < d.length; f++) {
          _._clearTimer(d[f]);
          var p = _._soundById(d[f]);
          if (p && !p._paused && (p._seek = _.seek(d[f]), p._rateSeek = 0, p._paused = !0, _._stopFade(d[f]), p._node))
            if (_._webAudio) {
              if (!p._node.bufferSource)
                continue;
              typeof p._node.bufferSource.stop > "u" ? p._node.bufferSource.noteOff(0) : p._node.bufferSource.stop(0), _._cleanBuffer(p._node);
            } else (!isNaN(p._node.duration) || p._node.duration === 1 / 0) && p._node.pause();
          arguments[1] || _._emit("pause", p ? p._id : null);
        }
        return _;
      },
      /**
       * Stop playback and reset to start.
       * @param  {Number} id The sound ID (empty to stop all in group).
       * @param  {Boolean} internal Internal Use: true prevents event firing.
       * @return {Howl}
       */
      stop: function(l, _) {
        var d = this;
        if (d._state !== "loaded" || d._playLock)
          return d._queue.push({
            event: "stop",
            action: function() {
              d.stop(l);
            }
          }), d;
        for (var f = d._getSoundIds(l), p = 0; p < f.length; p++) {
          d._clearTimer(f[p]);
          var g = d._soundById(f[p]);
          g && (g._seek = g._start || 0, g._rateSeek = 0, g._paused = !0, g._ended = !0, d._stopFade(f[p]), g._node && (d._webAudio ? g._node.bufferSource && (typeof g._node.bufferSource.stop > "u" ? g._node.bufferSource.noteOff(0) : g._node.bufferSource.stop(0), d._cleanBuffer(g._node)) : (!isNaN(g._node.duration) || g._node.duration === 1 / 0) && (g._node.currentTime = g._start || 0, g._node.pause(), g._node.duration === 1 / 0 && d._clearSound(g._node))), _ || d._emit("stop", g._id));
        }
        return d;
      },
      /**
       * Mute/unmute a single sound or all sounds in this Howl group.
       * @param  {Boolean} muted Set to true to mute and false to unmute.
       * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
       * @return {Howl}
       */
      mute: function(l, _) {
        var d = this;
        if (d._state !== "loaded" || d._playLock)
          return d._queue.push({
            event: "mute",
            action: function() {
              d.mute(l, _);
            }
          }), d;
        if (typeof _ > "u")
          if (typeof l == "boolean")
            d._muted = l;
          else
            return d._muted;
        for (var f = d._getSoundIds(_), p = 0; p < f.length; p++) {
          var g = d._soundById(f[p]);
          g && (g._muted = l, g._interval && d._stopFade(g._id), d._webAudio && g._node ? g._node.gain.setValueAtTime(l ? 0 : g._volume, e.ctx.currentTime) : g._node && (g._node.muted = e._muted ? !0 : l), d._emit("mute", g._id));
        }
        return d;
      },
      /**
       * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
       *   volume() -> Returns the group's volume value.
       *   volume(id) -> Returns the sound id's current volume.
       *   volume(vol) -> Sets the volume of all sounds in this Howl group.
       *   volume(vol, id) -> Sets the volume of passed sound id.
       * @return {Howl/Number} Returns self or current volume.
       */
      volume: function() {
        var l = this, _ = arguments, d, f;
        if (_.length === 0)
          return l._volume;
        if (_.length === 1 || _.length === 2 && typeof _[1] > "u") {
          var p = l._getSoundIds(), g = p.indexOf(_[0]);
          g >= 0 ? f = parseInt(_[0], 10) : d = parseFloat(_[0]);
        } else _.length >= 2 && (d = parseFloat(_[0]), f = parseInt(_[1], 10));
        var m;
        if (typeof d < "u" && d >= 0 && d <= 1) {
          if (l._state !== "loaded" || l._playLock)
            return l._queue.push({
              event: "volume",
              action: function() {
                l.volume.apply(l, _);
              }
            }), l;
          typeof f > "u" && (l._volume = d), f = l._getSoundIds(f);
          for (var O = 0; O < f.length; O++)
            m = l._soundById(f[O]), m && (m._volume = d, _[2] || l._stopFade(f[O]), l._webAudio && m._node && !m._muted ? m._node.gain.setValueAtTime(d, e.ctx.currentTime) : m._node && !m._muted && (m._node.volume = d * e.volume()), l._emit("volume", m._id));
        } else
          return m = f ? l._soundById(f) : l._sounds[0], m ? m._volume : 0;
        return l;
      },
      /**
       * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
       * @param  {Number} from The value to fade from (0.0 to 1.0).
       * @param  {Number} to   The volume to fade to (0.0 to 1.0).
       * @param  {Number} len  Time in milliseconds to fade.
       * @param  {Number} id   The sound id (omit to fade all sounds).
       * @return {Howl}
       */
      fade: function(l, _, d, f) {
        var p = this;
        if (p._state !== "loaded" || p._playLock)
          return p._queue.push({
            event: "fade",
            action: function() {
              p.fade(l, _, d, f);
            }
          }), p;
        l = Math.min(Math.max(0, parseFloat(l)), 1), _ = Math.min(Math.max(0, parseFloat(_)), 1), d = parseFloat(d), p.volume(l, f);
        for (var g = p._getSoundIds(f), m = 0; m < g.length; m++) {
          var O = p._soundById(g[m]);
          if (O) {
            if (f || p._stopFade(g[m]), p._webAudio && !O._muted) {
              var y = e.ctx.currentTime, C = y + d / 1e3;
              O._volume = l, O._node.gain.setValueAtTime(l, y), O._node.gain.linearRampToValueAtTime(_, C);
            }
            p._startFadeInterval(O, l, _, d, g[m], typeof f > "u");
          }
        }
        return p;
      },
      /**
       * Starts the internal interval to fade a sound.
       * @param  {Object} sound Reference to sound to fade.
       * @param  {Number} from The value to fade from (0.0 to 1.0).
       * @param  {Number} to   The volume to fade to (0.0 to 1.0).
       * @param  {Number} len  Time in milliseconds to fade.
       * @param  {Number} id   The sound id to fade.
       * @param  {Boolean} isGroup   If true, set the volume on the group.
       */
      _startFadeInterval: function(l, _, d, f, p, g) {
        var m = this, O = _, y = d - _, C = Math.abs(y / 0.01), b = Math.max(4, C > 0 ? f / C : f), D = Date.now();
        l._fadeTo = d, l._interval = setInterval(function() {
          var P = (Date.now() - D) / f;
          D = Date.now(), O += y * P, O = Math.round(O * 100) / 100, y < 0 ? O = Math.max(d, O) : O = Math.min(d, O), m._webAudio ? l._volume = O : m.volume(O, l._id, !0), g && (m._volume = O), (d < _ && O <= d || d > _ && O >= d) && (clearInterval(l._interval), l._interval = null, l._fadeTo = null, m.volume(d, l._id), m._emit("fade", l._id));
        }, b);
      },
      /**
       * Internal method that stops the currently playing fade when
       * a new fade starts, volume is changed or the sound is stopped.
       * @param  {Number} id The sound id.
       * @return {Howl}
       */
      _stopFade: function(l) {
        var _ = this, d = _._soundById(l);
        return d && d._interval && (_._webAudio && d._node.gain.cancelScheduledValues(e.ctx.currentTime), clearInterval(d._interval), d._interval = null, _.volume(d._fadeTo, l), d._fadeTo = null, _._emit("fade", l)), _;
      },
      /**
       * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
       *   loop() -> Returns the group's loop value.
       *   loop(id) -> Returns the sound id's loop value.
       *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
       *   loop(loop, id) -> Sets the loop value of passed sound id.
       * @return {Howl/Boolean} Returns self or current loop value.
       */
      loop: function() {
        var l = this, _ = arguments, d, f, p;
        if (_.length === 0)
          return l._loop;
        if (_.length === 1)
          if (typeof _[0] == "boolean")
            d = _[0], l._loop = d;
          else
            return p = l._soundById(parseInt(_[0], 10)), p ? p._loop : !1;
        else _.length === 2 && (d = _[0], f = parseInt(_[1], 10));
        for (var g = l._getSoundIds(f), m = 0; m < g.length; m++)
          p = l._soundById(g[m]), p && (p._loop = d, l._webAudio && p._node && p._node.bufferSource && (p._node.bufferSource.loop = d, d && (p._node.bufferSource.loopStart = p._start || 0, p._node.bufferSource.loopEnd = p._stop, l.playing(g[m]) && (l.pause(g[m], !0), l.play(g[m], !0)))));
        return l;
      },
      /**
       * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
       *   rate() -> Returns the first sound node's current playback rate.
       *   rate(id) -> Returns the sound id's current playback rate.
       *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
       *   rate(rate, id) -> Sets the playback rate of passed sound id.
       * @return {Howl/Number} Returns self or the current playback rate.
       */
      rate: function() {
        var l = this, _ = arguments, d, f;
        if (_.length === 0)
          f = l._sounds[0]._id;
        else if (_.length === 1) {
          var p = l._getSoundIds(), g = p.indexOf(_[0]);
          g >= 0 ? f = parseInt(_[0], 10) : d = parseFloat(_[0]);
        } else _.length === 2 && (d = parseFloat(_[0]), f = parseInt(_[1], 10));
        var m;
        if (typeof d == "number") {
          if (l._state !== "loaded" || l._playLock)
            return l._queue.push({
              event: "rate",
              action: function() {
                l.rate.apply(l, _);
              }
            }), l;
          typeof f > "u" && (l._rate = d), f = l._getSoundIds(f);
          for (var O = 0; O < f.length; O++)
            if (m = l._soundById(f[O]), m) {
              l.playing(f[O]) && (m._rateSeek = l.seek(f[O]), m._playStart = l._webAudio ? e.ctx.currentTime : m._playStart), m._rate = d, l._webAudio && m._node && m._node.bufferSource ? m._node.bufferSource.playbackRate.setValueAtTime(d, e.ctx.currentTime) : m._node && (m._node.playbackRate = d);
              var y = l.seek(f[O]), C = (l._sprite[m._sprite][0] + l._sprite[m._sprite][1]) / 1e3 - y, b = C * 1e3 / Math.abs(m._rate);
              (l._endTimers[f[O]] || !m._paused) && (l._clearTimer(f[O]), l._endTimers[f[O]] = setTimeout(l._ended.bind(l, m), b)), l._emit("rate", m._id);
            }
        } else
          return m = l._soundById(f), m ? m._rate : l._rate;
        return l;
      },
      /**
       * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
       *   seek() -> Returns the first sound node's current seek position.
       *   seek(id) -> Returns the sound id's current seek position.
       *   seek(seek) -> Sets the seek position of the first sound node.
       *   seek(seek, id) -> Sets the seek position of passed sound id.
       * @return {Howl/Number} Returns self or the current seek position.
       */
      seek: function() {
        var l = this, _ = arguments, d, f;
        if (_.length === 0)
          l._sounds.length && (f = l._sounds[0]._id);
        else if (_.length === 1) {
          var p = l._getSoundIds(), g = p.indexOf(_[0]);
          g >= 0 ? f = parseInt(_[0], 10) : l._sounds.length && (f = l._sounds[0]._id, d = parseFloat(_[0]));
        } else _.length === 2 && (d = parseFloat(_[0]), f = parseInt(_[1], 10));
        if (typeof f > "u")
          return 0;
        if (typeof d == "number" && (l._state !== "loaded" || l._playLock))
          return l._queue.push({
            event: "seek",
            action: function() {
              l.seek.apply(l, _);
            }
          }), l;
        var m = l._soundById(f);
        if (m)
          if (typeof d == "number" && d >= 0) {
            var O = l.playing(f);
            O && l.pause(f, !0), m._seek = d, m._ended = !1, l._clearTimer(f), !l._webAudio && m._node && !isNaN(m._node.duration) && (m._node.currentTime = d);
            var y = function() {
              O && l.play(f, !0), l._emit("seek", f);
            };
            if (O && !l._webAudio) {
              var C = function() {
                l._playLock ? setTimeout(C, 0) : y();
              };
              setTimeout(C, 0);
            } else
              y();
          } else if (l._webAudio) {
            var b = l.playing(f) ? e.ctx.currentTime - m._playStart : 0, D = m._rateSeek ? m._rateSeek - m._seek : 0;
            return m._seek + (D + b * Math.abs(m._rate));
          } else
            return m._node.currentTime;
        return l;
      },
      /**
       * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
       * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
       * @return {Boolean} True if playing and false if not.
       */
      playing: function(l) {
        var _ = this;
        if (typeof l == "number") {
          var d = _._soundById(l);
          return d ? !d._paused : !1;
        }
        for (var f = 0; f < _._sounds.length; f++)
          if (!_._sounds[f]._paused)
            return !0;
        return !1;
      },
      /**
       * Get the duration of this sound. Passing a sound id will return the sprite duration.
       * @param  {Number} id The sound id to check. If none is passed, return full source duration.
       * @return {Number} Audio duration in seconds.
       */
      duration: function(l) {
        var _ = this, d = _._duration, f = _._soundById(l);
        return f && (d = _._sprite[f._sprite][1] / 1e3), d;
      },
      /**
       * Returns the current loaded state of this Howl.
       * @return {String} 'unloaded', 'loading', 'loaded'
       */
      state: function() {
        return this._state;
      },
      /**
       * Unload and destroy the current Howl object.
       * This will immediately stop all sound instances attached to this group.
       */
      unload: function() {
        for (var l = this, _ = l._sounds, d = 0; d < _.length; d++)
          _[d]._paused || l.stop(_[d]._id), l._webAudio || (l._clearSound(_[d]._node), _[d]._node.removeEventListener("error", _[d]._errorFn, !1), _[d]._node.removeEventListener(e._canPlayEvent, _[d]._loadFn, !1), _[d]._node.removeEventListener("ended", _[d]._endFn, !1), e._releaseHtml5Audio(_[d]._node)), delete _[d]._node, l._clearTimer(_[d]._id);
        var f = e._howls.indexOf(l);
        f >= 0 && e._howls.splice(f, 1);
        var p = !0;
        for (d = 0; d < e._howls.length; d++)
          if (e._howls[d]._src === l._src || l._src.indexOf(e._howls[d]._src) >= 0) {
            p = !1;
            break;
          }
        return n && p && delete n[l._src], e.noAudio = !1, l._state = "unloaded", l._sounds = [], l = null, null;
      },
      /**
       * Listen to a custom event.
       * @param  {String}   event Event name.
       * @param  {Function} fn    Listener to call.
       * @param  {Number}   id    (optional) Only listen to events for this sound.
       * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
       * @return {Howl}
       */
      on: function(l, _, d, f) {
        var p = this, g = p["_on" + l];
        return typeof _ == "function" && g.push(f ? { id: d, fn: _, once: f } : { id: d, fn: _ }), p;
      },
      /**
       * Remove a custom event. Call without parameters to remove all events.
       * @param  {String}   event Event name.
       * @param  {Function} fn    Listener to remove. Leave empty to remove all.
       * @param  {Number}   id    (optional) Only remove events for this sound.
       * @return {Howl}
       */
      off: function(l, _, d) {
        var f = this, p = f["_on" + l], g = 0;
        if (typeof _ == "number" && (d = _, _ = null), _ || d)
          for (g = 0; g < p.length; g++) {
            var m = d === p[g].id;
            if (_ === p[g].fn && m || !_ && m) {
              p.splice(g, 1);
              break;
            }
          }
        else if (l)
          f["_on" + l] = [];
        else {
          var O = Object.keys(f);
          for (g = 0; g < O.length; g++)
            O[g].indexOf("_on") === 0 && Array.isArray(f[O[g]]) && (f[O[g]] = []);
        }
        return f;
      },
      /**
       * Listen to a custom event and remove it once fired.
       * @param  {String}   event Event name.
       * @param  {Function} fn    Listener to call.
       * @param  {Number}   id    (optional) Only listen to events for this sound.
       * @return {Howl}
       */
      once: function(l, _, d) {
        var f = this;
        return f.on(l, _, d, 1), f;
      },
      /**
       * Emit all events of a specific type and pass the sound id.
       * @param  {String} event Event name.
       * @param  {Number} id    Sound ID.
       * @param  {Number} msg   Message to go with event.
       * @return {Howl}
       */
      _emit: function(l, _, d) {
        for (var f = this, p = f["_on" + l], g = p.length - 1; g >= 0; g--)
          (!p[g].id || p[g].id === _ || l === "load") && (setTimeout((function(m) {
            m.call(this, _, d);
          }).bind(f, p[g].fn), 0), p[g].once && f.off(l, p[g].fn, p[g].id));
        return f._loadQueue(l), f;
      },
      /**
       * Queue of actions initiated before the sound has loaded.
       * These will be called in sequence, with the next only firing
       * after the previous has finished executing (even if async like play).
       * @return {Howl}
       */
      _loadQueue: function(l) {
        var _ = this;
        if (_._queue.length > 0) {
          var d = _._queue[0];
          d.event === l && (_._queue.shift(), _._loadQueue()), l || d.action();
        }
        return _;
      },
      /**
       * Fired when playback ends at the end of the duration.
       * @param  {Sound} sound The sound object to work with.
       * @return {Howl}
       */
      _ended: function(l) {
        var _ = this, d = l._sprite;
        if (!_._webAudio && l._node && !l._node.paused && !l._node.ended && l._node.currentTime < l._stop)
          return setTimeout(_._ended.bind(_, l), 100), _;
        var f = !!(l._loop || _._sprite[d][2]);
        if (_._emit("end", l._id), !_._webAudio && f && _.stop(l._id, !0).play(l._id), _._webAudio && f) {
          _._emit("play", l._id), l._seek = l._start || 0, l._rateSeek = 0, l._playStart = e.ctx.currentTime;
          var p = (l._stop - l._start) * 1e3 / Math.abs(l._rate);
          _._endTimers[l._id] = setTimeout(_._ended.bind(_, l), p);
        }
        return _._webAudio && !f && (l._paused = !0, l._ended = !0, l._seek = l._start || 0, l._rateSeek = 0, _._clearTimer(l._id), _._cleanBuffer(l._node), e._autoSuspend()), !_._webAudio && !f && _.stop(l._id, !0), _;
      },
      /**
       * Clear the end timer for a sound playback.
       * @param  {Number} id The sound ID.
       * @return {Howl}
       */
      _clearTimer: function(l) {
        var _ = this;
        if (_._endTimers[l]) {
          if (typeof _._endTimers[l] != "function")
            clearTimeout(_._endTimers[l]);
          else {
            var d = _._soundById(l);
            d && d._node && d._node.removeEventListener("ended", _._endTimers[l], !1);
          }
          delete _._endTimers[l];
        }
        return _;
      },
      /**
       * Return the sound identified by this ID, or return null.
       * @param  {Number} id Sound ID
       * @return {Object}    Sound object or null.
       */
      _soundById: function(l) {
        for (var _ = this, d = 0; d < _._sounds.length; d++)
          if (l === _._sounds[d]._id)
            return _._sounds[d];
        return null;
      },
      /**
       * Return an inactive sound from the pool or create a new one.
       * @return {Sound} Sound playback object.
       */
      _inactiveSound: function() {
        var l = this;
        l._drain();
        for (var _ = 0; _ < l._sounds.length; _++)
          if (l._sounds[_]._ended)
            return l._sounds[_].reset();
        return new r(l);
      },
      /**
       * Drain excess inactive sounds from the pool.
       */
      _drain: function() {
        var l = this, _ = l._pool, d = 0, f = 0;
        if (!(l._sounds.length < _)) {
          for (f = 0; f < l._sounds.length; f++)
            l._sounds[f]._ended && d++;
          for (f = l._sounds.length - 1; f >= 0; f--) {
            if (d <= _)
              return;
            l._sounds[f]._ended && (l._webAudio && l._sounds[f]._node && l._sounds[f]._node.disconnect(0), l._sounds.splice(f, 1), d--);
          }
        }
      },
      /**
       * Get all ID's from the sounds pool.
       * @param  {Number} id Only return one ID if one is passed.
       * @return {Array}    Array of IDs.
       */
      _getSoundIds: function(l) {
        var _ = this;
        if (typeof l > "u") {
          for (var d = [], f = 0; f < _._sounds.length; f++)
            d.push(_._sounds[f]._id);
          return d;
        } else
          return [l];
      },
      /**
       * Load the sound back into the buffer source.
       * @param  {Sound} sound The sound object to work with.
       * @return {Howl}
       */
      _refreshBuffer: function(l) {
        var _ = this;
        return l._node.bufferSource = e.ctx.createBufferSource(), l._node.bufferSource.buffer = n[_._src], l._panner ? l._node.bufferSource.connect(l._panner) : l._node.bufferSource.connect(l._node), l._node.bufferSource.loop = l._loop, l._loop && (l._node.bufferSource.loopStart = l._start || 0, l._node.bufferSource.loopEnd = l._stop || 0), l._node.bufferSource.playbackRate.setValueAtTime(l._rate, e.ctx.currentTime), _;
      },
      /**
       * Prevent memory leaks by cleaning up the buffer source after playback.
       * @param  {Object} node Sound's audio node containing the buffer source.
       * @return {Howl}
       */
      _cleanBuffer: function(l) {
        var _ = this, d = e._navigator && e._navigator.vendor.indexOf("Apple") >= 0;
        if (!l.bufferSource)
          return _;
        if (e._scratchBuffer && l.bufferSource && (l.bufferSource.onended = null, l.bufferSource.disconnect(0), d))
          try {
            l.bufferSource.buffer = e._scratchBuffer;
          } catch {
          }
        return l.bufferSource = null, _;
      },
      /**
       * Set the source to a 0-second silence to stop any downloading (except in IE).
       * @param  {Object} node Audio node to clear.
       */
      _clearSound: function(l) {
        var _ = /MSIE |Trident\//.test(e._navigator && e._navigator.userAgent);
        _ || (l.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
      }
    };
    var r = function(l) {
      this._parent = l, this.init();
    };
    r.prototype = {
      /**
       * Initialize a new Sound object.
       * @return {Sound}
       */
      init: function() {
        var l = this, _ = l._parent;
        return l._muted = _._muted, l._loop = _._loop, l._volume = _._volume, l._rate = _._rate, l._seek = 0, l._paused = !0, l._ended = !0, l._sprite = "__default", l._id = ++e._counter, _._sounds.push(l), l.create(), l;
      },
      /**
       * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
       * @return {Sound}
       */
      create: function() {
        var l = this, _ = l._parent, d = e._muted || l._muted || l._parent._muted ? 0 : l._volume;
        return _._webAudio ? (l._node = typeof e.ctx.createGain > "u" ? e.ctx.createGainNode() : e.ctx.createGain(), l._node.gain.setValueAtTime(d, e.ctx.currentTime), l._node.paused = !0, l._node.connect(e.masterGain)) : e.noAudio || (l._node = e._obtainHtml5Audio(), l._errorFn = l._errorListener.bind(l), l._node.addEventListener("error", l._errorFn, !1), l._loadFn = l._loadListener.bind(l), l._node.addEventListener(e._canPlayEvent, l._loadFn, !1), l._endFn = l._endListener.bind(l), l._node.addEventListener("ended", l._endFn, !1), l._node.src = _._src, l._node.preload = _._preload === !0 ? "auto" : _._preload, l._node.volume = d * e.volume(), l._node.load()), l;
      },
      /**
       * Reset the parameters of this sound to the original state (for recycle).
       * @return {Sound}
       */
      reset: function() {
        var l = this, _ = l._parent;
        return l._muted = _._muted, l._loop = _._loop, l._volume = _._volume, l._rate = _._rate, l._seek = 0, l._rateSeek = 0, l._paused = !0, l._ended = !0, l._sprite = "__default", l._id = ++e._counter, l;
      },
      /**
       * HTML5 Audio error listener callback.
       */
      _errorListener: function() {
        var l = this;
        l._parent._emit("loaderror", l._id, l._node.error ? l._node.error.code : 0), l._node.removeEventListener("error", l._errorFn, !1);
      },
      /**
       * HTML5 Audio canplaythrough listener callback.
       */
      _loadListener: function() {
        var l = this, _ = l._parent;
        _._duration = Math.ceil(l._node.duration * 10) / 10, Object.keys(_._sprite).length === 0 && (_._sprite = { __default: [0, _._duration * 1e3] }), _._state !== "loaded" && (_._state = "loaded", _._emit("load"), _._loadQueue()), l._node.removeEventListener(e._canPlayEvent, l._loadFn, !1);
      },
      /**
       * HTML5 Audio ended listener callback.
       */
      _endListener: function() {
        var l = this, _ = l._parent;
        _._duration === 1 / 0 && (_._duration = Math.ceil(l._node.duration * 10) / 10, _._sprite.__default[1] === 1 / 0 && (_._sprite.__default[1] = _._duration * 1e3), _._ended(l)), l._node.removeEventListener("ended", l._endFn, !1);
      }
    };
    var n = {}, a = function(l) {
      var _ = l._src;
      if (n[_]) {
        l._duration = n[_].duration, u(l);
        return;
      }
      if (/^data:[^;]+;base64,/.test(_)) {
        for (var d = atob(_.split(",")[1]), f = new Uint8Array(d.length), p = 0; p < d.length; ++p)
          f[p] = d.charCodeAt(p);
        h(f.buffer, l);
      } else {
        var g = new XMLHttpRequest();
        g.open(l._xhr.method, _, !0), g.withCredentials = l._xhr.withCredentials, g.responseType = "arraybuffer", l._xhr.headers && Object.keys(l._xhr.headers).forEach(function(m) {
          g.setRequestHeader(m, l._xhr.headers[m]);
        }), g.onload = function() {
          var m = (g.status + "")[0];
          if (m !== "0" && m !== "2" && m !== "3") {
            l._emit("loaderror", null, "Failed loading audio file with status: " + g.status + ".");
            return;
          }
          h(g.response, l);
        }, g.onerror = function() {
          l._webAudio && (l._html5 = !0, l._webAudio = !1, l._sounds = [], delete n[_], l.load());
        }, o(g);
      }
    }, o = function(l) {
      try {
        l.send();
      } catch {
        l.onerror();
      }
    }, h = function(l, _) {
      var d = function() {
        _._emit("loaderror", null, "Decoding audio data failed.");
      }, f = function(p) {
        p && _._sounds.length > 0 ? (n[_._src] = p, u(_, p)) : d();
      };
      typeof Promise < "u" && e.ctx.decodeAudioData.length === 1 ? e.ctx.decodeAudioData(l).then(f).catch(d) : e.ctx.decodeAudioData(l, f, d);
    }, u = function(l, _) {
      _ && !l._duration && (l._duration = _.duration), Object.keys(l._sprite).length === 0 && (l._sprite = { __default: [0, l._duration * 1e3] }), l._state !== "loaded" && (l._state = "loaded", l._emit("load"), l._loadQueue());
    }, c = function() {
      if (e.usingWebAudio) {
        try {
          typeof AudioContext < "u" ? e.ctx = new AudioContext() : typeof webkitAudioContext < "u" ? e.ctx = new webkitAudioContext() : e.usingWebAudio = !1;
        } catch {
          e.usingWebAudio = !1;
        }
        e.ctx || (e.usingWebAudio = !1);
        var l = /iP(hone|od|ad)/.test(e._navigator && e._navigator.platform), _ = e._navigator && e._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/), d = _ ? parseInt(_[1], 10) : null;
        if (l && d && d < 9) {
          var f = /safari/.test(e._navigator && e._navigator.userAgent.toLowerCase());
          e._navigator && !f && (e.usingWebAudio = !1);
        }
        e.usingWebAudio && (e.masterGain = typeof e.ctx.createGain > "u" ? e.ctx.createGainNode() : e.ctx.createGain(), e.masterGain.gain.setValueAtTime(e._muted ? 0 : e._volume, e.ctx.currentTime), e.masterGain.connect(e.ctx.destination)), e._setup();
      }
    };
    i.Howler = e, i.Howl = s, typeof rh < "u" ? (rh.HowlerGlobal = t, rh.Howler = e, rh.Howl = s, rh.Sound = r) : typeof window < "u" && (window.HowlerGlobal = t, window.Howler = e, window.Howl = s, window.Sound = r);
  })();
  /*!
   *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
   *  
   *  howler.js v2.2.4
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   */
  (function() {
    HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function(e) {
      var s = this;
      if (!s.ctx || !s.ctx.listener)
        return s;
      for (var r = s._howls.length - 1; r >= 0; r--)
        s._howls[r].stereo(e);
      return s;
    }, HowlerGlobal.prototype.pos = function(e, s, r) {
      var n = this;
      if (!n.ctx || !n.ctx.listener)
        return n;
      if (s = typeof s != "number" ? n._pos[1] : s, r = typeof r != "number" ? n._pos[2] : r, typeof e == "number")
        n._pos = [e, s, r], typeof n.ctx.listener.positionX < "u" ? (n.ctx.listener.positionX.setTargetAtTime(n._pos[0], Howler.ctx.currentTime, 0.1), n.ctx.listener.positionY.setTargetAtTime(n._pos[1], Howler.ctx.currentTime, 0.1), n.ctx.listener.positionZ.setTargetAtTime(n._pos[2], Howler.ctx.currentTime, 0.1)) : n.ctx.listener.setPosition(n._pos[0], n._pos[1], n._pos[2]);
      else
        return n._pos;
      return n;
    }, HowlerGlobal.prototype.orientation = function(e, s, r, n, a, o) {
      var h = this;
      if (!h.ctx || !h.ctx.listener)
        return h;
      var u = h._orientation;
      if (s = typeof s != "number" ? u[1] : s, r = typeof r != "number" ? u[2] : r, n = typeof n != "number" ? u[3] : n, a = typeof a != "number" ? u[4] : a, o = typeof o != "number" ? u[5] : o, typeof e == "number")
        h._orientation = [e, s, r, n, a, o], typeof h.ctx.listener.forwardX < "u" ? (h.ctx.listener.forwardX.setTargetAtTime(e, Howler.ctx.currentTime, 0.1), h.ctx.listener.forwardY.setTargetAtTime(s, Howler.ctx.currentTime, 0.1), h.ctx.listener.forwardZ.setTargetAtTime(r, Howler.ctx.currentTime, 0.1), h.ctx.listener.upX.setTargetAtTime(n, Howler.ctx.currentTime, 0.1), h.ctx.listener.upY.setTargetAtTime(a, Howler.ctx.currentTime, 0.1), h.ctx.listener.upZ.setTargetAtTime(o, Howler.ctx.currentTime, 0.1)) : h.ctx.listener.setOrientation(e, s, r, n, a, o);
      else
        return u;
      return h;
    }, Howl.prototype.init = /* @__PURE__ */ function(e) {
      return function(s) {
        var r = this;
        return r._orientation = s.orientation || [1, 0, 0], r._stereo = s.stereo || null, r._pos = s.pos || null, r._pannerAttr = {
          coneInnerAngle: typeof s.coneInnerAngle < "u" ? s.coneInnerAngle : 360,
          coneOuterAngle: typeof s.coneOuterAngle < "u" ? s.coneOuterAngle : 360,
          coneOuterGain: typeof s.coneOuterGain < "u" ? s.coneOuterGain : 0,
          distanceModel: typeof s.distanceModel < "u" ? s.distanceModel : "inverse",
          maxDistance: typeof s.maxDistance < "u" ? s.maxDistance : 1e4,
          panningModel: typeof s.panningModel < "u" ? s.panningModel : "HRTF",
          refDistance: typeof s.refDistance < "u" ? s.refDistance : 1,
          rolloffFactor: typeof s.rolloffFactor < "u" ? s.rolloffFactor : 1
        }, r._onstereo = s.onstereo ? [{ fn: s.onstereo }] : [], r._onpos = s.onpos ? [{ fn: s.onpos }] : [], r._onorientation = s.onorientation ? [{ fn: s.onorientation }] : [], e.call(this, s);
      };
    }(Howl.prototype.init), Howl.prototype.stereo = function(e, s) {
      var r = this;
      if (!r._webAudio)
        return r;
      if (r._state !== "loaded")
        return r._queue.push({
          event: "stereo",
          action: function() {
            r.stereo(e, s);
          }
        }), r;
      var n = typeof Howler.ctx.createStereoPanner > "u" ? "spatial" : "stereo";
      if (typeof s > "u")
        if (typeof e == "number")
          r._stereo = e, r._pos = [e, 0, 0];
        else
          return r._stereo;
      for (var a = r._getSoundIds(s), o = 0; o < a.length; o++) {
        var h = r._soundById(a[o]);
        if (h)
          if (typeof e == "number")
            h._stereo = e, h._pos = [e, 0, 0], h._node && (h._pannerAttr.panningModel = "equalpower", (!h._panner || !h._panner.pan) && t(h, n), n === "spatial" ? typeof h._panner.positionX < "u" ? (h._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime), h._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), h._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : h._panner.setPosition(e, 0, 0) : h._panner.pan.setValueAtTime(e, Howler.ctx.currentTime)), r._emit("stereo", h._id);
          else
            return h._stereo;
      }
      return r;
    }, Howl.prototype.pos = function(e, s, r, n) {
      var a = this;
      if (!a._webAudio)
        return a;
      if (a._state !== "loaded")
        return a._queue.push({
          event: "pos",
          action: function() {
            a.pos(e, s, r, n);
          }
        }), a;
      if (s = typeof s != "number" ? 0 : s, r = typeof r != "number" ? -0.5 : r, typeof n > "u")
        if (typeof e == "number")
          a._pos = [e, s, r];
        else
          return a._pos;
      for (var o = a._getSoundIds(n), h = 0; h < o.length; h++) {
        var u = a._soundById(o[h]);
        if (u)
          if (typeof e == "number")
            u._pos = [e, s, r], u._node && ((!u._panner || u._panner.pan) && t(u, "spatial"), typeof u._panner.positionX < "u" ? (u._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime), u._panner.positionY.setValueAtTime(s, Howler.ctx.currentTime), u._panner.positionZ.setValueAtTime(r, Howler.ctx.currentTime)) : u._panner.setPosition(e, s, r)), a._emit("pos", u._id);
          else
            return u._pos;
      }
      return a;
    }, Howl.prototype.orientation = function(e, s, r, n) {
      var a = this;
      if (!a._webAudio)
        return a;
      if (a._state !== "loaded")
        return a._queue.push({
          event: "orientation",
          action: function() {
            a.orientation(e, s, r, n);
          }
        }), a;
      if (s = typeof s != "number" ? a._orientation[1] : s, r = typeof r != "number" ? a._orientation[2] : r, typeof n > "u")
        if (typeof e == "number")
          a._orientation = [e, s, r];
        else
          return a._orientation;
      for (var o = a._getSoundIds(n), h = 0; h < o.length; h++) {
        var u = a._soundById(o[h]);
        if (u)
          if (typeof e == "number")
            u._orientation = [e, s, r], u._node && (u._panner || (u._pos || (u._pos = a._pos || [0, 0, -0.5]), t(u, "spatial")), typeof u._panner.orientationX < "u" ? (u._panner.orientationX.setValueAtTime(e, Howler.ctx.currentTime), u._panner.orientationY.setValueAtTime(s, Howler.ctx.currentTime), u._panner.orientationZ.setValueAtTime(r, Howler.ctx.currentTime)) : u._panner.setOrientation(e, s, r)), a._emit("orientation", u._id);
          else
            return u._orientation;
      }
      return a;
    }, Howl.prototype.pannerAttr = function() {
      var e = this, s = arguments, r, n, a;
      if (!e._webAudio)
        return e;
      if (s.length === 0)
        return e._pannerAttr;
      if (s.length === 1)
        if (typeof s[0] == "object")
          r = s[0], typeof n > "u" && (r.pannerAttr || (r.pannerAttr = {
            coneInnerAngle: r.coneInnerAngle,
            coneOuterAngle: r.coneOuterAngle,
            coneOuterGain: r.coneOuterGain,
            distanceModel: r.distanceModel,
            maxDistance: r.maxDistance,
            refDistance: r.refDistance,
            rolloffFactor: r.rolloffFactor,
            panningModel: r.panningModel
          }), e._pannerAttr = {
            coneInnerAngle: typeof r.pannerAttr.coneInnerAngle < "u" ? r.pannerAttr.coneInnerAngle : e._coneInnerAngle,
            coneOuterAngle: typeof r.pannerAttr.coneOuterAngle < "u" ? r.pannerAttr.coneOuterAngle : e._coneOuterAngle,
            coneOuterGain: typeof r.pannerAttr.coneOuterGain < "u" ? r.pannerAttr.coneOuterGain : e._coneOuterGain,
            distanceModel: typeof r.pannerAttr.distanceModel < "u" ? r.pannerAttr.distanceModel : e._distanceModel,
            maxDistance: typeof r.pannerAttr.maxDistance < "u" ? r.pannerAttr.maxDistance : e._maxDistance,
            refDistance: typeof r.pannerAttr.refDistance < "u" ? r.pannerAttr.refDistance : e._refDistance,
            rolloffFactor: typeof r.pannerAttr.rolloffFactor < "u" ? r.pannerAttr.rolloffFactor : e._rolloffFactor,
            panningModel: typeof r.pannerAttr.panningModel < "u" ? r.pannerAttr.panningModel : e._panningModel
          });
        else
          return a = e._soundById(parseInt(s[0], 10)), a ? a._pannerAttr : e._pannerAttr;
      else s.length === 2 && (r = s[0], n = parseInt(s[1], 10));
      for (var o = e._getSoundIds(n), h = 0; h < o.length; h++)
        if (a = e._soundById(o[h]), a) {
          var u = a._pannerAttr;
          u = {
            coneInnerAngle: typeof r.coneInnerAngle < "u" ? r.coneInnerAngle : u.coneInnerAngle,
            coneOuterAngle: typeof r.coneOuterAngle < "u" ? r.coneOuterAngle : u.coneOuterAngle,
            coneOuterGain: typeof r.coneOuterGain < "u" ? r.coneOuterGain : u.coneOuterGain,
            distanceModel: typeof r.distanceModel < "u" ? r.distanceModel : u.distanceModel,
            maxDistance: typeof r.maxDistance < "u" ? r.maxDistance : u.maxDistance,
            refDistance: typeof r.refDistance < "u" ? r.refDistance : u.refDistance,
            rolloffFactor: typeof r.rolloffFactor < "u" ? r.rolloffFactor : u.rolloffFactor,
            panningModel: typeof r.panningModel < "u" ? r.panningModel : u.panningModel
          };
          var c = a._panner;
          c || (a._pos || (a._pos = e._pos || [0, 0, -0.5]), t(a, "spatial"), c = a._panner), c.coneInnerAngle = u.coneInnerAngle, c.coneOuterAngle = u.coneOuterAngle, c.coneOuterGain = u.coneOuterGain, c.distanceModel = u.distanceModel, c.maxDistance = u.maxDistance, c.refDistance = u.refDistance, c.rolloffFactor = u.rolloffFactor, c.panningModel = u.panningModel;
        }
      return e;
    }, Sound.prototype.init = /* @__PURE__ */ function(e) {
      return function() {
        var s = this, r = s._parent;
        s._orientation = r._orientation, s._stereo = r._stereo, s._pos = r._pos, s._pannerAttr = r._pannerAttr, e.call(this), s._stereo ? r.stereo(s._stereo) : s._pos && r.pos(s._pos[0], s._pos[1], s._pos[2], s._id);
      };
    }(Sound.prototype.init), Sound.prototype.reset = /* @__PURE__ */ function(e) {
      return function() {
        var s = this, r = s._parent;
        return s._orientation = r._orientation, s._stereo = r._stereo, s._pos = r._pos, s._pannerAttr = r._pannerAttr, s._stereo ? r.stereo(s._stereo) : s._pos ? r.pos(s._pos[0], s._pos[1], s._pos[2], s._id) : s._panner && (s._panner.disconnect(0), s._panner = void 0, r._refreshBuffer(s)), e.call(this);
      };
    }(Sound.prototype.reset);
    var t = function(e, s) {
      s = s || "spatial", s === "spatial" ? (e._panner = Howler.ctx.createPanner(), e._panner.coneInnerAngle = e._pannerAttr.coneInnerAngle, e._panner.coneOuterAngle = e._pannerAttr.coneOuterAngle, e._panner.coneOuterGain = e._pannerAttr.coneOuterGain, e._panner.distanceModel = e._pannerAttr.distanceModel, e._panner.maxDistance = e._pannerAttr.maxDistance, e._panner.refDistance = e._pannerAttr.refDistance, e._panner.rolloffFactor = e._pannerAttr.rolloffFactor, e._panner.panningModel = e._pannerAttr.panningModel, typeof e._panner.positionX < "u" ? (e._panner.positionX.setValueAtTime(e._pos[0], Howler.ctx.currentTime), e._panner.positionY.setValueAtTime(e._pos[1], Howler.ctx.currentTime), e._panner.positionZ.setValueAtTime(e._pos[2], Howler.ctx.currentTime)) : e._panner.setPosition(e._pos[0], e._pos[1], e._pos[2]), typeof e._panner.orientationX < "u" ? (e._panner.orientationX.setValueAtTime(e._orientation[0], Howler.ctx.currentTime), e._panner.orientationY.setValueAtTime(e._orientation[1], Howler.ctx.currentTime), e._panner.orientationZ.setValueAtTime(e._orientation[2], Howler.ctx.currentTime)) : e._panner.setOrientation(e._orientation[0], e._orientation[1], e._orientation[2])) : (e._panner = Howler.ctx.createStereoPanner(), e._panner.pan.setValueAtTime(e._stereo, Howler.ctx.currentTime)), e._panner.connect(e._node), e._paused || e._parent.pause(e._id, !0).play(e._id, !0);
    };
  })();
})(Un);
class vrt {
  constructor(t) {
    this._sampleUrl = t, this._isPlaying = !1, this._startPos = 0, this._currentPos = 0, this._playLength = 0, this._sequence = [], this._cache = /* @__PURE__ */ new Map();
  }
  async play(t, e, s = 0, r = -1) {
    this.reset(), this._currentSong = new lT(t), this._startPos = Math.trunc(s), this._playLength = r, this._currentPos = this._startPos, this._currentSongId = e, await this.preload(), this._isPlaying = !0, this.tick(), this._tickerInterval = window.setInterval(() => this.tick(), 1e3);
  }
  reset() {
    this._isPlaying = !1, window.clearInterval(this._tickerInterval), Un.Howler.stop(), this._currentSongId = -1, this._currentSong = void 0, this._tickerInterval = void 0, this._startPos = 0, this._playLength = 0, this._sequence = [], this._currentPos = 0;
  }
  pause() {
    this._isPlaying = !1, Un.Howler.stop();
  }
  resume() {
    this._isPlaying = !0;
  }
  stop() {
    const t = this._currentSongId;
    this.reset(), x().dispatchEvent(new Yo(Yo.TRAX_SONG_COMPLETE, t));
  }
  /**
   * Sets global howler volume for all sounds
   * @param volume value from 0.0 to 1.0
   */
  setVolume(t) {
    Un.Howler.volume(t);
  }
  /**
   * Gets global howler volume for all sounds
   * @returns value from 0.0 to 1.0
   */
  getVolume() {
    return Un.Howler.volume();
  }
  /**
   * Gets sample from cache or loads it if not in cache
   * @param id sample id
   * @returns howl sound object
   */
  async getSample(t) {
    let e = this._cache.get(t);
    return e || (e = await this.loadSong(t)), Promise.resolve(e);
  }
  async preload() {
    if (this._sequence = [], !!this._currentSong) {
      for (const t of this._currentSong.channels) {
        const e = [];
        for (const s of t.items) {
          const r = await this.getSample(s.id), n = Math.ceil(s.length * 2 / Math.ceil(r.duration()));
          for (let a = 0; a < n; a++)
            for (let o = 0; o < Math.ceil(r.duration()); o++)
              e.push({ sampleId: s.id, offset: o });
        }
        this._sequence.push(e);
      }
      this._playLength <= 0 && (this._playLength = Math.max(...this._sequence.map((t) => t.length)));
    }
  }
  async preloadSamplesForSong(t) {
    const e = new lT(t);
    await Promise.all(e.getSampleIds().map((s) => this.getSample(s)));
  }
  async loadSong(t) {
    return new Promise((e, s) => {
      const r = new Un.Howl({
        src: [this._sampleUrl.replace("%sample%", t.toString())],
        preload: !0
      });
      r.once("load", () => {
        this._cache.set(t, r), e(r);
      }), r.once("loaderror", () => {
        rt.error("failed to load sample " + t), s("failed to load sample " + t);
      });
    });
  }
  tick() {
    this._currentPos > this._playLength - 1 && this.stop(), this._isPlaying && (this._currentSong && this.playPosition(this._currentPos), this._currentPos++);
  }
  playPosition(t) {
    if (!(!this._currentSong || !this._sequence) && Un.Howler._audioUnlocked)
      for (const e of this._sequence) {
        const s = e[t];
        if (!s || s.sampleId === -1 || s.sampleId === 0) continue;
        const r = this._cache.get(s.sampleId);
        r && (s.offset === 0 ? r.play() : r.playing() || (r.seek(s.offset), r.play()));
      }
  }
}
const sa = class sa {
  constructor() {
    this._timerInstance = 1, this._songRequestList = [], this._requestedSongs = /* @__PURE__ */ new Map(), this._availableSongs = /* @__PURE__ */ new Map(), this._songRequestsPerPriority = [], this._songRequestCountsPerPriority = [], this._diskInventoryMissingData = [], this._songDiskInventory = new be(), this._priorityPlaying = -1, this._requestNumberPlaying = -1, this._songIdPlaying = 1, this._previousNotifiedSongId = -1, this._previousNotificationTime = -1, this.onJukeboxInit = this.onJukeboxInit.bind(this), this.onJukeboxDispose = this.onJukeboxDispose.bind(this), this.onSoundMachineInit = this.onSoundMachineInit.bind(this), this.onSoundMachineDispose = this.onSoundMachineDispose.bind(this), this.onTraxSongComplete = this.onTraxSongComplete.bind(this);
  }
  init() {
    G().registerMessageEvent(new MC(this.onTraxSongInfoMessageEvent.bind(this))), G().registerMessageEvent(new bC(this.onSongDiskInventoryMessage.bind(this))), this._timerInstance = window.setInterval(this.onTick.bind(this), 1e3), this._musicPlayer = new vrt(Ct().getValue("external.samples.url")), x().addEventListener(ne.JUKEBOX_INIT, this.onJukeboxInit), x().addEventListener(ne.JUKEBOX_DISPOSE, this.onJukeboxDispose), x().addEventListener(ne.SOUND_MACHINE_INIT, this.onSoundMachineInit), x().addEventListener(ne.SOUND_MACHINE_DISPOSE, this.onSoundMachineDispose), x().addEventListener(Yo.TRAX_SONG_COMPLETE, this.onTraxSongComplete);
  }
  getRoomItemPlaylist(t) {
    return this._roomItemPlaylist;
  }
  get songDiskInventory() {
    return this._songDiskInventory;
  }
  getSongDiskInventorySize() {
    return this._songDiskInventory.length;
  }
  getSongDiskInventoryDiskId(t) {
    return t >= 0 && t < this._songDiskInventory.length ? this._songDiskInventory.getKey(t) : -1;
  }
  getSongDiskInventorySongId(t) {
    return t >= 0 && t < this._songDiskInventory.length ? this._songDiskInventory.getWithIndex(t) : -1;
  }
  getSongInfo(t) {
    const e = this.getSongDataEntry(t);
    return e || this.requestSongInfoWithoutSamples(t), e;
  }
  getSongIdPlayingAtPriority(t) {
    return t !== this._priorityPlaying ? -1 : this._songIdPlaying;
  }
  stop(t) {
    const e = t === this._priorityPlaying, s = this.getTopRequestPriority() === t;
    e ? (this.resetSongStartRequest(t), this.stopSongAtPriority(t)) : (this.resetSongStartRequest(t), s && this.reRequestSongAtPriority(this._priorityPlaying));
  }
  addSongInfoRequest(t) {
    this.requestSong(t, !0);
  }
  requestSongInfoWithoutSamples(t) {
    this.requestSong(t, !1);
  }
  requestUserSongDisks() {
    G().connection.send(new iM());
  }
  updateVolume(t) {
    this._musicPlayer.setVolume(t);
  }
  dispose() {
    this._timerInstance && (clearInterval(this._timerInstance), this._timerInstance = void 0), x().removeEventListener(ne.JUKEBOX_INIT, this.onJukeboxInit), x().removeEventListener(ne.JUKEBOX_DISPOSE, this.onJukeboxDispose), x().removeEventListener(ne.SOUND_MACHINE_INIT, this.onSoundMachineInit), x().removeEventListener(ne.SOUND_MACHINE_DISPOSE, this.onSoundMachineDispose), x().removeEventListener(Yo.TRAX_SONG_COMPLETE, this.onTraxSongComplete);
  }
  get samplesIdsInUse() {
    let t, e, s = [];
    for (let r = 0; r < this._songRequestsPerPriority.length; r++)
      if (this._songRequestsPerPriority[r] && (t = this._songRequestsPerPriority[r], e = this._availableSongs.get(t.songId), e)) {
        const n = e.songData;
        if (n.length > 0) {
          const a = new lT(n);
          s = s.concat(a.getSampleIds());
        }
      }
    return s;
  }
  onSongLoaded(t) {
    const e = this.getTopRequestPriority();
    if (e >= 0) {
      const s = this.getSongIdRequestedAtPriority(e);
      t === s && this.playSongObject(e, t);
    }
  }
  samplesUnloaded(t) {
    throw new Error("Method not implemented.");
  }
  onTraxSongComplete(t) {
    if (this.getSongIdPlayingAtPriority(this._priorityPlaying) === t.id) {
      this.getTopRequestPriority() === this._priorityPlaying && this.getSongRequestCountAtPriority(this._priorityPlaying) == this._requestNumberPlaying && this.resetSongStartRequest(this._priorityPlaying);
      const e = this._priorityPlaying;
      this.playSongWithHighestPriority(), e >= Ns.PRIORITY_SONG_PLAY && x().dispatchEvent(new nn(nn.NPW_USER_STOP_SONG, e, t.id, -1));
    }
  }
  onTraxSongInfoMessageEvent(t) {
    const e = t.getParser();
    for (const s of e.songs) {
      const r = !!this.getSongDataEntry(s.id);
      if (this.areSamplesRequested(s.id), !r) {
        const n = new jM(s.id, s.length, s.name, s.creator, s.data);
        this._availableSongs.set(s.id, n);
        const a = this.getTopRequestPriority(), o = this.getSongIdRequestedAtPriority(a);
        for (s.id === o && this.playSongObject(a, o), x().dispatchEvent(new Ho(Ho.SIR_TRAX_SONG_INFO_RECEIVED, s.id)); this._diskInventoryMissingData.indexOf(s.id) != -1; )
          this._diskInventoryMissingData.splice(this._diskInventoryMissingData.indexOf(s.id), 1), this._diskInventoryMissingData.length === 0 && x().dispatchEvent(new Xa(Xa.SDIR_SONG_DISK_INVENTORY_RECEIVENT_EVENT));
      }
    }
  }
  onSongDiskInventoryMessage(t) {
    const e = t.getParser();
    this._songDiskInventory.reset();
    for (let s = 0; s < e.songDiskCount; s++) {
      const r = e.getDiskId(s), n = e.getSongId(s);
      this._songDiskInventory.add(r, n), this._availableSongs.get(n) || (this._diskInventoryMissingData.push(n), this.requestSongInfoWithoutSamples(n));
    }
    this._diskInventoryMissingData.length === 0 && x().dispatchEvent(new Xa(Xa.SDIR_SONG_DISK_INVENTORY_RECEIVENT_EVENT));
  }
  onTick() {
    this._songRequestList.length !== 0 && (G().connection.send(new sM(...this._songRequestList)), this._songRequestList = []);
  }
  requestSong(t, e) {
    this._requestedSongs.get(t) === void 0 && (this._requestedSongs.set(t, e), this._songRequestList.push(t));
  }
  areSamplesRequested(t) {
    return this._requestedSongs.get(t) ? this._requestedSongs.get(t) : !1;
  }
  processSongEntryForPlaying(t, e = !0) {
    return this.getSongDataEntry(t) ? !0 : (this.addSongInfoRequest(t), !1);
  }
  playSong(t, e, s = 0, r = 0, n = 0.5, a = 0.5) {
    return !this.addSongStartRequest(e, t, s, r, n, a) || !this.processSongEntryForPlaying(t) ? !1 : (e >= this._priorityPlaying && this.playSongObject(e, t), !0);
  }
  playSongObject(t, e) {
    if (e === -1 || t < 0 || t >= Ns.PRIORITY_COUNT)
      return !1;
    let s = !1;
    this.stopSongAtPriority(this._priorityPlaying) && (s = !0);
    const r = this.getSongDataEntry(e);
    if (!r)
      return !1;
    if (s)
      return !0;
    this._musicPlayer.setVolume(Dn().traxVolume);
    let n = sa.SKIP_POSITION_SET, a = 0;
    const o = this.getSongStartRequest(t);
    return o && (n = o.startPos, a = o.playLength, o.fadeInSeconds, o.fadeOutSeconds), n >= r.length / 1e3 ? !1 : (n <= sa.SKIP_POSITION_SET && (n = 0), n = Math.trunc(n), this._priorityPlaying = t, this._requestNumberPlaying = this.getSongRequestCountAtPriority(t), this._songIdPlaying = e, this._priorityPlaying <= sa.MAXIMUM_NOTIFY_PRIORITY && this.notifySongPlaying(r), this._musicPlayer.preloadSamplesForSong(r.songData).then(() => this._musicPlayer.play(r.songData, r.id, n, a)), t > Ns.PRIORITY_ROOM_PLAYLIST && x().dispatchEvent(new nn(nn.NPE_USER_PLAY_SONG, t, r.id, -1)), !0);
  }
  notifySongPlaying(t) {
    const s = Date.now();
    t.length >= 8e3 && (this._previousNotifiedSongId != t.id || s > this._previousNotificationTime + 8e3) && (x().dispatchEvent(new Ap(t.name, t.creator)), this._previousNotifiedSongId = t.id, this._previousNotificationTime = s);
  }
  addSongStartRequest(t, e, s, r, n, a) {
    if (t < 0 || t >= Ns.PRIORITY_COUNT)
      return !1;
    const o = new Art(e, s, r, n, a);
    return this._songRequestsPerPriority[t] = o, this._songRequestCountsPerPriority[t] = this._songRequestCountsPerPriority[t] + 1, !0;
  }
  getSongDataEntry(t) {
    let e;
    return this._availableSongs && (e = this._availableSongs.get(t)), e;
  }
  getSongStartRequest(t) {
    return this._songRequestsPerPriority[t];
  }
  getTopRequestPriority() {
    return this._songRequestsPerPriority.length - 1;
  }
  getSongIdRequestedAtPriority(t) {
    return t < 0 || t >= Ns.PRIORITY_COUNT || !this._songRequestsPerPriority[t] ? -1 : this._songRequestsPerPriority[t].songId;
  }
  getSongRequestCountAtPriority(t) {
    return t < 0 || t >= Ns.PRIORITY_COUNT ? -1 : this._songRequestCountsPerPriority[t];
  }
  playSongWithHighestPriority() {
    let t;
    this._priorityPlaying = -1, this._songIdPlaying = -1, this._requestNumberPlaying = -1;
    let s = this.getTopRequestPriority();
    for (; s >= 0; ) {
      if (t = this.getSongIdRequestedAtPriority(s), t >= 0 && this.playSongObject(s, t))
        return;
      s--;
    }
  }
  resetSongStartRequest(t) {
    t >= 0 && t < Ns.PRIORITY_COUNT && (this._songRequestsPerPriority[t] = void 0);
  }
  reRequestSongAtPriority(t) {
    this._songRequestCountsPerPriority[t] = this._songRequestCountsPerPriority[t] + 1;
  }
  stopSongAtPriority(t) {
    if (t === this._priorityPlaying && this._priorityPlaying >= 0) {
      const e = this.getSongIdPlayingAtPriority(t);
      if (e >= 0)
        return this.getSongDataEntry(e), this._musicPlayer.stop(), !0;
    }
    return !1;
  }
  onSoundMachineInit(t) {
    this.disposeRoomPlaylist();
  }
  onSoundMachineDispose(t) {
    this.disposeRoomPlaylist();
  }
  onJukeboxInit(t) {
    this.disposeRoomPlaylist(), this._roomItemPlaylist = new yrt(), this._roomItemPlaylist.init(), G().connection.send(new eM());
  }
  onJukeboxDispose(t) {
    this.disposeRoomPlaylist();
  }
  disposeRoomPlaylist() {
    this._roomItemPlaylist && (this._roomItemPlaylist.dispose(), this._roomItemPlaylist = void 0);
  }
};
sa.SKIP_POSITION_SET = -1, sa.MAXIMUM_NOTIFY_PRIORITY = Ns.PRIORITY_ROOM_PLAYLIST;
let cT = sa;
class Crt {
  constructor() {
    this._volumeSystem = 0.5, this._volumeFurni = 0.5, this._volumeTrax = 0.5, this._internalSamples = new be(), this._furniSamples = new be(), this._furnitureBeingPlayed = new be(), this._musicController = new cT();
  }
  async init() {
    this._musicController.init(), x().addEventListener(Ws.PLAY_SAMPLE, (t) => this.onEvent(t)), x().addEventListener(lt.REMOVED, (t) => this.onEvent(t)), x().addEventListener(ae.DISPOSED, (t) => this.onEvent(t)), x().addEventListener(Mu.SETTINGS_UPDATED, (t) => this.onEvent(t)), x().addEventListener(nc.PLAY_SOUND, (t) => this.onEvent(t));
  }
  onEvent(t) {
    var e;
    switch (t.type) {
      case Ws.PLAY_SAMPLE: {
        const s = t;
        this.playFurniSample(s.objectId, s.sampleId, s.pitch);
        return;
      }
      case lt.REMOVED: {
        const s = t;
        this.stopFurniSample(s.objectId);
        return;
      }
      case ae.DISPOSED: {
        this._furnitureBeingPlayed.getKeys().forEach((s) => {
          this.stopFurniSample(s);
        });
        return;
      }
      case Mu.SETTINGS_UPDATED: {
        const s = t, r = s.volumeFurni !== this._volumeFurni, n = s.volumeTrax !== this._volumeTrax;
        this._volumeSystem = s.volumeSystem / 100, this._volumeFurni = s.volumeFurni / 100, this._volumeTrax = s.volumeTrax / 100, r && this.updateFurniSamplesVolume(this._volumeFurni), n && ((e = this._musicController) == null || e.updateVolume(this._volumeTrax));
        return;
      }
      case nc.PLAY_SOUND: {
        const s = t;
        this.playInternalSample(s.sampleCode);
        return;
      }
    }
  }
  playSample(t, e, s = 1) {
    t.volume = e, t.currentTime = 0;
    try {
      t.play();
    } catch (r) {
      rt.error(r);
    }
  }
  playInternalSample(t) {
    let e = this._internalSamples.getValue(t);
    if (!e) {
      const s = Ct().getValue("sounds.url");
      e = new Audio(s.replace("%sample%", t)), this._internalSamples.add(t, e);
    }
    this.playSample(e, this._volumeSystem);
  }
  playFurniSample(t, e, s) {
    let r = this._furniSamples.getValue(e);
    if (!r) {
      const n = Ct().getValue("external.samples.url");
      r = new Audio(n.replace("%sample%", e.toString())), this._furniSamples.add(e, r);
    }
    this._furnitureBeingPlayed.hasKey(t) || this._furnitureBeingPlayed.add(t, e), r.onended = (n) => this.stopFurniSample(t), r.onpause = (n) => this.stopFurniSample(t), r.onerror = (n) => this.stopFurniSample(t), this.playSample(r, this._volumeFurni, s);
  }
  stopInternalSample(t) {
    const e = this._internalSamples.getValue(t);
    if (e)
      try {
        e.pause();
      } catch (s) {
        rt.error(s);
      }
  }
  stopFurniSample(t) {
    const e = this._furnitureBeingPlayed.getValue(t);
    if (!e) return;
    const s = this._furniSamples.getValue(e);
    if (this._furnitureBeingPlayed.remove(t), !!s)
      try {
        s.pause();
      } catch (r) {
        rt.error(r);
      }
  }
  updateInternalSamplesVolume(t) {
    this._internalSamples.getValues().forEach((e) => {
      e.volume = t;
    });
  }
  updateFurniSamplesVolume(t) {
    this._furniSamples.getValues().forEach((e) => {
      e.volume = t;
    });
  }
  get traxVolume() {
    return this._volumeTrax;
  }
  get musicController() {
    return this._musicController;
  }
}
const xrt = new Crt(), Dn = () => xrt;
window.NitroDevTools = {
  roomEngine: SI()
};
class fnt extends Xy {
}
class gnt extends Yl {
}
class pnt extends Qt {
}
class mnt extends xt {
}
class Ent extends Kt {
}
class Tnt extends ku {
}
class Int extends Ft {
}
class Snt extends W {
}
wd.defaultOptions.hello = !0;
ke.defaultOptions.scaleMode = window.devicePixelRatio % 1 ? "linear" : "nearest";
Wt.set(ZR);
export {
  Pt as $,
  gN as A,
  _p as A$,
  Mu as A0,
  nc as A1,
  ac as A2,
  Qg as A3,
  Jg as A4,
  tp as A5,
  oc as A6,
  nR as A7,
  iR as A8,
  A as A9,
  Er as AA,
  ee as AB,
  Ie as AC,
  ne as AD,
  At as AE,
  Ii as AF,
  La as AG,
  N as AH,
  VF as AI,
  HF as AJ,
  zo as AK,
  aR as AL,
  Vo as AM,
  np as AN,
  oR as AO,
  Jt as AP,
  ap as AQ,
  op as AR,
  hp as AS,
  lc as AT,
  YF as AU,
  rn as AV,
  We as AW,
  mt as AX,
  up as AY,
  lp as AZ,
  cp as A_,
  qt as Aa,
  rR as Ab,
  ep as Ac,
  bs as Ad,
  sp as Ae,
  ip as Af,
  rp as Ag,
  ae as Ah,
  lt as Ai,
  kF as Aj,
  zF as Ak,
  Ha as Al,
  Ya as Am,
  Ws as An,
  Q as Ao,
  hc as Ap,
  di as Aq,
  qs as Ar,
  _a as As,
  ti as At,
  Ke as Au,
  z as Av,
  gr as Aw,
  uc as Ax,
  at as Ay,
  $e as Az,
  ve as B,
  mI as B$,
  dp as B0,
  hR as B1,
  fp as B2,
  gp as B3,
  pp as B4,
  Wa as B5,
  mp as B6,
  br as B7,
  cc as B8,
  _c as B9,
  El as BA,
  Ji as BB,
  EM as BC,
  fI as BD,
  TM as BE,
  IM as BF,
  SM as BG,
  AM as BH,
  Nc as BI,
  RM as BJ,
  OM as BK,
  Mst as BL,
  yM as BM,
  vM as BN,
  CM as BO,
  xM as BP,
  MM as BQ,
  gI as BR,
  Uc as BS,
  bM as BT,
  pI as BU,
  PM as BV,
  Dc as BW,
  NM as BX,
  Ht as BY,
  Sa as BZ,
  UM as B_,
  uR as Ba,
  dc as Bb,
  Ep as Bc,
  Tp as Bd,
  Ip as Be,
  lR as Bf,
  ja as Bg,
  Pr as Bh,
  Sp as Bi,
  fc as Bj,
  Ap as Bk,
  nn as Bl,
  Nr as Bm,
  Xa as Bn,
  Ho as Bo,
  Yo as Bp,
  Zf as Bq,
  pl as Br,
  est as Bs,
  si as Bt,
  SI as Bu,
  lrt as Bv,
  tg as Bw,
  aT as Bx,
  ml as By,
  dnt as Bz,
  Qt as C,
  yE as C$,
  DM as C0,
  _n as C1,
  Fu as C2,
  Ps as C3,
  Lc as C4,
  qe as C5,
  Tr as C6,
  Ir as C7,
  we as C8,
  wu as C9,
  Lst as CA,
  Fst as CB,
  wst as CC,
  Gst as CD,
  Bst as CE,
  kst as CF,
  zst as CG,
  Vst as CH,
  Hst as CI,
  Yst as CJ,
  Wst as CK,
  jst as CL,
  Xst as CM,
  Kst as CN,
  RE as CO,
  Fc as CP,
  qst as CQ,
  wc as CR,
  $st as CS,
  OE as CT,
  Zst as CU,
  Qst as CV,
  Jst as CW,
  tit as CX,
  eit as CY,
  wt as CZ,
  sit as C_,
  Ae as Ca,
  ka as Cb,
  Sr as Cc,
  Ce as Cd,
  xR as Ce,
  gM as Cf,
  Cst as Cg,
  TE as Ch,
  pM as Ci,
  Ia as Cj,
  mM as Ck,
  ue as Cl,
  xst as Cm,
  ye as Cn,
  Ai as Co,
  IE as Cp,
  dn as Cq,
  bst as Cr,
  Pst as Cs,
  $d as Ct,
  Nst as Cu,
  SE as Cv,
  AE as Cw,
  Ust as Cx,
  LM as Cy,
  Dst as Cz,
  Wt as D,
  Bu as D$,
  iit as D0,
  rit as D1,
  _e as D2,
  nit as D3,
  ait as D4,
  oit as D5,
  hit as D6,
  uit as D7,
  lit as D8,
  vE as D9,
  UE as DA,
  NE as DB,
  DE as DC,
  LE as DD,
  vit as DE,
  Cit as DF,
  xit as DG,
  Mit as DH,
  xe as DI,
  fn as DJ,
  wM as DK,
  bit as DL,
  Pit as DM,
  Nit as DN,
  zc as DO,
  BM as DP,
  Aa as DQ,
  an as DR,
  GM as DS,
  Vt as DT,
  Fn as DU,
  kc as DV,
  Te as DW,
  TI as DX,
  kM as DY,
  BE as DZ,
  kE as D_,
  cit as Da,
  CE as Db,
  _it as Dc,
  dit as Dd,
  fit as De,
  git as Df,
  pit as Dg,
  mit as Dh,
  Gc as Di,
  Eit as Dj,
  xE as Dk,
  Tit as Dl,
  ME as Dm,
  Iit as Dn,
  bE as Do,
  Sit as Dp,
  PE as Dq,
  Ait as Dr,
  Rit as Ds,
  Oit as Dt,
  yit as Du,
  Bc as Dv,
  Ko as Dw,
  FE as Dx,
  EI as Dy,
  FM as Dz,
  B as E,
  art as E$,
  Git as E0,
  zE as E1,
  Bit as E2,
  zM as E3,
  kit as E4,
  VM as E5,
  HE as E6,
  Vit as E7,
  YE as E8,
  WE as E9,
  sT as EA,
  YM as EB,
  cnt as EC,
  Yt as ED,
  Qit as EE,
  Jit as EF,
  nT as EG,
  WM as EH,
  srt as EI,
  trt as EJ,
  rT as EK,
  ert as EL,
  ua as EM,
  _nt as EN,
  iT as EO,
  Pc as EP,
  Irt as EQ,
  Trt as ER,
  hT as ES,
  prt as ET,
  frt as EU,
  grt as EV,
  II as EW,
  Ert as EX,
  uT as EY,
  EE as EZ,
  Yc as E_,
  jE as Ea,
  Hit as Eb,
  XE as Ec,
  HM as Ed,
  zit as Ee,
  VE as Ef,
  MR as Eg,
  KE as Eh,
  Yit as Ei,
  qE as Ej,
  Wit as Ek,
  $E as El,
  jit as Em,
  Xit as En,
  ZE as Eo,
  Kit as Ep,
  qit as Eq,
  QE as Er,
  Xi as Es,
  Yi as Et,
  JE as Eu,
  tT as Ev,
  $it as Ew,
  eT as Ex,
  Hc as Ey,
  Zit as Ez,
  pN as F,
  be as F$,
  hrt as F0,
  crt as F1,
  drt as F2,
  irt as F3,
  ort as F4,
  oT as F5,
  Wc as F6,
  Ye as F7,
  Uit as F8,
  Gu as F9,
  Mh as FA,
  vR as FB,
  Sst as FC,
  gi as FD,
  rst as FE,
  nst as FF,
  ast as FG,
  ost as FH,
  hst as FI,
  ust as FJ,
  lst as FK,
  cst as FL,
  $a as FM,
  fst as FN,
  gst as FO,
  Ast as FP,
  Rst as FQ,
  Dn as FR,
  Crt as FS,
  jM as FT,
  Art as FU,
  yrt as FV,
  cT as FW,
  Ns as FX,
  Rrt as FY,
  Ort as FZ,
  lT as F_,
  bh as Fa,
  wE as Fb,
  Dit as Fc,
  zi as Fd,
  Qf as Fe,
  $s as Ff,
  Fit as Fg,
  wit as Fh,
  GE as Fi,
  Vc as Fj,
  Jf as Fk,
  Lit as Fl,
  Zr as Fm,
  Xo as Fn,
  Est as Fo,
  CR as Fp,
  Tst as Fq,
  _st as Fr,
  ist as Fs,
  pst as Ft,
  dst as Fu,
  Ost as Fv,
  mE as Fw,
  Za as Fx,
  yR as Fy,
  Ist as Fz,
  WP as G,
  x1 as G0,
  Gd as G1,
  dA as G2,
  Ql as G3,
  Jl as G4,
  Urt as G5,
  Drt as G6,
  ma as G7,
  Lrt as G8,
  on as G9,
  Yrt as GA,
  Wrt as GB,
  uF as GC,
  jrt as GD,
  lF as GE,
  Wu as GF,
  Xrt as GG,
  sh as GH,
  sR as GI,
  Krt as GJ,
  cF as GK,
  qrt as GL,
  $rt as GM,
  Zrt as GN,
  fnt as GO,
  gnt as GP,
  pnt as GQ,
  mnt as GR,
  Ent as GS,
  Tnt as GT,
  Int as GU,
  Snt as GV,
  VT as Ga,
  P1 as Gb,
  Nt as Gc,
  Tu as Gd,
  sy as Ge,
  Ut as Gf,
  Frt as Gg,
  wrt as Gh,
  wg as Gi,
  Oh as Gj,
  Xg as Gk,
  rt as Gl,
  ic as Gm,
  Gy as Gn,
  tR as Go,
  zrt as Gp,
  rc as Gq,
  Fg as Gr,
  le as Gs,
  v as Gt,
  oF as Gu,
  Kg as Gv,
  qg as Gw,
  eR as Gx,
  Vrt as Gy,
  Hrt as Gz,
  Nrt as H,
  TT as I,
  Or as J,
  a1 as K,
  o1 as L,
  ot as M,
  Uo as N,
  la as O,
  st as P,
  ps as Q,
  Kt as R,
  Pd as S,
  js as T,
  Bl as U,
  Zs as V,
  mT as W,
  bn as X,
  dt as Y,
  Se as Z,
  gn as _,
  Js as a,
  fr as a$,
  ga as a0,
  nU as a1,
  yg as a2,
  JD as a3,
  Es as a4,
  w0 as a5,
  TS as a6,
  ES as a7,
  Ot as a8,
  ab as a9,
  gs as aA,
  xr as aB,
  nA as aC,
  bg as aD,
  Wl as aE,
  jl as aF,
  Pg as aG,
  En as aH,
  tn as aI,
  Ng as aJ,
  Wi as aK,
  Xl as aL,
  Kl as aM,
  aA as aN,
  ql as aO,
  ns as aP,
  pa as aQ,
  Fo as aR,
  wo as aS,
  mu as aT,
  L as aU,
  tt as aV,
  yt as aW,
  pr as aX,
  Xt as aY,
  I as aZ,
  j as a_,
  yT as aa,
  Al as ab,
  vT as ac,
  N0 as ad,
  U0 as ae,
  VS as af,
  cU as ag,
  ge as ah,
  ob as ai,
  XD as aj,
  Hl as ak,
  Og as al,
  kS as am,
  Ll as an,
  B0 as ao,
  xg as ap,
  Mg as aq,
  Va as ar,
  et as as,
  Jr as at,
  sA as au,
  iA as av,
  rA as aw,
  as as ax,
  Gi as ay,
  ci as az,
  PD as b,
  bB as b$,
  oA as b0,
  en as b1,
  hA as b2,
  ey as b3,
  $l as b4,
  v1 as b5,
  Ug as b6,
  Rh as b7,
  Eu as b8,
  mr as b9,
  Gp as bA,
  RB as bB,
  Fp as bC,
  OB as bD,
  wp as bE,
  mR as bF,
  yB as bG,
  qF as bH,
  KF as bI,
  Op as bJ,
  $F as bK,
  vB as bL,
  CB as bM,
  JF as bN,
  Dp as bO,
  cB as bP,
  ui as bQ,
  hB as bR,
  uB as bS,
  lB as bT,
  ZF as bU,
  cR as bV,
  Lp as bW,
  _B as bX,
  dR as bY,
  xB as bZ,
  MB as b_,
  Dg as ba,
  Lg as bb,
  C1 as bc,
  _i as bd,
  Us as be,
  J as bf,
  uA as bg,
  lA as bh,
  ji as bi,
  cA as bj,
  Zl as bk,
  Ss as bl,
  _A as bm,
  Ln as bn,
  Mr as bo,
  FF as bp,
  Rt as bq,
  $g as br,
  Zg as bs,
  LF as bt,
  Rp as bu,
  XF as bv,
  vl as bw,
  gc as bx,
  QF as by,
  $f as bz,
  It as c,
  S6 as c$,
  AB as c0,
  QT as c1,
  SB as c2,
  pR as c3,
  fB as c4,
  gB as c5,
  TB as c6,
  IB as c7,
  Pu as c8,
  dB as c9,
  $j as cA,
  Zj as cB,
  Qj as cC,
  Jj as cD,
  Lu as cE,
  t6 as cF,
  Vv as cG,
  e6 as cH,
  s6 as cI,
  i6 as cJ,
  r6 as cK,
  n6 as cL,
  a6 as cM,
  o6 as cN,
  h6 as cO,
  u6 as cP,
  l6 as cQ,
  c6 as cR,
  _6 as cS,
  d6 as cT,
  f6 as cU,
  g6 as cV,
  p6 as cW,
  m6 as cX,
  E6 as cY,
  T6 as cZ,
  I6 as c_,
  Dl as ca,
  pB as cb,
  mB as cc,
  fR as cd,
  EB as ce,
  Kf as cf,
  gR as cg,
  qf as ch,
  Qrt as ci,
  NB as cj,
  UB as ck,
  Jrt as cl,
  Jet as cm,
  G as cn,
  Xet as co,
  Qet as cp,
  Ket as cq,
  qet as cr,
  Zet as cs,
  $et as ct,
  LB as cu,
  R as cv,
  Xj as cw,
  Kj as cx,
  zv as cy,
  qj as cz,
  $o as d,
  C8 as d$,
  A6 as d0,
  R6 as d1,
  O6 as d2,
  y6 as d3,
  v6 as d4,
  C6 as d5,
  x6 as d6,
  M6 as d7,
  b6 as d8,
  P6 as d9,
  s8 as dA,
  i8 as dB,
  r8 as dC,
  n8 as dD,
  mm as dE,
  a8 as dF,
  o8 as dG,
  h8 as dH,
  u8 as dI,
  l8 as dJ,
  c8 as dK,
  _8 as dL,
  d8 as dM,
  f8 as dN,
  g8 as dO,
  p8 as dP,
  m8 as dQ,
  E8 as dR,
  T8 as dS,
  Yv as dT,
  I8 as dU,
  S8 as dV,
  A8 as dW,
  R8 as dX,
  O8 as dY,
  y8 as dZ,
  v8 as d_,
  N6 as da,
  U6 as db,
  D6 as dc,
  L6 as dd,
  F6 as de,
  w6 as df,
  G6 as dg,
  B6 as dh,
  k6 as di,
  z6 as dj,
  V6 as dk,
  H6 as dl,
  Y6 as dm,
  W6 as dn,
  j6 as dp,
  X6 as dq,
  K6 as dr,
  q6 as ds,
  Hv as dt,
  $6 as du,
  Z6 as dv,
  Q6 as dw,
  J6 as dx,
  t8 as dy,
  e8 as dz,
  Ee as e,
  Kv as e$,
  x8 as e0,
  M8 as e1,
  b8 as e2,
  P8 as e3,
  N8 as e4,
  U8 as e5,
  D8 as e6,
  L8 as e7,
  F8 as e8,
  w8 as e9,
  hX as eA,
  uX as eB,
  lX as eC,
  cX as eD,
  _X as eE,
  dX as eF,
  fX as eG,
  qa as eH,
  gX as eI,
  pX as eJ,
  mX as eK,
  jv as eL,
  EX as eM,
  TX as eN,
  IX as eO,
  SX as eP,
  AX as eQ,
  RX as eR,
  OX as eS,
  yX as eT,
  vX as eU,
  CX as eV,
  xX as eW,
  MX as eX,
  bX as eY,
  PX as eZ,
  Xv as e_,
  G8 as ea,
  B8 as eb,
  k8 as ec,
  z8 as ed,
  V8 as ee,
  H8 as ef,
  Y8 as eg,
  W8 as eh,
  j8 as ei,
  X8 as ej,
  K8 as ek,
  Em as el,
  q8 as em,
  $8 as en,
  Z8 as eo,
  Wv as ep,
  Q8 as eq,
  J8 as er,
  tX as es,
  eX as et,
  sX as eu,
  iX as ev,
  rX as ew,
  nX as ex,
  aX as ey,
  oX as ez,
  W as f,
  LK as f$,
  NX as f0,
  UX as f1,
  DX as f2,
  LX as f3,
  qv as f4,
  FX as f5,
  wX as f6,
  GX as f7,
  BX as f8,
  kX as f9,
  hK as fA,
  uK as fB,
  lK as fC,
  cK as fD,
  _K as fE,
  dK as fF,
  fK as fG,
  gK as fH,
  pK as fI,
  mK as fJ,
  EK as fK,
  TK as fL,
  IK as fM,
  SK as fN,
  AK as fO,
  RK as fP,
  OK as fQ,
  yK as fR,
  vK as fS,
  CK as fT,
  xK as fU,
  MK as fV,
  bK as fW,
  PK as fX,
  NK as fY,
  UK as fZ,
  DK as f_,
  zX as fa,
  VX as fb,
  HX as fc,
  YX as fd,
  WX as fe,
  jX as ff,
  XX as fg,
  KX as fh,
  qX as fi,
  $v as fj,
  $X as fk,
  ZX as fl,
  QX as fm,
  JX as fn,
  int as fo,
  rnt as fp,
  tK as fq,
  eK as fr,
  sK as fs,
  iK as ft,
  rK as fu,
  Zv as fv,
  nK as fw,
  aK as fx,
  nnt as fy,
  oK as fz,
  lg as g,
  FW as g$,
  FK as g0,
  wK as g1,
  GK as g2,
  BK as g3,
  kK as g4,
  zK as g5,
  VK as g6,
  HK as g7,
  YK as g8,
  WK as g9,
  AR as gA,
  f7 as gB,
  g7 as gC,
  p7 as gD,
  m7 as gE,
  E7 as gF,
  T7 as gG,
  I7 as gH,
  S7 as gI,
  A7 as gJ,
  tC as gK,
  R7 as gL,
  O7 as gM,
  y7 as gN,
  v7 as gO,
  ant as gP,
  C7 as gQ,
  x7 as gR,
  M7 as gS,
  b7 as gT,
  P7 as gU,
  eC as gV,
  N7 as gW,
  U7 as gX,
  D7 as gY,
  DW as gZ,
  LW as g_,
  jK as ga,
  XK as gb,
  KK as gc,
  qK as gd,
  Qv as ge,
  $K as gf,
  ZK as gg,
  QK as gh,
  JK as gi,
  t7 as gj,
  e7 as gk,
  Jv as gl,
  s7 as gm,
  i7 as gn,
  Tm as go,
  r7 as gp,
  Im as gq,
  n7 as gr,
  a7 as gs,
  o7 as gt,
  h7 as gu,
  u7 as gv,
  l7 as gw,
  c7 as gx,
  _7 as gy,
  d7 as gz,
  ke as h,
  gC as h$,
  wW as h0,
  UW as h1,
  L7 as h2,
  F7 as h3,
  sC as h4,
  iC as h5,
  rC as h6,
  nC as h7,
  w7 as h8,
  aC as h9,
  $7 as hA,
  Z7 as hB,
  Q7 as hC,
  J7 as hD,
  t9 as hE,
  e9 as hF,
  s9 as hG,
  fC as hH,
  xm as hI,
  Mm as hJ,
  bm as hK,
  i9 as hL,
  Pm as hM,
  r9 as hN,
  Nm as hO,
  Um as hP,
  n9 as hQ,
  a9 as hR,
  Dm as hS,
  o9 as hT,
  h9 as hU,
  u9 as hV,
  Lm as hW,
  l9 as hX,
  c9 as hY,
  _9 as hZ,
  d9 as h_,
  oC as ha,
  hC as hb,
  uC as hc,
  lC as hd,
  cC as he,
  _C as hf,
  dC as hg,
  G7 as hh,
  B7 as hi,
  k7 as hj,
  z7 as hk,
  V7 as hl,
  H7 as hm,
  Y7 as hn,
  W7 as ho,
  j7 as hp,
  X7 as hq,
  K7 as hr,
  Sm as hs,
  Am as ht,
  Rm as hu,
  Om as hv,
  ym as hw,
  vm as hx,
  q7 as hy,
  Cm as hz,
  Xe as i,
  L9 as i$,
  f9 as i0,
  g9 as i1,
  Fm as i2,
  wm as i3,
  Gm as i4,
  Bm as i5,
  km as i6,
  zm as i7,
  Vm as i8,
  Hm as i9,
  yc as iA,
  Zm as iB,
  vc as iC,
  Qm as iD,
  Jm as iE,
  OC as iF,
  tE as iG,
  Cc as iH,
  eE as iI,
  xc as iJ,
  sE as iK,
  I9 as iL,
  S9 as iM,
  A9 as iN,
  R9 as iO,
  iE as iP,
  O9 as iQ,
  y9 as iR,
  v9 as iS,
  C9 as iT,
  x9 as iU,
  M9 as iV,
  b9 as iW,
  P9 as iX,
  N9 as iY,
  U9 as iZ,
  D9 as i_,
  p9 as ia,
  m9 as ib,
  E9 as ic,
  Ym as id,
  Wm as ie,
  jm as ig,
  Xm as ih,
  T9 as ii,
  Km as ij,
  jo as ik,
  qm as il,
  pC as im,
  mC as io,
  Ac as ip,
  EC as iq,
  TC as ir,
  IC as is,
  SC as it,
  AC as iu,
  RC as iv,
  uI as iw,
  Rc as ix,
  Oc as iy,
  $m as iz,
  Oa as j,
  Sq as j$,
  F9 as j0,
  w9 as j1,
  yC as j2,
  vC as j3,
  CC as j4,
  xC as j5,
  G9 as j6,
  B9 as j7,
  k9 as j8,
  MC as j9,
  GC as jA,
  sq as jB,
  iq as jC,
  rq as jD,
  rE as jE,
  BC as jF,
  kC as jG,
  zC as jH,
  nq as jI,
  aq as jJ,
  oq as jK,
  hq as jL,
  S as jM,
  uq as jN,
  lq as jO,
  cq as jP,
  _q as jQ,
  dq as jR,
  fq as jS,
  gq as jT,
  pq as jU,
  mq as jV,
  Eq as jW,
  bc as jX,
  nE as jY,
  Tq as jZ,
  Iq as j_,
  bC as ja,
  z9 as jb,
  V9 as jc,
  H9 as jd,
  PC as je,
  NC as jf,
  Y9 as jg,
  W9 as jh,
  j9 as ji,
  UC as jj,
  Mc as jk,
  lI as jl,
  X9 as jm,
  K9 as jn,
  DC as jo,
  LC as jp,
  q9 as jq,
  $9 as jr,
  Z9 as js,
  Q9 as jt,
  J9 as ju,
  tq as jv,
  FC as jw,
  eq as jx,
  wC as jy,
  cI as jz,
  DD as k,
  b$ as k$,
  Aq as k0,
  Rq as k1,
  Oq as k2,
  yq as k3,
  vq as k4,
  Cq as k5,
  xq as k6,
  Mq as k7,
  bq as k8,
  Pq as k9,
  r$ as kA,
  n$ as kB,
  a$ as kC,
  o$ as kD,
  h$ as kE,
  u$ as kF,
  aE as kG,
  l$ as kH,
  c$ as kI,
  _$ as kJ,
  d$ as kK,
  f$ as kL,
  g$ as kM,
  p$ as kN,
  m$ as kO,
  E$ as kP,
  T$ as kQ,
  I$ as kR,
  S$ as kS,
  A$ as kT,
  R$ as kU,
  O$ as kV,
  y$ as kW,
  v$ as kX,
  C$ as kY,
  x$ as kZ,
  M$ as k_,
  Nq as ka,
  Uq as kb,
  Dq as kc,
  Lq as kd,
  Fq as ke,
  wq as kf,
  Gq as kg,
  Bq as kh,
  kq as ki,
  zq as kj,
  Vq as kk,
  Hq as kl,
  Yq as km,
  Wq as kn,
  jq as ko,
  Xq as kp,
  Kq as kq,
  qq as kr,
  $q as ks,
  Zq as kt,
  Qq as ku,
  Jq as kv,
  t$ as kw,
  e$ as kx,
  s$ as ky,
  i$ as kz,
  UD as l,
  LZ as l$,
  P$ as l0,
  N$ as l1,
  U$ as l2,
  D$ as l3,
  L$ as l4,
  F$ as l5,
  w$ as l6,
  G$ as l7,
  B$ as l8,
  k$ as l9,
  lZ as lA,
  cZ as lB,
  _Z as lC,
  dZ as lD,
  fZ as lE,
  gZ as lF,
  pZ as lG,
  mZ as lH,
  EZ as lI,
  TZ as lJ,
  IZ as lK,
  SZ as lL,
  AZ as lM,
  RZ as lN,
  OZ as lO,
  yZ as lP,
  vZ as lQ,
  CZ as lR,
  xZ as lS,
  MZ as lT,
  bZ as lU,
  PZ as lV,
  ont as lW,
  NZ as lX,
  UZ as lY,
  DZ as lZ,
  HC as l_,
  z$ as la,
  V$ as lb,
  H$ as lc,
  VC as ld,
  Y$ as le,
  W$ as lf,
  j$ as lg,
  X$ as lh,
  K$ as li,
  q$ as lj,
  $$ as lk,
  Z$ as ll,
  oE as lm,
  Q$ as ln,
  hE as lo,
  J$ as lp,
  tZ as lq,
  eZ as lr,
  sZ as ls,
  iZ as lt,
  rZ as lu,
  nZ as lv,
  aZ as lw,
  oZ as lx,
  hZ as ly,
  uZ as lz,
  Bi as m,
  kQ as m$,
  FZ as m0,
  YC as m1,
  wZ as m2,
  WC as m3,
  jC as m4,
  GZ as m5,
  BZ as m6,
  kZ as m7,
  zZ as m8,
  VZ as m9,
  gQ as mA,
  pQ as mB,
  mQ as mC,
  EQ as mD,
  TQ as mE,
  IQ as mF,
  SQ as mG,
  AQ as mH,
  RR as mI,
  RQ as mJ,
  OQ as mK,
  yQ as mL,
  vQ as mM,
  OR as mN,
  CQ as mO,
  xQ as mP,
  MQ as mQ,
  bQ as mR,
  PQ as mS,
  NQ as mT,
  UQ as mU,
  DQ as mV,
  LQ as mW,
  FQ as mX,
  wQ as mY,
  GQ as mZ,
  BQ as m_,
  HZ as ma,
  YZ as mb,
  WZ as mc,
  jZ as md,
  XZ as me,
  KZ as mf,
  qZ as mg,
  $Z as mh,
  ZZ as mi,
  QZ as mj,
  JZ as mk,
  tQ as ml,
  eQ as mm,
  sQ as mn,
  iQ as mo,
  rQ as mp,
  nQ as mq,
  aQ as mr,
  oQ as ms,
  hQ as mt,
  uQ as mu,
  lQ as mv,
  cQ as mw,
  _Q as mx,
  dQ as my,
  fQ as mz,
  Do as n,
  XJ as n$,
  zQ as n0,
  VQ as n1,
  HQ as n2,
  YQ as n3,
  WQ as n4,
  jQ as n5,
  XQ as n6,
  KQ as n7,
  qQ as n8,
  $Q as n9,
  IJ as nA,
  SJ as nB,
  AJ as nC,
  RJ as nD,
  OJ as nE,
  yJ as nF,
  vJ as nG,
  CJ as nH,
  xJ as nI,
  MJ as nJ,
  bJ as nK,
  PJ as nL,
  NJ as nM,
  UJ as nN,
  DJ as nO,
  LJ as nP,
  FJ as nQ,
  wJ as nR,
  GJ as nS,
  BJ as nT,
  kJ as nU,
  zJ as nV,
  VJ as nW,
  HJ as nX,
  YJ as nY,
  WJ as nZ,
  jJ as n_,
  uE as na,
  ZQ as nb,
  QQ as nc,
  JQ as nd,
  tJ as ne,
  eJ as nf,
  sJ as ng,
  iJ as nh,
  rJ as ni,
  yr as nj,
  nJ as nk,
  lE as nl,
  aJ as nm,
  oJ as nn,
  hJ as no,
  uJ as np,
  lJ as nq,
  cJ as nr,
  _J as ns,
  dJ as nt,
  fJ as nu,
  gJ as nv,
  pJ as nw,
  mJ as nx,
  EJ as ny,
  TJ as nz,
  BD as o,
  Dtt as o$,
  KJ as o0,
  qJ as o1,
  $J as o2,
  ZJ as o3,
  QJ as o4,
  JJ as o5,
  ttt as o6,
  ett as o7,
  stt as o8,
  itt as o9,
  ptt as oA,
  mtt as oB,
  Ett as oC,
  Ttt as oD,
  Itt as oE,
  Stt as oF,
  Att as oG,
  Rtt as oH,
  Ott as oI,
  ytt as oJ,
  vtt as oK,
  Ctt as oL,
  xtt as oM,
  unt as oN,
  nx as oO,
  ax as oP,
  Mtt as oQ,
  ox as oR,
  hx as oS,
  btt as oT,
  ux as oU,
  lx as oV,
  cx as oW,
  _x as oX,
  Ptt as oY,
  Ntt as oZ,
  Utt as o_,
  rtt as oa,
  ntt as ob,
  att as oc,
  ott as od,
  htt as oe,
  utt as of,
  hnt as og,
  XC as oh,
  KC as oi,
  cE as oj,
  qC as ok,
  ltt as ol,
  $C as om,
  ZC as on,
  QC as oo,
  JC as op,
  tx as oq,
  ex as or,
  sx as os,
  ix as ot,
  rx as ou,
  ctt as ov,
  _tt as ow,
  dtt as ox,
  ftt as oy,
  gtt as oz,
  mn as p,
  aet as p$,
  Ltt as p0,
  Ftt as p1,
  dx as p2,
  fx as p3,
  wtt as p4,
  _E as p5,
  px as p6,
  mx as p7,
  Ex as p8,
  gx as p9,
  Fx as pA,
  wx as pB,
  Ytt as pC,
  Gx as pD,
  Wtt as pE,
  jtt as pF,
  Xtt as pG,
  Bx as pH,
  Ktt as pI,
  kx as pJ,
  qtt as pK,
  $tt as pL,
  Ztt as pM,
  Qtt as pN,
  zx as pO,
  Jtt as pP,
  tet as pQ,
  eet as pR,
  set as pS,
  gE as pT,
  iet as pU,
  ret as pV,
  net as pW,
  Vx as pX,
  Hx as pY,
  dI as pZ,
  Yx as p_,
  dE as pa,
  Tx as pb,
  Ix as pc,
  Sx as pd,
  Ax as pe,
  Rx as pf,
  Ox as pg,
  Gtt as ph,
  yx as pi,
  vx as pj,
  Cx as pk,
  Btt as pl,
  ktt as pm,
  fE as pn,
  xx as po,
  Mx as pp,
  bx as pq,
  Px as pr,
  ztt as ps,
  Nx as pt,
  Vtt as pu,
  Ux as pv,
  Dx as pw,
  Lx as px,
  Htt as py,
  _I as pz,
  kD as q,
  fM as q$,
  Wx as q0,
  jx as q1,
  Xx as q2,
  Kx as q3,
  qx as q4,
  oet as q5,
  het as q6,
  uet as q7,
  $x as q8,
  Zx as q9,
  bet as qA,
  Pet as qB,
  Net as qC,
  Uet as qD,
  rM as qE,
  nM as qF,
  aM as qG,
  oM as qH,
  hM as qI,
  uM as qJ,
  Det as qK,
  lM as qL,
  Let as qM,
  Fet as qN,
  wet as qO,
  cM as qP,
  Get as qQ,
  Bet as qR,
  ket as qS,
  zet as qT,
  Vet as qU,
  Het as qV,
  Yet as qW,
  Wet as qX,
  _M as qY,
  jet as qZ,
  dM as q_,
  Qx as qa,
  Jx as qb,
  pE as qc,
  cet as qd,
  _et as qe,
  det as qf,
  fet as qg,
  get as qh,
  pet as qi,
  met as qj,
  Eet as qk,
  lnt as ql,
  Tet as qm,
  Iet as qn,
  tM as qo,
  eM as qp,
  Aet as qq,
  sM as qr,
  Ret as qs,
  Oet as qt,
  iM as qu,
  yet as qv,
  vet as qw,
  Cet as qx,
  xet as qy,
  Met as qz,
  Tb as r,
  eI as r$,
  FB as r0,
  wB as r1,
  GB as r2,
  BB as r3,
  kB as r4,
  zB as r5,
  VB as r6,
  HB as r7,
  YB as r8,
  WB as r9,
  pk as rA,
  mk as rB,
  Ek as rC,
  Tk as rD,
  Ik as rE,
  Sk as rF,
  Xd as rG,
  Ak as rH,
  jd as rI,
  Rk as rJ,
  Ok as rK,
  yk as rL,
  vk as rM,
  Ck as rN,
  Nv as rO,
  xk as rP,
  Mk as rQ,
  bk as rR,
  Pk as rS,
  Bp as rT,
  Nk as rU,
  Uk as rV,
  Dk as rW,
  Lk as rX,
  Fk as rY,
  wk as rZ,
  Gk as r_,
  jB as ra,
  XB as rb,
  KB as rc,
  qB as rd,
  JT as re,
  $B as rf,
  ZB as rg,
  QB as rh,
  tk as ri,
  JB as rj,
  sk as rk,
  ek as rl,
  ik as rm,
  rk as rn,
  nk as ro,
  ak as rp,
  ok as rq,
  hk as rr,
  uk as rs,
  lk as rt,
  ck as ru,
  tI as rv,
  _k as rw,
  dk as rx,
  fk as ry,
  gk as rz,
  RT as s,
  G5 as s$,
  Bk as s0,
  kk as s1,
  zk as s2,
  Vk as s3,
  Hk as s4,
  Yk as s5,
  WV as s6,
  jV as s7,
  XV as s8,
  KV as s9,
  m5 as sA,
  E5 as sB,
  em as sC,
  Fv as sD,
  T5 as sE,
  ER as sF,
  I5 as sG,
  S5 as sH,
  A5 as sI,
  R5 as sJ,
  O5 as sK,
  y5 as sL,
  v5 as sM,
  C5 as sN,
  x5 as sO,
  M5 as sP,
  b5 as sQ,
  sm as sR,
  P5 as sS,
  im as sT,
  rm as sU,
  N5 as sV,
  U5 as sW,
  D5 as sX,
  L5 as sY,
  F5 as sZ,
  w5 as s_,
  qV as sa,
  $V as sb,
  ZV as sc,
  QV as sd,
  JV as se,
  t5 as sf,
  Jp as sg,
  e5 as sh,
  tm as si,
  s5 as sj,
  i5 as sk,
  r5 as sl,
  n5 as sm,
  a5 as sn,
  o5 as so,
  h5 as sp,
  u5 as sq,
  l5 as sr,
  Dv as ss,
  c5 as st,
  _5 as su,
  d5 as sv,
  f5 as sw,
  g5 as sx,
  Lv as sy,
  p5 as sz,
  ll as t,
  GH as t$,
  B5 as t0,
  k5 as t1,
  z5 as t2,
  nm as t3,
  V5 as t4,
  am as t5,
  H5 as t6,
  Y5 as t7,
  W5 as t8,
  j5 as t9,
  dH as tA,
  Xu as tB,
  fH as tC,
  gH as tD,
  pH as tE,
  mH as tF,
  EH as tG,
  TH as tH,
  IH as tI,
  SH as tJ,
  AH as tK,
  RH as tL,
  OH as tM,
  yH as tN,
  vH as tO,
  CH as tP,
  xH as tQ,
  MH as tR,
  bH as tS,
  PH as tT,
  NH as tU,
  UH as tV,
  om as tW,
  DH as tX,
  hm as tY,
  FH as tZ,
  wH as t_,
  X5 as ta,
  qd as tb,
  K5 as tc,
  snt as td,
  q5 as te,
  $5 as tf,
  Z5 as tg,
  Q5 as th,
  J5 as ti,
  tH as tj,
  eH as tk,
  sH as tl,
  iH as tm,
  rH as tn,
  oH as to,
  hH as tp,
  uH as tq,
  lH as tr,
  nH as ts,
  TR as tt,
  aH as tu,
  aI as tv,
  Uu as tw,
  cH as tx,
  _H as ty,
  ju as tz,
  LD as u,
  _m as u$,
  um as u0,
  BH as u1,
  kH as u2,
  zH as u3,
  VH as u4,
  HH as u5,
  lm as u6,
  cm as u7,
  YH as u8,
  WH as u9,
  mV as uA,
  EV as uB,
  TV as uC,
  IV as uD,
  SV as uE,
  qp as uF,
  AV as uG,
  RV as uH,
  $p as uI,
  Kd as uJ,
  nI as uK,
  OV as uL,
  yV as uM,
  vV as uN,
  ent as uO,
  CV as uP,
  xV as uQ,
  Zp as uR,
  MV as uS,
  bV as uT,
  PV as uU,
  NV as uV,
  UV as uW,
  Qp as uX,
  DV as uY,
  LV as uZ,
  FV as u_,
  LH as ua,
  jH as ub,
  XH as uc,
  mc as ud,
  fz as ue,
  Yp as uf,
  gz as ug,
  pz as uh,
  mz as ui,
  Ez as uj,
  Tz as uk,
  Iz as ul,
  Sz as um,
  Az as un,
  Rz as uo,
  Oz as up,
  yz as uq,
  vz as ur,
  Cz as us,
  xz as ut,
  Mz as uu,
  bz as uv,
  fV as uw,
  gV as ux,
  Ic as uy,
  pV as uz,
  uN as v,
  sW as v$,
  KH as v0,
  qH as v1,
  $H as v2,
  ZH as v3,
  QH as v4,
  JH as v5,
  tY as v6,
  eY as v7,
  wv as v8,
  IR as v9,
  RY as vA,
  OY as vB,
  yY as vC,
  vY as vD,
  CY as vE,
  xY as vF,
  MY as vG,
  bY as vH,
  gm as vI,
  GY as vJ,
  BY as vK,
  kY as vL,
  zY as vM,
  VY as vN,
  HY as vO,
  YY as vP,
  WY as vQ,
  jY as vR,
  XY as vS,
  KY as vT,
  qY as vU,
  $Y as vV,
  ZY as vW,
  QY as vX,
  JY as vY,
  tW as vZ,
  eW as v_,
  dm as va,
  fm as vb,
  iY as vc,
  rY as vd,
  sY as ve,
  Du as vf,
  nY as vg,
  Gv as vh,
  Sc as vi,
  oY as vj,
  hY as vk,
  uY as vl,
  lY as vm,
  cY as vn,
  _Y as vo,
  gY as vp,
  pY as vq,
  mY as vr,
  EY as vs,
  dY as vt,
  aY as vu,
  TY as vv,
  fY as vw,
  IY as vx,
  SY as vy,
  AY as vz,
  ce as w,
  uj as w$,
  iW as w0,
  rW as w1,
  aW as w2,
  oW as w3,
  nW as w4,
  hW as w5,
  uW as w6,
  lW as w7,
  cW as w8,
  _W as w9,
  bW as wA,
  PW as wB,
  NW as wC,
  GW as wD,
  BW as wE,
  kW as wF,
  SR as wG,
  zW as wH,
  VW as wI,
  HW as wJ,
  YW as wK,
  WW as wL,
  jW as wM,
  XW as wN,
  qW as wO,
  $W as wP,
  ZW as wQ,
  KW as wR,
  QW as wS,
  JW as wT,
  tj as wU,
  ej as wV,
  sj as wW,
  ij as wX,
  nj as wY,
  oj as wZ,
  hj as w_,
  dW as wa,
  fW as wb,
  PY as wc,
  NY as wd,
  UY as we,
  Bv as wf,
  DY as wg,
  LY as wh,
  FY as wi,
  pm as wj,
  wY as wk,
  gW as wl,
  pW as wm,
  mW as wn,
  EW as wo,
  TW as wp,
  IW as wq,
  SW as wr,
  AW as ws,
  RW as wt,
  OW as wu,
  yW as wv,
  vW as ww,
  CW as wx,
  xW as wy,
  MW as wz,
  lN as x,
  N4 as x$,
  lj as x0,
  cj as x1,
  aj as x2,
  rj as x3,
  _j as x4,
  dj as x5,
  fj as x6,
  Ca as x7,
  gj as x8,
  pj as x9,
  u4 as xA,
  l4 as xB,
  Tn as xC,
  c4 as xD,
  _4 as xE,
  d4 as xF,
  f4 as xG,
  g4 as xH,
  p4 as xI,
  m4 as xJ,
  E4 as xK,
  T4 as xL,
  Kp as xM,
  I4 as xN,
  S4 as xO,
  A4 as xP,
  R4 as xQ,
  O4 as xR,
  y4 as xS,
  sI as xT,
  v4 as xU,
  C4 as xV,
  x4 as xW,
  M4 as xX,
  iI as xY,
  b4 as xZ,
  P4 as x_,
  mj as xa,
  Ej as xb,
  Tj as xc,
  Wp as xd,
  Pz as xe,
  Nz as xf,
  Uz as xg,
  Dz as xh,
  Lz as xi,
  Fz as xj,
  wz as xk,
  Gz as xl,
  Bz as xm,
  kz as xn,
  t4 as xo,
  Wo as xp,
  e4 as xq,
  s4 as xr,
  i4 as xs,
  r4 as xt,
  n4 as xu,
  w4 as xv,
  G4 as xw,
  a4 as xx,
  o4 as xy,
  h4 as xz,
  fN as y,
  Qz as y$,
  U4 as y0,
  D4 as y1,
  L4 as y2,
  F4 as y3,
  Tc as y4,
  B4 as y5,
  cn as y6,
  k4 as y7,
  z4 as y8,
  V4 as y9,
  Ka as yA,
  Ij as yB,
  oI as yC,
  Sj as yD,
  Aj as yE,
  Rj as yF,
  Oj as yG,
  yj as yH,
  vj as yI,
  Cj as yJ,
  xj as yK,
  Mj as yL,
  zz as yM,
  Vz as yN,
  Yz as yO,
  Hz as yP,
  Wz as yQ,
  jz as yR,
  Xz as yS,
  Kz as yT,
  Nu as yU,
  Ec as yV,
  jp as yW,
  qz as yX,
  $z as yY,
  Zz as yZ,
  Xp as y_,
  H4 as ya,
  Y4 as yb,
  W4 as yc,
  j4 as yd,
  X4 as ye,
  K4 as yf,
  q4 as yg,
  $4 as yh,
  Z4 as yi,
  Q4 as yj,
  J4 as yk,
  rI as yl,
  tV as ym,
  eV as yn,
  sV as yo,
  iV as yp,
  rV as yq,
  nV as yr,
  aV as ys,
  oV as yt,
  hV as yu,
  uV as yv,
  lV as yw,
  cV as yx,
  _V as yy,
  dV as yz,
  Prt as z,
  Ze as z$,
  Jz as z0,
  bj as z1,
  Pj as z2,
  Nj as z3,
  Uj as z4,
  Dj as z5,
  hI as z6,
  Lj as z7,
  Fj as z8,
  wj as z9,
  nz as zA,
  zp as zB,
  az as zC,
  oz as zD,
  hz as zE,
  Uv as zF,
  Vp as zG,
  uz as zH,
  lz as zI,
  cz as zJ,
  _z as zK,
  dz as zL,
  Hp as zM,
  wV as zN,
  GV as zO,
  xh as zP,
  BV as zQ,
  kV as zR,
  zV as zS,
  VV as zT,
  HV as zU,
  YV as zV,
  jj as zW,
  WF as zX,
  Ct as zY,
  GF as zZ,
  x as z_,
  Gj as za,
  Bj as zb,
  zj as zc,
  Vj as zd,
  Hj as ze,
  Wj as zf,
  kj as zg,
  kv as zh,
  Yj as zi,
  Wk as zj,
  pc as zk,
  jk as zl,
  kp as zm,
  Xk as zn,
  Kk as zo,
  qk as zp,
  tnt as zq,
  $k as zr,
  Zk as zs,
  Qk as zt,
  Jk as zu,
  tz as zv,
  ez as zw,
  sz as zx,
  iz as zy,
  rz as zz
};
